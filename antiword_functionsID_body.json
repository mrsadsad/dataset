{
    "resources/antiword/xml.c@vPushStack": "static void vPushStack ( UCHAR ucTag ) { fail ( tStackNextFree > tStacksize ) ; if ( tStackNextFree == tStacksize ) { /* The stack is full; enlarge the stack */ tStacksize += EXTENSION_STACK_SIZE ; aucStack = xrealloc ( aucStack , tStacksize * sizeof ( UCHAR ) ) ; DBG_DEC ( tStacksize ) ; } fail ( tStackNextFree >= tStacksize ) ; aucStack [ tStackNextFree ++ ] = ucTag ; }",
    "resources/antiword/xml.c@ucPopStack": "static UCHAR ucPopStack ( void ) { DBG_DEC_C ( tStackNextFree > tStacksize , tStackNextFree ) ; DBG_DEC_C ( tStackNextFree > tStacksize , tStacksize ) ; fail ( tStackNextFree > tStacksize ) ; fail ( tStackNextFree == 0 ) ; if ( tStackNextFree == 0 ) { werr ( 1 , \"The stack is empty, unable to continue\" ) ; return TAG_NOTAG ; } return aucStack [ -- tStackNextFree ] ; }",
    "resources/antiword/xml.c@ucReadStack": "static UCHAR ucReadStack ( void ) { DBG_DEC_C ( tStackNextFree > tStacksize , tStackNextFree ) ; DBG_DEC_C ( tStackNextFree > tStacksize , tStacksize ) ; fail ( tStackNextFree > tStacksize ) ; if ( tStackNextFree == 0 ) { /* The stack is empty */ return TAG_NOTAG ; } return aucStack [ tStackNextFree - 1 ] ; }",
    "resources/antiword/xml.c@vPrintLevel": "static void vPrintLevel ( FILE * pOutFile ) { size_t tIndex ; fail ( pOutFile == NULL ) ; for ( tIndex = 0 ; tIndex < tStackNextFree ; tIndex ++ ) { ( void ) putc ( ' ' , pOutFile ) ; } }",
    "resources/antiword/xml.c@vPrintFootnote": "static void vPrintFootnote ( diagram_type * pDiag , UINT uiFootnoteIndex ) { const char * szText , * pcTmp ; BOOL bSuScript ; UCHAR ucTopTag ; TRACE_MSG ( \"vPrintFootnote\" ) ; szText = szGetFootnootText ( uiFootnoteIndex ) ; if ( szText == NULL ) { szText = \"\" ; } /* Remove the subscript/superscript (if any) */ ucTopTag = ucReadStack ( ) ; bSuScript = ucTopTag == TAG_SUBSCRIPT || ucTopTag == TAG_SUPERSCRIPT ; if ( bSuScript ) { vAddEndTag ( pDiag , ucTopTag ) ; } /* Start a footnote */ vAddStartTag ( pDiag , TAG_FOOTNOTE , NULL ) ; vAddStartTag ( pDiag , TAG_PARA , NULL ) ; /* Print a footnote */ for ( pcTmp = szText ; * pcTmp != '\\0' ; pcTmp ++ ) { if ( * pcTmp == PAR_END ) { if ( * ( pcTmp + 1 ) != PAR_END && * ( pcTmp + 1 ) != '\\0' ) { /* PAR_END is not empty and not last */ vAddEndTag ( pDiag , TAG_PARA ) ; vAddStartTag ( pDiag , TAG_PARA , NULL ) ; } } else { vPrintChar ( pDiag , * pcTmp ) ; } } /* End a footnote */ vAddEndTag ( pDiag , TAG_PARA ) ; vAddEndTag ( pDiag , TAG_FOOTNOTE ) ; /* Repair the subscript/superscript (if any) */ if ( bSuScript ) { vAddStartTag ( pDiag , ucTopTag , NULL ) ; } }",
    "resources/antiword/xml.c@vPrintChar": "static void vPrintChar ( diagram_type * pDiag , char cChar ) { fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; switch ( cChar ) { case FOOTNOTE_OR_ENDNOTE : uiFootnoteNumber ++ ; vPrintFootnote ( pDiag , uiFootnoteNumber - 1 ) ; break ; case '<' : fprintf ( pDiag -> pOutFile , \"%s\" , \"&lt;\" ) ; break ; case '>' : fprintf ( pDiag -> pOutFile , \"%s\" , \"&gt;\" ) ; break ; case '&' : fprintf ( pDiag -> pOutFile , \"%s\" , \"&amp;\" ) ; break ; default : ( void ) putc ( cChar , pDiag -> pOutFile ) ; break ; } }",
    "resources/antiword/xml.c@vPrintSpecialChar": "static void vPrintSpecialChar ( diagram_type * pDiag , USHORT usChar ) { ULONG ulChar ; size_t tLen , tIndex ; char szResult [ 4 ] ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( iWordVersion < 0 ) ; fail ( eEncoding == encoding_neutral ) ; ulChar = ulTranslateCharacters ( usChar , 0 , iWordVersion , conversion_xml , eEncoding , bOldMacFile ) ; tLen = tUcs2Utf8 ( ulChar , szResult , sizeof ( szResult ) ) ; if ( tLen == 1 ) { vPrintChar ( pDiag , szResult [ 0 ] ) ; } else { for ( tIndex = 0 ; tIndex < tLen ; tIndex ++ ) { ( void ) putc ( szResult [ tIndex ] , pDiag -> pOutFile ) ; } } }",
    "resources/antiword/xml.c@vPrintSpecialString": "static void vPrintSpecialString ( diagram_type * pDiag , const char * szString ) { int iIndex ; USHORT usChar ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( szString == NULL ) ; for ( iIndex = 0 ; szString [ iIndex ] != '\\0' ; iIndex ++ ) { usChar = ( USHORT ) ( UCHAR ) szString [ iIndex ] ; vPrintSpecialChar ( pDiag , usChar ) ; } }",
    "resources/antiword/xml.c@vAddStartTag": "static void vAddStartTag ( diagram_type * pDiag , UCHAR ucTag , const char * szAttribute ) { fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( ( size_t ) ucTag >= elementsof ( atDocBookTags ) ) ; if ( atDocBookTags [ ( UINT ) ucTag ] . bAddNewlineStart ) { fprintf ( pDiag -> pOutFile , \"\\n\" ) ; vPrintLevel ( pDiag -> pOutFile ) ; } if ( szAttribute == NULL || szAttribute [ 0 ] == '\\0' ) { fprintf ( pDiag -> pOutFile , \"<%s>\" , atDocBookTags [ ( UINT ) ucTag ] . szTagname ) ; } else { fprintf ( pDiag -> pOutFile , \"<%s %s>\" , atDocBookTags [ ( UINT ) ucTag ] . szTagname , szAttribute ) ; } if ( atDocBookTags [ ( UINT ) ucTag ] . bAddNewlineEnd ) { fprintf ( pDiag -> pOutFile , \"\\n\" ) ; pDiag -> lXleft = 0 ; } vPushStack ( ucTag ) ; /* Set global variables */ switch ( ucTag ) { case TAG_CHAPTER : usHeaderLevelCurrent = 1 ; bEmptyHeaderLevel = TRUE ; break ; case TAG_SECT1 : usHeaderLevelCurrent = 2 ; bEmptyHeaderLevel = TRUE ; break ; case TAG_SECT2 : usHeaderLevelCurrent = 3 ; bEmptyHeaderLevel = TRUE ; break ; case TAG_SECT3 : usHeaderLevelCurrent = 4 ; bEmptyHeaderLevel = TRUE ; break ; case TAG_SECT4 : usHeaderLevelCurrent = 5 ; bEmptyHeaderLevel = TRUE ; break ; case TAG_SECT5 : usHeaderLevelCurrent = 6 ; bEmptyHeaderLevel = TRUE ; break ; case TAG_TITLE : fail ( uiParagraphLevel != 0 ) ; bTitleOpen = TRUE ; break ; case TAG_FOOTNOTE : bFootnoteOpen = TRUE ; break ; case TAG_PARA : fail ( bTitleOpen && ! bFootnoteOpen ) ; uiParagraphLevel ++ ; bEmptyHeaderLevel = FALSE ; break ; case TAG_EMPHASIS : bEmphasisOpen = TRUE ; break ; case TAG_ITEMIZEDLIST : case TAG_ORDEREDLIST : uiListLevel ++ ; bEmptyListLevel = TRUE ; bEmptyHeaderLevel = FALSE ; break ; case TAG_LISTITEM : bEmptyListLevel = FALSE ; break ; case TAG_SUPERSCRIPT : bSuperscriptOpen = TRUE ; break ; case TAG_SUBSCRIPT : bSubscriptOpen = TRUE ; break ; case TAG_INFORMALTABLE : bTableOpen = TRUE ; bEmptyHeaderLevel = FALSE ; break ; default : break ; } }",
    "resources/antiword/xml.c@vAddEndTag": "static void vAddEndTag ( diagram_type * pDiag , UCHAR ucTag ) { UCHAR ucTopTag ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( ( size_t ) ucTag >= elementsof ( atDocBookTags ) ) ; # if defined ( DEBUG ) ucTopTag = ucReadStack ( ) ; if ( ucTag != ucTopTag ) { DBG_DEC ( ucTag ) ; DBG_MSG ( atDocBookTags [ ( UINT ) ucTag ] . szTagname ) ; vStackTrace ( ) ; } # endif /* DEBUG */ ucTopTag = ucPopStack ( ) ; fail ( ( size_t ) ucTopTag >= elementsof ( atDocBookTags ) ) ; if ( ucTag != ucTopTag ) { DBG_DEC ( ucTag ) ; DBG_DEC ( ucTopTag ) ; DBG_FIXME ( ) ; werr ( 1 , \"Impossible tag sequence, unable to continue\" ) ; } if ( atDocBookTags [ ( UINT ) ucTag ] . bAddNewlineEnd ) { fprintf ( pDiag -> pOutFile , \"\\n\" ) ; vPrintLevel ( pDiag -> pOutFile ) ; } fprintf ( pDiag -> pOutFile , \"</%s>\" , atDocBookTags [ ( UINT ) ucTag ] . szTagname ) ; if ( atDocBookTags [ ( UINT ) ucTag ] . bAddNewlineStart ) { fprintf ( pDiag -> pOutFile , \"\\n\" ) ; pDiag -> lXleft = 0 ; } /* Set global variables */ switch ( ucTag ) { case TAG_CHAPTER : usHeaderLevelCurrent = 0 ; break ; case TAG_SECT1 : usHeaderLevelCurrent = 1 ; break ; case TAG_SECT2 : usHeaderLevelCurrent = 2 ; break ; case TAG_SECT3 : usHeaderLevelCurrent = 3 ; break ; case TAG_SECT4 : usHeaderLevelCurrent = 4 ; break ; case TAG_SECT5 : usHeaderLevelCurrent = 5 ; break ; case TAG_TITLE : bTitleOpen = FALSE ; break ; case TAG_FOOTNOTE : bFootnoteOpen = FALSE ; break ; case TAG_PARA : uiParagraphLevel -- ; break ; case TAG_EMPHASIS : bEmphasisOpen = FALSE ; break ; case TAG_SUPERSCRIPT : bSuperscriptOpen = FALSE ; break ; case TAG_ITEMIZEDLIST : case TAG_ORDEREDLIST : uiListLevel -- ; break ; case TAG_SUBSCRIPT : bSubscriptOpen = FALSE ; break ; case TAG_INFORMALTABLE : bTableOpen = FALSE ; iTableColumnsCurrent = 0 ; break ; default : break ; } }",
    "resources/antiword/xml.c@vAddEndTagOptional": "static void vAddEndTagOptional ( diagram_type * pDiag , UCHAR ucTag ) { UCHAR ucTopTag ; ucTopTag = ucReadStack ( ) ; if ( ucTag == ucTopTag ) { vAddEndTag ( pDiag , ucTag ) ; } }",
    "resources/antiword/xml.c@vAddCombinedTag": "static void vAddCombinedTag ( diagram_type * pDiag , UCHAR ucTag , const char * szAttribute ) { fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( ( size_t ) ucTag >= elementsof ( atDocBookTags ) ) ; if ( atDocBookTags [ ( UINT ) ucTag ] . bAddNewlineStart ) { fprintf ( pDiag -> pOutFile , \"\\n\" ) ; vPrintLevel ( pDiag -> pOutFile ) ; } if ( szAttribute == NULL || szAttribute [ 0 ] == '\\0' ) { fprintf ( pDiag -> pOutFile , \"<%s/>\" , atDocBookTags [ ( UINT ) ucTag ] . szTagname ) ; } else { fprintf ( pDiag -> pOutFile , \"<%s %s/>\" , atDocBookTags [ ( UINT ) ucTag ] . szTagname , szAttribute ) ; } if ( atDocBookTags [ ( UINT ) ucTag ] . bAddNewlineStart ) { fprintf ( pDiag -> pOutFile , \"\\n\" ) ; pDiag -> lXleft = 0 ; } }",
    "resources/antiword/xml.c@vAddEndTagsUntil2": "static void vAddEndTagsUntil2 ( diagram_type * pDiag , UCHAR ucTag1 , UCHAR ucTag2 ) { UCHAR ucTopTag ; do { ucTopTag = ucReadStack ( ) ; switch ( ucTopTag ) { case TAG_CHAPTER : case TAG_SECT1 : case TAG_SECT2 : case TAG_SECT3 : case TAG_SECT4 : case TAG_SECT5 : if ( bEmptyHeaderLevel ) { /*\n\t\t\t\t * An empty chapter is legal in Word,\n\t\t\t\t * but not in DocBook.\n\t\t\t\t */ vAddCombinedTag ( pDiag , TAG_PARA , NULL ) ; bEmptyHeaderLevel = FALSE ; } break ; case TAG_ITEMIZEDLIST : case TAG_ORDEREDLIST : if ( bEmptyListLevel ) { /*\n\t\t\t\t * A list without items is legal in Word,\n\t\t\t\t * but not in DocBook. (Nor are empty items)\n\t\t\t\t */ vAddStartTag ( pDiag , TAG_LISTITEM , NULL ) ; vAddCombinedTag ( pDiag , TAG_PARA , NULL ) ; vAddEndTag ( pDiag , TAG_LISTITEM ) ; bEmptyListLevel = FALSE ; } break ; default : break ; } vAddEndTag ( pDiag , ucTopTag ) ; } while ( ucTopTag != ucTag1 && ucTopTag != ucTag2 ) ; }",
    "resources/antiword/xml.c@vCreateBookIntro": "void vCreateBookIntro ( diagram_type * pDiag , int iVersion ) { const char * szTitle , * szSubject , * szAuthor ; const char * szLastSaveDtm , * szCompany ; const char * szLanguage ; char szTmp [ 13 ] ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( iVersion < 0 ) ; fail ( eEncoding == encoding_neutral ) ; iWordVersion = iVersion ; bOldMacFile = bIsOldMacFile ( ) ; szTitle = szGetTitle ( ) ; szSubject = szGetSubject ( ) ; szAuthor = szGetAuthor ( ) ; szLastSaveDtm = szGetLastSaveDtm ( ) ; szCompany = szGetCompany ( ) ; /* Start Book */ szLanguage = szGetLanguage ( ) ; if ( szLanguage != NULL ) { DBG_MSG ( szLanguage ) ; sprintf ( szTmp , \"lang='%.5s'\" , szLanguage ) ; szLanguage = szTmp ; } vAddStartTag ( pDiag , TAG_BOOK , szLanguage ) ; /* Book title */ if ( szTitle != NULL && szTitle [ 0 ] != '\\0' ) { vAddStartTag ( pDiag , TAG_TITLE , NULL ) ; vPrintSpecialString ( pDiag , szTitle ) ; vAddEndTag ( pDiag , TAG_TITLE ) ; } /* Bookinfo */ if ( ( szTitle != NULL && szTitle [ 0 ] != '\\0' ) || ( szSubject != NULL && szSubject [ 0 ] != '\\0' ) || ( szAuthor != NULL && szAuthor [ 0 ] != '\\0' ) || ( szLastSaveDtm != NULL && szLastSaveDtm [ 0 ] != '\\0' ) || ( szCompany != NULL && szCompany [ 0 ] != '\\0' ) ) { vAddStartTag ( pDiag , TAG_BOOKINFO , NULL ) ; if ( szTitle != NULL && szTitle [ 0 ] != '\\0' ) { vAddStartTag ( pDiag , TAG_TITLE , NULL ) ; vPrintSpecialString ( pDiag , szTitle ) ; vAddEndTag ( pDiag , TAG_TITLE ) ; } if ( szSubject != NULL && szSubject [ 0 ] != '\\0' ) { vAddStartTag ( pDiag , TAG_SUBTITLE , NULL ) ; vPrintSpecialString ( pDiag , szSubject ) ; vAddEndTag ( pDiag , TAG_SUBTITLE ) ; } if ( szAuthor != NULL && szAuthor [ 0 ] != '\\0' ) { vAddStartTag ( pDiag , TAG_AUTHOR , NULL ) ; vAddStartTag ( pDiag , TAG_SURNAME , NULL ) ; vPrintSpecialString ( pDiag , szAuthor ) ; vAddEndTag ( pDiag , TAG_SURNAME ) ; vAddEndTag ( pDiag , TAG_AUTHOR ) ; } if ( szLastSaveDtm != NULL && szLastSaveDtm [ 0 ] != '\\0' ) { vAddStartTag ( pDiag , TAG_DATE , NULL ) ; vPrintSpecialString ( pDiag , szLastSaveDtm ) ; vAddEndTag ( pDiag , TAG_DATE ) ; } if ( szCompany != NULL && szCompany [ 0 ] != '\\0' ) { vAddStartTag ( pDiag , TAG_CORPNAME , NULL ) ; vPrintSpecialString ( pDiag , szCompany ) ; vAddEndTag ( pDiag , TAG_CORPNAME ) ; } vAddEndTag ( pDiag , TAG_BOOKINFO ) ; } }",
    "resources/antiword/xml.c@vPrologueXML": "void vPrologueXML ( diagram_type * pDiag , const options_type * pOptions ) { fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( pOptions == NULL ) ; # if defined ( DEBUG ) vCheckTagTable ( ) ; # endif /* DEBUG */ /* Set global variables to their start values */ eEncoding = pOptions -> eEncoding ; bEmphasisOpen = FALSE ; bSuperscriptOpen = FALSE ; bSubscriptOpen = FALSE ; bTitleOpen = FALSE ; bTableOpen = FALSE ; bFootnoteOpen = FALSE ; uiParagraphLevel = 0 ; uiListLevel = 0 ; bEmptyListLevel = TRUE ; usHeaderLevelCurrent = 0 ; bEmptyHeaderLevel = TRUE ; iTableColumnsCurrent = 0 ; uiFootnoteNumber = 0 ; pDiag -> lXleft = 0 ; pDiag -> lYtop = 0 ; /* Create an empty stack */ tStacksize = INITIAL_STACK_SIZE ; aucStack = xcalloc ( tStacksize , sizeof ( UCHAR ) ) ; tStackNextFree = 0 ; }",
    "resources/antiword/xml.c@vEpilogueXML": "void vEpilogueXML ( diagram_type * pDiag ) { vStackTrace ( ) ; vAddEndTagsUntil1 ( pDiag , TAG_BOOK ) ; vStackTrace ( ) ; /* Destroy the stack */ fail ( tStackNextFree != 0 ) ; tStacksize = 0 ; aucStack = xfree ( aucStack ) ; tStackNextFree = 0 ; }",
    "resources/antiword/xml.c@vPrintXML": "static void vPrintXML ( diagram_type * pDiag , const char * szString , size_t tStringLength , USHORT usFontstyle ) { const char * szAttr ; int iCount ; size_t tNextFree ; BOOL bNotReady , bEmphasisNew , bSuperscriptNew , bSubscriptNew ; UCHAR ucTopTag , aucStorage [ 3 ] ; fail ( szString == NULL ) ; if ( szString == NULL || szString [ 0 ] == '\\0' || tStringLength == 0 ) { return ; } if ( tStringLength == 1 && szString [ 0 ] == FOOTNOTE_OR_ENDNOTE ) { /* Don't do anything special for just a single footnote */ bEmphasisNew = FALSE ; bSuperscriptNew = FALSE ; bSubscriptNew = FALSE ; } else { /* Situation normal */ bEmphasisNew = bIsBold ( usFontstyle ) || bIsItalic ( usFontstyle ) || bIsUnderline ( usFontstyle ) || bIsStrike ( usFontstyle ) ; bSuperscriptNew = bIsSuperscript ( usFontstyle ) ; bSubscriptNew = bIsSubscript ( usFontstyle ) ; } /* End what has to be ended (or more to keep the stack happy) */ tNextFree = 0 ; bNotReady = TRUE ; do { ucTopTag = ucReadStack ( ) ; switch ( ucTopTag ) { case TAG_EMPHASIS : fail ( ! bEmphasisOpen ) ; if ( bEmphasisNew ) { aucStorage [ tNextFree ++ ] = ucTopTag ; } vAddEndTag ( pDiag , ucTopTag ) ; break ; case TAG_SUPERSCRIPT : fail ( ! bSuperscriptOpen ) ; if ( bSuperscriptNew ) { aucStorage [ tNextFree ++ ] = ucTopTag ; } vAddEndTag ( pDiag , ucTopTag ) ; break ; case TAG_SUBSCRIPT : fail ( ! bSubscriptOpen ) ; if ( bSubscriptNew ) { aucStorage [ tNextFree ++ ] = ucTopTag ; } vAddEndTag ( pDiag , ucTopTag ) ; break ; default : bNotReady = FALSE ; break ; } fail ( tNextFree > elementsof ( aucStorage ) ) ; fail ( bNotReady && tNextFree == elementsof ( aucStorage ) ) ; } while ( bNotReady ) ; /* Just te make sure */ vStartOfParagraphXML ( pDiag , 1 ) ; /* Restart to keep the stack happy */ for ( iCount = ( int ) tNextFree - 1 ; iCount > 0 ; iCount -- ) { vAddStartTag ( pDiag , aucStorage [ iCount ] , NULL ) ; } /* Start what has to be started */ if ( bEmphasisNew && ! bEmphasisOpen ) { if ( bIsBold ( usFontstyle ) ) { szAttr = \"role='bold'\" ; } else if ( bIsItalic ( usFontstyle ) ) { szAttr = NULL ; } else if ( bIsUnderline ( usFontstyle ) ) { szAttr = \"role='underline'\" ; } else if ( bIsStrike ( usFontstyle ) ) { szAttr = \"role='strikethrough'\" ; } else { szAttr = NULL ; } vAddStartTag ( pDiag , TAG_EMPHASIS , szAttr ) ; } if ( bSuperscriptNew && ! bSuperscriptOpen ) { vAddStartTag ( pDiag , TAG_SUPERSCRIPT , NULL ) ; } if ( bSubscriptNew && ! bSubscriptOpen ) { vAddStartTag ( pDiag , TAG_SUBSCRIPT , NULL ) ; } /* The print the string */ for ( iCount = 0 ; iCount < ( int ) tStringLength ; iCount ++ ) { vPrintChar ( pDiag , szString [ iCount ] ) ; } }",
    "resources/antiword/xml.c@vMove2NextLineXML": "void vMove2NextLineXML ( diagram_type * pDiag ) { fail ( pDiag == NULL ) ; /*\n\tif (uiParagraphLevel != 0) {\n\t\tWe need something like HTML's <BR> tag\n\t}\n\t*/ }",
    "resources/antiword/xml.c@vSubstringXML": "void vSubstringXML ( diagram_type * pDiag , const char * szString , size_t tStringLength , long lStringWidth , USHORT usFontstyle ) { fail ( pDiag == NULL || szString == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( pDiag -> lXleft < 0 ) ; fail ( tStringLength != strlen ( szString ) ) ; if ( szString [ 0 ] == '\\0' || tStringLength == 0 ) { return ; } vPrintXML ( pDiag , szString , tStringLength , usFontstyle ) ; pDiag -> lXleft += lStringWidth ; }",
    "resources/antiword/xml.c@vStartOfParagraphXML": "void vStartOfParagraphXML ( diagram_type * pDiag , UINT uiMaxLevel ) { fail ( pDiag == NULL ) ; if ( uiParagraphLevel >= uiMaxLevel || bTitleOpen ) { /* In Word a title is just a paragraph */ return ; } if ( uiListLevel != 0 && bEmptyListLevel ) { /* No paragraphs in a list before the first listitem */ return ; } if ( usHeaderLevelCurrent == 0 ) { /* No paragraphs without an open header */ vAddStartTag ( pDiag , TAG_CHAPTER , NULL ) ; /* Dummy title */ vAddCombinedTag ( pDiag , TAG_TITLE , NULL ) ; } vAddStartTag ( pDiag , TAG_PARA , NULL ) ; }",
    "resources/antiword/xml.c@vEndOfParagraphXML": "void vEndOfParagraphXML ( diagram_type * pDiag , UINT uiMaxLevel ) { UCHAR ucTopTag ; fail ( pDiag == NULL ) ; if ( uiParagraphLevel > uiMaxLevel ) { DBG_DEC ( uiParagraphLevel ) ; return ; } for ( ; ; ) { ucTopTag = ucReadStack ( ) ; switch ( ucTopTag ) { case TAG_EMPHASIS : fail ( ! bEmphasisOpen ) ; vAddEndTag ( pDiag , TAG_EMPHASIS ) ; break ; case TAG_SUPERSCRIPT : fail ( ! bSuperscriptOpen ) ; vAddEndTag ( pDiag , TAG_SUPERSCRIPT ) ; break ; case TAG_SUBSCRIPT : fail ( ! bSubscriptOpen ) ; vAddEndTag ( pDiag , TAG_SUBSCRIPT ) ; break ; case TAG_TITLE : fail ( ! bTitleOpen ) ; vAddEndTag ( pDiag , TAG_TITLE ) ; return ; case TAG_PARA : fail ( uiParagraphLevel == 0 ) ; vAddEndTag ( pDiag , TAG_PARA ) ; return ; case TAG_TBODY : case TAG_TGROUP : case TAG_INFORMALTABLE : fail ( ! bTableOpen ) ; vAddEndTag ( pDiag , ucTopTag ) ; break ; case TAG_NOTAG : DBG_FIXME ( ) ; werr ( 1 , \"Impossible tag sequence, unable to continue\" ) ; break ; default : DBG_DEC ( ucTopTag ) ; DBG_MSG_C ( ( size_t ) ucTopTag < elementsof ( atDocBookTags ) , atDocBookTags [ ( UINT ) ucTopTag ] . szTagname ) ; return ; } } }",
    "resources/antiword/xml.c@vEndOfPageXML": "void vEndOfPageXML ( diagram_type * pDiag ) { if ( bTableOpen || usHeaderLevelCurrent == 0 ) { /* No beginpage in a table or outside a chapter */ return ; } if ( bTitleOpen ) { /* A beginpage is not allowed when in a title */ /* So start a new paragraph */ vEndOfParagraphXML ( pDiag , UINT_MAX ) ; vStartOfParagraphXML ( pDiag , UINT_MAX ) ; return ; } vAddCombinedTag ( pDiag , TAG_BEGINPAGE , NULL ) ; }",
    "resources/antiword/xml.c@vCloseHeaderLevels": "static void vCloseHeaderLevels ( diagram_type * pDiag , USHORT usIstd ) { BOOL bNotReady ; UCHAR ucTopTag ; DBG_MSG ( \"vCloseHeaderLevels\" ) ; DBG_DEC ( usIstd ) ; DBG_DEC ( usHeaderLevelCurrent ) ; vStackTrace ( ) ; bNotReady = TRUE ; do { ucTopTag = ucReadStack ( ) ; switch ( ucTopTag ) { case TAG_TITLE : case TAG_PARA : vAddEndTag ( pDiag , ucTopTag ) ; break ; default : bNotReady = FALSE ; break ; } } while ( bNotReady ) ; vStackTrace ( ) ; while ( usHeaderLevelCurrent >= usIstd ) { if ( bEmptyHeaderLevel ) { vAddCombinedTag ( pDiag , TAG_PARA , NULL ) ; bEmptyHeaderLevel = FALSE ; } switch ( usHeaderLevelCurrent ) { case 1 : vAddEndTag ( pDiag , TAG_CHAPTER ) ; break ; case 2 : vAddEndTag ( pDiag , TAG_SECT1 ) ; break ; case 3 : vAddEndTag ( pDiag , TAG_SECT2 ) ; break ; case 4 : vAddEndTag ( pDiag , TAG_SECT3 ) ; break ; case 5 : vAddEndTag ( pDiag , TAG_SECT4 ) ; break ; case 6 : vAddEndTag ( pDiag , TAG_SECT5 ) ; break ; default : DBG_DEC ( usHeaderLevelCurrent ) ; DBG_FIXME ( ) ; return ; } } DBG_DEC ( usHeaderLevelCurrent ) ; vStackTrace ( ) ; }",
    "resources/antiword/xml.c@vSetHeadersXML": "void vSetHeadersXML ( diagram_type * pDiag , USHORT usIstd ) { fail ( pDiag == NULL ) ; if ( usIstd == 0 || usIstd > 6 ) { DBG_DEC_C ( usIstd != 0 && usIstd <= 9 , usIstd ) ; return ; } DBG_DEC ( usIstd ) ; if ( bTableOpen || uiListLevel != 0 ) { /* No headers when you're in a table or in a list */ return ; } /* Close levels */ vCloseHeaderLevels ( pDiag , usIstd ) ; DBG_DEC ( usHeaderLevelCurrent ) ; /* Open levels */ while ( usHeaderLevelCurrent < usIstd ) { switch ( usHeaderLevelCurrent ) { case 0 : vAddStartTag ( pDiag , TAG_CHAPTER , NULL ) ; break ; case 1 : vAddStartTag ( pDiag , TAG_SECT1 , NULL ) ; break ; case 2 : vAddStartTag ( pDiag , TAG_SECT2 , NULL ) ; break ; case 3 : vAddStartTag ( pDiag , TAG_SECT3 , NULL ) ; break ; case 4 : vAddStartTag ( pDiag , TAG_SECT4 , NULL ) ; break ; case 5 : vAddStartTag ( pDiag , TAG_SECT5 , NULL ) ; break ; default : DBG_DEC ( usHeaderLevelCurrent ) ; DBG_FIXME ( ) ; return ; } fail ( usIstd == 0 ) ; /* The next paragraph should be a title */ if ( usHeaderLevelCurrent < usIstd ) { /* This chapter level is not in the Word document */ vAddCombinedTag ( pDiag , TAG_TITLE , NULL ) ; } else { vAddStartTag ( pDiag , TAG_TITLE , NULL ) ; } } }",
    "resources/antiword/xml.c@vStartOfListXML": "void vStartOfListXML ( diagram_type * pDiag , UCHAR ucNFC , BOOL bIsEndOfTable ) { const char * szAttr ; UCHAR ucTag ; fail ( pDiag == NULL ) ; if ( bIsEndOfTable ) { /* FIXME: until a list in a table is allowed */ vEndOfTableXML ( pDiag ) ; } if ( bTableOpen ) { /* FIXME: a list in a table should be allowed */ return ; } if ( usHeaderLevelCurrent == 0 ) { /* No list without an open header */ vAddStartTag ( pDiag , TAG_CHAPTER , NULL ) ; /* Dummy title */ vAddCombinedTag ( pDiag , TAG_TITLE , NULL ) ; } switch ( ucNFC ) { case LIST_ARABIC_NUM : case LIST_ORDINAL_NUM : case LIST_NUMBER_TXT : case LIST_ORDINAL_TXT : case LIST_OUTLINE_NUM : ucTag = TAG_ORDEREDLIST ; szAttr = \"numeration='arabic'\" ; break ; case LIST_UPPER_ROMAN : ucTag = TAG_ORDEREDLIST ; szAttr = \"numeration='upperroman'\" ; break ; case LIST_LOWER_ROMAN : ucTag = TAG_ORDEREDLIST ; szAttr = \"numeration='lowerroman'\" ; break ; case LIST_UPPER_ALPHA : ucTag = TAG_ORDEREDLIST ; szAttr = \"numeration='upperalpha'\" ; break ; case LIST_LOWER_ALPHA : ucTag = TAG_ORDEREDLIST ; szAttr = \"numeration='loweralpha'\" ; break ; case LIST_SPECIAL : case LIST_SPECIAL2 : case LIST_BULLETS : ucTag = TAG_ITEMIZEDLIST ; szAttr = \"mark='bullet'\" ; break ; default : ucTag = TAG_ORDEREDLIST ; szAttr = \"numeration='arabic'\" ; DBG_HEX ( ucNFC ) ; DBG_FIXME ( ) ; break ; } vAddStartTag ( pDiag , ucTag , szAttr ) ; }",
    "resources/antiword/xml.c@vEndOfListXML": "void vEndOfListXML ( diagram_type * pDiag ) { fail ( pDiag == NULL ) ; if ( bTableOpen ) { /* FIXME: a list in a table should be allowed */ return ; } if ( uiListLevel != 0 ) { vStackTrace ( ) ; vAddEndTagsUntil2 ( pDiag , TAG_ITEMIZEDLIST , TAG_ORDEREDLIST ) ; vStackTrace ( ) ; } }",
    "resources/antiword/xml.c@vStartOfListItemXML": "void vStartOfListItemXML ( diagram_type * pDiag , BOOL bNoMarks ) { const char * szAttr ; UCHAR ucTopTag ; fail ( pDiag == NULL ) ; if ( bTableOpen ) { /* FIXME: a list in a table should be allowed */ return ; } ucTopTag = ucReadStack ( ) ; if ( ucTopTag != TAG_ITEMIZEDLIST && ucTopTag != TAG_ORDEREDLIST ) { /* Must end a previous list item first */ vAddEndTagsUntil1 ( pDiag , TAG_LISTITEM ) ; } DBG_DEC_C ( ucReadStack ( ) != TAG_ITEMIZEDLIST && ucReadStack ( ) != TAG_ORDEREDLIST , ucReadStack ( ) ) ; /* Start a new list item */ szAttr = bNoMarks ? \"override='none'\" : NULL ; vAddStartTag ( pDiag , TAG_LISTITEM , szAttr ) ; /* Start a new paragraph (independant of level) */ vAddStartTag ( pDiag , TAG_PARA , NULL ) ; }",
    "resources/antiword/xml.c@vStartOfTable": "static void vStartOfTable ( diagram_type * pDiag , UCHAR ucBorderInfo ) { const char * szFrame ; BOOL bNotReady ; UCHAR ucTopTag ; char cColSep , cRowSep ; char szAttr [ 40 ] ; fail ( pDiag == NULL ) ; /* Close elements that cannot contain a table */ bNotReady = TRUE ; do { ucTopTag = ucReadStack ( ) ; switch ( ucTopTag ) { case TAG_TITLE : fail ( ! bTitleOpen ) ; vAddEndTag ( pDiag , TAG_TITLE ) ; break ; case TAG_EMPHASIS : fail ( ! bEmphasisOpen ) ; vAddEndTag ( pDiag , TAG_EMPHASIS ) ; break ; case TAG_SUPERSCRIPT : fail ( ! bSuperscriptOpen ) ; vAddEndTag ( pDiag , TAG_SUPERSCRIPT ) ; break ; case TAG_SUBSCRIPT : fail ( ! bSubscriptOpen ) ; vAddEndTag ( pDiag , TAG_SUBSCRIPT ) ; break ; default : bNotReady = FALSE ; break ; } } while ( bNotReady ) ; /* Create table attributes */ switch ( ucBorderInfo ) { case TABLE_BORDER_TOP : szFrame = \"top\" ; break ; case TABLE_BORDER_LEFT | TABLE_BORDER_RIGHT : szFrame = \"sides\" ; break ; case TABLE_BORDER_TOP | TABLE_BORDER_BOTTOM : szFrame = \"topbot\" ; break ; case TABLE_BORDER_BOTTOM : szFrame = \"bottom\" ; break ; case TABLE_BORDER_TOP | TABLE_BORDER_LEFT | TABLE_BORDER_BOTTOM | TABLE_BORDER_RIGHT : szFrame = \"all\" ; break ; default : szFrame = \"none\" ; break ; } cColSep = bIsTableBorderLeft ( ucBorderInfo ) || bIsTableBorderRight ( ucBorderInfo ) ? '1' : '0' ; cRowSep = bIsTableBorderTop ( ucBorderInfo ) || bIsTableBorderBottom ( ucBorderInfo ) ? '1' : '0' ; sprintf ( szAttr , \"frame='%.6s' colsep='%c' rowsep='%c'\" , szFrame , cColSep , cRowSep ) ; if ( usHeaderLevelCurrent == 0 ) { /* No table without an open header */ vAddStartTag ( pDiag , TAG_CHAPTER , NULL ) ; /* Dummy title */ vAddCombinedTag ( pDiag , TAG_TITLE , NULL ) ; } vAddStartTag ( pDiag , TAG_INFORMALTABLE , szAttr ) ; }",
    "resources/antiword/xml.c@vStartOfTableGroup": "static void vStartOfTableGroup ( diagram_type * pDiag , int iNbrOfColumns , const short * asColumnWidth ) { double dWidth ; int iIndex ; char szCols [ 6 + 3 * sizeof ( int ) + 1 + 1 ] ; char szColWidth [ 10 + 3 * sizeof ( short ) + 3 + 3 + 1 ] ; fail ( iNbrOfColumns < 1 ) ; fail ( asColumnWidth == NULL ) ; sprintf ( szCols , \"cols='%d'\" , iNbrOfColumns ) ; vAddStartTag ( pDiag , TAG_TGROUP , szCols ) ; for ( iIndex = 0 ; iIndex < iNbrOfColumns ; iIndex ++ ) { fail ( asColumnWidth [ iIndex ] < 0 ) ; dWidth = dTwips2Points ( asColumnWidth [ iIndex ] ) ; if ( dWidth <= 1.0 ) { strcpy ( szColWidth , \"colwidth='1.00pt'\" ) ; } else { sprintf ( szColWidth , \"colwidth='%.2fpt'\" , dWidth ) ; } vAddCombinedTag ( pDiag , TAG_COLSPEC , szColWidth ) ; } }",
    "resources/antiword/xml.c@vEndOfTableXML": "void vEndOfTableXML ( diagram_type * pDiag ) { fail ( pDiag == NULL ) ; if ( bTableOpen ) { vAddEndTag ( pDiag , TAG_TBODY ) ; vAddEndTag ( pDiag , TAG_TGROUP ) ; vAddEndTag ( pDiag , TAG_INFORMALTABLE ) ; } }",
    "resources/antiword/xml.c@vAddTableRowXML": "void vAddTableRowXML ( diagram_type * pDiag , char * * aszColTxt , int iNbrOfColumns , const short * asColumnWidth , UCHAR ucBorderInfo ) { size_t tCount , tStringLength ; int iIndex ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( aszColTxt == NULL ) ; fail ( iNbrOfColumns < 1 ) ; fail ( asColumnWidth == NULL ) ; if ( iNbrOfColumns != iTableColumnsCurrent ) { /* A new number of columns */ /* End the old table body and table group (if they exist) */ vAddEndTagOptional ( pDiag , TAG_TBODY ) ; vAddEndTagOptional ( pDiag , TAG_TGROUP ) ; if ( ! bTableOpen ) { /* No table yet. Start a new table */ vStartOfTable ( pDiag , ucBorderInfo ) ; } /* Start a new table group and a new table body */ vStartOfTableGroup ( pDiag , iNbrOfColumns , asColumnWidth ) ; vAddStartTag ( pDiag , TAG_TBODY , NULL ) ; iTableColumnsCurrent = iNbrOfColumns ; } /* Add the table row */ vAddStartTag ( pDiag , TAG_ROW , NULL ) ; for ( iIndex = 0 ; iIndex < iNbrOfColumns ; iIndex ++ ) { /* Add a table cell */ fail ( aszColTxt [ iIndex ] == NULL ) ; vAddStartTag ( pDiag , TAG_ENTRY , NULL ) ; tStringLength = strlen ( aszColTxt [ iIndex ] ) ; for ( tCount = 0 ; tCount < tStringLength ; tCount ++ ) { vPrintChar ( pDiag , aszColTxt [ iIndex ] [ tCount ] ) ; } vAddEndTag ( pDiag , TAG_ENTRY ) ; } vAddEndTag ( pDiag , TAG_ROW ) ; }",
    "resources/antiword/pictlist.c@vDestroyPictInfoList": "void vDestroyPictInfoList ( void ) { picture_mem_type * pCurr , * pNext ; DBG_MSG ( \"vDestroyPictInfoList\" ) ; /* Free the Picture Information List */ pCurr = pAnchor ; while ( pCurr != NULL ) { pNext = pCurr -> pNext ; pCurr = xfree ( pCurr ) ; pCurr = pNext ; } pAnchor = NULL ; /* Reset all control variables */ pPictureLast = NULL ; }",
    "resources/antiword/pictlist.c@vAdd2PictInfoList": "void vAdd2PictInfoList ( const picture_block_type * pPictureBlock ) { picture_mem_type * pListMember ; fail ( pPictureBlock == NULL ) ; NO_DBG_MSG ( \"bAdd2PictInfoList\" ) ; if ( pPictureBlock -> ulFileOffset == FC_INVALID ) { /*\n\t\t * This offset is really past the end of the file,\n\t\t * so don't waste any memory by storing it.\n\t\t */ return ; } if ( pPictureBlock -> ulFileOffsetPicture == FC_INVALID ) { /*\n\t\t * The place where this picture is supposed to be stored\n\t\t * doesn't exist.\n\t\t */ return ; } NO_DBG_HEX ( pPictureBlock -> ulFileOffset ) ; NO_DBG_HEX ( pPictureBlock -> ulFileOffsetPicture ) ; NO_DBG_HEX ( pPictureBlock -> ulPictureOffset ) ; /* Create list member */ pListMember = xmalloc ( sizeof ( picture_mem_type ) ) ; /* Fill the list member */ pListMember -> tInfo = * pPictureBlock ; pListMember -> pNext = NULL ; /* Add the new member to the list */ if ( pAnchor == NULL ) { pAnchor = pListMember ; } else { fail ( pPictureLast == NULL ) ; pPictureLast -> pNext = pListMember ; } pPictureLast = pListMember ; }",
    "resources/antiword/pictlist.c@ulGetPictInfoListItem": "ULONG ulGetPictInfoListItem ( ULONG ulFileOffset ) { picture_mem_type * pCurr ; for ( pCurr = pAnchor ; pCurr != NULL ; pCurr = pCurr -> pNext ) { if ( pCurr -> tInfo . ulFileOffset == ulFileOffset ) { return pCurr -> tInfo . ulFileOffsetPicture ; } } return FC_INVALID ; }",
    "resources/antiword/drawfile.c@pFillError": "static os_error * pFillError ( int iErrorNumber ) { static os_error tError ; const drawfile_error_type * pTmp ; const char * szErrorText ; szErrorText = \"Unknown error\" ; for ( pTmp = atErrors ; pTmp < atErrors + elementsof ( atErrors ) ; pTmp ++ ) { if ( iErrorNumber == pTmp -> iErrorNumber ) { szErrorText = pTmp -> szErrorText ; break ; } } tError . errnum = iErrorNumber ; strncpy ( tError . errmess , szErrorText , sizeof ( tError . errmess ) - 1 ) ; tError . errmess [ sizeof ( tError . errmess ) - 1 ] = '\\0' ; DBG_DEC ( tError . errnum ) ; DBG_MSG ( tError . errmess ) ; return & tError ; }",
    "resources/antiword/drawfile.c@Drawfile_Bbox": "os_error * Drawfile_Bbox ( drawfile_bbox_flags flags , drawfile_diagram const * diagram , int size , os_trfm const * trfm , wimp_box * bbox ) { return SWI ( 5 , 0 , DrawFile_BBox | XOS_Bit , flags , diagram , size , trfm , bbox ) ; }",
    "resources/antiword/drawfile.c@Drawfile_CreateDiagram": "os_error * Drawfile_CreateDiagram ( drawfile_info * pInfo , size_t tMemorySize , const char * szCreator , wimp_box tBbox ) { drawfile_diagram * pDiag ; if ( tMemorySize < offsetof ( drawfile_diagram , objects ) ) { return pFillError ( DRAWFILE_SMALL_MEMORY ) ; } pDiag = ( drawfile_diagram * ) pInfo -> data ; strncpy ( pDiag -> tag , \"Draw\" , 4 ) ; pDiag -> major_version = 201 ; pDiag -> minor_version = 0 ; strncpy ( pDiag -> source , szCreator , sizeof ( pDiag -> source ) ) ; pDiag -> bbox = tBbox ; /* Memory in use */ pInfo -> length = offsetof ( drawfile_diagram , objects ) ; return NULL ; }",
    "resources/antiword/drawfile.c@Drawfile_AppendObject": "os_error * Drawfile_AppendObject ( drawfile_info * pInfo , size_t tMemorySize , const drawfile_object * pObject , BOOL bRebind ) { wimp_box * pMainBbox ; const wimp_box * pBbox ; byte * pAfter ; if ( tMemorySize < pInfo -> length + pObject -> size ) { return pFillError ( DRAWFILE_OBJECT_TOO_SMALL ) ; } /* After the last object */ pAfter = ( byte * ) pInfo -> data + pInfo -> length ; /* Copy in the new data */ memcpy ( pAfter , pObject , pObject -> size ) ; /* Rebind if needed */ if ( bRebind ) { pMainBbox = & ( ( drawfile_diagram * ) pInfo -> data ) -> bbox ; switch ( pObject -> type ) { case drawfile_TYPE_FONT_TABLE : pBbox = NULL ; break ; case drawfile_TYPE_TEXT : pBbox = & pObject -> data . text . bbox ; break ; case drawfile_TYPE_PATH : pBbox = & pObject -> data . path . bbox ; break ; case drawfile_TYPE_SPRITE : pBbox = & pObject -> data . sprite . bbox ; break ; case drawfile_TYPE_GROUP : pBbox = & pObject -> data . group . bbox ; break ; case drawfile_TYPE_TAGGED : pBbox = & pObject -> data . tagged . bbox ; break ; case drawfile_TYPE_TEXT_AREA : pBbox = & pObject -> data . text_area . bbox ; break ; case drawfile_TYPE_TEXT_COLUMN : pBbox = NULL ; break ; case drawfile_TYPE_OPTIONS : pBbox = & pObject -> data . options . bbox ; break ; case drawfile_TYPE_TRFM_TEXT : pBbox = & pObject -> data . trfm_text . bbox ; break ; case drawfile_TYPE_TRFM_SPRITE : pBbox = & pObject -> data . trfm_sprite . bbox ; break ; case drawfile_TYPE_JPEG : pBbox = & pObject -> data . jpeg . bbox ; break ; default : pBbox = NULL ; break ; } if ( pBbox != NULL ) { if ( pBbox -> min . x < pMainBbox -> min . x ) { pMainBbox -> min . x = pBbox -> min . x ; } if ( pBbox -> min . y < pMainBbox -> min . y ) { pMainBbox -> min . y = pBbox -> min . y ; } if ( pBbox -> max . x > pMainBbox -> max . x ) { pMainBbox -> max . x = pBbox -> max . x ; } if ( pBbox -> max . y > pMainBbox -> max . y ) { pMainBbox -> max . y = pBbox -> max . y ; } } } /* Memory in use */ pInfo -> length += pObject -> size ; return NULL ; }",
    "resources/antiword/drawfile.c@Drawfile_RenderDiagram": "os_error * Drawfile_RenderDiagram ( drawfile_info * pInfo , window_redrawblock * pRedraw , double dScale ) { int aiTransform [ 6 ] ; fail ( pInfo == NULL ) ; fail ( pInfo -> data == NULL ) ; fail ( pRedraw == NULL ) ; fail ( dScale < 0.01 ) ; aiTransform [ 0 ] = ( int ) ( dScale * 0x10000 ) ; aiTransform [ 1 ] = 0 ; aiTransform [ 2 ] = 0 ; aiTransform [ 3 ] = ( int ) ( dScale * 0x10000 ) ; aiTransform [ 4 ] = ( pRedraw -> rect . min . x - pRedraw -> scroll . x ) * 256 ; aiTransform [ 5 ] = ( pRedraw -> rect . max . y - pRedraw -> scroll . y ) * 256 ; return SWI ( 6 , 0 , DrawFile_Render | XOS_Bit , 0 , pInfo -> data , pInfo -> length , aiTransform , & pRedraw -> rect , 0 ) ; }",
    "resources/antiword/drawfile.c@pVerifyText": "static os_error * pVerifyText ( const drawfile_text * pText ) { const unsigned char * pucTmp ; if ( pText -> text [ 0 ] == '\\0' ) { return pFillError ( DRAWFILE_NO_TEXT ) ; } pucTmp = ( const unsigned char * ) pText -> text ; while ( * pucTmp != '\\0' ) { if ( * pucTmp < 0x20 || * pucTmp == 0x7f ) { return pFillError ( DRAWFILE_BAD_CHARACTER ) ; } pucTmp ++ ; } return NULL ; }",
    "resources/antiword/drawfile.c@pVerifyPath": "static os_error * pVerifyPath ( const drawfile_path * pPath , int iSize ) { const int * piTmp ; int iElements ; BOOL bLine ; bLine = FALSE ; iElements = ( iSize - offsetof ( drawfile_path , path ) ) / 4 ; for ( piTmp = pPath -> path ; piTmp < pPath -> path + iElements ; piTmp ++ ) { switch ( * piTmp ) { case drawfile_PATH_END_PATH : if ( bLine ) { return NULL ; } return pFillError ( DRAWFILE_PATH_WITHOUT_LINES ) ; case drawfile_PATH_LINE_TO : bLine = TRUE ; piTmp += 2 ; break ; case drawfile_PATH_MOVE_TO : piTmp += 2 ; break ; case drawfile_PATH_CLOSE_LINE : bLine = TRUE ; break ; default : return pFillError ( DRAWFILE_BAD_PATH_TYPE ) ; } } return pFillError ( DRAWFILE_PATH_WITHOUT_END ) ; }",
    "resources/antiword/drawfile.c@pVerifySprite": "static os_error * pVerifySprite ( const drawfile_sprite * pSprite , int iSize ) { iSize -= offsetof ( drawfile_sprite , header ) ; if ( iSize < pSprite -> header . offset_next ) { DBG_DEC ( iSize ) ; DBG_DEC ( pSprite -> header . offset_next ) ; return pFillError ( DRAWFILE_BAD_SPRITE_SIZE ) ; } return NULL ; }",
    "resources/antiword/drawfile.c@pVerifyJpeg": "static os_error * pVerifyJpeg ( const drawfile_jpeg * pJpeg , int iSize ) { iSize -= offsetof ( drawfile_jpeg , data ) ; if ( iSize < pJpeg -> len ) { DBG_DEC ( iSize ) ; DBG_DEC ( pJpeg -> len ) ; return pFillError ( DRAWFILE_BAD_JPEG_SIZE ) ; } return NULL ; }",
    "resources/antiword/drawfile.c@Drawfile_VerifyDiagram": "os_error * Drawfile_VerifyDiagram ( drawfile_info * pInfo ) { drawfile_diagram * pDiag ; drawfile_object * pObj ; os_error * pError ; const char * pcTmp ; int iToGo , iFontTables ; BOOL bTypeFontTable ; TRACE_MSG ( \"Drawfile_VerifyDiagram\" ) ; fail ( pInfo == NULL ) ; if ( pInfo -> length < offsetof ( drawfile_diagram , objects ) ) { return pFillError ( DRAWFILE_TOO_SMALL ) ; } pDiag = ( drawfile_diagram * ) pInfo -> data ; if ( strncmp ( pDiag -> tag , \"Draw\" , 4 ) != 0 || pDiag -> major_version != 201 || pDiag -> minor_version != 0 ) { return pFillError ( DRAWFILE_NOT_A_DRAWFILE ) ; } iToGo = pInfo -> length - offsetof ( drawfile_diagram , objects ) ; pcTmp = ( const char * ) pInfo -> data + offsetof ( drawfile_diagram , objects ) ; iFontTables = 0 ; bTypeFontTable = FALSE ; while ( iToGo > 0 ) { pObj = ( drawfile_object * ) pcTmp ; if ( pObj -> size < 0 || pObj -> size % 4 != 0 ) { return pFillError ( DRAWFILE_OBJECT_SIZE ) ; } switch ( pObj -> type ) { case drawfile_TYPE_FONT_TABLE : if ( bTypeFontTable ) { return pFillError ( DRAWFILE_MANY_FONTTABLES ) ; } bTypeFontTable = TRUE ; break ; case drawfile_TYPE_TEXT : if ( pObj -> data . text . style . font_ref != 0 && ! bTypeFontTable ) { return pFillError ( DRAWFILE_TEXT_NO_FONT ) ; } pError = pVerifyText ( & pObj -> data . text ) ; if ( pError != NULL ) { return pError ; } break ; case drawfile_TYPE_PATH : pError = pVerifyPath ( & pObj -> data . path , pObj -> size - offsetof ( drawfile_object , data ) ) ; if ( pError != NULL ) { return pError ; } break ; case drawfile_TYPE_SPRITE : pError = pVerifySprite ( & pObj -> data . sprite , pObj -> size - offsetof ( drawfile_object , data ) ) ; if ( pError != NULL ) { return pError ; } break ; case drawfile_TYPE_JPEG : pError = pVerifyJpeg ( & pObj -> data . jpeg , pObj -> size - offsetof ( drawfile_object , data ) ) ; if ( pError != NULL ) { return pError ; } break ; default : DBG_DEC ( pObj -> type ) ; return pFillError ( DRAWFILE_OBJECT_UNEXPECTED ) ; } pcTmp += pObj -> size ; iToGo -= pObj -> size ; } if ( iToGo < 0 ) { return pFillError ( DRAWFILE_SIZE_ERROR ) ; } return NULL ; }",
    "resources/antiword/drawfile.c@Drawfile_QueryBox": "void Drawfile_QueryBox ( drawfile_info * pInfo , wimp_box * pRect , BOOL bScreenUnits ) { fail ( pInfo == NULL ) ; fail ( pRect == NULL ) ; Error_CheckFatal ( Drawfile_Bbox ( 0 , pInfo -> data , pInfo -> length , NULL , pRect ) ) ; if ( bScreenUnits ) { pRect -> min . x = Drawfile_DrawToScreen ( pRect -> min . x ) ; pRect -> min . y = Drawfile_DrawToScreen ( pRect -> min . y ) ; pRect -> max . x = Drawfile_DrawToScreen ( pRect -> max . x ) ; pRect -> max . y = Drawfile_DrawToScreen ( pRect -> max . y ) ; } }",
    "resources/antiword/wordole.c@ulReadLong": "static ULONG ulReadLong ( FILE * pFile , ULONG ulOffset ) { UCHAR aucBytes [ 4 ] ; fail ( pFile == NULL ) ; if ( ! bReadBytes ( aucBytes , 4 , ulOffset , pFile ) ) { werr ( 1 , \"Read long 0x%lx not possible\" , ulOffset ) ; } return ulGetLong ( 0 , aucBytes ) ; }",
    "resources/antiword/wordole.c@vName2String": "static void vName2String ( char * szName , const UCHAR * aucBytes , size_t tNameSize ) { char * pcChar ; size_t tIndex ; fail ( aucBytes == NULL || szName == NULL ) ; if ( tNameSize < 2 ) { szName [ 0 ] = '\\0' ; return ; } for ( tIndex = 0 , pcChar = szName ; tIndex < 2 * tNameSize ; tIndex += 2 , pcChar ++ ) { * pcChar = ( char ) aucBytes [ tIndex ] ; } szName [ tNameSize - 1 ] = '\\0' ; }",
    "resources/antiword/wordole.c@tReadBlockIndices": "static size_t tReadBlockIndices ( FILE * pFile , ULONG * aulBlockDepot , size_t tMaxRec , ULONG ulOffset ) { size_t tDone ; int iIndex ; UCHAR aucBytes [ BIG_BLOCK_SIZE ] ; fail ( pFile == NULL || aulBlockDepot == NULL ) ; fail ( tMaxRec == 0 ) ; /* Read a big block with BBD or SBD indices */ if ( ! bReadBytes ( aucBytes , BIG_BLOCK_SIZE , ulOffset , pFile ) ) { werr ( 0 , \"Reading big block from 0x%lx is not possible\" , ulOffset ) ; return 0 ; } /* Split the big block into indices, an index is four bytes */ tDone = min ( tMaxRec , ( size_t ) BIG_BLOCK_SIZE / 4 ) ; for ( iIndex = 0 ; iIndex < ( int ) tDone ; iIndex ++ ) { aulBlockDepot [ iIndex ] = ulGetLong ( 4 * iIndex , aucBytes ) ; NO_DBG_DEC ( aulBlockDepot [ iIndex ] ) ; } return tDone ; }",
    "resources/antiword/wordole.c@bGetBBD": "static BOOL bGetBBD ( FILE * pFile , const ULONG * aulDepot , size_t tDepotLen , ULONG * aulBBD , size_t tBBDLen ) { ULONG ulBegin ; size_t tToGo , tDone ; int iIndex ; fail ( pFile == NULL || aulDepot == NULL || aulBBD == NULL ) ; DBG_MSG ( \"bGetBBD\" ) ; tToGo = tBBDLen ; for ( iIndex = 0 ; iIndex < ( int ) tDepotLen && tToGo != 0 ; iIndex ++ ) { ulBegin = ( aulDepot [ iIndex ] + 1 ) * BIG_BLOCK_SIZE ; NO_DBG_HEX ( ulBegin ) ; tDone = tReadBlockIndices ( pFile , aulBBD , tToGo , ulBegin ) ; fail ( tDone > tToGo ) ; if ( tDone == 0 ) { return FALSE ; } aulBBD += tDone ; tToGo -= tDone ; } return tToGo == 0 ; }",
    "resources/antiword/wordole.c@bGetSBD": "static BOOL bGetSBD ( FILE * pFile , const ULONG * aulDepot , size_t tDepotLen , ULONG * aulSBD , size_t tSBDLen ) { ULONG ulBegin ; size_t tToGo , tDone ; int iIndex ; fail ( pFile == NULL || aulDepot == NULL || aulSBD == NULL ) ; DBG_MSG ( \"bGetSBD\" ) ; tToGo = tSBDLen ; for ( iIndex = 0 ; iIndex < ( int ) tDepotLen && tToGo != 0 ; iIndex ++ ) { fail ( aulDepot [ iIndex ] >= ULONG_MAX / BIG_BLOCK_SIZE ) ; ulBegin = ( aulDepot [ iIndex ] + 1 ) * BIG_BLOCK_SIZE ; NO_DBG_HEX ( ulBegin ) ; tDone = tReadBlockIndices ( pFile , aulSBD , tToGo , ulBegin ) ; fail ( tDone > tToGo ) ; if ( tDone == 0 ) { return FALSE ; } aulSBD += tDone ; tToGo -= tDone ; } return tToGo == 0 ; }",
    "resources/antiword/wordole.c@vComputePPSlevels": "static void vComputePPSlevels ( pps_entry_type * atPPSlist , pps_entry_type * pNode , int iLevel , int iRecursionLevel ) { fail ( atPPSlist == NULL || pNode == NULL ) ; fail ( iLevel < 0 || iRecursionLevel < 0 ) ; if ( iRecursionLevel > 25 ) { /* This removes the possibility of an infinite recursion */ DBG_DEC ( iRecursionLevel ) ; return ; } if ( pNode -> iLevel <= iLevel ) { /* Avoid entering a loop */ DBG_DEC ( iLevel ) ; DBG_DEC ( pNode -> iLevel ) ; return ; } pNode -> iLevel = iLevel ; if ( pNode -> ulDir != PPS_NUMBER_INVALID ) { vComputePPSlevels ( atPPSlist , & atPPSlist [ pNode -> ulDir ] , iLevel + 1 , iRecursionLevel + 1 ) ; } if ( pNode -> ulNext != PPS_NUMBER_INVALID ) { vComputePPSlevels ( atPPSlist , & atPPSlist [ pNode -> ulNext ] , iLevel , iRecursionLevel + 1 ) ; } if ( pNode -> ulPrevious != PPS_NUMBER_INVALID ) { vComputePPSlevels ( atPPSlist , & atPPSlist [ pNode -> ulPrevious ] , iLevel , iRecursionLevel + 1 ) ; } }",
    "resources/antiword/wordole.c@bGetPPS": "static BOOL bGetPPS ( FILE * pFile , const ULONG * aulRootList , size_t tRootListLen , pps_info_type * pPPS ) { pps_entry_type * atPPSlist ; ULONG ulBegin , ulOffset , ulTmp ; size_t tNbrOfPPS , tNameSize ; int iIndex , iStartBlock , iRootIndex ; BOOL bWord , bExcel ; UCHAR aucBytes [ PROPERTY_SET_STORAGE_SIZE ] ; fail ( pFile == NULL || aulRootList == NULL || pPPS == NULL ) ; DBG_MSG ( \"bGetPPS\" ) ; NO_DBG_DEC ( tRootListLen ) ; bWord = FALSE ; bExcel = FALSE ; ( void ) memset ( pPPS , 0 , sizeof ( * pPPS ) ) ; /* Read and store all the Property Set Storage entries */ tNbrOfPPS = tRootListLen * BIG_BLOCK_SIZE / PROPERTY_SET_STORAGE_SIZE ; atPPSlist = xcalloc ( tNbrOfPPS , sizeof ( pps_entry_type ) ) ; iRootIndex = 0 ; for ( iIndex = 0 ; iIndex < ( int ) tNbrOfPPS ; iIndex ++ ) { ulTmp = ( ULONG ) iIndex * PROPERTY_SET_STORAGE_SIZE ; iStartBlock = ( int ) ( ulTmp / BIG_BLOCK_SIZE ) ; ulOffset = ulTmp % BIG_BLOCK_SIZE ; ulBegin = ( aulRootList [ iStartBlock ] + 1 ) * BIG_BLOCK_SIZE + ulOffset ; NO_DBG_HEX ( ulBegin ) ; if ( ! bReadBytes ( aucBytes , PROPERTY_SET_STORAGE_SIZE , ulBegin , pFile ) ) { werr ( 0 , \"Reading PPS %d is not possible\" , iIndex ) ; atPPSlist = xfree ( atPPSlist ) ; return FALSE ; } tNameSize = ( size_t ) usGetWord ( 0x40 , aucBytes ) ; tNameSize = ( tNameSize + 1 ) / 2 ; vName2String ( atPPSlist [ iIndex ] . szName , aucBytes , tNameSize ) ; atPPSlist [ iIndex ] . ucType = ucGetByte ( 0x42 , aucBytes ) ; if ( atPPSlist [ iIndex ] . ucType == 5 ) { iRootIndex = iIndex ; } atPPSlist [ iIndex ] . ulPrevious = ulGetLong ( 0x44 , aucBytes ) ; atPPSlist [ iIndex ] . ulNext = ulGetLong ( 0x48 , aucBytes ) ; atPPSlist [ iIndex ] . ulDir = ulGetLong ( 0x4c , aucBytes ) ; atPPSlist [ iIndex ] . ulSB = ulGetLong ( 0x74 , aucBytes ) ; atPPSlist [ iIndex ] . ulSize = ulGetLong ( 0x78 , aucBytes ) ; atPPSlist [ iIndex ] . iLevel = INT_MAX ; if ( ( atPPSlist [ iIndex ] . ulPrevious >= ( ULONG ) tNbrOfPPS && atPPSlist [ iIndex ] . ulPrevious != PPS_NUMBER_INVALID ) || ( atPPSlist [ iIndex ] . ulNext >= ( ULONG ) tNbrOfPPS && atPPSlist [ iIndex ] . ulNext != PPS_NUMBER_INVALID ) || ( atPPSlist [ iIndex ] . ulDir >= ( ULONG ) tNbrOfPPS && atPPSlist [ iIndex ] . ulDir != PPS_NUMBER_INVALID ) ) { DBG_DEC ( iIndex ) ; DBG_DEC ( atPPSlist [ iIndex ] . ulPrevious ) ; DBG_DEC ( atPPSlist [ iIndex ] . ulNext ) ; DBG_DEC ( atPPSlist [ iIndex ] . ulDir ) ; DBG_DEC ( tNbrOfPPS ) ; werr ( 0 , \"The Property Set Storage is damaged\" ) ; atPPSlist = xfree ( atPPSlist ) ; return FALSE ; } } # if 0 /* defined(DEBUG) */ DBG_MSG ( \"Before\" ) ; for ( iIndex = 0 ; iIndex < ( int ) tNbrOfPPS ; iIndex ++ ) { DBG_MSG ( atPPSlist [ iIndex ] . szName ) ; DBG_HEX ( atPPSlist [ iIndex ] . ulDir ) ; DBG_HEX ( atPPSlist [ iIndex ] . ulPrevious ) ; DBG_HEX ( atPPSlist [ iIndex ] . ulNext ) ; DBG_DEC ( atPPSlist [ iIndex ] . ulSB ) ; DBG_HEX ( atPPSlist [ iIndex ] . ulSize ) ; DBG_DEC ( atPPSlist [ iIndex ] . iLevel ) ; } # endif /* DEBUG */ /* Add level information to each entry */ vComputePPSlevels ( atPPSlist , & atPPSlist [ iRootIndex ] , 0 , 0 ) ; /* Check the entries on level 1 for the required information */ NO_DBG_MSG ( \"After\" ) ; for ( iIndex = 0 ; iIndex < ( int ) tNbrOfPPS ; iIndex ++ ) { # if 0 /* defined(DEBUG) */ DBG_MSG ( atPPSlist [ iIndex ] . szName ) ; DBG_HEX ( atPPSlist [ iIndex ] . ulDir ) ; DBG_HEX ( atPPSlist [ iIndex ] . ulPrevious ) ; DBG_HEX ( atPPSlist [ iIndex ] . ulNext ) ; DBG_DEC ( atPPSlist [ iIndex ] . ulSB ) ; DBG_HEX ( atPPSlist [ iIndex ] . ulSize ) ; DBG_DEC ( atPPSlist [ iIndex ] . iLevel ) ; # endif /* DEBUG */ if ( atPPSlist [ iIndex ] . iLevel != 1 || atPPSlist [ iIndex ] . ucType != 2 || atPPSlist [ iIndex ] . szName [ 0 ] == '\\0' || atPPSlist [ iIndex ] . ulSize == 0 ) { /* This entry can be ignored */ continue ; } if ( pPPS -> tWordDocument . ulSize == 0 && STREQ ( atPPSlist [ iIndex ] . szName , \"WordDocument\" ) ) { pPPS -> tWordDocument . ulSB = atPPSlist [ iIndex ] . ulSB ; pPPS -> tWordDocument . ulSize = atPPSlist [ iIndex ] . ulSize ; bWord = TRUE ; } else if ( pPPS -> tData . ulSize == 0 && STREQ ( atPPSlist [ iIndex ] . szName , \"Data\" ) ) { pPPS -> tData . ulSB = atPPSlist [ iIndex ] . ulSB ; pPPS -> tData . ulSize = atPPSlist [ iIndex ] . ulSize ; } else if ( pPPS -> t0Table . ulSize == 0 && STREQ ( atPPSlist [ iIndex ] . szName , \"0Table\" ) ) { pPPS -> t0Table . ulSB = atPPSlist [ iIndex ] . ulSB ; pPPS -> t0Table . ulSize = atPPSlist [ iIndex ] . ulSize ; } else if ( pPPS -> t1Table . ulSize == 0 && STREQ ( atPPSlist [ iIndex ] . szName , \"1Table\" ) ) { pPPS -> t1Table . ulSB = atPPSlist [ iIndex ] . ulSB ; pPPS -> t1Table . ulSize = atPPSlist [ iIndex ] . ulSize ; } else if ( pPPS -> tSummaryInfo . ulSize == 0 && STREQ ( atPPSlist [ iIndex ] . szName , \"\\005SummaryInformation\" ) ) { pPPS -> tSummaryInfo . ulSB = atPPSlist [ iIndex ] . ulSB ; pPPS -> tSummaryInfo . ulSize = atPPSlist [ iIndex ] . ulSize ; } else if ( pPPS -> tDocSummaryInfo . ulSize == 0 && STREQ ( atPPSlist [ iIndex ] . szName , \"\\005DocumentSummaryInformation\" ) ) { pPPS -> tDocSummaryInfo . ulSB = atPPSlist [ iIndex ] . ulSB ; pPPS -> tDocSummaryInfo . ulSize = atPPSlist [ iIndex ] . ulSize ; } else if ( STREQ ( atPPSlist [ iIndex ] . szName , \"Book\" ) || STREQ ( atPPSlist [ iIndex ] . szName , \"Workbook\" ) ) { bExcel = TRUE ; } } /* Free the space for the Property Set Storage entries */ atPPSlist = xfree ( atPPSlist ) ; /* Draw your conclusions */ if ( bWord ) { return TRUE ; } if ( bExcel ) { werr ( 0 , \"Sorry, but this is an Excel spreadsheet\" ) ; } else { werr ( 0 , \"This OLE file does not contain a Word document\" ) ; } return FALSE ; }",
    "resources/antiword/wordole.c@vGetBbdList": "static void vGetBbdList ( FILE * pFile , int iNbr , ULONG * aulBbdList , ULONG ulOffset ) { int iIndex ; fail ( pFile == NULL ) ; fail ( iNbr > 127 ) ; fail ( aulBbdList == NULL ) ; NO_DBG_DEC ( iNbr ) ; for ( iIndex = 0 ; iIndex < iNbr ; iIndex ++ ) { aulBbdList [ iIndex ] = ulReadLong ( pFile , ulOffset + 4 * ( ULONG ) iIndex ) ; NO_DBG_DEC ( iIndex ) ; NO_DBG_HEX ( aulBbdList [ iIndex ] ) ; } }",
    "resources/antiword/wordole.c@bGetDocumentText": "static BOOL bGetDocumentText ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader , int iWordVersion ) { ULONG ulBeginOfText ; ULONG ulTextLen , ulFootnoteLen , ulEndnoteLen ; ULONG ulHdrFtrLen , ulMacroLen , ulAnnotationLen ; ULONG ulTextBoxLen , ulHdrTextBoxLen ; UINT uiQuickSaves ; BOOL bFarEastWord , bTemplate , bFastSaved , bEncrypted , bSuccess ; USHORT usIdent , usDocStatus ; fail ( pFile == NULL || pPPS == NULL ) ; fail ( aulBBD == NULL ) ; fail ( aulSBD == NULL ) ; DBG_MSG ( \"bGetDocumentText\" ) ; /* Get the \"magic number\" from the header */ usIdent = usGetWord ( 0x00 , aucHeader ) ; DBG_HEX ( usIdent ) ; bFarEastWord = usIdent == 0x8098 || usIdent == 0x8099 || usIdent == 0xa697 || usIdent == 0xa699 ; /* Get the status flags from the header */ usDocStatus = usGetWord ( 0x0a , aucHeader ) ; DBG_HEX ( usDocStatus ) ; bTemplate = ( usDocStatus & BIT ( 0 ) ) != 0 ; DBG_MSG_C ( bTemplate , \"This document is a Template\" ) ; bFastSaved = ( usDocStatus & BIT ( 2 ) ) != 0 ; uiQuickSaves = ( UINT ) ( usDocStatus & 0x00f0 ) >> 4 ; DBG_MSG_C ( bFastSaved , \"This document is Fast Saved\" ) ; DBG_DEC_C ( bFastSaved , uiQuickSaves ) ; bEncrypted = ( usDocStatus & BIT ( 8 ) ) != 0 ; if ( bEncrypted ) { werr ( 0 , \"Encrypted documents are not supported\" ) ; return FALSE ; } /* Get length information */ ulBeginOfText = ulGetLong ( 0x18 , aucHeader ) ; DBG_HEX ( ulBeginOfText ) ; switch ( iWordVersion ) { case 6 : case 7 : ulTextLen = ulGetLong ( 0x34 , aucHeader ) ; ulFootnoteLen = ulGetLong ( 0x38 , aucHeader ) ; ulHdrFtrLen = ulGetLong ( 0x3c , aucHeader ) ; ulMacroLen = ulGetLong ( 0x40 , aucHeader ) ; ulAnnotationLen = ulGetLong ( 0x44 , aucHeader ) ; ulEndnoteLen = ulGetLong ( 0x48 , aucHeader ) ; ulTextBoxLen = ulGetLong ( 0x4c , aucHeader ) ; ulHdrTextBoxLen = ulGetLong ( 0x50 , aucHeader ) ; break ; case 8 : ulTextLen = ulGetLong ( 0x4c , aucHeader ) ; ulFootnoteLen = ulGetLong ( 0x50 , aucHeader ) ; ulHdrFtrLen = ulGetLong ( 0x54 , aucHeader ) ; ulMacroLen = ulGetLong ( 0x58 , aucHeader ) ; ulAnnotationLen = ulGetLong ( 0x5c , aucHeader ) ; ulEndnoteLen = ulGetLong ( 0x60 , aucHeader ) ; ulTextBoxLen = ulGetLong ( 0x64 , aucHeader ) ; ulHdrTextBoxLen = ulGetLong ( 0x68 , aucHeader ) ; break ; default : werr ( 0 , \"This version of Word is not supported\" ) ; return FALSE ; } DBG_DEC ( ulTextLen ) ; DBG_DEC ( ulFootnoteLen ) ; DBG_DEC ( ulHdrFtrLen ) ; DBG_DEC ( ulMacroLen ) ; DBG_DEC ( ulAnnotationLen ) ; DBG_DEC ( ulEndnoteLen ) ; DBG_DEC ( ulTextBoxLen ) ; DBG_DEC ( ulHdrTextBoxLen ) ; /* Make a list of the text blocks */ switch ( iWordVersion ) { case 6 : case 7 : if ( bFastSaved ) { bSuccess = bGet6DocumentText ( pFile , bFarEastWord , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , aucHeader ) ; } else { bSuccess = bAddTextBlocks ( ulBeginOfText , ulTextLen + ulFootnoteLen + ulHdrFtrLen + ulMacroLen + ulAnnotationLen + ulEndnoteLen + ulTextBoxLen + ulHdrTextBoxLen , bFarEastWord , IGNORE_PROPMOD , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen ) ; } break ; case 8 : bSuccess = bGet8DocumentText ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; break ; default : werr ( 0 , \"This version of Word is not supported\" ) ; bSuccess = FALSE ; break ; } if ( bSuccess ) { vSplitBlockList ( pFile , ulTextLen , ulFootnoteLen , ulHdrFtrLen , ulMacroLen , ulAnnotationLen , ulEndnoteLen , ulTextBoxLen , ulHdrTextBoxLen , ! bFastSaved && iWordVersion == 8 ) ; } else { vDestroyTextBlockList ( ) ; werr ( 0 , \"I can't find the text of this document\" ) ; } return bSuccess ; }",
    "resources/antiword/wordole.c@vGetDocumentData": "static void vGetDocumentData ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const UCHAR * aucHeader , int iWordVersion ) { options_type tOptions ; ULONG ulBeginOfText ; BOOL bFastSaved , bHasImages , bSuccess ; USHORT usDocStatus ; fail ( pFile == NULL ) ; fail ( pPPS == NULL ) ; fail ( aulBBD == NULL ) ; /* Get the options */ vGetOptions ( & tOptions ) ; /* Get the status flags from the header */ usDocStatus = usGetWord ( 0x0a , aucHeader ) ; DBG_HEX ( usDocStatus ) ; bFastSaved = ( usDocStatus & BIT ( 2 ) ) != 0 ; bHasImages = ( usDocStatus & BIT ( 3 ) ) != 0 ; if ( ! bHasImages || tOptions . eConversionType == conversion_text || tOptions . eConversionType == conversion_fmt_text || tOptions . eConversionType == conversion_xml || tOptions . eImageLevel == level_no_images ) { /*\n\t\t * No images in the document or text-only output or\n\t\t * no images wanted, so no data blocks will be needed\n\t\t */ vDestroyDataBlockList ( ) ; return ; } /* Get length information */ ulBeginOfText = ulGetLong ( 0x18 , aucHeader ) ; DBG_HEX ( ulBeginOfText ) ; /* Make a list of the data blocks */ switch ( iWordVersion ) { case 6 : case 7 : /*\n\t\t * The data blocks are in the text stream. The text stream\n\t\t * is in \"fast saved\" format or \"normal saved\" format\n\t\t */ if ( bFastSaved ) { bSuccess = bGet6DocumentData ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , aucHeader ) ; } else { bSuccess = bAddDataBlocks ( ulBeginOfText , ( ULONG ) LONG_MAX , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen ) ; } break ; case 8 : /*\n\t\t * The data blocks are in the data stream. The data stream\n\t\t * is always in \"normal saved\" format\n\t\t */ bSuccess = bAddDataBlocks ( 0 , ( ULONG ) LONG_MAX , pPPS -> tData . ulSB , aulBBD , tBBDLen ) ; break ; default : werr ( 0 , \"This version of Word is not supported\" ) ; bSuccess = FALSE ; break ; } if ( ! bSuccess ) { vDestroyDataBlockList ( ) ; werr ( 0 , \"I can't find the data of this document\" ) ; } }",
    "resources/antiword/wordole.c@iInitDocumentOLE": "int iInitDocumentOLE ( FILE * pFile , long lFilesize ) { pps_info_type PPS_info ; ULONG * aulBBD , * aulSBD ; ULONG * aulRootList , * aulBbdList , * aulSbdList ; ULONG ulBdbListStart , ulAdditionalBBDlist ; ULONG ulRootStartblock , ulSbdStartblock , ulSBLstartblock ; ULONG ulStart , ulTmp ; long lMaxBlock ; size_t tBBDLen , tSBDLen , tNumBbdBlocks , tRootListLen ; int iWordVersion , iIndex , iToGo ; BOOL bSuccess ; USHORT usIdent , usDocStatus ; UCHAR aucHeader [ HEADER_SIZE ] ; fail ( pFile == NULL ) ; lMaxBlock = lFilesize / BIG_BLOCK_SIZE - 2 ; DBG_DEC ( lMaxBlock ) ; if ( lMaxBlock < 1 ) { return - 1 ; } tBBDLen = ( size_t ) ( lMaxBlock + 1 ) ; tNumBbdBlocks = ( size_t ) ulReadLong ( pFile , 0x2c ) ; DBG_DEC ( tNumBbdBlocks ) ; ulRootStartblock = ulReadLong ( pFile , 0x30 ) ; DBG_DEC ( ulRootStartblock ) ; ulSbdStartblock = ulReadLong ( pFile , 0x3c ) ; DBG_DEC ( ulSbdStartblock ) ; ulAdditionalBBDlist = ulReadLong ( pFile , 0x44 ) ; DBG_HEX ( ulAdditionalBBDlist ) ; ulSBLstartblock = ulReadLong ( pFile , ( ulRootStartblock + 1 ) * BIG_BLOCK_SIZE + 0x74 ) ; DBG_DEC ( ulSBLstartblock ) ; tSBDLen = ( size_t ) ( ulReadLong ( pFile , ( ulRootStartblock + 1 ) * BIG_BLOCK_SIZE + 0x78 ) / SMALL_BLOCK_SIZE ) ; /* All to be xcalloc-ed pointers to NULL */ aulRootList = NULL ; aulSbdList = NULL ; aulBbdList = NULL ; aulSBD = NULL ; aulBBD = NULL ; /* Big Block Depot */ aulBbdList = xcalloc ( tNumBbdBlocks , sizeof ( ULONG ) ) ; aulBBD = xcalloc ( tBBDLen , sizeof ( ULONG ) ) ; iToGo = ( int ) tNumBbdBlocks ; vGetBbdList ( pFile , min ( iToGo , 109 ) , aulBbdList , 0x4c ) ; ulStart = 109 ; iToGo -= 109 ; while ( ulAdditionalBBDlist != END_OF_CHAIN && iToGo > 0 ) { ulBdbListStart = ( ulAdditionalBBDlist + 1 ) * BIG_BLOCK_SIZE ; vGetBbdList ( pFile , min ( iToGo , 127 ) , aulBbdList + ulStart , ulBdbListStart ) ; ulAdditionalBBDlist = ulReadLong ( pFile , ulBdbListStart + 4 * 127 ) ; DBG_DEC ( ulAdditionalBBDlist ) ; DBG_HEX ( ulAdditionalBBDlist ) ; ulStart += 127 ; iToGo -= 127 ; } if ( ! bGetBBD ( pFile , aulBbdList , tNumBbdBlocks , aulBBD , tBBDLen ) ) { FREE_ALL ( ) ; return - 1 ; } aulBbdList = xfree ( aulBbdList ) ; /* Small Block Depot */ aulSbdList = xcalloc ( tBBDLen , sizeof ( ULONG ) ) ; aulSBD = xcalloc ( tSBDLen , sizeof ( ULONG ) ) ; for ( iIndex = 0 , ulTmp = ulSbdStartblock ; iIndex < ( int ) tBBDLen && ulTmp != END_OF_CHAIN ; iIndex ++ , ulTmp = aulBBD [ ulTmp ] ) { if ( ulTmp >= ( ULONG ) tBBDLen ) { DBG_DEC ( ulTmp ) ; DBG_DEC ( tBBDLen ) ; werr ( 1 , \"The Big Block Depot is damaged\" ) ; } aulSbdList [ iIndex ] = ulTmp ; NO_DBG_HEX ( aulSbdList [ iIndex ] ) ; } if ( ! bGetSBD ( pFile , aulSbdList , tBBDLen , aulSBD , tSBDLen ) ) { FREE_ALL ( ) ; return - 1 ; } aulSbdList = xfree ( aulSbdList ) ; /* Root list */ for ( tRootListLen = 0 , ulTmp = ulRootStartblock ; tRootListLen < tBBDLen && ulTmp != END_OF_CHAIN ; tRootListLen ++ , ulTmp = aulBBD [ ulTmp ] ) { if ( ulTmp >= ( ULONG ) tBBDLen ) { DBG_DEC ( ulTmp ) ; DBG_DEC ( tBBDLen ) ; werr ( 1 , \"The Big Block Depot is damaged\" ) ; } } if ( tRootListLen == 0 ) { werr ( 0 , \"No Rootlist found\" ) ; FREE_ALL ( ) ; return - 1 ; } aulRootList = xcalloc ( tRootListLen , sizeof ( ULONG ) ) ; for ( iIndex = 0 , ulTmp = ulRootStartblock ; iIndex < ( int ) tBBDLen && ulTmp != END_OF_CHAIN ; iIndex ++ , ulTmp = aulBBD [ ulTmp ] ) { if ( ulTmp >= ( ULONG ) tBBDLen ) { DBG_DEC ( ulTmp ) ; DBG_DEC ( tBBDLen ) ; werr ( 1 , \"The Big Block Depot is damaged\" ) ; } aulRootList [ iIndex ] = ulTmp ; NO_DBG_DEC ( aulRootList [ iIndex ] ) ; } fail ( tRootListLen != ( size_t ) iIndex ) ; bSuccess = bGetPPS ( pFile , aulRootList , tRootListLen , & PPS_info ) ; aulRootList = xfree ( aulRootList ) ; if ( ! bSuccess ) { FREE_ALL ( ) ; return - 1 ; } /* Small block list */ if ( ! bCreateSmallBlockList ( ulSBLstartblock , aulBBD , tBBDLen ) ) { FREE_ALL ( ) ; return - 1 ; } if ( PPS_info . tWordDocument . ulSize < MIN_SIZE_FOR_BBD_USE ) { DBG_DEC ( PPS_info . tWordDocument . ulSize ) ; FREE_ALL ( ) ; werr ( 0 , \"I'm afraid the text stream of this file \" \"is too small to handle.\" ) ; return - 1 ; } /* Read the headerblock */ if ( ! bReadBuffer ( pFile , PPS_info . tWordDocument . ulSB , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucHeader , 0 , HEADER_SIZE ) ) { FREE_ALL ( ) ; return - 1 ; } usIdent = usGetWord ( 0x00 , aucHeader ) ; DBG_HEX ( usIdent ) ; fail ( usIdent != 0x8098 && /* Word 7 for oriental languages */ usIdent != 0x8099 && /* Word 7 for oriental languages */ usIdent != 0xa5dc && /* Word 6 & 7 */ usIdent != 0xa5ec && /* Word 7 & 97 & 98 */ usIdent != 0xa697 && /* Word 7 for oriental languages */ usIdent != 0xa699 ) ; /* Word 7 for oriental languages */ iWordVersion = iGetVersionNumber ( aucHeader ) ; if ( iWordVersion < 6 ) { FREE_ALL ( ) ; werr ( 0 , \"This file is from a version of Word before Word 6.\" ) ; return - 1 ; } /* Get the status flags from the header */ usDocStatus = usGetWord ( 0x0a , aucHeader ) ; if ( usDocStatus & BIT ( 9 ) ) { PPS_info . tTable = PPS_info . t1Table ; } else { PPS_info . tTable = PPS_info . t0Table ; } /* Clean the entries that should not be used */ memset ( & PPS_info . t0Table , 0 , sizeof ( PPS_info . t0Table ) ) ; memset ( & PPS_info . t1Table , 0 , sizeof ( PPS_info . t1Table ) ) ; bSuccess = bGetDocumentText ( pFile , & PPS_info , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader , iWordVersion ) ; if ( bSuccess ) { vGetDocumentData ( pFile , & PPS_info , aulBBD , tBBDLen , aucHeader , iWordVersion ) ; vGetPropertyInfo ( pFile , & PPS_info , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader , iWordVersion ) ; vSetDefaultTabWidth ( pFile , & PPS_info , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader , iWordVersion ) ; vGetNotesInfo ( pFile , & PPS_info , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader , iWordVersion ) ; } FREE_ALL ( ) ; return bSuccess ? iWordVersion : - 1 ; }",
    "resources/antiword/wordwin.c@bGetDocumentText": "static BOOL bGetDocumentText ( FILE * pFile , const UCHAR * aucHeader ) { text_block_type tTextBlock ; ULONG ulBeginOfText ; ULONG ulTextLen , ulFootnoteLen ; ULONG ulHdrFtrLen , ulMacroLen , ulAnnotationLen ; UINT uiQuickSaves ; USHORT usDocStatus ; BOOL bTemplate , bFastSaved , bEncrypted , bSuccess ; fail ( pFile == NULL ) ; fail ( aucHeader == NULL ) ; DBG_MSG ( \"bGetDocumentText\" ) ; /* Get the status flags from the header */ usDocStatus = usGetWord ( 0x0a , aucHeader ) ; DBG_HEX ( usDocStatus ) ; bTemplate = ( usDocStatus & BIT ( 0 ) ) != 0 ; DBG_MSG_C ( bTemplate , \"This document is a Template\" ) ; bFastSaved = ( usDocStatus & BIT ( 2 ) ) != 0 ; uiQuickSaves = ( UINT ) ( usDocStatus & 0x00f0 ) >> 4 ; DBG_MSG_C ( bFastSaved , \"This document is Fast Saved\" ) ; DBG_DEC_C ( bFastSaved , uiQuickSaves ) ; if ( bFastSaved ) { werr ( 0 , \"Word2: fast saved documents are not supported yet\" ) ; return FALSE ; } bEncrypted = ( usDocStatus & BIT ( 8 ) ) != 0 ; if ( bEncrypted ) { werr ( 0 , \"Encrypted documents are not supported\" ) ; return FALSE ; } /* Get length information */ ulBeginOfText = ulGetLong ( 0x18 , aucHeader ) ; DBG_HEX ( ulBeginOfText ) ; ulTextLen = ulGetLong ( 0x34 , aucHeader ) ; ulFootnoteLen = ulGetLong ( 0x38 , aucHeader ) ; ulHdrFtrLen = ulGetLong ( 0x3c , aucHeader ) ; ulMacroLen = ulGetLong ( 0x40 , aucHeader ) ; ulAnnotationLen = ulGetLong ( 0x44 , aucHeader ) ; DBG_DEC ( ulTextLen ) ; DBG_DEC ( ulFootnoteLen ) ; DBG_DEC ( ulHdrFtrLen ) ; DBG_DEC ( ulMacroLen ) ; DBG_DEC ( ulAnnotationLen ) ; if ( bFastSaved ) { bSuccess = FALSE ; } else { tTextBlock . ulFileOffset = ulBeginOfText ; tTextBlock . ulCharPos = ulBeginOfText ; tTextBlock . ulLength = ulTextLen + ulFootnoteLen + ulHdrFtrLen + ulMacroLen + ulAnnotationLen ; tTextBlock . bUsesUnicode = FALSE ; tTextBlock . usPropMod = IGNORE_PROPMOD ; bSuccess = bAdd2TextBlockList ( & tTextBlock ) ; DBG_HEX_C ( ! bSuccess , tTextBlock . ulFileOffset ) ; DBG_HEX_C ( ! bSuccess , tTextBlock . ulCharPos ) ; DBG_DEC_C ( ! bSuccess , tTextBlock . ulLength ) ; DBG_DEC_C ( ! bSuccess , tTextBlock . bUsesUnicode ) ; DBG_DEC_C ( ! bSuccess , tTextBlock . usPropMod ) ; } if ( bSuccess ) { vSplitBlockList ( pFile , ulTextLen , ulFootnoteLen , ulHdrFtrLen , ulMacroLen , ulAnnotationLen , 0 , 0 , 0 , FALSE ) ; } else { vDestroyTextBlockList ( ) ; werr ( 0 , \"I can't find the text of this document\" ) ; } return bSuccess ; }",
    "resources/antiword/wordwin.c@vGetDocumentData": "static void vGetDocumentData ( FILE * pFile , const UCHAR * aucHeader ) { data_block_type tDataBlock ; options_type tOptions ; ULONG ulEndOfText , ulBeginCharInfo ; BOOL bFastSaved , bHasImages , bSuccess ; USHORT usDocStatus ; /* Get the options */ vGetOptions ( & tOptions ) ; /* Get the status flags from the header */ usDocStatus = usGetWord ( 0x0a , aucHeader ) ; DBG_HEX ( usDocStatus ) ; bFastSaved = ( usDocStatus & BIT ( 2 ) ) != 0 ; bHasImages = ( usDocStatus & BIT ( 3 ) ) != 0 ; if ( ! bHasImages || tOptions . eConversionType == conversion_text || tOptions . eConversionType == conversion_fmt_text || tOptions . eConversionType == conversion_xml || tOptions . eImageLevel == level_no_images ) { /*\n\t\t * No images in the document or text-only output or\n\t\t * no images wanted, so no data blocks will be needed\n\t\t */ vDestroyDataBlockList ( ) ; return ; } if ( bFastSaved ) { bSuccess = FALSE ; } else { /* This datablock is too big, but it contains all images */ ulEndOfText = ulGetLong ( 0x1c , aucHeader ) ; DBG_HEX ( ulEndOfText ) ; ulBeginCharInfo = ulGetLong ( 0xa0 , aucHeader ) ; DBG_HEX ( ulBeginCharInfo ) ; if ( ulBeginCharInfo > ulEndOfText ) { tDataBlock . ulFileOffset = ulEndOfText ; tDataBlock . ulDataPos = ulEndOfText ; tDataBlock . ulLength = ulBeginCharInfo - ulEndOfText ; bSuccess = bAdd2DataBlockList ( & tDataBlock ) ; DBG_HEX_C ( ! bSuccess , tDataBlock . ulFileOffset ) ; DBG_HEX_C ( ! bSuccess , tDataBlock . ulDataPos ) ; DBG_DEC_C ( ! bSuccess , tDataBlock . ulLength ) ; } else { bSuccess = ulBeginCharInfo == ulEndOfText ; } } if ( ! bSuccess ) { vDestroyDataBlockList ( ) ; werr ( 0 , \"I can't find the data of this document\" ) ; } }",
    "resources/antiword/wordwin.c@iInitDocumentWIN": "int iInitDocumentWIN ( FILE * pFile , long lFilesize ) { int iWordVersion ; BOOL bSuccess ; USHORT usIdent ; UCHAR aucHeader [ 384 ] ; fail ( pFile == NULL ) ; if ( lFilesize < 384 ) { return - 1 ; } /* Read the headerblock */ if ( ! bReadBytes ( aucHeader , 384 , 0x00 , pFile ) ) { return - 1 ; } /* Get the \"magic number\" from the header */ usIdent = usGetWord ( 0x00 , aucHeader ) ; DBG_HEX ( usIdent ) ; fail ( usIdent != 0xa59b && /* WinWord 1.x */ usIdent != 0xa5db ) ; /* WinWord 2.0 */ iWordVersion = iGetVersionNumber ( aucHeader ) ; if ( iWordVersion != 1 && iWordVersion != 2 ) { werr ( 0 , \"This file is not from ''Win Word 1 or 2'.\" ) ; return - 1 ; } bSuccess = bGetDocumentText ( pFile , aucHeader ) ; if ( bSuccess ) { vGetDocumentData ( pFile , aucHeader ) ; vGetPropertyInfo ( pFile , NULL , NULL , 0 , NULL , 0 , aucHeader , iWordVersion ) ; vSetDefaultTabWidth ( pFile , NULL , NULL , 0 , NULL , 0 , aucHeader , iWordVersion ) ; vGetNotesInfo ( pFile , NULL , NULL , 0 , NULL , 0 , aucHeader , iWordVersion ) ; } return bSuccess ? iWordVersion : - 1 ; }",
    "resources/antiword/worddos.c@bGetDocumentText": "static BOOL bGetDocumentText ( FILE * pFile , long lFilesize , const UCHAR * aucHeader ) { text_block_type tTextBlock ; ULONG ulTextLen ; BOOL bFastSaved ; UCHAR ucDocStatus , ucVersion ; fail ( pFile == NULL ) ; fail ( lFilesize < 128 ) ; fail ( aucHeader == NULL ) ; /* Get the status flags from the header */ ucDocStatus = ucGetByte ( 0x75 , aucHeader ) ; DBG_HEX ( ucDocStatus ) ; bFastSaved = ( ucDocStatus & BIT ( 1 ) ) != 0 ; DBG_MSG_C ( bFastSaved , \"This document is Fast Saved\" ) ; ucVersion = ucGetByte ( 0x74 , aucHeader ) ; DBG_DEC ( ucVersion ) ; DBG_MSG_C ( ucVersion == 0 , \"Written by Word 4.0 or earlier\" ) ; DBG_MSG_C ( ucVersion == 3 , \"Word 5.0 format, but not written by Word\" ) ; DBG_MSG_C ( ucVersion == 4 , \"Written by Word 5.x\" ) ; if ( bFastSaved ) { werr ( 0 , \"Word for DOS: autosave documents are not supported\" ) ; return FALSE ; } /* Get length information */ ulTextLen = ulGetLong ( 0x0e , aucHeader ) ; DBG_HEX ( ulTextLen ) ; ulTextLen -= 128 ; DBG_DEC ( ulTextLen ) ; tTextBlock . ulFileOffset = 128 ; tTextBlock . ulCharPos = 128 ; tTextBlock . ulLength = ulTextLen ; tTextBlock . bUsesUnicode = FALSE ; tTextBlock . usPropMod = IGNORE_PROPMOD ; if ( ! bAdd2TextBlockList ( & tTextBlock ) ) { DBG_HEX ( tTextBlock . ulFileOffset ) ; DBG_HEX ( tTextBlock . ulCharPos ) ; DBG_DEC ( tTextBlock . ulLength ) ; DBG_DEC ( tTextBlock . bUsesUnicode ) ; DBG_DEC ( tTextBlock . usPropMod ) ; return FALSE ; } return TRUE ; }",
    "resources/antiword/worddos.c@iInitDocumentDOS": "int iInitDocumentDOS ( FILE * pFile , long lFilesize ) { int iWordVersion ; BOOL bSuccess ; USHORT usIdent ; UCHAR aucHeader [ 128 ] ; fail ( pFile == NULL ) ; if ( lFilesize < 128 ) { return - 1 ; } /* Read the headerblock */ if ( ! bReadBytes ( aucHeader , 128 , 0x00 , pFile ) ) { return - 1 ; } /* Get the \"magic number\" from the header */ usIdent = usGetWord ( 0x00 , aucHeader ) ; DBG_HEX ( usIdent ) ; fail ( usIdent != 0xbe31 ) ; /* Word for DOS */ iWordVersion = iGetVersionNumber ( aucHeader ) ; if ( iWordVersion != 0 ) { werr ( 0 , \"This file is not from 'Word for DOS'.\" ) ; return - 1 ; } bSuccess = bGetDocumentText ( pFile , lFilesize , aucHeader ) ; if ( bSuccess ) { vGetPropertyInfo ( pFile , NULL , NULL , 0 , NULL , 0 , aucHeader , iWordVersion ) ; vSetDefaultTabWidth ( pFile , NULL , NULL , 0 , NULL , 0 , aucHeader , iWordVersion ) ; vGetNotesInfo ( pFile , NULL , NULL , 0 , NULL , 0 , aucHeader , iWordVersion ) ; } return bSuccess ? iWordVersion : - 1 ; }",
    "resources/antiword/png2eps.c@tSkipToData": "static size_t tSkipToData ( FILE * pFile , size_t tMaxBytes , size_t * ptSkipped ) { ULONG ulName , ulTmp ; size_t tDataLength , tToSkip ; int iCounter ; fail ( pFile == NULL ) ; fail ( ptSkipped == NULL ) ; /* Examine chunks */ while ( * ptSkipped + 8 < tMaxBytes ) { tDataLength = ( size_t ) ulNextLongBE ( pFile ) ; DBG_DEC ( tDataLength ) ; * ptSkipped += 4 ; ulName = 0x00 ; for ( iCounter = 0 ; iCounter < 4 ; iCounter ++ ) { ulTmp = ( ULONG ) iNextByte ( pFile ) ; if ( ! isalpha ( ( int ) ulTmp ) ) { DBG_HEX ( ulTmp ) ; return ( size_t ) - 1 ; } ulName <<= 8 ; ulName |= ulTmp ; } DBG_HEX ( ulName ) ; * ptSkipped += 4 ; if ( ulName == PNG_CN_IEND ) { break ; } if ( ulName == PNG_CN_IDAT ) { return tDataLength ; } tToSkip = tDataLength + 4 ; if ( tToSkip >= tMaxBytes - * ptSkipped ) { DBG_DEC ( tToSkip ) ; DBG_DEC ( tMaxBytes - * ptSkipped ) ; return ( size_t ) - 1 ; } ( void ) tSkipBytes ( pFile , tToSkip ) ; * ptSkipped += tToSkip ; } return ( size_t ) - 1 ; }",
    "resources/antiword/png2eps.c@tFindFirstPixelData": "static size_t tFindFirstPixelData ( FILE * pFile , size_t tMaxBytes , size_t * ptSkipped ) { fail ( pFile == NULL ) ; fail ( tMaxBytes == 0 ) ; fail ( ptSkipped == NULL ) ; if ( tMaxBytes < 8 ) { DBG_DEC ( tMaxBytes ) ; return ( size_t ) - 1 ; } /* Skip over the PNG signature */ ( void ) tSkipBytes ( pFile , 8 ) ; * ptSkipped = 8 ; return tSkipToData ( pFile , tMaxBytes , ptSkipped ) ; }",
    "resources/antiword/png2eps.c@tFindNextPixelData": "static size_t tFindNextPixelData ( FILE * pFile , size_t tMaxBytes , size_t * ptSkipped ) { fail ( pFile == NULL ) ; fail ( tMaxBytes == 0 ) ; fail ( ptSkipped == NULL ) ; if ( tMaxBytes < 4 ) { DBG_DEC ( tMaxBytes ) ; return ( size_t ) - 1 ; } /* Skip over the crc */ ( void ) tSkipBytes ( pFile , 4 ) ; * ptSkipped = 4 ; return tSkipToData ( pFile , tMaxBytes , ptSkipped ) ; }",
    "resources/antiword/png2eps.c@bTranslatePNG": "",
    "resources/antiword/findtext.c@bAddTextBlocks": "",
    "resources/antiword/findtext.c@bGet6DocumentText": "",
    "resources/antiword/findtext.c@bGet8DocumentText": "",
    "resources/antiword/wordmac.c@bGetDocumentText": "static BOOL bGetDocumentText ( FILE * pFile , const UCHAR * aucHeader ) { text_block_type tTextBlock ; ULONG ulBeginOfText , ulEndOfText ; ULONG ulTextLen ; UCHAR ucDocStatus ; BOOL bFastSaved ; fail ( pFile == NULL ) ; fail ( aucHeader == NULL ) ; DBG_MSG ( \"bGetDocumentText\" ) ; NO_DBG_PRINT_BLOCK ( aucHeader , 0x20 ) ; /* Get the status flags from the header */ ucDocStatus = ucGetByte ( 0x0a , aucHeader ) ; DBG_HEX ( ucDocStatus ) ; bFastSaved = ( ucDocStatus & BIT ( 5 ) ) != 0 ; DBG_MSG_C ( bFastSaved , \"This document is Fast Saved\" ) ; if ( bFastSaved ) { werr ( 0 , \"MacWord: fast saved documents are not supported yet\" ) ; return FALSE ; } /* Get length information */ ulBeginOfText = ulGetLongBE ( 0x14 , aucHeader ) ; DBG_HEX ( ulBeginOfText ) ; ulEndOfText = ulGetLongBE ( 0x18 , aucHeader ) ; DBG_HEX ( ulEndOfText ) ; ulTextLen = ulEndOfText - ulBeginOfText ; DBG_DEC ( ulTextLen ) ; tTextBlock . ulFileOffset = ulBeginOfText ; tTextBlock . ulCharPos = ulBeginOfText ; tTextBlock . ulLength = ulTextLen ; tTextBlock . bUsesUnicode = FALSE ; tTextBlock . usPropMod = IGNORE_PROPMOD ; if ( ! bAdd2TextBlockList ( & tTextBlock ) ) { DBG_HEX ( tTextBlock . ulFileOffset ) ; DBG_HEX ( tTextBlock . ulCharPos ) ; DBG_DEC ( tTextBlock . ulLength ) ; DBG_DEC ( tTextBlock . bUsesUnicode ) ; DBG_DEC ( tTextBlock . usPropMod ) ; return FALSE ; } return TRUE ; }",
    "resources/antiword/wordmac.c@iInitDocumentMAC": "int iInitDocumentMAC ( FILE * pFile , long lFilesize ) { int iWordVersion ; BOOL bSuccess ; USHORT usIdent ; UCHAR aucHeader [ 256 ] ; fail ( pFile == NULL ) ; if ( lFilesize < 256 ) { return - 1 ; } /* Read the headerblock */ if ( ! bReadBytes ( aucHeader , 256 , 0x00 , pFile ) ) { return - 1 ; } /* Get the \"magic number\" from the header */ usIdent = usGetWord ( 0x00 , aucHeader ) ; DBG_HEX ( usIdent ) ; fail ( usIdent != 0x37fe ) ; /* MacWord 4 and 5 */ iWordVersion = iGetVersionNumber ( aucHeader ) ; if ( iWordVersion != 4 && iWordVersion != 5 ) { werr ( 0 , \"This file is not from ''Mac Word 4 or 5'.\" ) ; return - 1 ; } bSuccess = bGetDocumentText ( pFile , aucHeader ) ; if ( bSuccess ) { vGetPropertyInfo ( pFile , NULL , NULL , 0 , NULL , 0 , aucHeader , iWordVersion ) ; vSetDefaultTabWidth ( pFile , NULL , NULL , 0 , NULL , 0 , aucHeader , iWordVersion ) ; } return bSuccess ? iWordVersion : - 1 ; }",
    "resources/antiword/blocklist.c@pFreeOneList": "static list_mem_type * pFreeOneList ( list_mem_type * pAnchor ) { list_mem_type * pCurr , * pNext ; pCurr = pAnchor ; while ( pCurr != NULL ) { pNext = pCurr -> pNext ; pCurr = xfree ( pCurr ) ; pCurr = pNext ; } return NULL ; }",
    "resources/antiword/blocklist.c@vDestroyTextBlockList": "void vDestroyTextBlockList ( void ) { DBG_MSG ( \"vDestroyTextBlockList\" ) ; /* Free the lists one by one */ pTextAnchor = pFreeOneList ( pTextAnchor ) ; pFootnoteAnchor = pFreeOneList ( pFootnoteAnchor ) ; pHdrFtrAnchor = pFreeOneList ( pHdrFtrAnchor ) ; pMacroAnchor = pFreeOneList ( pMacroAnchor ) ; pAnnotationAnchor = pFreeOneList ( pAnnotationAnchor ) ; pEndnoteAnchor = pFreeOneList ( pEndnoteAnchor ) ; pTextBoxAnchor = pFreeOneList ( pTextBoxAnchor ) ; pHdrTextBoxAnchor = pFreeOneList ( pHdrTextBoxAnchor ) ; /* Reset all the controle variables */ pBlockLast = NULL ; tOthers . pBlockCurrent = NULL ; tHdrFtr . pBlockCurrent = NULL ; tFootnote . pBlockCurrent = NULL ; }",
    "resources/antiword/blocklist.c@bAdd2TextBlockList": "",
    "resources/antiword/blocklist.c@vSpitList": "static void vSpitList ( list_mem_type * * ppAnchorCurr , list_mem_type * * ppAnchorNext , ULONG ulListLen ) { list_mem_type * pCurr ; long lCharsToGo , lBytesTooFar ; fail ( ppAnchorCurr == NULL ) ; fail ( ppAnchorNext == NULL ) ; fail ( ulListLen > ( ULONG ) LONG_MAX ) ; pCurr = NULL ; lCharsToGo = ( long ) ulListLen ; lBytesTooFar = - 1 ; if ( ulListLen != 0 ) { DBG_DEC ( ulListLen ) ; for ( pCurr = * ppAnchorCurr ; pCurr != NULL ; pCurr = pCurr -> pNext ) { NO_DBG_DEC ( pCurr -> tInfo . ulLength ) ; fail ( pCurr -> tInfo . ulLength == 0 ) ; fail ( pCurr -> tInfo . ulLength > ( ULONG ) LONG_MAX ) ; if ( pCurr -> tInfo . bUsesUnicode ) { fail ( odd ( pCurr -> tInfo . ulLength ) ) ; lCharsToGo -= ( long ) ( pCurr -> tInfo . ulLength / 2 ) ; if ( lCharsToGo < 0 ) { lBytesTooFar = - 2 * lCharsToGo ; } } else { lCharsToGo -= ( long ) pCurr -> tInfo . ulLength ; if ( lCharsToGo < 0 ) { lBytesTooFar = - lCharsToGo ; } } if ( lCharsToGo <= 0 ) { break ; } } } /* Split the list */ if ( ulListLen == 0 ) { /* Current blocklist is empty */ * ppAnchorNext = * ppAnchorCurr ; * ppAnchorCurr = NULL ; } else if ( pCurr == NULL ) { /* No blocks for the next list */ * ppAnchorNext = NULL ; } else if ( lCharsToGo == 0 ) { /* Move the integral number of blocks to the next list */ * ppAnchorNext = pCurr -> pNext ; pCurr -> pNext = NULL ; } else { /* Split the part current block list, part next block list */ DBG_DEC ( lBytesTooFar ) ; fail ( lBytesTooFar <= 0 ) ; * ppAnchorNext = xmalloc ( sizeof ( list_mem_type ) ) ; DBG_HEX ( pCurr -> tInfo . ulFileOffset ) ; ( * ppAnchorNext ) -> tInfo . ulFileOffset = pCurr -> tInfo . ulFileOffset + pCurr -> tInfo . ulLength - lBytesTooFar ; DBG_HEX ( ( * ppAnchorNext ) -> tInfo . ulFileOffset ) ; DBG_HEX ( pCurr -> tInfo . ulCharPos ) ; ( * ppAnchorNext ) -> tInfo . ulCharPos = pCurr -> tInfo . ulCharPos + pCurr -> tInfo . ulLength - lBytesTooFar ; DBG_HEX ( ( * ppAnchorNext ) -> tInfo . ulCharPos ) ; ( * ppAnchorNext ) -> tInfo . ulLength = ( ULONG ) lBytesTooFar ; pCurr -> tInfo . ulLength -= ( ULONG ) lBytesTooFar ; ( * ppAnchorNext ) -> tInfo . bUsesUnicode = pCurr -> tInfo . bUsesUnicode ; ( * ppAnchorNext ) -> tInfo . usPropMod = pCurr -> tInfo . usPropMod ; /* Move the integral number of blocks to the next list */ ( * ppAnchorNext ) -> pNext = pCurr -> pNext ; pCurr -> pNext = NULL ; } }",
    "resources/antiword/blocklist.c@bIsEmptyBox": "static BOOL bIsEmptyBox ( FILE * pFile , const list_mem_type * pAnchor ) { const list_mem_type * pCurr ; size_t tIndex , tSize ; UCHAR * aucBuffer ; char cChar ; fail ( pFile == NULL ) ; if ( pAnchor == NULL ) { return TRUE ; } aucBuffer = NULL ; for ( pCurr = pAnchor ; pCurr != NULL ; pCurr = pCurr -> pNext ) { fail ( pCurr -> tInfo . ulLength == 0 ) ; tSize = ( size_t ) pCurr -> tInfo . ulLength ; # if defined ( __dos ) && ! defined ( __DJGPP__ ) if ( pCurr -> tInfo . ulLength > 0xffffUL ) { tSize = 0xffff ; } # endif /* __dos && !__DJGPP__ */ fail ( aucBuffer != NULL ) ; aucBuffer = xmalloc ( tSize ) ; if ( ! bReadBytes ( aucBuffer , tSize , pCurr -> tInfo . ulFileOffset , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return FALSE ; } for ( tIndex = 0 ; tIndex < tSize ; tIndex ++ ) { cChar = ( char ) aucBuffer [ tIndex ] ; switch ( cChar ) { case '\\0' : case '\\r' : case '\\n' : case '\\f' : case '\\t' : case '\\v' : case ' ' : break ; default : aucBuffer = xfree ( aucBuffer ) ; return FALSE ; } } aucBuffer = xfree ( aucBuffer ) ; } fail ( aucBuffer != NULL ) ; return TRUE ; }",
    "resources/antiword/blocklist.c@vSplitBlockList": "void vSplitBlockList ( FILE * pFile , ULONG ulTextLen , ULONG ulFootnoteLen , ULONG ulHdrFtrLen , ULONG ulMacroLen , ULONG ulAnnotationLen , ULONG ulEndnoteLen , ULONG ulTextBoxLen , ULONG ulHdrTextBoxLen , BOOL bMustExtend ) { list_mem_type * apAnchors [ 8 ] ; list_mem_type * pGarbageAnchor , * pCurr ; size_t tIndex ; DBG_MSG ( \"vSplitBlockList\" ) ; pGarbageAnchor = NULL ; DBG_MSG_C ( ulTextLen != 0 , \"Text block list\" ) ; vSpitList ( & pTextAnchor , & pFootnoteAnchor , ulTextLen ) ; DBG_MSG_C ( ulFootnoteLen != 0 , \"Footnote block list\" ) ; vSpitList ( & pFootnoteAnchor , & pHdrFtrAnchor , ulFootnoteLen ) ; DBG_MSG_C ( ulHdrFtrLen != 0 , \"Header/Footer block list\" ) ; vSpitList ( & pHdrFtrAnchor , & pMacroAnchor , ulHdrFtrLen ) ; DBG_MSG_C ( ulMacroLen != 0 , \"Macro block list\" ) ; vSpitList ( & pMacroAnchor , & pAnnotationAnchor , ulMacroLen ) ; DBG_MSG_C ( ulAnnotationLen != 0 , \"Annotation block list\" ) ; vSpitList ( & pAnnotationAnchor , & pEndnoteAnchor , ulAnnotationLen ) ; DBG_MSG_C ( ulEndnoteLen != 0 , \"Endnote block list\" ) ; vSpitList ( & pEndnoteAnchor , & pTextBoxAnchor , ulEndnoteLen ) ; DBG_MSG_C ( ulTextBoxLen != 0 , \"Textbox block list\" ) ; vSpitList ( & pTextBoxAnchor , & pHdrTextBoxAnchor , ulTextBoxLen ) ; DBG_MSG_C ( ulHdrTextBoxLen != 0 , \"HeaderTextbox block list\" ) ; vSpitList ( & pHdrTextBoxAnchor , & pGarbageAnchor , ulHdrTextBoxLen ) ; /* Free the garbage block list, this should not be needed */ DBG_DEC_C ( pGarbageAnchor != NULL , pGarbageAnchor -> tInfo . ulLength ) ; pGarbageAnchor = pFreeOneList ( pGarbageAnchor ) ; # if defined ( DEBUG ) vCheckList ( pTextAnchor , ulTextLen , \"Software error (Text)\" ) ; vCheckList ( pFootnoteAnchor , ulFootnoteLen , \"Software error (Footnote)\" ) ; vCheckList ( pHdrFtrAnchor , ulHdrFtrLen , \"Software error (Hdr/Ftr)\" ) ; vCheckList ( pMacroAnchor , ulMacroLen , \"Software error (Macro)\" ) ; vCheckList ( pAnnotationAnchor , ulAnnotationLen , \"Software error (Annotation)\" ) ; vCheckList ( pEndnoteAnchor , ulEndnoteLen , \"Software error (Endnote)\" ) ; vCheckList ( pTextBoxAnchor , ulTextBoxLen , \"Software error (TextBox)\" ) ; vCheckList ( pHdrTextBoxAnchor , ulHdrTextBoxLen , \"Software error (HdrTextBox)\" ) ; # endif /* DEBUG */ /* Remove the list if the text box is empty */ if ( bIsEmptyBox ( pFile , pTextBoxAnchor ) ) { pTextBoxAnchor = pFreeOneList ( pTextBoxAnchor ) ; } if ( bIsEmptyBox ( pFile , pHdrTextBoxAnchor ) ) { pHdrTextBoxAnchor = pFreeOneList ( pHdrTextBoxAnchor ) ; } if ( ! bMustExtend ) { return ; } /*\n\t * All blocks (except the last one) must have a length that\n\t * is a multiple of the Big Block Size\n\t */ apAnchors [ 0 ] = pTextAnchor ; apAnchors [ 1 ] = pFootnoteAnchor ; apAnchors [ 2 ] = pHdrFtrAnchor ; apAnchors [ 3 ] = pMacroAnchor ; apAnchors [ 4 ] = pAnnotationAnchor ; apAnchors [ 5 ] = pEndnoteAnchor ; apAnchors [ 6 ] = pTextBoxAnchor ; apAnchors [ 7 ] = pHdrTextBoxAnchor ; for ( tIndex = 0 ; tIndex < elementsof ( apAnchors ) ; tIndex ++ ) { for ( pCurr = apAnchors [ tIndex ] ; pCurr != NULL ; pCurr = pCurr -> pNext ) { if ( pCurr -> pNext != NULL && pCurr -> tInfo . ulLength % BIG_BLOCK_SIZE != 0 ) { DBG_DEC ( tIndex ) ; DBG_HEX ( pCurr -> tInfo . ulFileOffset ) ; DBG_HEX ( pCurr -> tInfo . ulCharPos ) ; DBG_DEC ( pCurr -> tInfo . ulLength ) ; pCurr -> tInfo . ulLength /= BIG_BLOCK_SIZE ; pCurr -> tInfo . ulLength ++ ; pCurr -> tInfo . ulLength *= BIG_BLOCK_SIZE ; DBG_DEC ( pCurr -> tInfo . ulLength ) ; } } } }",
    "resources/antiword/blocklist.c@bExistsTextBox": "",
    "resources/antiword/blocklist.c@bExistsHdrTextBox": "",
    "resources/antiword/blocklist.c@usGetNextByte": "static USHORT usGetNextByte ( FILE * pFile , readinfo_type * pInfoCurrent , list_mem_type * pAnchor , ULONG * pulFileOffset , ULONG * pulCharPos , USHORT * pusPropMod ) { ULONG ulReadOff ; size_t tReadLen ; fail ( pInfoCurrent == NULL ) ; if ( pInfoCurrent -> pBlockCurrent == NULL || pInfoCurrent -> tByteNext >= sizeof ( pInfoCurrent -> aucBlock ) || pInfoCurrent -> ulBlockOffset + pInfoCurrent -> tByteNext >= pInfoCurrent -> pBlockCurrent -> tInfo . ulLength ) { if ( pInfoCurrent -> pBlockCurrent == NULL ) { /* First block, first part */ pInfoCurrent -> pBlockCurrent = pAnchor ; pInfoCurrent -> ulBlockOffset = 0 ; } else if ( pInfoCurrent -> ulBlockOffset + sizeof ( pInfoCurrent -> aucBlock ) < pInfoCurrent -> pBlockCurrent -> tInfo . ulLength ) { /* Same block, next part */ pInfoCurrent -> ulBlockOffset += sizeof ( pInfoCurrent -> aucBlock ) ; } else { /* Next block, first part */ pInfoCurrent -> pBlockCurrent = pInfoCurrent -> pBlockCurrent -> pNext ; pInfoCurrent -> ulBlockOffset = 0 ; } if ( pInfoCurrent -> pBlockCurrent == NULL ) { /* Past the last part of the last block */ return ( USHORT ) EOF ; } tReadLen = ( size_t ) ( pInfoCurrent -> pBlockCurrent -> tInfo . ulLength - pInfoCurrent -> ulBlockOffset ) ; if ( tReadLen > sizeof ( pInfoCurrent -> aucBlock ) ) { tReadLen = sizeof ( pInfoCurrent -> aucBlock ) ; } ulReadOff = pInfoCurrent -> pBlockCurrent -> tInfo . ulFileOffset + pInfoCurrent -> ulBlockOffset ; if ( ! bReadBytes ( pInfoCurrent -> aucBlock , tReadLen , ulReadOff , pFile ) ) { /* Don't read from this list any longer */ pInfoCurrent -> pBlockCurrent = NULL ; return ( USHORT ) EOF ; } pInfoCurrent -> tByteNext = 0 ; } if ( pulFileOffset != NULL ) { * pulFileOffset = pInfoCurrent -> pBlockCurrent -> tInfo . ulFileOffset + pInfoCurrent -> ulBlockOffset + pInfoCurrent -> tByteNext ; } if ( pulCharPos != NULL ) { * pulCharPos = pInfoCurrent -> pBlockCurrent -> tInfo . ulCharPos + pInfoCurrent -> ulBlockOffset + pInfoCurrent -> tByteNext ; } if ( pusPropMod != NULL ) { * pusPropMod = pInfoCurrent -> pBlockCurrent -> tInfo . usPropMod ; } return ( USHORT ) pInfoCurrent -> aucBlock [ pInfoCurrent -> tByteNext ++ ] ; }",
    "resources/antiword/blocklist.c@usGetNextChar": "static USHORT usGetNextChar ( FILE * pFile , list_id_enum eListID , ULONG * pulFileOffset , ULONG * pulCharPos , USHORT * pusPropMod ) { readinfo_type * pReadinfo ; list_mem_type * pAnchor ; USHORT usLSB , usMSB ; switch ( eListID ) { case text_list : pReadinfo = & tOthers ; pAnchor = pTextAnchor ; break ; case footnote_list : pReadinfo = & tFootnote ; pAnchor = pFootnoteAnchor ; break ; case hdrftr_list : pReadinfo = & tHdrFtr ; pAnchor = pHdrFtrAnchor ; break ; case endnote_list : pReadinfo = & tOthers ; pAnchor = pEndnoteAnchor ; break ; case textbox_list : pReadinfo = & tOthers ; pAnchor = pTextBoxAnchor ; break ; case hdrtextbox_list : pReadinfo = & tOthers ; pAnchor = pHdrTextBoxAnchor ; break ; default : DBG_DEC ( eListID ) ; return ( USHORT ) EOF ; } usLSB = usGetNextByte ( pFile , pReadinfo , pAnchor , pulFileOffset , pulCharPos , pusPropMod ) ; if ( usLSB == ( USHORT ) EOF ) { return ( USHORT ) EOF ; } fail ( pReadinfo -> pBlockCurrent == NULL ) ; if ( pReadinfo -> pBlockCurrent -> tInfo . bUsesUnicode ) { usMSB = usGetNextByte ( pFile , pReadinfo , pAnchor , NULL , NULL , NULL ) ; } else { usMSB = 0x00 ; } if ( usMSB == ( USHORT ) EOF ) { DBG_MSG ( \"usGetNextChar: Unexpected EOF\" ) ; DBG_HEX_C ( pulFileOffset != NULL , * pulFileOffset ) ; DBG_HEX_C ( pulCharPos != NULL , * pulCharPos ) ; return ( USHORT ) EOF ; } return ( usMSB << 8 ) | usLSB ; }",
    "resources/antiword/blocklist.c@usNextChar": "USHORT usNextChar ( FILE * pFile , list_id_enum eListID , ULONG * pulFileOffset , ULONG * pulCharPos , USHORT * pusPropMod ) { USHORT usRetVal ; fail ( pFile == NULL ) ; usRetVal = usGetNextChar ( pFile , eListID , pulFileOffset , pulCharPos , pusPropMod ) ; if ( usRetVal == ( USHORT ) EOF ) { if ( pulFileOffset != NULL ) { * pulFileOffset = FC_INVALID ; } if ( pulCharPos != NULL ) { * pulCharPos = CP_INVALID ; } if ( pusPropMod != NULL ) { * pusPropMod = IGNORE_PROPMOD ; } } return usRetVal ; }",
    "resources/antiword/blocklist.c@usToHdrFtrPosition": "USHORT usToHdrFtrPosition ( FILE * pFile , ULONG ulCharPos ) { ULONG ulCharPosCurr ; USHORT usChar ; tHdrFtr . pBlockCurrent = NULL ; /* To reset the header/footer list */ do { usChar = usNextChar ( pFile , hdrftr_list , NULL , & ulCharPosCurr , NULL ) ; } while ( usChar != ( USHORT ) EOF && ulCharPosCurr != ulCharPos ) ; return usChar ; }",
    "resources/antiword/blocklist.c@usToFootnotePosition": "USHORT usToFootnotePosition ( FILE * pFile , ULONG ulCharPos ) { ULONG ulCharPosCurr ; USHORT usChar ; tFootnote . pBlockCurrent = NULL ; /* To reset the footnote list */ do { usChar = usNextChar ( pFile , footnote_list , NULL , & ulCharPosCurr , NULL ) ; } while ( usChar != ( USHORT ) EOF && ulCharPosCurr != ulCharPos ) ; return usChar ; }",
    "resources/antiword/blocklist.c@ulCharPos2FileOffsetX": "ULONG ulCharPos2FileOffsetX ( ULONG ulCharPos , list_id_enum * peListID ) { static list_id_enum eListIDs [ 8 ] = { text_list , footnote_list , hdrftr_list , macro_list , annotation_list , endnote_list , textbox_list , hdrtextbox_list , } ; list_mem_type * apAnchors [ 8 ] ; list_mem_type * pCurr ; list_id_enum eListGuess ; ULONG ulBestGuess ; size_t tIndex ; fail ( peListID == NULL ) ; if ( ulCharPos == CP_INVALID ) { * peListID = no_list ; return FC_INVALID ; } apAnchors [ 0 ] = pTextAnchor ; apAnchors [ 1 ] = pFootnoteAnchor ; apAnchors [ 2 ] = pHdrFtrAnchor ; apAnchors [ 3 ] = pMacroAnchor ; apAnchors [ 4 ] = pAnnotationAnchor ; apAnchors [ 5 ] = pEndnoteAnchor ; apAnchors [ 6 ] = pTextBoxAnchor ; apAnchors [ 7 ] = pHdrTextBoxAnchor ; eListGuess = no_list ; /* Best guess is no list */ ulBestGuess = FC_INVALID ; /* Best guess is \"file offset not found\" */ for ( tIndex = 0 ; tIndex < elementsof ( apAnchors ) ; tIndex ++ ) { for ( pCurr = apAnchors [ tIndex ] ; pCurr != NULL ; pCurr = pCurr -> pNext ) { if ( ulCharPos == pCurr -> tInfo . ulCharPos + pCurr -> tInfo . ulLength && pCurr -> pNext != NULL ) { /*\n\t\t\t\t * The character position is one beyond this\n\t\t\t\t * block, so we guess it's the first byte of\n\t\t\t\t * the next block (if there is a next block)\n\t\t\t\t */ eListGuess = eListIDs [ tIndex ] ; ulBestGuess = pCurr -> pNext -> tInfo . ulFileOffset ; } if ( ulCharPos < pCurr -> tInfo . ulCharPos || ulCharPos >= pCurr -> tInfo . ulCharPos + pCurr -> tInfo . ulLength ) { /* Character position is not in this block */ continue ; } /* The character position is in the current block */ * peListID = eListIDs [ tIndex ] ; return pCurr -> tInfo . ulFileOffset + ulCharPos - pCurr -> tInfo . ulCharPos ; } } /* Passed beyond the end of the last list */ NO_DBG_HEX ( ulCharPos ) ; NO_DBG_HEX ( ulBestGuess ) ; * peListID = eListGuess ; return ulBestGuess ; }",
    "resources/antiword/blocklist.c@ulCharPos2FileOffset": "ULONG ulCharPos2FileOffset ( ULONG ulCharPos ) { list_id_enum eListID ; return ulCharPos2FileOffsetX ( ulCharPos , & eListID ) ; }",
    "resources/antiword/blocklist.c@ulHdrFtrOffset2CharPos": "ULONG ulHdrFtrOffset2CharPos ( ULONG ulHdrFtrOffset ) { list_mem_type * pCurr ; ULONG ulOffset ; ulOffset = ulHdrFtrOffset ; for ( pCurr = pHdrFtrAnchor ; pCurr != NULL ; pCurr = pCurr -> pNext ) { if ( ulOffset >= pCurr -> tInfo . ulLength ) { /* The offset is not in this block */ ulOffset -= pCurr -> tInfo . ulLength ; continue ; } return pCurr -> tInfo . ulCharPos + ulOffset ; } return CP_INVALID ; }",
    "resources/antiword/blocklist.c@ulGetSeqNumber": "ULONG ulGetSeqNumber ( ULONG ulFileOffset ) { list_mem_type * pCurr ; ULONG ulSeq ; if ( ulFileOffset == FC_INVALID ) { return FC_INVALID ; } ulSeq = 0 ; for ( pCurr = pTextAnchor ; pCurr != NULL ; pCurr = pCurr -> pNext ) { if ( ulFileOffset >= pCurr -> tInfo . ulFileOffset && ulFileOffset < pCurr -> tInfo . ulFileOffset + pCurr -> tInfo . ulLength ) { /* The file offset is within the current textblock */ return ulSeq + ulFileOffset - pCurr -> tInfo . ulFileOffset ; } ulSeq += pCurr -> tInfo . ulLength ; } return FC_INVALID ; }",
    "resources/antiword/notes.c@vDestroyNotesInfoLists": "void vDestroyNotesInfoLists ( void ) { footnote_local_type * pRecord ; size_t tFootnote ; TRACE_MSG ( \"vDestroyNotesInfoLists\" ) ; /* Free the lists and reset all control variables */ aulEndnoteList = xfree ( aulEndnoteList ) ; aulFootnoteList = xfree ( aulFootnoteList ) ; tEndnoteListLength = 0 ; tFootnoteListLength = 0 ; for ( tFootnote = 0 ; tFootnote < tFootnoteTextLength ; tFootnote ++ ) { pRecord = pFootnoteText + tFootnote ; pRecord -> tInfo . szText = xfree ( pRecord -> tInfo . szText ) ; } pFootnoteText = xfree ( pFootnoteText ) ; tFootnoteTextLength = 0 ; }",
    "resources/antiword/notes.c@vGet0FootnotesInfoAndText": "static void vGet0FootnotesInfoAndText ( FILE * pFile , const UCHAR * aucHeader ) { footnote_local_type * pCurr ; UCHAR * aucBuffer ; ULONG ulFileOffset , ulBeginOfText , ulOffset , ulBeginFootnoteInfo ; ULONG ulCharPos , ulBeginNextBlock ; size_t tFootnotes , tFootnoteInfoLen ; size_t tIndex ; UCHAR aucTmp [ 2 ] ; TRACE_MSG ( \"vGet0FootnotesInfoAndText\" ) ; fail ( pFile == NULL || aucHeader == NULL ) ; ulBeginOfText = 128 ; NO_DBG_HEX ( ulBeginOfText ) ; ulBeginFootnoteInfo = 128 * ( ULONG ) usGetWord ( 0x14 , aucHeader ) ; DBG_HEX ( ulBeginFootnoteInfo ) ; ulBeginNextBlock = 128 * ( ULONG ) usGetWord ( 0x16 , aucHeader ) ; DBG_HEX ( ulBeginNextBlock ) ; if ( ulBeginFootnoteInfo == ulBeginNextBlock ) { DBG_MSG ( \"No Footnotes in this document\" ) ; return ; } /* Read the the number of footnotes + 1 */ if ( ! bReadBytes ( aucTmp , 2 , ulBeginFootnoteInfo , pFile ) ) { return ; } tFootnotes = ( size_t ) usGetWord ( 0 , aucTmp ) ; if ( tFootnotes < 2 ) { DBG_MSG ( \"No Footnotes in this document (2)\" ) ; } DBG_DEC ( tFootnotes ) ; tFootnoteInfoLen = 8 * tFootnotes ; aucBuffer = xmalloc ( tFootnoteInfoLen ) ; if ( ! bReadBytes ( aucBuffer , tFootnoteInfoLen , ulBeginFootnoteInfo + 4 , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } DBG_PRINT_BLOCK ( aucBuffer , tFootnoteInfoLen ) ; /* Get footnote information */ fail ( tFootnoteListLength != 0 ) ; tFootnoteListLength = tFootnotes - 1 ; fail ( tFootnoteListLength == 0 ) ; fail ( aulFootnoteList != NULL ) ; aulFootnoteList = xcalloc ( tFootnoteListLength , sizeof ( ULONG ) ) ; for ( tIndex = 0 ; tIndex < tFootnoteListLength ; tIndex ++ ) { ulOffset = ulGetLong ( tIndex * 8 , aucBuffer ) ; DBG_HEX ( ulOffset ) ; ulFileOffset = ulCharPos2FileOffset ( ulBeginOfText + ulOffset ) ; DBG_HEX ( ulFileOffset ) ; aulFootnoteList [ tIndex ] = ulFileOffset ; } /* Get footnote text */ fail ( tFootnoteTextLength != 0 ) ; tFootnoteTextLength = tFootnotes - 1 ; fail ( tFootnoteTextLength == 0 ) ; fail ( pFootnoteText != NULL ) ; pFootnoteText = xcalloc ( tFootnoteTextLength , sizeof ( footnote_local_type ) ) ; for ( tIndex = 0 ; tIndex < tFootnoteTextLength ; tIndex ++ ) { pCurr = pFootnoteText + tIndex ; pCurr -> tInfo . szText = NULL ; ulOffset = ulGetLong ( tIndex * 8 + 4 , aucBuffer ) ; DBG_HEX ( ulOffset ) ; ulCharPos = ulBeginOfText + ulOffset ; DBG_HEX ( ulCharPos ) ; DBG_HEX ( ulCharPos2FileOffset ( ulCharPos ) ) ; pCurr -> ulCharPosStart = ulCharPos ; ulOffset = ulGetLong ( ( tIndex + 1 ) * 8 + 4 , aucBuffer ) ; DBG_HEX ( ulOffset ) ; ulCharPos = ulBeginOfText + ulOffset ; DBG_HEX ( ulCharPos ) ; DBG_HEX ( ulCharPos2FileOffset ( ulCharPos ) ) ; pCurr -> ulCharPosNext = ulCharPos ; pCurr -> bUseful = pCurr -> ulCharPosStart != pCurr -> ulCharPosNext ; } aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/notes.c@vGet0NotesInfo": "static void vGet0NotesInfo ( FILE * pFile , const UCHAR * aucHeader ) { TRACE_MSG ( \"vGet0NotesInfo\" ) ; vGet0FootnotesInfoAndText ( pFile , aucHeader ) ; /* There are no endnotes in a Word for DOS file */ }",
    "resources/antiword/notes.c@vGet2FootnotesInfo": "static void vGet2FootnotesInfo ( FILE * pFile , const UCHAR * aucHeader ) { UCHAR * aucBuffer ; ULONG ulFileOffset , ulBeginOfText , ulOffset , ulBeginFootnoteInfo ; size_t tFootnoteInfoLen ; size_t tIndex ; TRACE_MSG ( \"vGet2FootnotesInfo\" ) ; fail ( pFile == NULL || aucHeader == NULL ) ; ulBeginOfText = ulGetLong ( 0x18 , aucHeader ) ; /* fcMin */ NO_DBG_HEX ( ulBeginOfText ) ; ulBeginFootnoteInfo = ulGetLong ( 0x64 , aucHeader ) ; /* fcPlcffndRef */ NO_DBG_HEX ( ulBeginFootnoteInfo ) ; tFootnoteInfoLen = ( size_t ) usGetWord ( 0x68 , aucHeader ) ; /* cbPlcffndRef */ NO_DBG_DEC ( tFootnoteInfoLen ) ; if ( tFootnoteInfoLen < 10 ) { DBG_MSG ( \"No Footnotes in this document\" ) ; return ; } aucBuffer = xmalloc ( tFootnoteInfoLen ) ; if ( ! bReadBytes ( aucBuffer , tFootnoteInfoLen , ulBeginFootnoteInfo , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tFootnoteInfoLen ) ; fail ( tFootnoteListLength != 0 ) ; tFootnoteListLength = ( tFootnoteInfoLen - 4 ) / 6 ; fail ( tFootnoteListLength == 0 ) ; fail ( aulFootnoteList != NULL ) ; aulFootnoteList = xcalloc ( tFootnoteListLength , sizeof ( ULONG ) ) ; for ( tIndex = 0 ; tIndex < tFootnoteListLength ; tIndex ++ ) { ulOffset = ulGetLong ( tIndex * 4 , aucBuffer ) ; NO_DBG_HEX ( ulOffset ) ; ulFileOffset = ulCharPos2FileOffset ( ulBeginOfText + ulOffset ) ; NO_DBG_HEX ( ulFileOffset ) ; aulFootnoteList [ tIndex ] = ulFileOffset ; } aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/notes.c@vGet2FootnotesText": "static void vGet2FootnotesText ( FILE * pFile , const UCHAR * aucHeader ) { footnote_local_type * pCurr ; UCHAR * aucBuffer ; ULONG ulCharPos , ulBeginOfFootnotes , ulOffset , ulBeginFootnoteText ; size_t tFootnoteTextLen ; size_t tIndex ; TRACE_MSG ( \"vGet2FootnotesText\" ) ; fail ( pFile == NULL || aucHeader == NULL ) ; ulBeginOfFootnotes = ulGetLong ( 0x18 , aucHeader ) ; /* fcMin */ ulBeginOfFootnotes += ulGetLong ( 0x34 , aucHeader ) ; /* ccpText */ NO_DBG_HEX ( ulBeginOfFootnotes ) ; ulBeginFootnoteText = ulGetLong ( 0x6a , aucHeader ) ; /* fcPlcffndTxt */ NO_DBG_HEX ( ulBeginFootnoteText ) ; tFootnoteTextLen = ( size_t ) usGetWord ( 0x6e , aucHeader ) ; /* cbPlcffndTxt */ NO_DBG_DEC ( tFootnoteTextLen ) ; if ( tFootnoteTextLen < 12 ) { DBG_MSG ( \"No Footnote text in this document\" ) ; return ; } aucBuffer = xmalloc ( tFootnoteTextLen ) ; if ( ! bReadBytes ( aucBuffer , tFootnoteTextLen , ulBeginFootnoteText , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tFootnoteTextLen ) ; fail ( tFootnoteTextLength != 0 ) ; tFootnoteTextLength = tFootnoteTextLen / 4 - 2 ; fail ( tFootnoteTextLength == 0 ) ; fail ( pFootnoteText != NULL ) ; pFootnoteText = xcalloc ( tFootnoteTextLength , sizeof ( footnote_local_type ) ) ; for ( tIndex = 0 ; tIndex < tFootnoteTextLength ; tIndex ++ ) { pCurr = pFootnoteText + tIndex ; pCurr -> tInfo . szText = NULL ; ulOffset = ulGetLong ( tIndex * 4 , aucBuffer ) ; NO_DBG_HEX ( ulOffset ) ; ulCharPos = ulBeginOfFootnotes + ulOffset ; NO_DBG_HEX ( ulCharPos ) ; NO_DBG_HEX ( ulCharPos2FileOffset ( ulCharPos ) ) ; pCurr -> ulCharPosStart = ulCharPos ; ulOffset = ulGetLong ( tIndex * 4 + 4 , aucBuffer ) ; NO_DBG_HEX ( ulOffset ) ; ulCharPos = ulBeginOfFootnotes + ulOffset ; NO_DBG_HEX ( ulCharPos ) ; NO_DBG_HEX ( ulCharPos2FileOffset ( ulCharPos ) ) ; pCurr -> ulCharPosNext = ulCharPos ; pCurr -> bUseful = pCurr -> ulCharPosStart != pCurr -> ulCharPosNext ; } aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/notes.c@vGet2NotesInfo": "static void vGet2NotesInfo ( FILE * pFile , const UCHAR * aucHeader ) { TRACE_MSG ( \"vGet2NotesInfo\" ) ; vGet2FootnotesInfo ( pFile , aucHeader ) ; vGet2FootnotesText ( pFile , aucHeader ) ; /* There are no endnotes in a WinWord 1/2 file */ }",
    "resources/antiword/notes.c@vGet6FootnotesInfo": "static void vGet6FootnotesInfo ( FILE * pFile , ULONG ulStartBlock , const ULONG * aulBBD , size_t tBBDLen , const UCHAR * aucHeader ) { UCHAR * aucBuffer ; ULONG ulFileOffset , ulBeginOfText , ulOffset , ulBeginFootnoteInfo ; size_t tFootnoteInfoLen ; size_t tIndex ; TRACE_MSG ( \"vGet6FootnotesInfo\" ) ; fail ( pFile == NULL || aucHeader == NULL ) ; fail ( ulStartBlock > MAX_BLOCKNUMBER && ulStartBlock != END_OF_CHAIN ) ; fail ( aulBBD == NULL ) ; ulBeginOfText = ulGetLong ( 0x18 , aucHeader ) ; /* fcMin */ NO_DBG_HEX ( ulBeginOfText ) ; ulBeginFootnoteInfo = ulGetLong ( 0x68 , aucHeader ) ; /* fcPlcffndRef */ NO_DBG_HEX ( ulBeginFootnoteInfo ) ; tFootnoteInfoLen = ( size_t ) ulGetLong ( 0x6c , aucHeader ) ; /* lcbPlcffndRef */ NO_DBG_DEC ( tFootnoteInfoLen ) ; if ( tFootnoteInfoLen < 10 ) { DBG_MSG ( \"No Footnotes in this document\" ) ; return ; } aucBuffer = xmalloc ( tFootnoteInfoLen ) ; if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucBuffer , ulBeginFootnoteInfo , tFootnoteInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tFootnoteInfoLen ) ; fail ( tFootnoteListLength != 0 ) ; tFootnoteListLength = ( tFootnoteInfoLen - 4 ) / 6 ; fail ( tFootnoteListLength == 0 ) ; fail ( aulFootnoteList != NULL ) ; aulFootnoteList = xcalloc ( tFootnoteListLength , sizeof ( ULONG ) ) ; for ( tIndex = 0 ; tIndex < tFootnoteListLength ; tIndex ++ ) { ulOffset = ulGetLong ( tIndex * 4 , aucBuffer ) ; NO_DBG_HEX ( ulOffset ) ; ulFileOffset = ulCharPos2FileOffset ( ulBeginOfText + ulOffset ) ; NO_DBG_HEX ( ulFileOffset ) ; aulFootnoteList [ tIndex ] = ulFileOffset ; } aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/notes.c@vGet6FootnotesText": "static void vGet6FootnotesText ( FILE * pFile , ULONG ulStartBlock , const ULONG * aulBBD , size_t tBBDLen , const UCHAR * aucHeader ) { footnote_local_type * pCurr ; UCHAR * aucBuffer ; ULONG ulCharPos , ulBeginOfFootnotes , ulOffset , ulBeginFootnoteText ; size_t tFootnoteTextLen ; size_t tIndex ; TRACE_MSG ( \"vGet6FootnotesText\" ) ; fail ( pFile == NULL || aucHeader == NULL ) ; fail ( ulStartBlock > MAX_BLOCKNUMBER && ulStartBlock != END_OF_CHAIN ) ; fail ( aulBBD == NULL ) ; ulBeginOfFootnotes = ulGetLong ( 0x18 , aucHeader ) ; /* fcMin */ ulBeginOfFootnotes += ulGetLong ( 0x34 , aucHeader ) ; /* ccpText */ NO_DBG_HEX ( ulBeginOfFootnotes ) ; ulBeginFootnoteText = ulGetLong ( 0x70 , aucHeader ) ; /* fcPlcffndTxt */ NO_DBG_HEX ( ulBeginFootnoteText ) ; tFootnoteTextLen = ( size_t ) ulGetLong ( 0x74 , aucHeader ) ; /* lcbPlcffndTxt */ NO_DBG_DEC ( tFootnoteTextLen ) ; if ( tFootnoteTextLen < 12 ) { DBG_MSG ( \"No Footnote text in this document\" ) ; return ; } aucBuffer = xmalloc ( tFootnoteTextLen ) ; if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucBuffer , ulBeginFootnoteText , tFootnoteTextLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tFootnoteTextLen ) ; fail ( tFootnoteTextLength != 0 ) ; tFootnoteTextLength = tFootnoteTextLen / 4 - 2 ; fail ( tFootnoteTextLength == 0 ) ; fail ( pFootnoteText != NULL ) ; pFootnoteText = xcalloc ( tFootnoteTextLength , sizeof ( footnote_local_type ) ) ; for ( tIndex = 0 ; tIndex < tFootnoteTextLength ; tIndex ++ ) { pCurr = pFootnoteText + tIndex ; pCurr -> tInfo . szText = NULL ; ulOffset = ulGetLong ( tIndex * 4 , aucBuffer ) ; NO_DBG_HEX ( ulOffset ) ; ulCharPos = ulBeginOfFootnotes + ulOffset ; NO_DBG_HEX ( ulCharPos ) ; NO_DBG_HEX ( ulCharPos2FileOffset ( ulCharPos ) ) ; pCurr -> ulCharPosStart = ulCharPos ; ulOffset = ulGetLong ( tIndex * 4 + 4 , aucBuffer ) ; NO_DBG_HEX ( ulOffset ) ; ulCharPos = ulBeginOfFootnotes + ulOffset ; NO_DBG_HEX ( ulCharPos ) ; NO_DBG_HEX ( ulCharPos2FileOffset ( ulCharPos ) ) ; pCurr -> ulCharPosNext = ulCharPos ; pCurr -> bUseful = pCurr -> ulCharPosStart != pCurr -> ulCharPosNext ; } aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/notes.c@vGet6EndnotesInfo": "static void vGet6EndnotesInfo ( FILE * pFile , ULONG ulStartBlock , const ULONG * aulBBD , size_t tBBDLen , const UCHAR * aucHeader ) { UCHAR * aucBuffer ; ULONG ulFileOffset , ulBeginOfText , ulOffset , ulBeginEndnoteInfo ; size_t tEndnoteInfoLen ; size_t tIndex ; TRACE_MSG ( \"vGet6EndnotesInfo\" ) ; fail ( pFile == NULL || aucHeader == NULL ) ; fail ( ulStartBlock > MAX_BLOCKNUMBER && ulStartBlock != END_OF_CHAIN ) ; fail ( aulBBD == NULL ) ; ulBeginOfText = ulGetLong ( 0x18 , aucHeader ) ; /* fcMin */ NO_DBG_HEX ( ulBeginOfText ) ; ulBeginEndnoteInfo = ulGetLong ( 0x1d2 , aucHeader ) ; /* fcPlcfendRef */ NO_DBG_HEX ( ulBeginEndnoteInfo ) ; tEndnoteInfoLen = ( size_t ) ulGetLong ( 0x1d6 , aucHeader ) ; /* lcbPlcfendRef */ NO_DBG_DEC ( tEndnoteInfoLen ) ; if ( tEndnoteInfoLen < 10 ) { DBG_MSG ( \"No Endnotes in this document\" ) ; return ; } aucBuffer = xmalloc ( tEndnoteInfoLen ) ; if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucBuffer , ulBeginEndnoteInfo , tEndnoteInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tEndnoteInfoLen ) ; fail ( tEndnoteListLength != 0 ) ; tEndnoteListLength = ( tEndnoteInfoLen - 4 ) / 6 ; fail ( tEndnoteListLength == 0 ) ; fail ( aulEndnoteList != NULL ) ; aulEndnoteList = xcalloc ( tEndnoteListLength , sizeof ( ULONG ) ) ; for ( tIndex = 0 ; tIndex < tEndnoteListLength ; tIndex ++ ) { ulOffset = ulGetLong ( tIndex * 4 , aucBuffer ) ; NO_DBG_HEX ( ulOffset ) ; ulFileOffset = ulCharPos2FileOffset ( ulBeginOfText + ulOffset ) ; NO_DBG_HEX ( ulFileOffset ) ; aulEndnoteList [ tIndex ] = ulFileOffset ; } aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/notes.c@vGet6NotesInfo": "static void vGet6NotesInfo ( FILE * pFile , ULONG ulStartBlock , const ULONG * aulBBD , size_t tBBDLen , const UCHAR * aucHeader ) { TRACE_MSG ( \"vGet6NotesInfo\" ) ; vGet6FootnotesInfo ( pFile , ulStartBlock , aulBBD , tBBDLen , aucHeader ) ; vGet6FootnotesText ( pFile , ulStartBlock , aulBBD , tBBDLen , aucHeader ) ; vGet6EndnotesInfo ( pFile , ulStartBlock , aulBBD , tBBDLen , aucHeader ) ; }",
    "resources/antiword/notes.c@vGet8FootnotesInfo": "static void vGet8FootnotesInfo ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { const ULONG * aulBlockDepot ; UCHAR * aucBuffer ; ULONG ulFileOffset , ulBeginOfText , ulOffset , ulBeginFootnoteInfo ; size_t tFootnoteInfoLen , tBlockDepotLen , tBlockSize ; size_t tIndex ; TRACE_MSG ( \"vGet8FootnotesInfo\" ) ; ulBeginOfText = ulGetLong ( 0x18 , aucHeader ) ; /* fcMin */ NO_DBG_HEX ( ulBeginOfText ) ; ulBeginFootnoteInfo = ulGetLong ( 0xaa , aucHeader ) ; /* fcPlcffndRef */ NO_DBG_HEX ( ulBeginFootnoteInfo ) ; tFootnoteInfoLen = ( size_t ) ulGetLong ( 0xae , aucHeader ) ; /* lcbPlcffndRef */ NO_DBG_DEC ( tFootnoteInfoLen ) ; if ( tFootnoteInfoLen < 10 ) { DBG_MSG ( \"No Footnotes in this document\" ) ; return ; } NO_DBG_DEC ( pPPS -> tTable . ulSB ) ; NO_DBG_HEX ( pPPS -> tTable . ulSize ) ; if ( pPPS -> tTable . ulSize == 0 ) { DBG_MSG ( \"No footnotes information\" ) ; return ; } if ( pPPS -> tTable . ulSize < MIN_SIZE_FOR_BBD_USE ) { /* Use the Small Block Depot */ aulBlockDepot = aulSBD ; tBlockDepotLen = tSBDLen ; tBlockSize = SMALL_BLOCK_SIZE ; } else { /* Use the Big Block Depot */ aulBlockDepot = aulBBD ; tBlockDepotLen = tBBDLen ; tBlockSize = BIG_BLOCK_SIZE ; } aucBuffer = xmalloc ( tFootnoteInfoLen ) ; if ( ! bReadBuffer ( pFile , pPPS -> tTable . ulSB , aulBlockDepot , tBlockDepotLen , tBlockSize , aucBuffer , ulBeginFootnoteInfo , tFootnoteInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tFootnoteInfoLen ) ; fail ( tFootnoteListLength != 0 ) ; tFootnoteListLength = ( tFootnoteInfoLen - 4 ) / 6 ; fail ( tFootnoteListLength == 0 ) ; fail ( aulFootnoteList != NULL ) ; aulFootnoteList = xcalloc ( tFootnoteListLength , sizeof ( ULONG ) ) ; for ( tIndex = 0 ; tIndex < tFootnoteListLength ; tIndex ++ ) { ulOffset = ulGetLong ( tIndex * 4 , aucBuffer ) ; NO_DBG_HEX ( ulOffset ) ; ulFileOffset = ulCharPos2FileOffset ( ulBeginOfText + ulOffset ) ; NO_DBG_HEX ( ulFileOffset ) ; aulFootnoteList [ tIndex ] = ulFileOffset ; } aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/notes.c@vGet8FootnotesText": "static void vGet8FootnotesText ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { footnote_local_type * pCurr ; const ULONG * aulBlockDepot ; UCHAR * aucBuffer ; ULONG ulCharPos , ulBeginOfFootnotes , ulOffset , ulBeginFootnoteText ; size_t tFootnoteTextLen , tBlockDepotLen , tBlockSize ; size_t tIndex ; TRACE_MSG ( \"vGet8FootnotesText\" ) ; ulBeginOfFootnotes = ulGetLong ( 0x18 , aucHeader ) ; /* fcMin */ ulBeginOfFootnotes += ulGetLong ( 0x4c , aucHeader ) ; /* ccpText */ NO_DBG_HEX ( ulBeginOfFootnotes ) ; ulBeginFootnoteText = ulGetLong ( 0xb2 , aucHeader ) ; /* fcPlcffndTxt */ NO_DBG_HEX ( ulBeginFootnoteText ) ; tFootnoteTextLen = ( size_t ) ulGetLong ( 0xb6 , aucHeader ) ; /* lcbPlcffndTxt */ NO_DBG_DEC ( tFootnoteTextLen ) ; if ( tFootnoteTextLen < 12 ) { DBG_MSG ( \"No Footnote text in this document\" ) ; return ; } NO_DBG_DEC ( pPPS -> tTable . ulSB ) ; NO_DBG_HEX ( pPPS -> tTable . ulSize ) ; if ( pPPS -> tTable . ulSize == 0 ) { DBG_MSG ( \"No footnote text information\" ) ; return ; } if ( pPPS -> tTable . ulSize < MIN_SIZE_FOR_BBD_USE ) { /* Use the Small Block Depot */ aulBlockDepot = aulSBD ; tBlockDepotLen = tSBDLen ; tBlockSize = SMALL_BLOCK_SIZE ; } else { /* Use the Big Block Depot */ aulBlockDepot = aulBBD ; tBlockDepotLen = tBBDLen ; tBlockSize = BIG_BLOCK_SIZE ; } aucBuffer = xmalloc ( tFootnoteTextLen ) ; if ( ! bReadBuffer ( pFile , pPPS -> tTable . ulSB , aulBlockDepot , tBlockDepotLen , tBlockSize , aucBuffer , ulBeginFootnoteText , tFootnoteTextLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tFootnoteTextLen ) ; fail ( tFootnoteTextLength != 0 ) ; tFootnoteTextLength = tFootnoteTextLen / 4 - 2 ; fail ( tFootnoteTextLength == 0 ) ; fail ( pFootnoteText != NULL ) ; pFootnoteText = xcalloc ( tFootnoteTextLength , sizeof ( footnote_local_type ) ) ; for ( tIndex = 0 ; tIndex < tFootnoteTextLength ; tIndex ++ ) { pCurr = pFootnoteText + tIndex ; pCurr -> tInfo . szText = NULL ; ulOffset = ulGetLong ( tIndex * 4 , aucBuffer ) ; NO_DBG_HEX ( ulOffset ) ; ulCharPos = ulBeginOfFootnotes + ulOffset ; NO_DBG_HEX ( ulCharPos ) ; NO_DBG_HEX ( ulCharPos2FileOffset ( ulCharPos ) ) ; pCurr -> ulCharPosStart = ulCharPos ; ulOffset = ulGetLong ( tIndex * 4 + 4 , aucBuffer ) ; NO_DBG_HEX ( ulOffset ) ; ulCharPos = ulBeginOfFootnotes + ulOffset ; NO_DBG_HEX ( ulCharPos ) ; NO_DBG_HEX ( ulCharPos2FileOffset ( ulCharPos ) ) ; pCurr -> ulCharPosNext = ulCharPos ; pCurr -> bUseful = pCurr -> ulCharPosStart != pCurr -> ulCharPosNext ; } aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/notes.c@vGet8EndnotesInfo": "static void vGet8EndnotesInfo ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { const ULONG * aulBlockDepot ; UCHAR * aucBuffer ; ULONG ulFileOffset , ulBeginOfText , ulOffset , ulBeginEndnoteInfo ; size_t tEndnoteInfoLen , tBlockDepotLen , tBlockSize ; size_t tIndex ; TRACE_MSG ( \"vGet8EndnotesInfo\" ) ; ulBeginOfText = ulGetLong ( 0x18 , aucHeader ) ; /* fcMin */ NO_DBG_HEX ( ulBeginOfText ) ; ulBeginEndnoteInfo = ulGetLong ( 0x20a , aucHeader ) ; /* fcPlcfendRef */ NO_DBG_HEX ( ulBeginEndnoteInfo ) ; tEndnoteInfoLen = ( size_t ) ulGetLong ( 0x20e , aucHeader ) ; /* lcbPlcfendRef */ NO_DBG_DEC ( tEndnoteInfoLen ) ; if ( tEndnoteInfoLen < 10 ) { DBG_MSG ( \"No endnotes in this document\" ) ; return ; } NO_DBG_DEC ( pPPS -> tTable . ulSB ) ; NO_DBG_HEX ( pPPS -> tTable . ulSize ) ; if ( pPPS -> tTable . ulSize == 0 ) { DBG_MSG ( \"No endnotes information\" ) ; return ; } if ( pPPS -> tTable . ulSize < MIN_SIZE_FOR_BBD_USE ) { /* Use the Small Block Depot */ aulBlockDepot = aulSBD ; tBlockDepotLen = tSBDLen ; tBlockSize = SMALL_BLOCK_SIZE ; } else { /* Use the Big Block Depot */ aulBlockDepot = aulBBD ; tBlockDepotLen = tBBDLen ; tBlockSize = BIG_BLOCK_SIZE ; } aucBuffer = xmalloc ( tEndnoteInfoLen ) ; if ( ! bReadBuffer ( pFile , pPPS -> tTable . ulSB , aulBlockDepot , tBlockDepotLen , tBlockSize , aucBuffer , ulBeginEndnoteInfo , tEndnoteInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tEndnoteInfoLen ) ; fail ( tEndnoteListLength != 0 ) ; tEndnoteListLength = ( tEndnoteInfoLen - 4 ) / 6 ; fail ( tEndnoteListLength == 0 ) ; fail ( aulEndnoteList != NULL ) ; aulEndnoteList = xcalloc ( tEndnoteListLength , sizeof ( ULONG ) ) ; for ( tIndex = 0 ; tIndex < tEndnoteListLength ; tIndex ++ ) { ulOffset = ulGetLong ( tIndex * 4 , aucBuffer ) ; NO_DBG_HEX ( ulOffset ) ; ulFileOffset = ulCharPos2FileOffset ( ulBeginOfText + ulOffset ) ; NO_DBG_HEX ( ulFileOffset ) ; aulEndnoteList [ tIndex ] = ulFileOffset ; } aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/notes.c@vGet8NotesInfo": "static void vGet8NotesInfo ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { TRACE_MSG ( \"vGet8NotesInfo\" ) ; vGet8FootnotesInfo ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; vGet8FootnotesText ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; vGet8EndnotesInfo ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; }",
    "resources/antiword/notes.c@vGetNotesInfo": "void vGetNotesInfo ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader , int iWordVersion ) { TRACE_MSG ( \"vGetNotesInfo\" ) ; fail ( pFile == NULL ) ; fail ( pPPS == NULL && iWordVersion >= 6 ) ; fail ( aulBBD == NULL && tBBDLen != 0 ) ; fail ( aulSBD == NULL && tSBDLen != 0 ) ; fail ( aucHeader == NULL ) ; switch ( iWordVersion ) { case 0 : vGet0NotesInfo ( pFile , aucHeader ) ; break ; case 1 : case 2 : vGet2NotesInfo ( pFile , aucHeader ) ; break ; case 4 : case 5 : break ; case 6 : case 7 : vGet6NotesInfo ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , aucHeader ) ; break ; case 8 : vGet8NotesInfo ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; break ; default : werr ( 0 , \"Sorry, no notes information\" ) ; break ; } }",
    "resources/antiword/notes.c@vPrepareFootnoteText": "void vPrepareFootnoteText ( FILE * pFile ) { footnote_local_type * pCurr ; size_t tFootnote ; fail ( pFile == NULL ) ; fail ( pFootnoteText == NULL && tFootnoteTextLength != 0 ) ; if ( pFootnoteText == NULL || tFootnoteTextLength == 0 ) { /* No information */ return ; } /* Fill text and useful-ness */ for ( tFootnote = 0 ; tFootnote < tFootnoteTextLength ; tFootnote ++ ) { pCurr = pFootnoteText + tFootnote ; pCurr -> bUseful = pCurr -> ulCharPosStart != pCurr -> ulCharPosNext ; if ( pCurr -> bUseful ) { pCurr -> tInfo . szText = szFootnoteDecryptor ( pFile , pCurr -> ulCharPosStart , pCurr -> ulCharPosNext ) ; } else { pCurr -> tInfo . szText = NULL ; } } }",
    "resources/antiword/notes.c@szGetFootnootText": "const char * szGetFootnootText ( UINT uiFootnoteIndex ) { if ( ( size_t ) uiFootnoteIndex >= tFootnoteTextLength ) { return NULL ; } return pFootnoteText [ uiFootnoteIndex ] . tInfo . szText ; }",
    "resources/antiword/notes.c@eGetNotetype": "notetype_enum eGetNotetype ( ULONG ulFileOffset ) { size_t tIndex ; TRACE_MSG ( \"eGetNotetype\" ) ; fail ( aulFootnoteList == NULL && tFootnoteListLength != 0 ) ; fail ( aulEndnoteList == NULL && tEndnoteListLength != 0 ) ; /* Go for the easy answers first */ if ( tFootnoteListLength == 0 && tEndnoteListLength == 0 ) { return notetype_is_unknown ; } if ( tEndnoteListLength == 0 ) { return notetype_is_footnote ; } if ( tFootnoteListLength == 0 ) { return notetype_is_endnote ; } /* No easy answer, so we search */ for ( tIndex = 0 ; tIndex < tFootnoteListLength ; tIndex ++ ) { if ( aulFootnoteList [ tIndex ] == ulFileOffset ) { return notetype_is_footnote ; } } for ( tIndex = 0 ; tIndex < tEndnoteListLength ; tIndex ++ ) { if ( aulEndnoteList [ tIndex ] == ulFileOffset ) { return notetype_is_endnote ; } } /* Not found */ return notetype_is_unknown ; }",
    "resources/antiword/chartrans.c@iCompare": "static int iCompare ( const void * pvRecord1 , const void * pvRecord2 ) { USHORT usUnicode1 , usUnicode2 ; usUnicode1 = ( ( char_table_type * ) pvRecord1 ) -> usUnicode ; usUnicode2 = ( ( char_table_type * ) pvRecord2 ) -> usUnicode ; if ( usUnicode1 < usUnicode2 ) { return - 1 ; } if ( usUnicode1 > usUnicode2 ) { return 1 ; } return 0 ; }",
    "resources/antiword/chartrans.c@pGetCharTableRecord": "static const char_table_type * pGetCharTableRecord ( USHORT usUnicode ) { char_table_type tKey ; if ( tNextPosFree == 0 ) { return NULL ; } tKey . usUnicode = usUnicode ; tKey . ucLocal = 0 ; return ( char_table_type * ) bsearch ( & tKey , atCharTable , tNextPosFree , sizeof ( atCharTable [ 0 ] ) , iCompare ) ; }",
    "resources/antiword/chartrans.c@ucGetBulletCharacter": "UCHAR ucGetBulletCharacter ( conversion_type eConversionType , encoding_type eEncoding ) { # if defined ( __riscos ) return 0x8f ; # else const char_table_type * pRec ; fail ( eEncoding == encoding_utf_8 ) ; if ( eEncoding == encoding_latin_1 && ( eConversionType == conversion_ps || eConversionType == conversion_pdf ) ) { /* Ugly, but it makes the PostScript and PDF look better */ return ( UCHAR ) 143 ; } if ( eConversionType != conversion_text && eConversionType != conversion_fmt_text ) { pRec = pGetCharTableRecord ( UNICODE_BULLET ) ; if ( pRec != NULL ) { return pRec -> ucLocal ; } pRec = pGetCharTableRecord ( UNICODE_BULLET_OPERATOR ) ; if ( pRec != NULL ) { return pRec -> ucLocal ; } pRec = pGetCharTableRecord ( UNICODE_MIDDLE_DOT ) ; if ( pRec != NULL ) { return pRec -> ucLocal ; } } return ( UCHAR ) '.' ; # endif /* __riscos */ }",
    "resources/antiword/chartrans.c@ucGetNbspCharacter": "UCHAR ucGetNbspCharacter ( void ) { const char_table_type * pRec ; pRec = pGetCharTableRecord ( 0x00a0 ) ; /* Unicode non-breaking space */ if ( pRec == NULL ) { DBG_MSG ( \"Non-breaking space record not found\" ) ; /* No value found, use the best guess */ return ( UCHAR ) 0xa0 ; } return pRec -> ucLocal ; }",
    "resources/antiword/chartrans.c@bReadCharacterMappingTable": "",
    "resources/antiword/chartrans.c@ulTranslateCharacters": "ULONG ulTranslateCharacters ( USHORT usChar , ULONG ulFileOffset , int iWordVersion , conversion_type eConversionType , encoding_type eEncoding , BOOL bUseMacCharSet ) { const char_table_type * pTmp ; const USHORT * usCharSet ; usCharSet = NULL ; if ( bUseMacCharSet ) { /* Macintosh character set */ usCharSet = usMacRoman ; } else if ( iWordVersion == 0 ) { /* DOS character set */ usCharSet = usCp850 ; } else { /* Windows character set */ switch ( eEncoding ) { case encoding_latin_2 : usCharSet = usCp1250 ; break ; case encoding_cyrillic : usCharSet = usCp1251 ; break ; case encoding_latin_1 : default : usCharSet = usCp1252 ; break ; } } fail ( usCharSet == NULL ) ; if ( usChar >= 0x80 && usChar <= 0x9f ) { /* Translate implementation defined characters */ usChar = usCharSet [ usChar - 0x80 ] ; } else if ( iWordVersion < 8 && usChar >= 0xa0 && usChar <= 0xff ) { /* Translate old character set to Unixcode */ usChar = usCharSet [ usChar - 0x80 ] ; } /* Microsoft Unicode to real Unicode */ if ( usChar >= 0xf020 && usChar <= 0xf0ff ) { DBG_HEX_C ( usPrivateArea [ usChar - 0xf020 ] == 0x003f , usChar ) ; usChar = usPrivateArea [ usChar - 0xf020 ] ; } /* Characters with a special meaning in Word */ switch ( usChar ) { case IGNORE_CHARACTER : case FOOTNOTE_SEPARATOR : case FOOTNOTE_CONTINUATION : case ANNOTATION : case FRAME : case LINE_FEED : case WORD_SOFT_HYPHEN : case UNICODE_HYPHENATION_POINT : return IGNORE_CHARACTER ; case PICTURE : case TABLE_SEPARATOR : case TAB : case HARD_RETURN : case PAGE_BREAK : case PAR_END : case COLUMN_FEED : return ( ULONG ) usChar ; case FOOTNOTE_OR_ENDNOTE : NO_DBG_HEX ( ulFileOffset ) ; switch ( eGetNotetype ( ulFileOffset ) ) { case notetype_is_footnote : return FOOTNOTE_CHAR ; case notetype_is_endnote : return ENDNOTE_CHAR ; default : return UNKNOWN_NOTE_CHAR ; } case WORD_UNBREAKABLE_JOIN : return ( ULONG ) OUR_UNBREAKABLE_JOIN ; default : break ; } if ( eEncoding != encoding_utf_8 ) { /* Latin characters in an oriental text */ if ( usChar >= 0xff01 && usChar <= 0xff5e ) { usChar -= 0xfee0 ; } } if ( eEncoding == encoding_latin_1 && ( eConversionType == conversion_ps || eConversionType == conversion_pdf ) ) { /* Ugly, but it makes the PostScript and PDF look better */ switch ( usChar ) { case UNICODE_ELLIPSIS : return 140 ; case UNICODE_TRADEMARK_SIGN : return 141 ; case UNICODE_PER_MILLE_SIGN : return 142 ; case UNICODE_BULLET : case UNICODE_BULLET_OPERATOR : case UNICODE_BLACK_CLUB_SUIT : return 143 ; case UNICODE_LEFT_SINGLE_QMARK : return 144 ; case UNICODE_RIGHT_SINGLE_QMARK : return 145 ; case UNICODE_SINGLE_LEFT_ANGLE_QMARK : return 146 ; case UNICODE_SINGLE_RIGHT_ANGLE_QMARK : return 147 ; case UNICODE_LEFT_DOUBLE_QMARK : return 148 ; case UNICODE_RIGHT_DOUBLE_QMARK : return 149 ; case UNICODE_DOUBLE_LOW_9_QMARK : return 150 ; case UNICODE_EN_DASH : return 151 ; case UNICODE_EM_DASH : return 152 ; case UNICODE_MINUS_SIGN : return 153 ; case UNICODE_CAPITAL_LIGATURE_OE : return 154 ; case UNICODE_SMALL_LIGATURE_OE : return 155 ; case UNICODE_DAGGER : return 156 ; case UNICODE_DOUBLE_DAGGER : return 157 ; case UNICODE_SMALL_LIGATURE_FI : return 158 ; case UNICODE_SMALL_LIGATURE_FL : return 159 ; default : break ; } } if ( eConversionType == conversion_pdf ) { if ( eEncoding == encoding_latin_1 ) { switch ( usChar ) { case UNICODE_EURO_SIGN : return 128 ; default : break ; } } else if ( eEncoding == encoding_latin_2 ) { switch ( usChar ) { case UNICODE_CAPITAL_D_WITH_STROKE : case UNICODE_SMALL_D_WITH_STROKE : return 0x3f ; default : break ; } } } if ( usChar < 0x80 ) { /* US ASCII */ if ( usChar < 0x20 || usChar == 0x7f ) { /* Ignore control characters */ DBG_HEX ( usChar ) ; DBG_FIXME ( ) ; return IGNORE_CHARACTER ; } return ( ULONG ) usChar ; } if ( eEncoding == encoding_utf_8 ) { /* No need to convert Unicode characters */ return ( ULONG ) usChar ; } /* Unicode to local representation */ pTmp = pGetCharTableRecord ( usChar ) ; if ( pTmp != NULL ) { DBG_HEX_C ( usChar >= 0x7f && usChar <= 0x9f , usChar ) ; return ( ULONG ) pTmp -> ucLocal ; } /* Fancy characters to simple US ASCII */ switch ( usChar ) { case UNICODE_SMALL_F_HOOK : return ( ULONG ) 'f' ; case UNICODE_GREEK_CAPITAL_CHI : return ( ULONG ) 'X' ; case UNICODE_GREEK_SMALL_UPSILON : return ( ULONG ) 'v' ; case UNICODE_MODIFIER_CIRCUMFLEX : case UNICODE_UPWARDS_ARROW : return ( ULONG ) '^' ; case UNICODE_SMALL_TILDE : case UNICODE_TILDE_OPERATOR : return ( ULONG ) '~' ; case UNICODE_EN_QUAD : case UNICODE_EM_QUAD : case UNICODE_EN_SPACE : case UNICODE_EM_SPACE : case UNICODE_THREE_PER_EM_SPACE : case UNICODE_FOUR_PER_EM_SPACE : case UNICODE_SIX_PER_EM_SPACE : case UNICODE_FIGURE_SPACE : case UNICODE_PUNCTUATION_SPACE : case UNICODE_THIN_SPACE : case UNICODE_NARROW_NO_BREAK_SPACE : case UNICODE_LIGHT_SHADE : case UNICODE_MEDIUM_SHADE : case UNICODE_DARK_SHADE : return ( ULONG ) ' ' ; case UNICODE_LEFT_DOUBLE_QMARK : case UNICODE_RIGHT_DOUBLE_QMARK : case UNICODE_DOUBLE_LOW_9_QMARK : case UNICODE_DOUBLE_HIGH_REV_9_QMARK : case UNICODE_DOUBLE_PRIME : return ( ULONG ) '\"' ; case UNICODE_LEFT_SINGLE_QMARK : case UNICODE_RIGHT_SINGLE_QMARK : case UNICODE_SINGLE_LOW_9_QMARK : case UNICODE_SINGLE_HIGH_REV_9_QMARK : case UNICODE_PRIME : return ( ULONG ) '\\'' ; case UNICODE_HYPHEN : case UNICODE_NON_BREAKING_HYPHEN : case UNICODE_FIGURE_DASH : case UNICODE_EN_DASH : case UNICODE_EM_DASH : case UNICODE_HORIZONTAL_BAR : case UNICODE_MINUS_SIGN : case UNICODE_BD_LIGHT_HORIZONTAL : case UNICODE_BD_DOUBLE_HORIZONTAL : return ( ULONG ) '-' ; case UNICODE_DOUBLE_VERTICAL_LINE : case UNICODE_BD_LIGHT_VERTICAL : case UNICODE_BD_DOUBLE_VERTICAL : return ( ULONG ) '|' ; case UNICODE_DOUBLE_LOW_LINE : return ( ULONG ) '_' ; case UNICODE_DAGGER : return ( ULONG ) '+' ; case UNICODE_DOUBLE_DAGGER : return ( ULONG ) '#' ; case UNICODE_BULLET : case UNICODE_BULLET_OPERATOR : case UNICODE_BLACK_CLUB_SUIT : return ( ULONG ) ucGetBulletCharacter ( eConversionType , eEncoding ) ; case UNICODE_ONE_DOT_LEADER : case UNICODE_TWO_DOT_LEADER : return ( ULONG ) '.' ; case UNICODE_ELLIPSIS : # if defined ( __riscos ) return ( ULONG ) OUR_ELLIPSIS ; # else if ( ulFileOffset == 0 ) { return ( ULONG ) OUR_ELLIPSIS ; } return UNICODE_ELLIPSIS ; # endif /* __riscos */ case UNICODE_DOUBLE_LEFT_ANGLE_QMARK : case UNICODE_TRIANGULAR_BULLET : case UNICODE_SINGLE_LEFT_ANGLE_QMARK : case UNICODE_LEFTWARDS_ARROW : return ( ULONG ) '<' ; case UNICODE_DOUBLE_RIGHT_ANGLE_QMARK : case UNICODE_SINGLE_RIGHT_ANGLE_QMARK : case UNICODE_RIGHTWARDS_ARROW : return ( ULONG ) '>' ; case UNICODE_UNDERTIE : return ( ULONG ) '-' ; case UNICODE_N_ARY_SUMMATION : return ( ULONG ) 'S' ; case UNICODE_EURO_SIGN : return ( ULONG ) 'E' ; case UNICODE_CIRCLE : case UNICODE_SQUARE : return ( ULONG ) 'O' ; case UNICODE_DIAMOND : return ( ULONG ) OUR_DIAMOND ; case UNICODE_NUMERO_SIGN : return ( ULONG ) 'N' ; case UNICODE_KELVIN_SIGN : return ( ULONG ) 'K' ; case UNICODE_DOWNWARDS_ARROW : return ( ULONG ) 'v' ; case UNICODE_FRACTION_SLASH : case UNICODE_DIVISION_SLASH : return ( ULONG ) '/' ; case UNICODE_ASTERISK_OPERATOR : return ( ULONG ) '*' ; case UNICODE_RATIO : return ( ULONG ) ':' ; case UNICODE_BD_LIGHT_DOWN_RIGHT : case UNICODE_BD_LIGHT_DOWN_AND_LEFT : case UNICODE_BD_LIGHT_UP_AND_RIGHT : case UNICODE_BD_LIGHT_UP_AND_LEFT : case UNICODE_BD_LIGHT_VERTICAL_AND_RIGHT : case UNICODE_BD_LIGHT_VERTICAL_AND_LEFT : case UNICODE_BD_LIGHT_DOWN_AND_HORIZONTAL : case UNICODE_BD_LIGHT_UP_AND_HORIZONTAL : case UNICODE_BD_LIGHT_VERTICAL_AND_HORIZONTAL : case UNICODE_BD_DOUBLE_DOWN_AND_RIGHT : case UNICODE_BD_DOUBLE_DOWN_AND_LEFT : case UNICODE_BD_DOUBLE_UP_AND_RIGHT : case UNICODE_BD_DOUBLE_UP_AND_LEFT : case UNICODE_BD_DOUBLE_VERTICAL_AND_RIGHT : case UNICODE_BD_DOUBLE_VERTICAL_AND_LEFT : case UNICODE_BD_DOUBLE_DOWN_AND_HORIZONTAL : case UNICODE_BD_DOUBLE_UP_AND_HORIZONTAL : case UNICODE_BD_DOUBLE_VERTICAL_AND_HORIZONTAL : case UNICODE_BLACK_SQUARE : return ( ULONG ) '+' ; case UNICODE_HAIR_SPACE : case UNICODE_ZERO_WIDTH_SPACE : case UNICODE_ZERO_WIDTH_NON_JOINER : case UNICODE_ZERO_WIDTH_JOINER : case UNICODE_LEFT_TO_RIGHT_MARK : case UNICODE_RIGHT_TO_LEFT_MARK : case UNICODE_LEFT_TO_RIGHT_EMBEDDING : case UNICODE_RIGHT_TO_LEFT_EMBEDDING : case UNICODE_POP_DIRECTIONAL_FORMATTING : case UNICODE_LEFT_TO_RIGHT_OVERRIDE : case UNICODE_RIGHT_TO_LEFT_OVERRIDE : case UNICODE_ZERO_WIDTH_NO_BREAK_SPACE : return IGNORE_CHARACTER ; default : break ; } if ( usChar == UNICODE_TRADEMARK_SIGN ) { /*\n\t\t * No local representation, it doesn't look like anything in\n\t\t * US-ASCII and a question mark does more harm than good.\n\t\t */ return IGNORE_CHARACTER ; } if ( usChar >= 0xa0 && usChar <= 0xff ) { /* Before Word 97, Word did't use Unicode */ return ( ULONG ) usChar ; } DBG_HEX_C ( usChar < 0x3000 || usChar >= 0xd800 , ulFileOffset ) ; DBG_HEX_C ( usChar < 0x3000 || usChar >= 0xd800 , usChar ) ; DBG_MSG_C ( usChar >= 0xe000 && usChar < 0xf900 , \"Private Use Area\" ) ; /* Untranslated Unicode character */ return 0x3f ; }",
    "resources/antiword/chartrans.c@ulToUpper": "ULONG ulToUpper ( ULONG ulChar ) { if ( ulChar < 0x80 ) { /* US ASCII: use standard function */ return ( ULONG ) toupper ( ( int ) ulChar ) ; } if ( ulChar >= 0xe0 && ulChar <= 0xfe && ulChar != 0xf7 ) { /*\n\t\t * Lower case accented characters\n\t\t * 0xf7 is Division sign; 0xd7 is Multiplication sign\n\t\t * 0xff is y with diaeresis; 0xdf is Sharp s\n\t\t */ return ulChar & ~ 0x20 ; } # if defined ( __STDC_ISO_10646__ ) /*\n\t * If this is ISO C99 and all locales have wchar_t = ISO 10646\n\t * (e.g., glibc 2.2 or newer), then use standard function\n\t */ if ( ulChar > 0xff ) { return ( ULONG ) towupper ( ( wint_t ) ulChar ) ; } # endif /* __STDC_ISO_10646__ */ return ulChar ; }",
    "resources/antiword/fonts_u.c@pOpenFontTableFile": "FILE * pOpenFontTableFile ( void ) { FILE * pFile ; const char * szHome , * szAntiword , * szGlobalFile ; char szEnvironmentFile [ PATH_MAX + 1 ] ; char szLocalFile [ PATH_MAX + 1 ] ; szEnvironmentFile [ 0 ] = '\\0' ; szLocalFile [ 0 ] = '\\0' ; /* Try the environment version of the fontnames file */ szAntiword = szGetAntiwordDirectory ( ) ; if ( szAntiword != NULL && szAntiword [ 0 ] != '\\0' ) { if ( strlen ( szAntiword ) + sizeof ( FILE_SEPARATOR FONTNAMES_FILE ) >= sizeof ( szEnvironmentFile ) ) { werr ( 0 , \"The name of your ANTIWORDHOME directory is too long\" ) ; return NULL ; } sprintf ( szEnvironmentFile , \"%s%s\" , szAntiword , FILE_SEPARATOR FONTNAMES_FILE ) ; DBG_MSG ( szEnvironmentFile ) ; pFile = fopen ( szEnvironmentFile , \"r\" ) ; if ( pFile != NULL ) { return pFile ; } } /* Try the local version of the fontnames file */ szHome = szGetHomeDirectory ( ) ; if ( strlen ( szHome ) + sizeof ( FILE_SEPARATOR ANTIWORD_DIR FILE_SEPARATOR FONTNAMES_FILE ) >= sizeof ( szLocalFile ) ) { werr ( 0 , \"The name of your HOME directory is too long\" ) ; return NULL ; } sprintf ( szLocalFile , \"%s%s\" , szHome , FILE_SEPARATOR ANTIWORD_DIR FILE_SEPARATOR FONTNAMES_FILE ) ; DBG_MSG ( szLocalFile ) ; pFile = fopen ( szLocalFile , \"r\" ) ; if ( pFile != NULL ) { return pFile ; } /* Try the global version of the fontnames file */ szGlobalFile = GLOBAL_ANTIWORD_DIR FILE_SEPARATOR FONTNAMES_FILE ; DBG_MSG ( szGlobalFile ) ; pFile = fopen ( szGlobalFile , \"r\" ) ; if ( pFile != NULL ) { return pFile ; } if ( szEnvironmentFile [ 0 ] != '\\0' ) { werr ( 0 , \"I can not open your fontnames file.\\n\" \"Neither '%s' nor\\n\" \"'%s' nor\\n\" \"'%s' can be opened for reading.\" , szEnvironmentFile , szLocalFile , szGlobalFile ) ; } else { werr ( 0 , \"I can not open your fontnames file.\\n\" \"Neither '%s' nor\\n\" \"'%s' can be opened for reading.\" , szLocalFile , szGlobalFile ) ; } return NULL ; }",
    "resources/antiword/fonts_u.c@vCloseFont": "void vCloseFont ( void ) { NO_DBG_MSG ( \"vCloseFont\" ) ; /* For safety: to be overwritten at the next call of tOpenfont() */ eEncoding = encoding_neutral ; bUsePlainText = TRUE ; }",
    "resources/antiword/fonts_u.c@tOpenFont": "drawfile_fontref tOpenFont ( UCHAR ucWordFontNumber , USHORT usFontStyle , USHORT usWordFontSize ) { options_type tOptions ; const char * szOurFontname ; size_t tIndex ; int iFontnumber ; NO_DBG_MSG ( \"tOpenFont\" ) ; NO_DBG_DEC ( ucWordFontNumber ) ; NO_DBG_HEX ( usFontStyle ) ; NO_DBG_DEC ( usWordFontSize ) ; /* Keep the relevant bits */ usFontStyle &= FONT_BOLD | FONT_ITALIC ; NO_DBG_HEX ( usFontStyle ) ; vGetOptions ( & tOptions ) ; eEncoding = tOptions . eEncoding ; bUsePlainText = tOptions . eConversionType != conversion_draw && tOptions . eConversionType != conversion_ps && tOptions . eConversionType != conversion_pdf ; if ( bUsePlainText ) { /* Plain text, no fonts */ return ( drawfile_fontref ) 0 ; } iFontnumber = iGetFontByNumber ( ucWordFontNumber , usFontStyle ) ; szOurFontname = szGetOurFontname ( iFontnumber ) ; if ( szOurFontname == NULL || szOurFontname [ 0 ] == '\\0' ) { DBG_DEC ( iFontnumber ) ; return ( drawfile_fontref ) 0 ; } NO_DBG_MSG ( szOurFontname ) ; for ( tIndex = 0 ; tIndex < elementsof ( szFontnames ) ; tIndex ++ ) { if ( STREQ ( szFontnames [ tIndex ] , szOurFontname ) ) { NO_DBG_DEC ( tIndex ) ; return ( drawfile_fontref ) tIndex ; } } return ( drawfile_fontref ) 0 ; }",
    "resources/antiword/fonts_u.c@tOpenTableFont": "drawfile_fontref tOpenTableFont ( USHORT usWordFontSize ) { options_type tOptions ; int iWordFontnumber ; NO_DBG_MSG ( \"tOpenTableFont\" ) ; vGetOptions ( & tOptions ) ; eEncoding = tOptions . eEncoding ; bUsePlainText = tOptions . eConversionType != conversion_draw && tOptions . eConversionType != conversion_ps && tOptions . eConversionType != conversion_pdf ; if ( bUsePlainText ) { /* Plain text, no fonts */ return ( drawfile_fontref ) 0 ; } iWordFontnumber = iFontname2Fontnumber ( TABLE_FONT , FONT_REGULAR ) ; if ( iWordFontnumber < 0 || iWordFontnumber > ( int ) UCHAR_MAX ) { DBG_DEC ( iWordFontnumber ) ; return ( drawfile_fontref ) 0 ; } return tOpenFont ( ( UCHAR ) iWordFontnumber , FONT_REGULAR , usWordFontSize ) ; }",
    "resources/antiword/fonts_u.c@szGetFontname": "const char * szGetFontname ( drawfile_fontref tFontRef ) { fail ( ( size_t ) ( UCHAR ) tFontRef >= elementsof ( szFontnames ) ) ; return szFontnames [ ( int ) ( UCHAR ) tFontRef ] ; }",
    "resources/antiword/fonts_u.c@lComputeStringWidth": "long lComputeStringWidth ( const char * szString , size_t tStringLength , drawfile_fontref tFontRef , USHORT usFontSize ) { USHORT * ausCharWidths ; UCHAR * pucChar ; long lRelWidth ; size_t tIndex ; int iFontRef ; fail ( szString == NULL ) ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; if ( szString [ 0 ] == '\\0' || tStringLength == 0 ) { /* Empty string */ return 0 ; } if ( eEncoding == encoding_utf_8 ) { fail ( ! bUsePlainText ) ; return lChar2MilliPoints ( utf8_strwidth ( szString , tStringLength ) ) ; } if ( bUsePlainText ) { /* No current font, use \"systemfont\" */ return lChar2MilliPoints ( tStringLength ) ; } if ( eEncoding == encoding_cyrillic ) { /* FIXME: until the character tables are available */ return ( tStringLength * 600L * ( long ) usFontSize + 1 ) / 2 ; } DBG_DEC_C ( eEncoding != encoding_latin_1 && eEncoding != encoding_latin_2 , eEncoding ) ; fail ( eEncoding != encoding_latin_1 && eEncoding != encoding_latin_2 ) ; /* Compute the relative string width */ iFontRef = ( int ) ( UCHAR ) tFontRef ; if ( eEncoding == encoding_latin_2 ) { ausCharWidths = ausCharacterWidths2 [ iFontRef ] ; } else { ausCharWidths = ausCharacterWidths1 [ iFontRef ] ; } lRelWidth = 0 ; for ( tIndex = 0 , pucChar = ( UCHAR * ) szString ; tIndex < tStringLength ; tIndex ++ , pucChar ++ ) { lRelWidth += ( long ) ausCharWidths [ ( int ) * pucChar ] ; } /* Compute the absolute string width */ return ( lRelWidth * ( long ) usFontSize + 1 ) / 2 ; }",
    "resources/antiword/fonts_u.c@tCountColumns": "size_t tCountColumns ( const char * szString , size_t tLength ) { fail ( szString == NULL ) ; if ( eEncoding != encoding_utf_8 ) { /* One byte, one character, one column */ return tLength ; } return ( size_t ) utf8_strwidth ( szString , tLength ) ; }",
    "resources/antiword/fonts_u.c@tGetCharacterLength": "size_t tGetCharacterLength ( const char * szString ) { fail ( szString == NULL ) ; if ( eEncoding != encoding_utf_8 ) { return 1 ; } return ( size_t ) utf8_chrlength ( szString ) ; }",
    "resources/antiword/saveas.c@saveas": "static void saveas ( int iFileType , char * szOutfile , size_t tEstSize , save_filesaver save_function , void * pvReference ) { TRACE_MSG ( \"saveas\" ) ; if ( tSaveWindow == 0 ) { tSaveWindow = Window_Create ( \"xfer_send\" , template_TITLEMIN ) ; } Icon_SetText ( tSaveWindow , FILENAME_ICON , szOutfile ) ; Window_Show ( tSaveWindow , open_UNDERPOINTER ) ; ( void ) Save_InitSaveWindowHandler ( tSaveWindow , FALSE , TRUE , TRUE , DRAG_SPRITE , OK_BUTTON , CANCEL_BUTTON , FILENAME_ICON , save_function , NULL , NULL , tEstSize , iFileType , pvReference ) ; }",
    "resources/antiword/saveas.c@bWrite2File": "static BOOL bWrite2File ( void * pvBytes , size_t tSize , FILE * pFile , const char * szFilename ) { if ( fwrite ( pvBytes , sizeof ( char ) , tSize , pFile ) != tSize ) { werr ( 0 , \"I can't write to '%s'\" , szFilename ) ; return FALSE ; } return TRUE ; }",
    "resources/antiword/saveas.c@bText2File": "static BOOL bText2File ( char * szFilename , void * pvHandle ) { FILE * pFile ; diagram_type * pDiag ; drawfile_object * pObj ; drawfile_text * pText ; const char * pcTmp ; int iToGo , iX , iYtopPrev , iHeight , iLines ; BOOL bFirst , bIndent , bSuccess ; TRACE_MSG ( \"bText2File\" ) ; fail ( szFilename == NULL || szFilename [ 0 ] == '\\0' ) ; fail ( pvHandle == NULL ) ; DBG_MSG ( szFilename ) ; pDiag = ( diagram_type * ) pvHandle ; pFile = fopen ( szFilename , \"w\" ) ; if ( pFile == NULL ) { werr ( 0 , \"I can't open '%s' for writing\" , szFilename ) ; return FALSE ; } bFirst = TRUE ; iYtopPrev = 0 ; iHeight = ( int ) lWord2DrawUnits20 ( DEFAULT_FONT_SIZE ) ; bSuccess = TRUE ; fail ( pDiag -> tInfo . length < offsetof ( drawfile_diagram , objects ) ) ; iToGo = pDiag -> tInfo . length - offsetof ( drawfile_diagram , objects ) ; DBG_DEC ( iToGo ) ; pcTmp = ( const char * ) pDiag -> tInfo . data + offsetof ( drawfile_diagram , objects ) ; while ( iToGo > 0 && bSuccess ) { pObj = ( drawfile_object * ) pcTmp ; switch ( pObj -> type ) { case drawfile_TYPE_TEXT : pText = & pObj -> data . text ; /* Compute the number of lines */ iLines = ( iYtopPrev - pText -> bbox . max . y + iHeight / 2 ) / iHeight ; DBG_DEC_C ( iLines < 0 , iYtopPrev ) ; DBG_DEC_C ( iLines < 0 , pText -> bbox . max . y ) ; fail ( iLines < 0 ) ; bIndent = iLines > 0 || bFirst ; bFirst = FALSE ; /* Print the newlines */ while ( iLines > 0 && bSuccess ) { bSuccess = bWrite2File ( \"\\n\" , 1 , pFile , szFilename ) ; iLines -- ; } /* Print the indentation */ if ( bIndent && bSuccess ) { for ( iX = Drawfile_ScreenToDraw ( 8 ) ; iX <= pText -> bbox . min . x && bSuccess ; iX += Drawfile_ScreenToDraw ( 16 ) ) { bSuccess = bWrite2File ( \" \" , 1 , pFile , szFilename ) ; } } if ( ! bSuccess ) { break ; } /* Print the text object */ bSuccess = bWrite2File ( pText -> text , strlen ( pText -> text ) , pFile , szFilename ) ; /* Setup for the next object */ iYtopPrev = pText -> bbox . max . y ; iHeight = pText -> bbox . max . y - pText -> bbox . min . y ; break ; case drawfile_TYPE_FONT_TABLE : case drawfile_TYPE_PATH : case drawfile_TYPE_SPRITE : case drawfile_TYPE_JPEG : /* These are not relevant in a textfile */ break ; default : DBG_DEC ( pObj -> type ) ; bSuccess = FALSE ; break ; } pcTmp += pObj -> size ; iToGo -= pObj -> size ; } DBG_DEC_C ( iToGo != 0 , iToGo ) ; if ( bSuccess ) { bSuccess = bWrite2File ( \"\\n\" , 1 , pFile , szFilename ) ; } ( void ) fclose ( pFile ) ; if ( bSuccess ) { vSetFiletype ( szFilename , FILETYPE_TEXT ) ; } else { ( void ) remove ( szFilename ) ; werr ( 0 , \"Unable to save textfile '%s'\" , szFilename ) ; } return bSuccess ; }",
    "resources/antiword/saveas.c@bSaveTextfile": "",
    "resources/antiword/saveas.c@bDraw2File": "static BOOL bDraw2File ( char * szFilename , void * pvHandle ) { FILE * pFile ; diagram_type * pDiagram ; wimp_box * pBbox ; drawfile_object * pObj ; drawfile_text * pText ; drawfile_path * pPath ; drawfile_sprite * pSprite ; drawfile_jpeg * pJpeg ; int * piPath ; char * pcTmp ; int iYadd , iToGo , iSize ; BOOL bSuccess ; TRACE_MSG ( \"bDraw2File\" ) ; fail ( szFilename == NULL || szFilename [ 0 ] == '\\0' ) ; fail ( pvHandle == NULL ) ; NO_DBG_MSG ( szFilename ) ; pDiagram = ( diagram_type * ) pvHandle ; pFile = fopen ( szFilename , \"wb\" ) ; if ( pFile == NULL ) { werr ( 0 , \"I can't open '%s' for writing\" , szFilename ) ; return FALSE ; } iToGo = pDiagram -> tInfo . length ; DBG_DEC ( iToGo ) ; pcTmp = pDiagram -> tInfo . data ; bSuccess = bWrite2File ( pcTmp , offsetof ( drawfile_diagram , bbox ) , pFile , szFilename ) ; if ( bSuccess ) { pcTmp += offsetof ( drawfile_diagram , bbox ) ; iToGo -= offsetof ( drawfile_diagram , bbox ) ; pBbox = ( wimp_box * ) pcTmp ; iYadd = - pBbox -> min . y ; pBbox -> min . y += iYadd ; pBbox -> max . y += iYadd ; bSuccess = bWrite2File ( pcTmp , sizeof ( * pBbox ) , pFile , szFilename ) ; iToGo -= sizeof ( * pBbox ) ; DBG_DEC ( iToGo ) ; pcTmp += sizeof ( * pBbox ) ; } else { iYadd = 0 ; } while ( iToGo > 0 && bSuccess ) { pObj = ( drawfile_object * ) pcTmp ; iSize = pObj -> size ; switch ( pObj -> type ) { case drawfile_TYPE_FONT_TABLE : bSuccess = bWrite2File ( pcTmp , iSize , pFile , szFilename ) ; pcTmp += iSize ; iToGo -= iSize ; break ; case drawfile_TYPE_TEXT : pText = & pObj -> data . text ; /* First correct the coordinates */ pText -> bbox . min . y += iYadd ; pText -> bbox . max . y += iYadd ; pText -> base . y += iYadd ; /* Now write the information to file */ bSuccess = bWrite2File ( pcTmp , iSize , pFile , szFilename ) ; pcTmp += pObj -> size ; iToGo -= pObj -> size ; break ; case drawfile_TYPE_PATH : pPath = & pObj -> data . path ; /* First correct the coordinates */ pPath -> bbox . min . y += iYadd ; pPath -> bbox . max . y += iYadd ; /* Now write the information to file */ bSuccess = bWrite2File ( pPath , sizeof ( * pPath ) , pFile , szFilename ) ; pcTmp += sizeof ( * pPath ) ; iSize = pObj -> size - sizeof ( * pPath ) ; fail ( iSize < 14 * sizeof ( int ) ) ; /* Second correct the path coordinates */ piPath = xmalloc ( iSize ) ; memcpy ( piPath , pcTmp , iSize ) ; piPath [ 2 ] += iYadd ; piPath [ 5 ] += iYadd ; piPath [ 8 ] += iYadd ; piPath [ 11 ] += iYadd ; if ( bSuccess ) { bSuccess = bWrite2File ( piPath , iSize , pFile , szFilename ) ; pcTmp += iSize ; } piPath = xfree ( piPath ) ; iToGo -= pObj -> size ; break ; case drawfile_TYPE_SPRITE : pSprite = & pObj -> data . sprite ; /* First correct the coordinates */ pSprite -> bbox . min . y += iYadd ; pSprite -> bbox . max . y += iYadd ; /* Now write the information to file */ bSuccess = bWrite2File ( pcTmp , iSize , pFile , szFilename ) ; pcTmp += pObj -> size ; iToGo -= pObj -> size ; break ; case drawfile_TYPE_JPEG : pJpeg = & pObj -> data . jpeg ; /* First correct the coordinates */ pJpeg -> bbox . min . y += iYadd ; pJpeg -> bbox . max . y += iYadd ; pJpeg -> trfm . entries [ 2 ] [ 1 ] += iYadd ; /* Now write the information to file */ bSuccess = bWrite2File ( pcTmp , iSize , pFile , szFilename ) ; pcTmp += pObj -> size ; iToGo -= pObj -> size ; break ; default : DBG_DEC ( pObj -> type ) ; bSuccess = FALSE ; break ; } } DBG_DEC_C ( iToGo != 0 , iToGo ) ; ( void ) fclose ( pFile ) ; if ( bSuccess ) { vSetFiletype ( szFilename , FILETYPE_DRAW ) ; } else { ( void ) remove ( szFilename ) ; werr ( 0 , \"Unable to save drawfile '%s'\" , szFilename ) ; } return bSuccess ; }",
    "resources/antiword/saveas.c@bSaveDrawfile": "",
    "resources/antiword/dib2sprt.c@iGetByteWidth": "static int iGetByteWidth ( const imagedata_type * pImg ) { switch ( pImg -> uiBitsPerComponent ) { case 1 : return ( pImg -> iWidth + 31 ) / 32 * sizeof ( int ) ; case 4 : return ( pImg -> iWidth + 7 ) / 8 * sizeof ( int ) ; case 8 : case 24 : return ( pImg -> iWidth + 3 ) / 4 * sizeof ( int ) ; default : DBG_DEC ( pImg -> uiBitsPerComponent ) ; return 0 ; } }",
    "resources/antiword/dib2sprt.c@pCreateBlankSprite": "static sprite_areainfo * pCreateBlankSprite ( const imagedata_type * pImg , size_t * pSize ) { sprite_areainfo * pArea ; UCHAR * pucTmp ; size_t tSize ; screen_modeval uMode ; int iIndex , iPaletteEntries ; TRACE_MSG ( \"pCreateBlankSprite\" ) ; fail ( pImg == NULL ) ; fail ( pSize == NULL ) ; switch ( pImg -> uiBitsPerComponent ) { case 1 : uMode . screen_mode = 18 ; iPaletteEntries = 2 ; break ; case 4 : uMode . screen_mode = 20 ; iPaletteEntries = 16 ; break ; case 8 : case 24 : uMode . screen_mode = 21 ; iPaletteEntries = 0 ; break ; default : DBG_DEC ( pImg -> uiBitsPerComponent ) ; return NULL ; } fail ( iPaletteEntries < 0 || iPaletteEntries > 16 ) ; /* Get memory for the sprite */ tSize = sizeof ( sprite_areainfo ) + Sprite_MemorySize ( pImg -> iWidth , pImg -> iHeight , uMode , iPaletteEntries > 0 ? sprite_HASPAL : sprite_HASNOMASKPAL ) ; DBG_DEC ( tSize ) ; pArea = xmalloc ( tSize ) ; /* Initialise sprite area */ pArea -> areasize = tSize ; pArea -> numsprites = 0 ; pArea -> firstoffset = sizeof ( sprite_areainfo ) ; pArea -> freeoffset = sizeof ( sprite_areainfo ) ; /* Create a blank sprite */ Error_CheckFatal ( Sprite_Create ( pArea , \"wordimage\" , iPaletteEntries > 0 ? 1 : 0 , pImg -> iWidth , pImg -> iHeight , uMode ) ) ; /* Add the palette */ pucTmp = ( UCHAR * ) pArea + pArea -> firstoffset + sizeof ( sprite_header ) ; for ( iIndex = 0 ; iIndex < iPaletteEntries ; iIndex ++ ) { /* First color */ * pucTmp ++ = 0 ; * pucTmp ++ = pImg -> aucPalette [ iIndex ] [ 0 ] ; * pucTmp ++ = pImg -> aucPalette [ iIndex ] [ 1 ] ; * pucTmp ++ = pImg -> aucPalette [ iIndex ] [ 2 ] ; /* Second color */ * pucTmp ++ = 0 ; * pucTmp ++ = pImg -> aucPalette [ iIndex ] [ 0 ] ; * pucTmp ++ = pImg -> aucPalette [ iIndex ] [ 1 ] ; * pucTmp ++ = pImg -> aucPalette [ iIndex ] [ 2 ] ; } * pSize = tSize ; return pArea ; }",
    "resources/antiword/dib2sprt.c@iReduceColor": "static int iReduceColor ( int iRed , int iGreen , int iBlue ) { int iResult ; iResult = ( iBlue & 0x80 ) ? 0x80 : 0 ; iResult |= ( iGreen & 0x80 ) ? 0x40 : 0 ; iResult |= ( iGreen & 0x40 ) ? 0x20 : 0 ; iResult |= ( iRed & 0x80 ) ? 0x10 : 0 ; iResult |= ( iBlue & 0x40 ) ? 0x08 : 0 ; iResult |= ( iRed & 0x40 ) ? 0x04 : 0 ; iResult |= ( ( iRed | iGreen | iBlue ) & 0x20 ) ? 0x02 : 0 ; iResult |= ( ( iRed | iGreen | iBlue ) & 0x10 ) ? 0x01 : 0 ; return iResult ; }",
    "resources/antiword/dib2sprt.c@vDecode1bpp": "static void vDecode1bpp ( FILE * pFile , UCHAR * pucData , const imagedata_type * pImg ) { int iX , iY , iByteWidth , iOffset , iTmp , iEighthWidth , iPadding ; UCHAR ucTmp ; DBG_MSG ( \"vDecode1bpp\" ) ; fail ( pFile == NULL ) ; fail ( pucData == NULL ) ; fail ( pImg == NULL ) ; fail ( pImg -> iColorsUsed < 1 || pImg -> iColorsUsed > 2 ) ; iByteWidth = iGetByteWidth ( pImg ) ; iEighthWidth = ( pImg -> iWidth + 7 ) / 8 ; iPadding = ROUND4 ( iEighthWidth ) - iEighthWidth ; for ( iY = pImg -> iHeight - 1 ; iY >= 0 ; iY -- ) { for ( iX = 0 ; iX < iEighthWidth ; iX ++ ) { iTmp = iNextByte ( pFile ) ; if ( iTmp == EOF ) { return ; } /* Reverse the bit order */ ucTmp = ( iTmp & BIT ( 0 ) ) ? ( UCHAR ) BIT ( 7 ) : 0 ; ucTmp |= ( iTmp & BIT ( 1 ) ) ? ( UCHAR ) BIT ( 6 ) : 0 ; ucTmp |= ( iTmp & BIT ( 2 ) ) ? ( UCHAR ) BIT ( 5 ) : 0 ; ucTmp |= ( iTmp & BIT ( 3 ) ) ? ( UCHAR ) BIT ( 4 ) : 0 ; ucTmp |= ( iTmp & BIT ( 4 ) ) ? ( UCHAR ) BIT ( 3 ) : 0 ; ucTmp |= ( iTmp & BIT ( 5 ) ) ? ( UCHAR ) BIT ( 2 ) : 0 ; ucTmp |= ( iTmp & BIT ( 6 ) ) ? ( UCHAR ) BIT ( 1 ) : 0 ; ucTmp |= ( iTmp & BIT ( 7 ) ) ? ( UCHAR ) BIT ( 0 ) : 0 ; iOffset = iY * iByteWidth + iX ; * ( pucData + iOffset ) = ucTmp ; } ( void ) tSkipBytes ( pFile , iPadding ) ; } }",
    "resources/antiword/dib2sprt.c@vDecode4bpp": "static void vDecode4bpp ( FILE * pFile , UCHAR * pucData , const imagedata_type * pImg ) { int iX , iY , iByteWidth , iOffset , iTmp , iHalfWidth , iPadding ; UCHAR ucTmp ; DBG_MSG ( \"vDecode4bpp\" ) ; fail ( pFile == NULL ) ; fail ( pucData == NULL ) ; fail ( pImg == NULL ) ; fail ( pImg -> iColorsUsed < 1 || pImg -> iColorsUsed > 16 ) ; iByteWidth = iGetByteWidth ( pImg ) ; iHalfWidth = ( pImg -> iWidth + 1 ) / 2 ; iPadding = ROUND4 ( iHalfWidth ) - iHalfWidth ; for ( iY = pImg -> iHeight - 1 ; iY >= 0 ; iY -- ) { for ( iX = 0 ; iX < iHalfWidth ; iX ++ ) { iTmp = iNextByte ( pFile ) ; if ( iTmp == EOF ) { return ; } /* Reverse the nibble order */ ucTmp = ( iTmp & 0xf0 ) >> 4 ; ucTmp |= ( iTmp & 0x0f ) << 4 ; iOffset = iY * iByteWidth + iX ; * ( pucData + iOffset ) = ucTmp ; } ( void ) tSkipBytes ( pFile , iPadding ) ; } }",
    "resources/antiword/dib2sprt.c@vDecode8bpp": "static void vDecode8bpp ( FILE * pFile , UCHAR * pucData , const imagedata_type * pImg ) { int iX , iY , iByteWidth , iOffset , iIndex , iPadding ; DBG_MSG ( \"vDecode8bpp\" ) ; fail ( pFile == NULL ) ; fail ( pucData == NULL ) ; fail ( pImg == NULL ) ; fail ( pImg -> iColorsUsed < 1 || pImg -> iColorsUsed > 256 ) ; iByteWidth = iGetByteWidth ( pImg ) ; iPadding = ROUND4 ( pImg -> iWidth ) - pImg -> iWidth ; for ( iY = pImg -> iHeight - 1 ; iY >= 0 ; iY -- ) { for ( iX = 0 ; iX < pImg -> iWidth ; iX ++ ) { iIndex = iNextByte ( pFile ) ; if ( iIndex == EOF ) { return ; } iOffset = iY * iByteWidth + iX ; * ( pucData + iOffset ) = iReduceColor ( pImg -> aucPalette [ iIndex ] [ 0 ] , pImg -> aucPalette [ iIndex ] [ 1 ] , pImg -> aucPalette [ iIndex ] [ 2 ] ) ; } ( void ) tSkipBytes ( pFile , iPadding ) ; } }",
    "resources/antiword/dib2sprt.c@vDecode24bpp": "static void vDecode24bpp ( FILE * pFile , UCHAR * pucData , const imagedata_type * pImg ) { int iX , iY , iTripleWidth , iByteWidth , iOffset , iPadding ; int iRed , iGreen , iBlue ; DBG_MSG ( \"vDecode24bpp\" ) ; fail ( pFile == NULL ) ; fail ( pucData == NULL ) ; fail ( pImg == NULL ) ; iByteWidth = iGetByteWidth ( pImg ) ; iTripleWidth = pImg -> iWidth * 3 ; iPadding = ROUND4 ( iTripleWidth ) - iTripleWidth ; for ( iY = pImg -> iHeight - 1 ; iY >= 0 ; iY -- ) { for ( iX = 0 ; iX < pImg -> iWidth ; iX ++ ) { iBlue = iNextByte ( pFile ) ; if ( iBlue == EOF ) { return ; } iGreen = iNextByte ( pFile ) ; if ( iGreen == EOF ) { return ; } iRed = iNextByte ( pFile ) ; if ( iRed == EOF ) { return ; } iOffset = iY * iByteWidth + iX ; * ( pucData + iOffset ) = iReduceColor ( iRed , iGreen , iBlue ) ; } ( void ) tSkipBytes ( pFile , iPadding ) ; } }",
    "resources/antiword/dib2sprt.c@vDecodeRle4": "static void vDecodeRle4 ( FILE * pFile , UCHAR * pucData , const imagedata_type * pImg ) { int iX , iY , iByteWidth , iOffset , iTmp , iHalfWidth ; int iRun , iRunLength , iHalfRun ; BOOL bEOL ; UCHAR ucTmp ; DBG_MSG ( \"vDecodeRle4\" ) ; fail ( pFile == NULL ) ; fail ( pucData == NULL ) ; fail ( pImg == NULL ) ; fail ( pImg -> iColorsUsed < 1 || pImg -> iColorsUsed > 16 ) ; DBG_DEC ( pImg -> iWidth ) ; DBG_DEC ( pImg -> iHeight ) ; iByteWidth = iGetByteWidth ( pImg ) ; iHalfWidth = ( pImg -> iWidth + 1 ) / 2 ; for ( iY = pImg -> iHeight - 1 ; iY >= 0 ; iY -- ) { bEOL = FALSE ; iX = 0 ; while ( ! bEOL ) { iRunLength = iNextByte ( pFile ) ; if ( iRunLength == EOF ) { return ; } if ( iRunLength != 0 ) { /*\n\t\t\t\t * Encoded packet:\n\t\t\t\t * RunLength pixels, all the \"same\" value\n\t\t\t\t */ iTmp = iNextByte ( pFile ) ; if ( iTmp == EOF ) { return ; } /* Reverse the nibble order */ ucTmp = ( iTmp & 0xf0 ) >> 4 ; ucTmp |= ( iTmp & 0x0f ) << 4 ; iHalfRun = ( iRunLength + 1 ) / 2 ; for ( iRun = 0 ; iRun < iHalfRun ; iRun ++ ) { if ( iX < iHalfWidth ) { iOffset = iY * iByteWidth + iX ; * ( pucData + iOffset ) = ucTmp ; } iX ++ ; } continue ; } /* Literal or escape */ iRunLength = iNextByte ( pFile ) ; if ( iRunLength == EOF ) { return ; } if ( iRunLength == 0 ) { /* End of line escape */ bEOL = TRUE ; } else if ( iRunLength == 1 ) { /* End of file escape */ return ; } else if ( iRunLength == 2 ) { /* Delta escape */ DBG_MSG ( \"RLE4: encountered delta escape\" ) ; return ; } else { /* Literal packet */ iHalfRun = ( iRunLength + 1 ) / 2 ; for ( iRun = 0 ; iRun < iHalfRun ; iRun ++ ) { iTmp = iNextByte ( pFile ) ; if ( iTmp == EOF ) { return ; } /* Reverse the nibble order */ ucTmp = ( iTmp & 0xf0 ) >> 4 ; ucTmp |= ( iTmp & 0x0f ) << 4 ; if ( iX < iHalfWidth ) { iOffset = iY * iByteWidth + iX ; * ( pucData + iOffset ) = ucTmp ; } iX ++ ; } /* Padding if the number of bytes is odd */ if ( odd ( iHalfRun ) ) { ( void ) tSkipBytes ( pFile , 1 ) ; } } } DBG_DEC_C ( iX != iHalfWidth , iX ) ; } }",
    "resources/antiword/dib2sprt.c@vDecodeRle8": "static void vDecodeRle8 ( FILE * pFile , UCHAR * pucData , const imagedata_type * pImg ) { int iX , iY , iRun , iRunLength , iOffset , iIndex , iByteWidth ; BOOL bEOL ; DBG_MSG ( \"vDecodeRle8\" ) ; fail ( pFile == NULL ) ; fail ( pucData == NULL ) ; fail ( pImg == NULL ) ; fail ( pImg -> iColorsUsed < 1 || pImg -> iColorsUsed > 256 ) ; DBG_DEC ( pImg -> iWidth ) ; DBG_DEC ( pImg -> iHeight ) ; iByteWidth = iGetByteWidth ( pImg ) ; for ( iY = pImg -> iHeight - 1 ; iY >= 0 ; iY -- ) { bEOL = FALSE ; iX = 0 ; while ( ! bEOL ) { iRunLength = iNextByte ( pFile ) ; if ( iRunLength == EOF ) { return ; } if ( iRunLength != 0 ) { /*\n\t\t\t\t * Encoded packet:\n\t\t\t\t * RunLength pixels, all the same value\n\t\t\t\t */ iIndex = iNextByte ( pFile ) ; if ( iIndex == EOF ) { return ; } for ( iRun = 0 ; iRun < iRunLength ; iRun ++ ) { if ( iX < pImg -> iWidth ) { iOffset = iY * iByteWidth + iX ; * ( pucData + iOffset ) = iReduceColor ( pImg -> aucPalette [ iIndex ] [ 0 ] , pImg -> aucPalette [ iIndex ] [ 1 ] , pImg -> aucPalette [ iIndex ] [ 2 ] ) ; } iX ++ ; } continue ; } /* Literal or escape */ iRunLength = iNextByte ( pFile ) ; if ( iRunLength == EOF ) { return ; } if ( iRunLength == 0 ) { /* End of line escape */ bEOL = TRUE ; } else if ( iRunLength == 1 ) { /* End of file escape */ return ; } else if ( iRunLength == 2 ) { /* Delta escape */ DBG_MSG ( \"RLE8: encountered delta escape\" ) ; return ; } else { /* Literal packet */ for ( iRun = 0 ; iRun < iRunLength ; iRun ++ ) { iIndex = iNextByte ( pFile ) ; if ( iIndex == EOF ) { return ; } if ( iX < pImg -> iWidth ) { iOffset = iY * iByteWidth + iX ; * ( pucData + iOffset ) = iReduceColor ( pImg -> aucPalette [ iIndex ] [ 0 ] , pImg -> aucPalette [ iIndex ] [ 1 ] , pImg -> aucPalette [ iIndex ] [ 2 ] ) ; } iX ++ ; } /* Padding if the number of bytes is odd */ if ( odd ( iRunLength ) ) { ( void ) tSkipBytes ( pFile , 1 ) ; } } } DBG_DEC_C ( iX != pImg -> iWidth , iX ) ; } }",
    "resources/antiword/dib2sprt.c@vDecodeDIB": "static void vDecodeDIB ( diagram_type * pDiag , FILE * pFile , const imagedata_type * pImg ) { sprite_areainfo * pSprite ; UCHAR * pucPalette , * pucData ; size_t tSpriteSize ; int iHeaderSize ; /* Skip the bitmap info header */ iHeaderSize = ( int ) ulNextLong ( pFile ) ; ( void ) tSkipBytes ( pFile , iHeaderSize - 4 ) ; /* Skip the colortable */ if ( pImg -> uiBitsPerComponent <= 8 ) { ( void ) tSkipBytes ( pFile , pImg -> iColorsUsed * ( ( iHeaderSize > 12 ) ? 4 : 3 ) ) ; } /* Create an blank sprite */ pSprite = pCreateBlankSprite ( pImg , & tSpriteSize ) ; pucPalette = ( UCHAR * ) pSprite + pSprite -> firstoffset + sizeof ( sprite_header ) ; /* Add the pixel information */ switch ( pImg -> uiBitsPerComponent ) { case 1 : fail ( pImg -> eCompression != compression_none ) ; pucData = pucPalette + 2 * 8 ; vDecode1bpp ( pFile , pucData , pImg ) ; break ; case 4 : fail ( pImg -> eCompression != compression_none && pImg -> eCompression != compression_rle4 ) ; pucData = pucPalette + 16 * 8 ; if ( pImg -> eCompression == compression_rle4 ) { vDecodeRle4 ( pFile , pucData , pImg ) ; } else { vDecode4bpp ( pFile , pucData , pImg ) ; } break ; case 8 : fail ( pImg -> eCompression != compression_none && pImg -> eCompression != compression_rle8 ) ; pucData = pucPalette + 0 * 8 ; if ( pImg -> eCompression == compression_rle8 ) { vDecodeRle8 ( pFile , pucData , pImg ) ; } else { vDecode8bpp ( pFile , pucData , pImg ) ; } break ; case 24 : fail ( pImg -> eCompression != compression_none ) ; pucData = pucPalette + 0 * 8 ; vDecode24bpp ( pFile , pucData , pImg ) ; break ; default : DBG_DEC ( pImg -> uiBitsPerComponent ) ; break ; } # if 0 /* defined(DEBUG) */ vCopy2File ( ( UCHAR * ) pSprite , tSpriteSize ) ; # endif /* DEBUG */ /* Add the sprite to the Draw file */ vImage2Diagram ( pDiag , pImg , ( UCHAR * ) pSprite + pSprite -> firstoffset , tSpriteSize - pSprite -> firstoffset ) ; /* Clean up before you leave */ pSprite = xfree ( pSprite ) ; }",
    "resources/antiword/dib2sprt.c@bTranslateDIB": "",
    "resources/antiword/imgtrans.c@bTranslateImage": "",
    "resources/antiword/prop0.c@tConvertDosDate": "static time_t tConvertDosDate ( const char * szDosDate ) { struct tm tTime ; const char * pcTmp ; time_t tResult ; memset ( & tTime , 0 , sizeof ( tTime ) ) ; pcTmp = szDosDate ; /* Get the month */ if ( ! isdigit ( * pcTmp ) ) { return ( time_t ) - 1 ; } tTime . tm_mon = ( int ) ( * pcTmp - '0' ) ; pcTmp ++ ; if ( isdigit ( * pcTmp ) ) { tTime . tm_mon *= 10 ; tTime . tm_mon += ( int ) ( * pcTmp - '0' ) ; pcTmp ++ ; } /* Get the first separater */ if ( isalnum ( * pcTmp ) ) { return ( time_t ) - 1 ; } pcTmp ++ ; /* Get the day */ if ( ! isdigit ( * pcTmp ) ) { return ( time_t ) - 1 ; } tTime . tm_mday = ( int ) ( * pcTmp - '0' ) ; pcTmp ++ ; if ( isdigit ( * pcTmp ) ) { tTime . tm_mday *= 10 ; tTime . tm_mday += ( int ) ( * pcTmp - '0' ) ; pcTmp ++ ; } /* Get the second separater */ if ( isalnum ( * pcTmp ) ) { return ( time_t ) - 1 ; } pcTmp ++ ; /* Get the year */ if ( ! isdigit ( * pcTmp ) ) { return ( time_t ) - 1 ; } tTime . tm_year = ( int ) ( * pcTmp - '0' ) ; pcTmp ++ ; if ( isdigit ( * pcTmp ) ) { tTime . tm_year *= 10 ; tTime . tm_year += ( int ) ( * pcTmp - '0' ) ; pcTmp ++ ; } /* Check the values */ if ( tTime . tm_mon == 0 || tTime . tm_mday == 0 || tTime . tm_mday > 31 ) { return ( time_t ) - 1 ; } /* Correct the values */ tTime . tm_mon -- ; /* From 01-12 to 00-11 */ if ( tTime . tm_year < 80 ) { tTime . tm_year += 100 ; /* 00 means 2000 is 100 */ } tTime . tm_isdst = - 1 ; tResult = mktime ( & tTime ) ; NO_DBG_MSG ( ctime ( & tResult ) ) ; return tResult ; }",
    "resources/antiword/prop0.c@vGet0DopInfo": "void vGet0DopInfo ( FILE * pFile , const UCHAR * aucHeader ) { document_block_type tDocument ; UCHAR * aucBuffer ; ULONG ulBeginSumdInfo , ulBeginNextBlock ; size_t tLen ; USHORT usOffset ; tDocument . ucHdrFtrSpecification = 0 ; tDocument . usDefaultTabWidth = usGetWord ( 0x70 , aucHeader ) ; /* dxaTab */ tDocument . tCreateDate = ( time_t ) - 1 ; tDocument . tRevisedDate = ( time_t ) - 1 ; ulBeginSumdInfo = 128 * ( ULONG ) usGetWord ( 0x1c , aucHeader ) ; DBG_HEX ( ulBeginSumdInfo ) ; ulBeginNextBlock = 128 * ( ULONG ) usGetWord ( 0x6a , aucHeader ) ; DBG_HEX ( ulBeginNextBlock ) ; if ( ulBeginSumdInfo < ulBeginNextBlock && ulBeginNextBlock != 0 ) { /* There is a summary information block */ tLen = ( size_t ) ( ulBeginNextBlock - ulBeginSumdInfo ) ; aucBuffer = xmalloc ( tLen ) ; /* Read the summary information block */ if ( bReadBytes ( aucBuffer , tLen , ulBeginSumdInfo , pFile ) ) { usOffset = usGetWord ( 12 , aucBuffer ) ; if ( aucBuffer [ usOffset ] != 0 ) { NO_DBG_STRN ( aucBuffer + usOffset , 8 ) ; tDocument . tRevisedDate = tConvertDosDate ( ( char * ) aucBuffer + usOffset ) ; } usOffset = usGetWord ( 14 , aucBuffer ) ; if ( aucBuffer [ usOffset ] != 0 ) { NO_DBG_STRN ( aucBuffer + usOffset , 8 ) ; tDocument . tCreateDate = tConvertDosDate ( ( char * ) aucBuffer + usOffset ) ; } } aucBuffer = xfree ( aucBuffer ) ; } vCreateDocumentInfoList ( & tDocument ) ; }",
    "resources/antiword/prop0.c@vGet0SectionInfo": "static void vGet0SectionInfo ( const UCHAR * aucGrpprl , size_t tBytes , section_block_type * pSection ) { USHORT usCcol ; UCHAR ucTmp ; fail ( aucGrpprl == NULL || pSection == NULL ) ; if ( tBytes < 2 ) { return ; } /* bkc */ ucTmp = ucGetByte ( 1 , aucGrpprl ) ; DBG_HEX ( ucTmp ) ; ucTmp &= 0x07 ; DBG_HEX ( ucTmp ) ; pSection -> bNewPage = ucTmp != 0 && ucTmp != 1 ; if ( tBytes < 18 ) { return ; } /* ccolM1 */ usCcol = ( USHORT ) ucGetByte ( 17 , aucGrpprl ) ; DBG_DEC ( usCcol ) ; }",
    "resources/antiword/prop0.c@vGet0SepInfo": "void vGet0SepInfo ( FILE * pFile , const UCHAR * aucHeader ) { section_block_type tSection ; UCHAR * aucBuffer ; ULONG ulBeginOfText , ulTextOffset , ulBeginSectInfo ; ULONG ulCharPos , ulSectPage , ulBeginNextBlock ; size_t tSectInfoLen , tIndex , tSections , tBytes ; UCHAR aucTmp [ 2 ] , aucFpage [ 35 ] ; fail ( pFile == NULL || aucHeader == NULL ) ; ulBeginOfText = 128 ; NO_DBG_HEX ( ulBeginOfText ) ; ulBeginSectInfo = 128 * ( ULONG ) usGetWord ( 0x18 , aucHeader ) ; DBG_HEX ( ulBeginSectInfo ) ; ulBeginNextBlock = 128 * ( ULONG ) usGetWord ( 0x1a , aucHeader ) ; DBG_HEX ( ulBeginNextBlock ) ; if ( ulBeginSectInfo == ulBeginNextBlock ) { /* There is no section information block */ return ; } /* Get the the number of sections */ if ( ! bReadBytes ( aucTmp , 2 , ulBeginSectInfo , pFile ) ) { return ; } tSections = ( size_t ) usGetWord ( 0 , aucTmp ) ; NO_DBG_DEC ( tSections ) ; /* Read the Section Descriptors */ tSectInfoLen = 10 * tSections ; NO_DBG_DEC ( tSectInfoLen ) ; aucBuffer = xmalloc ( tSectInfoLen ) ; if ( ! bReadBytes ( aucBuffer , tSectInfoLen , ulBeginSectInfo + 4 , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tSectInfoLen ) ; /* Read the Section Properties */ for ( tIndex = 0 ; tIndex < tSections ; tIndex ++ ) { ulTextOffset = ulGetLong ( 10 * tIndex , aucBuffer ) ; NO_DBG_HEX ( ulTextOffset ) ; ulCharPos = ulBeginOfText + ulTextOffset ; NO_DBG_HEX ( ulTextOffset ) ; ulSectPage = ulGetLong ( 10 * tIndex + 6 , aucBuffer ) ; NO_DBG_HEX ( ulSectPage ) ; if ( ulSectPage == FC_INVALID || /* Must use defaults */ ulSectPage < 128 || /* Should not happen */ ulSectPage >= ulBeginSectInfo ) { /* Should not happen */ DBG_HEX_C ( ulSectPage != FC_INVALID , ulSectPage ) ; vDefault2SectionInfoList ( ulCharPos ) ; continue ; } /* Get the number of bytes to read */ if ( ! bReadBytes ( aucTmp , 1 , ulSectPage , pFile ) ) { continue ; } tBytes = 1 + ( size_t ) ucGetByte ( 0 , aucTmp ) ; NO_DBG_DEC ( tBytes ) ; if ( tBytes > sizeof ( aucFpage ) ) { DBG_DEC ( tBytes ) ; tBytes = sizeof ( aucFpage ) ; } /* Read the bytes */ if ( ! bReadBytes ( aucFpage , tBytes , ulSectPage , pFile ) ) { continue ; } NO_DBG_PRINT_BLOCK ( aucFpage , tBytes ) ; /* Process the bytes */ vGetDefaultSection ( & tSection ) ; vGet0SectionInfo ( aucFpage + 1 , tBytes - 1 , & tSection ) ; vAdd2SectionInfoList ( & tSection , ulCharPos ) ; } /* Clean up before you leave */ aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/prop0.c@vGet0StyleInfo": "static void vGet0StyleInfo ( int iFodo , const UCHAR * aucGrpprl , style_block_type * pStyle ) { int iBytes ; UCHAR ucTmp ; fail ( iFodo <= 0 || aucGrpprl == NULL || pStyle == NULL ) ; pStyle -> usIstdNext = ISTD_NORMAL ; iBytes = ( int ) ucGetByte ( iFodo , aucGrpprl ) ; if ( iBytes < 1 ) { return ; } /* stc if styled */ ucTmp = ucGetByte ( iFodo + 1 , aucGrpprl ) ; if ( ( ucTmp & BIT ( 0 ) ) != 0 ) { ucTmp >>= 1 ; if ( ucTmp >= 88 && ucTmp <= 94 ) { /* Header levels 1 through 7 */ pStyle -> usIstd = ucTmp - 87 ; pStyle -> ucNumLevel = 1 ; } } if ( iBytes < 2 ) { return ; } /* jc */ ucTmp = ucGetByte ( iFodo + 2 , aucGrpprl ) ; pStyle -> ucAlignment = ucTmp & 0x02 ; if ( iBytes < 3 ) { return ; } /* stc */ ucTmp = ucGetByte ( iFodo + 3 , aucGrpprl ) ; ucTmp &= 0x7f ; if ( ucTmp >= 88 && ucTmp <= 94 ) { /* Header levels 1 through 7 */ pStyle -> usIstd = ucTmp - 87 ; pStyle -> ucNumLevel = 1 ; } if ( iBytes < 6 ) { return ; } /* dxaRight */ pStyle -> sRightIndent = ( short ) usGetWord ( iFodo + 5 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> sRightIndent ) ; if ( iBytes < 8 ) { return ; } /* dxaLeft */ pStyle -> sLeftIndent = ( short ) usGetWord ( iFodo + 7 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> sLeftIndent ) ; if ( iBytes < 10 ) { return ; } /* dxaLeft1 */ pStyle -> sLeftIndent1 = ( short ) usGetWord ( iFodo + 9 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> sLeftIndent1 ) ; if ( iBytes < 14 ) { return ; } /* dyaBefore */ pStyle -> usBeforeIndent = usGetWord ( iFodo + 13 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> usBeforeIndent ) ; if ( iBytes < 16 ) { return ; } /* dyaAfter */ pStyle -> usAfterIndent = usGetWord ( iFodo + 15 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> usAfterIndent ) ; }",
    "resources/antiword/prop0.c@vGet0PapInfo": "void vGet0PapInfo ( FILE * pFile , const UCHAR * aucHeader ) { style_block_type tStyle ; ULONG ulBeginParfInfo , ulCharPos , ulCharPosNext ; int iIndex , iRun , iFodo ; UCHAR aucFpage [ 128 ] ; fail ( pFile == NULL || aucHeader == NULL ) ; ulBeginParfInfo = 128 * ( ULONG ) usGetWord ( 0x12 , aucHeader ) ; NO_DBG_HEX ( ulBeginParfInfo ) ; do { if ( ! bReadBytes ( aucFpage , 128 , ulBeginParfInfo , pFile ) ) { return ; } NO_DBG_PRINT_BLOCK ( aucFpage , 128 ) ; ulCharPosNext = ulGetLong ( 0 , aucFpage ) ; iRun = ( int ) ucGetByte ( 0x7f , aucFpage ) ; NO_DBG_DEC ( iRun ) ; for ( iIndex = 0 ; iIndex < iRun ; iIndex ++ ) { iFodo = ( int ) usGetWord ( 6 * iIndex + 8 , aucFpage ) ; if ( iFodo <= 0 || iFodo > 0x79 ) { DBG_DEC_C ( iFodo != ( int ) 0xffff , iFodo ) ; continue ; } vFillStyleFromStylesheet ( 0 , & tStyle ) ; vGet0StyleInfo ( iFodo , aucFpage + 4 , & tStyle ) ; ulCharPos = ulCharPosNext ; ulCharPosNext = ulGetLong ( 6 * iIndex + 4 , aucFpage ) ; tStyle . ulFileOffset = ulCharPos ; vAdd2StyleInfoList ( & tStyle ) ; } ulBeginParfInfo += 128 ; } while ( ulCharPosNext == ulBeginParfInfo ) ; }",
    "resources/antiword/prop0.c@vGet0FontInfo": "static void vGet0FontInfo ( int iFodo , const UCHAR * aucGrpprl , font_block_type * pFont ) { int iBytes ; UCHAR ucTmp ; fail ( iFodo <= 0 || aucGrpprl == NULL || pFont == NULL ) ; iBytes = ( int ) ucGetByte ( iFodo , aucGrpprl ) ; if ( iBytes < 2 ) { return ; } /* fBold, fItalic, cFtc */ ucTmp = ucGetByte ( iFodo + 2 , aucGrpprl ) ; if ( ( ucTmp & BIT ( 0 ) ) != 0 ) { pFont -> usFontStyle |= FONT_BOLD ; } if ( ( ucTmp & BIT ( 1 ) ) != 0 ) { pFont -> usFontStyle |= FONT_ITALIC ; } pFont -> ucFontNumber = ucTmp >> 2 ; NO_DBG_DEC ( pFont -> ucFontNumber ) ; if ( iBytes < 3 ) { return ; } /* cHps */ pFont -> usFontSize = ( USHORT ) ucGetByte ( iFodo + 3 , aucGrpprl ) ; NO_DBG_DEC ( pFont -> usFontSize ) ; if ( iBytes < 4 ) { return ; } /* cKul, fStrike, fCaps, fSmallCaps, fVanish */ ucTmp = ucGetByte ( iFodo + 4 , aucGrpprl ) ; if ( ( ucTmp & BIT ( 0 ) ) != 0 || ( ucTmp & BIT ( 2 ) ) != 0 ) { pFont -> usFontStyle |= FONT_UNDERLINE ; } if ( ( ucTmp & BIT ( 1 ) ) != 0 ) { pFont -> usFontStyle |= FONT_STRIKE ; } if ( ( ucTmp & BIT ( 4 ) ) != 0 ) { pFont -> usFontStyle |= FONT_CAPITALS ; } if ( ( ucTmp & BIT ( 5 ) ) != 0 ) { pFont -> usFontStyle |= FONT_SMALL_CAPITALS ; } if ( ( ucTmp & BIT ( 7 ) ) != 0 ) { pFont -> usFontStyle |= FONT_HIDDEN ; } DBG_HEX ( pFont -> usFontStyle ) ; if ( iBytes < 6 ) { return ; } /* cIss */ ucTmp = ucGetByte ( iFodo + 6 , aucGrpprl ) ; if ( ucTmp != 0 ) { if ( ucTmp < 128 ) { pFont -> usFontStyle |= FONT_SUPERSCRIPT ; DBG_MSG ( \"Superscript\" ) ; } else { pFont -> usFontStyle |= FONT_SUBSCRIPT ; DBG_MSG ( \"Subscript\" ) ; } } if ( iBytes < 7 ) { return ; } /* cIco */ ucTmp = ucGetByte ( iFodo + 7 , aucGrpprl ) ; switch ( ucTmp & 0x07 ) { case 0 : pFont -> ucFontColor = FONT_COLOR_BLACK ; break ; case 1 : pFont -> ucFontColor = FONT_COLOR_RED ; break ; case 2 : pFont -> ucFontColor = FONT_COLOR_GREEN ; break ; case 3 : pFont -> ucFontColor = FONT_COLOR_BLUE ; break ; case 4 : pFont -> ucFontColor = FONT_COLOR_CYAN ; break ; case 5 : pFont -> ucFontColor = FONT_COLOR_MAGENTA ; break ; case 6 : pFont -> ucFontColor = FONT_COLOR_YELLOW ; break ; case 7 : pFont -> ucFontColor = FONT_COLOR_WHITE ; break ; default : pFont -> ucFontColor = FONT_COLOR_BLACK ; break ; } NO_DBG_DEC ( pFont -> ucFontColor ) ; }",
    "resources/antiword/prop0.c@vGet0ChrInfo": "void vGet0ChrInfo ( FILE * pFile , const UCHAR * aucHeader ) { font_block_type tFont ; ULONG ulBeginCharInfo , ulCharPos , ulCharPosNext ; int iIndex , iRun , iFodo ; UCHAR aucFpage [ 128 ] ; fail ( pFile == NULL || aucHeader == NULL ) ; ulBeginCharInfo = ulGetLong ( 0x0e , aucHeader ) ; NO_DBG_HEX ( ulBeginCharInfo ) ; ulBeginCharInfo = ROUND128 ( ulBeginCharInfo ) ; NO_DBG_HEX ( ulBeginCharInfo ) ; do { if ( ! bReadBytes ( aucFpage , 128 , ulBeginCharInfo , pFile ) ) { return ; } NO_DBG_PRINT_BLOCK ( aucFpage , 128 ) ; ulCharPosNext = ulGetLong ( 0 , aucFpage ) ; iRun = ( int ) ucGetByte ( 0x7f , aucFpage ) ; NO_DBG_DEC ( iRun ) ; for ( iIndex = 0 ; iIndex < iRun ; iIndex ++ ) { iFodo = ( int ) usGetWord ( 6 * iIndex + 8 , aucFpage ) ; if ( iFodo <= 0 || iFodo > 0x79 ) { DBG_DEC_C ( iFodo != ( int ) 0xffff , iFodo ) ; continue ; } vFillFontFromStylesheet ( 0 , & tFont ) ; vGet0FontInfo ( iFodo , aucFpage + 4 , & tFont ) ; ulCharPos = ulCharPosNext ; ulCharPosNext = ulGetLong ( 6 * iIndex + 4 , aucFpage ) ; tFont . ulFileOffset = ulCharPos ; vAdd2FontInfoList ( & tFont ) ; } ulBeginCharInfo += 128 ; } while ( ulCharPosNext == ulBeginCharInfo ) ; }",
    "resources/antiword/finddata.c@bAddDataBlocks": "",
    "resources/antiword/finddata.c@bGet6DocumentData": "",
    "resources/antiword/datalist.c@vDestroyDataBlockList": "void vDestroyDataBlockList ( void ) { data_mem_type * pCurr , * pNext ; DBG_MSG ( \"vDestroyDataBlockList\" ) ; pCurr = pAnchor ; while ( pCurr != NULL ) { pNext = pCurr -> pNext ; pCurr = xfree ( pCurr ) ; pCurr = pNext ; } pAnchor = NULL ; /* Reset all the control variables */ pBlockLast = NULL ; pBlockCurrent = NULL ; ulBlockOffset = 0 ; tByteNext = 0 ; }",
    "resources/antiword/datalist.c@bAdd2DataBlockList": "",
    "resources/antiword/datalist.c@ulGetDataOffset": "ULONG ulGetDataOffset ( FILE * pFile ) { return pBlockCurrent -> tInfo . ulFileOffset + ulBlockOffset + tByteNext ; }",
    "resources/antiword/datalist.c@bSetDataOffset": "",
    "resources/antiword/datalist.c@iNextByte": "int iNextByte ( FILE * pFile ) { ULONG ulReadOff ; size_t tReadLen ; fail ( pBlockCurrent == NULL ) ; if ( tByteNext >= sizeof ( aucBlock ) || ulBlockOffset + tByteNext >= pBlockCurrent -> tInfo . ulLength ) { if ( ulBlockOffset + sizeof ( aucBlock ) < pBlockCurrent -> tInfo . ulLength ) { /* Same block, next part */ ulBlockOffset += sizeof ( aucBlock ) ; } else { /* Next block, first part */ pBlockCurrent = pBlockCurrent -> pNext ; ulBlockOffset = 0 ; } if ( pBlockCurrent == NULL ) { /* Past the last part of the last block */ errno = EIO ; return EOF ; } tReadLen = ( size_t ) ( pBlockCurrent -> tInfo . ulLength - ulBlockOffset ) ; if ( tReadLen > sizeof ( aucBlock ) ) { tReadLen = sizeof ( aucBlock ) ; } ulReadOff = pBlockCurrent -> tInfo . ulFileOffset + ulBlockOffset ; if ( ! bReadBytes ( aucBlock , tReadLen , ulReadOff , pFile ) ) { errno = EIO ; return EOF ; } tByteNext = 0 ; } return ( int ) aucBlock [ tByteNext ++ ] ; }",
    "resources/antiword/datalist.c@usNextWord": "USHORT usNextWord ( FILE * pFile ) { USHORT usLSB , usMSB ; usLSB = ( USHORT ) iNextByte ( pFile ) ; if ( usLSB == ( USHORT ) EOF ) { errno = EIO ; return ( USHORT ) EOF ; } usMSB = ( USHORT ) iNextByte ( pFile ) ; if ( usMSB == ( USHORT ) EOF ) { DBG_MSG ( \"usNextWord: Unexpected EOF\" ) ; errno = EIO ; return ( USHORT ) EOF ; } return ( usMSB << 8 ) | usLSB ; }",
    "resources/antiword/datalist.c@ulNextLong": "ULONG ulNextLong ( FILE * pFile ) { ULONG ulLSW , ulMSW ; ulLSW = ( ULONG ) usNextWord ( pFile ) ; if ( ulLSW == ( ULONG ) EOF ) { errno = EIO ; return ( ULONG ) EOF ; } ulMSW = ( ULONG ) usNextWord ( pFile ) ; if ( ulMSW == ( ULONG ) EOF ) { DBG_MSG ( \"ulNextLong: Unexpected EOF\" ) ; errno = EIO ; return ( ULONG ) EOF ; } return ( ulMSW << 16 ) | ulLSW ; }",
    "resources/antiword/datalist.c@usNextWordBE": "USHORT usNextWordBE ( FILE * pFile ) { USHORT usLSB , usMSB ; usMSB = ( USHORT ) iNextByte ( pFile ) ; if ( usMSB == ( USHORT ) EOF ) { errno = EIO ; return ( USHORT ) EOF ; } usLSB = ( USHORT ) iNextByte ( pFile ) ; if ( usLSB == ( USHORT ) EOF ) { DBG_MSG ( \"usNextWordBE: Unexpected EOF\" ) ; errno = EIO ; return ( USHORT ) EOF ; } return ( usMSB << 8 ) | usLSB ; }",
    "resources/antiword/datalist.c@ulNextLongBE": "ULONG ulNextLongBE ( FILE * pFile ) { ULONG ulLSW , ulMSW ; ulMSW = ( ULONG ) usNextWordBE ( pFile ) ; if ( ulMSW == ( ULONG ) EOF ) { errno = EIO ; return ( ULONG ) EOF ; } ulLSW = ( ULONG ) usNextWordBE ( pFile ) ; if ( ulLSW == ( ULONG ) EOF ) { DBG_MSG ( \"ulNextLongBE: Unexpected EOF\" ) ; errno = EIO ; return ( ULONG ) EOF ; } return ( ulMSW << 16 ) | ulLSW ; }",
    "resources/antiword/datalist.c@tSkipBytes": "size_t tSkipBytes ( FILE * pFile , size_t tToSkip ) { size_t tToGo , tMaxMove , tMove ; fail ( pFile == NULL ) ; fail ( pBlockCurrent == NULL ) ; tToGo = tToSkip ; while ( tToGo != 0 ) { /* Goto the end of the current block */ tMaxMove = min ( sizeof ( aucBlock ) - tByteNext , ( size_t ) ( pBlockCurrent -> tInfo . ulLength - ulBlockOffset - tByteNext ) ) ; tMove = min ( tMaxMove , tToGo ) ; tByteNext += tMove ; tToGo -= tMove ; if ( tToGo != 0 ) { /* Goto the next block */ if ( iNextByte ( pFile ) == EOF ) { return tToSkip - tToGo ; } tToGo -- ; } } return tToSkip ; }",
    "resources/antiword/datalist.c@ulDataPos2FileOffset": "ULONG ulDataPos2FileOffset ( ULONG ulDataPos ) { data_mem_type * pCurr ; fail ( ulDataPos == CP_INVALID ) ; for ( pCurr = pAnchor ; pCurr != NULL ; pCurr = pCurr -> pNext ) { if ( ulDataPos < pCurr -> tInfo . ulDataPos || ulDataPos >= pCurr -> tInfo . ulDataPos + pCurr -> tInfo . ulLength ) { /* The data offset is not in this block, try the next */ continue ; } /* The data offset is in the current block */ return pCurr -> tInfo . ulFileOffset + ulDataPos - pCurr -> tInfo . ulDataPos ; } /* Passed beyond the end of the list */ DBG_HEX_C ( ulDataPos != 0 , ulDataPos ) ; return FC_INVALID ; }",
    "resources/antiword/DOS-only/dos.c@iGetVersion": "static int iGetVersion ( void ) { union REGS uRegs ; memset ( & uRegs , 0 , sizeof ( uRegs ) ) ; uRegs . h . ah = 0x30 ; uRegs . h . al = 0x00 ; _doserrno = 0 ; intdos ( & uRegs , & uRegs ) ; if ( uRegs . x . cflag != 0 ) { DBG_DEC ( uRegs . x . cflag ) ; DBG_DEC ( _doserrno ) ; return - 1 ; } DBG_DEC ( uRegs . h . al ) ; DBG_DEC ( uRegs . h . ah ) ; return uRegs . h . al * 100 + uRegs . h . ah ; }",
    "resources/antiword/DOS-only/dos.c@iGetCodepage": "int iGetCodepage ( void ) { union REGS uRegs ; /* DOS function 0x66 first appeared in DOS 3.3 */ if ( iGetVersion ( ) < 330 ) { return 437 ; } memset ( & uRegs , 0 , sizeof ( uRegs ) ) ; uRegs . h . ah = 0x66 ; uRegs . h . al = 0x01 ; _doserrno = 0 ; intdos ( & uRegs , & uRegs ) ; if ( uRegs . x . cflag != 0 ) { DBG_DEC ( uRegs . x . cflag ) ; DBG_DEC ( _doserrno ) ; return 437 ; } DBG_DEC ( uRegs . x . bx ) ; DBG_DEC ( uRegs . x . dx ) ; return uRegs . x . bx ; }",
    "resources/antiword/DOS-only/getopt.c@getopt": "int getopt ( int argc , char * * argv , const char * optionS ) { char ch ; char * optP ; optarg = NULL ; if ( optind >= argc ) { letP = NULL ; return EOF ; } if ( letP == NULL ) { letP = argv [ optind ] ; if ( letP == NULL ) { return EOF ; } if ( * letP != '-' ) { letP = NULL ; return EOF ; } letP ++ ; if ( * letP == '-' ) { optind ++ ; letP = NULL ; return EOF ; } } ch = * ( letP ++ ) ; if ( '\\0' == ch ) { optind ++ ; letP = NULL ; return EOF ; } if ( ':' == ch || ( optP = strchr ( optionS , ch ) ) == NULL ) { if ( opterr ) { fprintf ( stderr , \"%s: illegal option -- %c\\n\" , argv [ 0 ] , ch ) ; } return '?' ; } if ( ':' != * ( ++ optP ) ) { /* Option without an argument */ if ( '\\0' == * letP ) { optind ++ ; letP = NULL ; } return ch ; } /* Option with an argument */ optind ++ ; if ( '\\0' == * letP ) { if ( argc <= optind ) { if ( opterr ) { fprintf ( stderr , \"%s: option requires an argument -- %c\\n\" , argv [ 0 ] , ch ) ; } return '?' ; } letP = argv [ optind ++ ] ; } optarg = letP ; letP = NULL ; return ch ; }",
    "resources/antiword/tabstop.c@vSet0DefaultTabWidth": "static void vSet0DefaultTabWidth ( const UCHAR * aucHeader ) { USHORT usTmp ; fail ( aucHeader == NULL ) ; usTmp = usGetWord ( 0x70 , aucHeader ) ; /* dxaTab */ DBG_DEC ( usTmp ) ; lDefaultTabWidth = usTmp == 0 ? HALF_INCH : lTwips2MilliPoints ( usTmp ) ; DBG_DEC ( lDefaultTabWidth ) ; }",
    "resources/antiword/tabstop.c@vSet2DefaultTabWidth": "static void vSet2DefaultTabWidth ( FILE * pFile , const UCHAR * aucHeader ) { UCHAR * aucBuffer ; ULONG ulBeginDocpInfo ; size_t tDocpInfoLen ; USHORT usTmp ; fail ( pFile == NULL || aucHeader == NULL ) ; ulBeginDocpInfo = ulGetLong ( 0x112 , aucHeader ) ; /* fcDop */ DBG_HEX ( ulBeginDocpInfo ) ; tDocpInfoLen = ( size_t ) usGetWord ( 0x116 , aucHeader ) ; /* cbDop */ DBG_DEC ( tDocpInfoLen ) ; if ( tDocpInfoLen < 12 ) { DBG_MSG ( \"No TAB information\" ) ; return ; } aucBuffer = xmalloc ( tDocpInfoLen ) ; if ( ! bReadBytes ( aucBuffer , tDocpInfoLen , ulBeginDocpInfo , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } usTmp = usGetWord ( 0x0a , aucBuffer ) ; /* dxaTab */ lDefaultTabWidth = usTmp == 0 ? HALF_INCH : lTwips2MilliPoints ( usTmp ) ; DBG_DEC ( lDefaultTabWidth ) ; aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/tabstop.c@vSet6DefaultTabWidth": "static void vSet6DefaultTabWidth ( FILE * pFile , ULONG ulStartBlock , const ULONG * aulBBD , size_t tBBDLen , const UCHAR * aucHeader ) { UCHAR * aucBuffer ; ULONG ulBeginDocpInfo ; size_t tDocpInfoLen ; USHORT usTmp ; ulBeginDocpInfo = ulGetLong ( 0x150 , aucHeader ) ; /* fcDop */ DBG_HEX ( ulBeginDocpInfo ) ; tDocpInfoLen = ( size_t ) ulGetLong ( 0x154 , aucHeader ) ; /* lcbDop */ DBG_DEC ( tDocpInfoLen ) ; if ( tDocpInfoLen < 12 ) { DBG_MSG ( \"No TAB information\" ) ; return ; } aucBuffer = xmalloc ( tDocpInfoLen ) ; if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucBuffer , ulBeginDocpInfo , tDocpInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } usTmp = usGetWord ( 0x0a , aucBuffer ) ; /* dxaTab */ lDefaultTabWidth = usTmp == 0 ? HALF_INCH : lTwips2MilliPoints ( usTmp ) ; DBG_DEC ( lDefaultTabWidth ) ; aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/tabstop.c@vSet8DefaultTabWidth": "static void vSet8DefaultTabWidth ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { const ULONG * aulBlockDepot ; UCHAR * aucBuffer ; ULONG ulBeginDocpInfo ; size_t tDocpInfoLen , tBlockDepotLen , tBlockSize ; USHORT usTmp ; ulBeginDocpInfo = ulGetLong ( 0x192 , aucHeader ) ; /* fcDop */ DBG_HEX ( ulBeginDocpInfo ) ; tDocpInfoLen = ( size_t ) ulGetLong ( 0x196 , aucHeader ) ; /* lcbDop */ DBG_DEC ( tDocpInfoLen ) ; if ( tDocpInfoLen < 12 ) { DBG_MSG ( \"No TAB information\" ) ; return ; } DBG_DEC ( pPPS -> tTable . ulSB ) ; DBG_HEX ( pPPS -> tTable . ulSize ) ; if ( pPPS -> tTable . ulSize == 0 ) { DBG_MSG ( \"No TAB information\" ) ; return ; } if ( pPPS -> tTable . ulSize < MIN_SIZE_FOR_BBD_USE ) { /* Use the Small Block Depot */ aulBlockDepot = aulSBD ; tBlockDepotLen = tSBDLen ; tBlockSize = SMALL_BLOCK_SIZE ; } else { /* Use the Big Block Depot */ aulBlockDepot = aulBBD ; tBlockDepotLen = tBBDLen ; tBlockSize = BIG_BLOCK_SIZE ; } aucBuffer = xmalloc ( tDocpInfoLen ) ; if ( ! bReadBuffer ( pFile , pPPS -> tTable . ulSB , aulBlockDepot , tBlockDepotLen , tBlockSize , aucBuffer , ulBeginDocpInfo , tDocpInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } usTmp = usGetWord ( 0x0a , aucBuffer ) ; /* dxaTab */ lDefaultTabWidth = usTmp == 0 ? HALF_INCH : lTwips2MilliPoints ( usTmp ) ; DBG_DEC ( lDefaultTabWidth ) ; aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/tabstop.c@vSetDefaultTabWidth": "void vSetDefaultTabWidth ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader , int iWordVersion ) { fail ( pFile == NULL && iWordVersion >= 1 ) ; fail ( pPPS == NULL && iWordVersion >= 6 ) ; fail ( aulBBD == NULL && tBBDLen != 0 ) ; fail ( aulSBD == NULL && tSBDLen != 0 ) ; fail ( aucHeader == NULL ) ; /* Reset to the default default value */ lDefaultTabWidth = HALF_INCH ; switch ( iWordVersion ) { case 0 : vSet0DefaultTabWidth ( aucHeader ) ; break ; case 1 : case 2 : vSet2DefaultTabWidth ( pFile , aucHeader ) ; break ; case 4 : case 5 : break ; case 6 : case 7 : vSet6DefaultTabWidth ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , aucHeader ) ; break ; case 8 : vSet8DefaultTabWidth ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; break ; default : werr ( 0 , \"Sorry, no TAB information\" ) ; break ; } }",
    "resources/antiword/doclist.c@vDestroyDocumentInfoList": "void vDestroyDocumentInfoList ( void ) { DBG_MSG ( \"vDestroyDocumentInfoList\" ) ; pAnchor = NULL ; }",
    "resources/antiword/doclist.c@vCreateDocumentInfoList": "void vCreateDocumentInfoList ( const document_block_type * pDocument ) { fail ( pDocument == NULL ) ; fail ( pAnchor != NULL ) ; tInfo = * pDocument ; pAnchor = & tInfo ; }",
    "resources/antiword/doclist.c@lGetDefaultTabWidth": "long lGetDefaultTabWidth ( void ) { long lDefaultTabWidth ; USHORT usTmp ; if ( pAnchor == NULL ) { DBG_FIXME ( ) ; return HALF_INCH ; } usTmp = pAnchor -> usDefaultTabWidth ; lDefaultTabWidth = usTmp == 0 ? HALF_INCH : lTwips2MilliPoints ( usTmp ) ; NO_DBG_DEC ( lDefaultTabWidth ) ; return lDefaultTabWidth ; }",
    "resources/antiword/doclist.c@ucGetDopHdrFtrSpecification": "UCHAR ucGetDopHdrFtrSpecification ( void ) { if ( pAnchor == NULL ) { DBG_FIXME ( ) ; return 0x00 ; } return pAnchor -> ucHdrFtrSpecification ; }",
    "resources/antiword/sectlist.c@vDestroySectionInfoList": "void vDestroySectionInfoList ( void ) { section_mem_type * pCurr , * pNext ; DBG_MSG ( \"vDestroySectionInfoList\" ) ; /* Free the Section Information List */ pCurr = pAnchor ; while ( pCurr != NULL ) { pNext = pCurr -> pNext ; pCurr = xfree ( pCurr ) ; pCurr = pNext ; } pAnchor = NULL ; /* Reset all control variables */ pSectionLast = NULL ; }",
    "resources/antiword/sectlist.c@vAdd2SectionInfoList": "void vAdd2SectionInfoList ( const section_block_type * pSection , ULONG ulCharPos ) { section_mem_type * pListMember ; fail ( pSection == NULL ) ; /* Create list member */ pListMember = xmalloc ( sizeof ( section_mem_type ) ) ; /* Fill the list member */ pListMember -> tInfo = * pSection ; pListMember -> ulCharPos = ulCharPos ; pListMember -> pNext = NULL ; /* Add the new member to the list */ if ( pAnchor == NULL ) { pAnchor = pListMember ; } else { fail ( pSectionLast == NULL ) ; pSectionLast -> pNext = pListMember ; } pSectionLast = pListMember ; }",
    "resources/antiword/sectlist.c@vGetDefaultSection": "void vGetDefaultSection ( section_block_type * pSection ) { ( void ) memset ( pSection , 0 , sizeof ( * pSection ) ) ; pSection -> bNewPage = TRUE ; }",
    "resources/antiword/sectlist.c@vDefault2SectionInfoList": "void vDefault2SectionInfoList ( ULONG ulCharPos ) { section_block_type tSection ; vGetDefaultSection ( & tSection ) ; vAdd2SectionInfoList ( & tSection , ulCharPos ) ; }",
    "resources/antiword/sectlist.c@pGetSectionInfo": "const section_block_type * pGetSectionInfo ( const section_block_type * pOld , ULONG ulCharPos ) { const section_mem_type * pCurr ; if ( pOld == NULL || ulCharPos == 0 ) { if ( pAnchor == NULL ) { /* There are no records, make one */ vDefault2SectionInfoList ( 0 ) ; fail ( pAnchor == NULL ) ; } /* The first record */ NO_DBG_MSG ( \"First record\" ) ; return & pAnchor -> tInfo ; } NO_DBG_HEX ( ulCharPos ) ; for ( pCurr = pAnchor ; pCurr != NULL ; pCurr = pCurr -> pNext ) { NO_DBG_HEX ( pCurr -> ulCharPos ) ; if ( ulCharPos == pCurr -> ulCharPos || ulCharPos + 1 == pCurr -> ulCharPos ) { NO_DBG_HEX ( pCurr -> ulCharPos ) ; return & pCurr -> tInfo ; } } return pOld ; }",
    "resources/antiword/sectlist.c@tGetNumberOfSections": "size_t tGetNumberOfSections ( void ) { const section_mem_type * pCurr ; size_t tCounter ; for ( tCounter = 0 , pCurr = pAnchor ; pCurr != NULL ; tCounter ++ , pCurr = pCurr -> pNext ) ; /* Empty */ return tCounter ; }",
    "resources/antiword/sectlist.c@ucGetSepHdrFtrSpecification": "UCHAR ucGetSepHdrFtrSpecification ( size_t tSectionNumber ) { const section_mem_type * pCurr ; size_t tIndex ; for ( tIndex = 0 , pCurr = pAnchor ; tIndex < tSectionNumber && pCurr != NULL ; tIndex ++ , pCurr = pCurr -> pNext ) ; /* Empty */ if ( pCurr == NULL ) { DBG_DEC ( tSectionNumber ) ; DBG_FIXME ( ) ; return 0x00 ; } return pCurr -> tInfo . ucHdrFtrSpecification ; }",
    "resources/antiword/propmod.c@vDestroyPropModList": "void vDestroyPropModList ( void ) { size_t tIndex ; DBG_MSG ( \"vDestroyPropModList\" ) ; /* Free all the elements of the list */ for ( tIndex = 0 ; tIndex < tNextFree ; tIndex ++ ) { ppAnchor [ tIndex ] = xfree ( ppAnchor [ tIndex ] ) ; } /* Free the list itself */ ppAnchor = xfree ( ppAnchor ) ; /* Reset all control variables */ tNextFree = 0 ; tMaxElements = 0 ; }",
    "resources/antiword/propmod.c@vAdd2PropModList": "void vAdd2PropModList ( const UCHAR * aucPropMod ) { size_t tSize , tLen ; fail ( aucPropMod == NULL ) ; NO_DBG_MSG ( \"vAdd2PropModList\" ) ; if ( tNextFree >= tMaxElements ) { tMaxElements += ELEMENTS_TO_ADD ; tSize = tMaxElements * sizeof ( UCHAR * * ) ; ppAnchor = xrealloc ( ppAnchor , tSize ) ; } NO_DBG_DEC ( tNextFree ) ; tLen = 2 + ( size_t ) usGetWord ( 0 , aucPropMod ) ; NO_DBG_HEX ( tLen ) ; NO_DBG_PRINT_BLOCK ( pucPropMod , tLen ) ; ppAnchor [ tNextFree ] = xmalloc ( tLen ) ; memcpy ( ppAnchor [ tNextFree ] , aucPropMod , tLen ) ; tNextFree ++ ; }",
    "resources/antiword/propmod.c@aucReadPropModListItem": "const UCHAR * aucReadPropModListItem ( USHORT usPropMod ) { static UCHAR aucBuffer [ 4 ] ; size_t tIndex ; if ( usPropMod == IGNORE_PROPMOD ) { /* This Properties Modifier must be ignored */ return NULL ; } if ( ! odd ( usPropMod ) ) { /* Variant 1: The information is in the input ifself */ aucBuffer [ 0 ] = 2 ; aucBuffer [ 1 ] = 0 ; aucBuffer [ 2 ] = ( UCHAR ) ( ( usPropMod & 0x00fe ) >> 1 ) ; aucBuffer [ 3 ] = ( UCHAR ) ( ( usPropMod & 0xff00 ) >> 8 ) ; return aucBuffer ; } if ( ppAnchor == NULL ) { /* No information available */ return NULL ; } /* Variant 2: The input contains an index */ tIndex = ( size_t ) ( usPropMod >> 1 ) ; if ( tIndex >= tNextFree ) { DBG_HEX ( usPropMod ) ; DBG_DEC ( tIndex ) ; DBG_DEC ( tNextFree ) ; return NULL ; } return ppAnchor [ tIndex ] ; }",
    "resources/antiword/fonts_r.c@pOpenFontTableFile": "FILE * pOpenFontTableFile ( void ) { FILE * pFileR , * pFileW ; char * szFontNamesFile ; size_t tSize ; BOOL bFailed ; char acBuffer [ 256 ] ; pFileR = fopen ( \"<AntiWord$FontNamesFile>\" , \"r\" ) ; if ( pFileR != NULL ) { /* The font table is already in the right directory */ return pFileR ; } szFontNamesFile = getenv ( \"AntiWord$FontNamesSave\" ) ; if ( szFontNamesFile == NULL ) { werr ( 0 , \"Warning: Name of the FontNames file not found\" ) ; return NULL ; } DBG_MSG ( szFontNamesFile ) ; pFileR = fopen ( \"<AntiWord$Dir>.Resources.Default\" , \"r\" ) ; if ( pFileR == NULL ) { werr ( 0 , \"I can't find 'Resources.Default'\" ) ; return NULL ; } /* Here the default font translation table is known to exist */ if ( ! bMakeDirectory ( szFontNamesFile ) ) { werr ( 0 , \"I can't make a directory for the FontNames file\" ) ; return NULL ; } /* Here the proper directory is known to exist */ pFileW = fopen ( szFontNamesFile , \"w\" ) ; if ( pFileW == NULL ) { ( void ) fclose ( pFileR ) ; werr ( 0 , \"I can't create a default FontNames file\" ) ; return NULL ; } /* Here the proper directory is known to be writeable */ /* Copy the default FontNames file */ bFailed = FALSE ; while ( ! feof ( pFileR ) ) { tSize = fread ( acBuffer , 1 , sizeof ( acBuffer ) , pFileR ) ; if ( ferror ( pFileR ) ) { DBG_MSG ( \"Read error\" ) ; bFailed = TRUE ; break ; } if ( fwrite ( acBuffer , 1 , tSize , pFileW ) != tSize ) { DBG_MSG ( \"Write error\" ) ; bFailed = TRUE ; break ; } } ( void ) fclose ( pFileW ) ; ( void ) fclose ( pFileR ) ; if ( bFailed ) { DBG_MSG ( \"Copying the FontNames file failed\" ) ; ( void ) remove ( szFontNamesFile ) ; return NULL ; } return fopen ( szFontNamesFile , \"r\" ) ; }",
    "resources/antiword/fonts_r.c@vCloseFont": "void vCloseFont ( void ) { os_error * e ; NO_DBG_MSG ( \"vCloseFont\" ) ; if ( tFontCurr == ( font_handle ) - 1 ) { return ; } e = Font_LoseFont ( tFontCurr ) ; if ( e != NULL ) { werr ( 0 , \"Close font error %d: %s\" , e -> errnum , e -> errmess ) ; } tFontCurr = ( font_handle ) - 1 ; }",
    "resources/antiword/fonts_r.c@tOpenFont": "drawfile_fontref tOpenFont ( UCHAR ucWordFontNumber , USHORT usFontStyle , USHORT usWordFontSize ) { os_error * e ; const char * szOurFontname ; font_handle tFont ; int iFontnumber ; NO_DBG_MSG ( \"tOpenFont\" ) ; NO_DBG_DEC ( ucWordFontNumber ) ; NO_DBG_HEX ( usFontStyle ) ; NO_DBG_DEC ( usWordFontSize ) ; /* Keep the relevant bits */ usFontStyle &= FONT_BOLD | FONT_ITALIC ; NO_DBG_HEX ( usFontStyle ) ; iFontnumber = iGetFontByNumber ( ucWordFontNumber , usFontStyle ) ; szOurFontname = szGetOurFontname ( iFontnumber ) ; if ( szOurFontname == NULL || szOurFontname [ 0 ] == '\\0' ) { tFontCurr = ( font_handle ) - 1 ; return ( byte ) 0 ; } NO_DBG_MSG ( szOurFontname ) ; e = Font_FindFont ( & tFont , ( char * ) szOurFontname , ( int ) usWordFontSize * 8 , ( int ) usWordFontSize * 8 , 0 , 0 ) ; if ( e != NULL ) { switch ( e -> errnum ) { case 523 : werr ( 0 , \"%s\" , e -> errmess ) ; break ; default : werr ( 0 , \"Open font error %d: %s\" , e -> errnum , e -> errmess ) ; break ; } tFontCurr = ( font_handle ) - 1 ; return ( drawfile_fontref ) 0 ; } tFontCurr = tFont ; NO_DBG_DEC ( tFontCurr ) ; return ( drawfile_fontref ) ( iFontnumber + 1 ) ; }",
    "resources/antiword/fonts_r.c@tOpenTableFont": "drawfile_fontref tOpenTableFont ( USHORT usWordFontSize ) { int iWordFontnumber ; NO_DBG_MSG ( \"tOpenTableFont\" ) ; iWordFontnumber = iFontname2Fontnumber ( TABLE_FONT , FONT_REGULAR ) ; if ( iWordFontnumber < 0 || iWordFontnumber > ( int ) UCHAR_MAX ) { DBG_DEC ( iWordFontnumber ) ; tFontCurr = ( font_handle ) - 1 ; return ( drawfile_fontref ) 0 ; } return tOpenFont ( ( UCHAR ) iWordFontnumber , FONT_REGULAR , usWordFontSize ) ; }",
    "resources/antiword/fonts_r.c@lComputeStringWidth": "long lComputeStringWidth ( const char * szString , size_t tStringLength , drawfile_fontref tFontRef , USHORT usFontSize ) { font_string tStr ; os_error * e ; fail ( szString == NULL ) ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; if ( szString [ 0 ] == '\\0' || tStringLength == 0 ) { /* Empty string */ return 0 ; } if ( tStringLength == 1 && szString [ 0 ] == TABLE_SEPARATOR ) { /* Font_strwidth doesn't like control characters */ return 0 ; } if ( tFontCurr == ( font_handle ) - 1 ) { /* No current font, use systemfont */ return lChar2MilliPoints ( tStringLength ) ; } tStr . s = ( char * ) szString ; tStr . x = INT_MAX ; tStr . y = INT_MAX ; tStr . split = - 1 ; tStr . term = tStringLength ; e = Font_StringWidth ( & tStr ) ; if ( e == NULL ) { return ( long ) tStr . x ; } DBG_DEC ( e -> errnum ) ; DBG_MSG ( e -> errmess ) ; DBG_DEC ( tStringLength ) ; DBG_MSG ( szString ) ; werr ( 0 , \"String width error %d: %s\" , e -> errnum , e -> errmess ) ; return lChar2MilliPoints ( tStringLength ) ; }",
    "resources/antiword/fonts_r.c@tCountColumns": "size_t tCountColumns ( const char * szString , size_t tLength ) { fail ( szString == NULL ) ; /* One byte, one character, one column */ return tLength ; }",
    "resources/antiword/fonts_r.c@tGetCharacterLength": "size_t tGetCharacterLength ( const char * szString ) { return 1 ; }",
    "resources/antiword/properties.c@vGetPropertyInfo": "void vGetPropertyInfo ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader , int iWordVersion ) { options_type tOptions ; TRACE_MSG ( \"vGetPropertyInfo\" ) ; fail ( pFile == NULL ) ; fail ( pPPS == NULL && iWordVersion >= 6 ) ; fail ( aulBBD == NULL && tBBDLen != 0 ) ; fail ( aulSBD == NULL && tSBDLen != 0 ) ; fail ( aucHeader == NULL ) ; /* Get the options */ vGetOptions ( & tOptions ) ; /* Get the property information per Word version */ switch ( iWordVersion ) { case 0 : vGet0DopInfo ( pFile , aucHeader ) ; vGet0SepInfo ( pFile , aucHeader ) ; vGet0PapInfo ( pFile , aucHeader ) ; if ( tOptions . eConversionType == conversion_draw || tOptions . eConversionType == conversion_ps || tOptions . eConversionType == conversion_xml || tOptions . eConversionType == conversion_fmt_text || tOptions . eConversionType == conversion_pdf ) { vGet0ChrInfo ( pFile , aucHeader ) ; } if ( tOptions . eConversionType == conversion_draw || tOptions . eConversionType == conversion_ps || tOptions . eConversionType == conversion_pdf ) { vCreate0FontTable ( ) ; } vSet0SummaryInfo ( pFile , aucHeader ) ; break ; case 1 : case 2 : vGet2Stylesheet ( pFile , iWordVersion , aucHeader ) ; vGet2DopInfo ( pFile , aucHeader ) ; vGet2SepInfo ( pFile , aucHeader ) ; vGet2PapInfo ( pFile , aucHeader ) ; if ( tOptions . eConversionType == conversion_ps || tOptions . eConversionType == conversion_pdf ) { vGet2HdrFtrInfo ( pFile , aucHeader ) ; } if ( tOptions . eConversionType == conversion_draw || tOptions . eConversionType == conversion_ps || tOptions . eConversionType == conversion_xml || tOptions . eConversionType == conversion_fmt_text || tOptions . eConversionType == conversion_pdf ) { vGet2ChrInfo ( pFile , iWordVersion , aucHeader ) ; } if ( tOptions . eConversionType == conversion_draw || tOptions . eConversionType == conversion_ps || tOptions . eConversionType == conversion_pdf ) { vCreate2FontTable ( pFile , iWordVersion , aucHeader ) ; } vSet2SummaryInfo ( pFile , iWordVersion , aucHeader ) ; break ; case 4 : case 5 : break ; case 6 : case 7 : vGet6Stylesheet ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , aucHeader ) ; vGet6DopInfo ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , aucHeader ) ; vGet6SepInfo ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , aucHeader ) ; vGet6PapInfo ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , aucHeader ) ; if ( tOptions . eConversionType == conversion_ps || tOptions . eConversionType == conversion_pdf ) { vGet6HdrFtrInfo ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , aucHeader ) ; } if ( tOptions . eConversionType == conversion_draw || tOptions . eConversionType == conversion_ps || tOptions . eConversionType == conversion_xml || tOptions . eConversionType == conversion_fmt_text || tOptions . eConversionType == conversion_pdf ) { vGet6ChrInfo ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , aucHeader ) ; } if ( tOptions . eConversionType == conversion_draw || tOptions . eConversionType == conversion_ps || tOptions . eConversionType == conversion_pdf ) { vCreate6FontTable ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , aucHeader ) ; } vSet6SummaryInfo ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; break ; case 8 : vGet8LstInfo ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; vGet8Stylesheet ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; vGet8DopInfo ( pFile , & pPPS -> tTable , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; vGet8SepInfo ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; vGet8PapInfo ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; if ( tOptions . eConversionType == conversion_ps || tOptions . eConversionType == conversion_pdf ) { vGet8HdrFtrInfo ( pFile , & pPPS -> tTable , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; } if ( tOptions . eConversionType == conversion_draw || tOptions . eConversionType == conversion_ps || tOptions . eConversionType == conversion_xml || tOptions . eConversionType == conversion_fmt_text || tOptions . eConversionType == conversion_pdf ) { vGet8ChrInfo ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; } if ( tOptions . eConversionType == conversion_draw || tOptions . eConversionType == conversion_ps || tOptions . eConversionType == conversion_pdf ) { vCreate8FontTable ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; } vSet8SummaryInfo ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen , aucHeader ) ; break ; default : DBG_DEC ( iWordVersion ) ; DBG_FIXME ( ) ; werr ( 0 , \"Sorry, no property information\" ) ; break ; } /* Temporarily: Correct the font table */ vCorrectFontTable ( tOptions . eConversionType , tOptions . eEncoding ) ; }",
    "resources/antiword/properties.c@ePropMod2RowInfo": "row_info_enum ePropMod2RowInfo ( USHORT usPropMod , int iWordVersion ) { row_block_type tRow ; const UCHAR * aucPropMod ; int iLen ; TRACE_MSG ( \"ePropMod2RowInfo\" ) ; aucPropMod = aucReadPropModListItem ( usPropMod ) ; if ( aucPropMod == NULL ) { return found_nothing ; } iLen = ( int ) usGetWord ( 0 , aucPropMod ) ; switch ( iWordVersion ) { case 0 : return found_nothing ; case 1 : case 2 : return eGet2RowInfo ( 0 , aucPropMod + 2 , iLen , & tRow ) ; case 4 : case 5 : return found_nothing ; case 6 : case 7 : return eGet6RowInfo ( 0 , aucPropMod + 2 , iLen , & tRow ) ; case 8 : return eGet8RowInfo ( 0 , aucPropMod + 2 , iLen , & tRow ) ; default : DBG_DEC ( iWordVersion ) ; DBG_FIXME ( ) ; return found_nothing ; } }",
    "resources/antiword/Win32-only/fonts_w.c@pOpenFontTableFile": "FILE * pOpenFontTableFile ( void ) { return NULL ; /* TBD .. new code , probably based on\n\t\tint EnumFontFamiliesEx(\n\t\t\tHDC hdc,                           // handle to device context\n\t\t\tLPLOGFONT lpLogfont,               // pointer to logical font information\n\t\t\tFONTENUMPROC lpEnumFontFamExProc,  // pointer to callback function\n\t\t\tLPARAM lParam,                     // application-supplied data\n\t\t\tDWORD dwFlags                      // reserved; must be zero\n\t\t\t);\n */ }",
    "resources/antiword/Win32-only/fonts_w.c@vCloseFont": "void vCloseFont ( void ) { }",
    "resources/antiword/Win32-only/fonts_w.c@tOpenFont": "draw_fontref tOpenFont ( int iWordFontNumber , unsigned char ucFontstyle , int iWordFontsize ) { /* No outline fonts, no postscript just plain text */ return ( draw_fontref ) 0 ; }",
    "resources/antiword/Win32-only/fonts_w.c@tOpenTableFont": "draw_fontref tOpenTableFont ( int iWordFontsize ) { /* No outline fonts, no postscript just plain text */ return ( draw_fontref ) 0 ; }",
    "resources/antiword/Win32-only/fonts_w.c@szGetFontname": "const char * szGetFontname ( draw_fontref tFontRef ) { return \"Dummy font name\" ; }",
    "resources/antiword/Win32-only/fonts_w.c@lComputeStringWidth": "long lComputeStringWidth ( char * szString , int iStringLength , draw_fontref tFontRef , int iFontsize ) { return iStringLength * 30 ; // enough to build only }",
    "resources/antiword/Win32-only/misc.c@szGetHomeDirectory": "const char * szGetHomeDirectory ( void ) { static char homedir [ 256 ] ; const char * szHome ; szHome = getenv ( \"HOME\" ) ; if ( szHome == NULL || szHome [ 0 ] == '\\0' ) { # if defined ( WIN32 ) ( void ) GetCurrentDirectory ( 255 , & homedir [ 0 ] ) ; szHome = & homedir [ 0 ] ; # else # if defined ( __dos ) szHome = \"C:\" ; # else werr ( 0 , \"I can't find the name of your HOME directory\" ) ; szHome = \"\" ; # endif /* __dos */ # endif // WIN32 } return szHome ; }",
    "resources/antiword/Win32-only/misc.c@lGetFilesize": "long lGetFilesize ( const char * szFilename ) { # if defined ( __riscos ) _kernel_swi_regs regs ; _kernel_oserror * e ; ( void ) memset ( & regs , 0 , sizeof ( regs ) ) ; regs . r [ 0 ] = 17 ; regs . r [ 1 ] = ( int ) szFilename ; e = _kernel_swi ( OS_File , & regs , & regs ) ; if ( e != NULL ) { werr ( 0 , \"Get Filesize error %d: %s\" , e -> errnum , e -> errmess ) ; return - 1 ; } if ( regs . r [ 0 ] != 1 ) { /* It's not a proper file or the file does not exist */ return - 1 ; } return ( long ) regs . r [ 4 ] ; # else struct stat tBuffer ; if ( stat ( szFilename , & tBuffer ) != 0 ) { werr ( 0 , \"Get Filesize error %d\" , errno ) ; return - 1 ; } if ( ! S_ISREG ( tBuffer . st_mode ) ) { /* It's not a regular file */ return - 1 ; } return ( long ) tBuffer . st_size ; # endif /* __riscos */ }",
    "resources/antiword/Win32-only/misc.c@bReadBytes": "BOOL bReadBytes ( unsigned char * aucBytes , size_t tMemb , long lOffset , FILE * pFile ) { fail ( aucBytes == NULL || pFile == NULL || lOffset < 0 ) ; if ( fseek ( pFile , lOffset , SEEK_SET ) != 0 ) { return FALSE ; } if ( fread ( aucBytes , sizeof ( unsigned char ) , tMemb , pFile ) != tMemb ) { return FALSE ; } return TRUE ; }",
    "resources/antiword/Win32-only/misc.c@bReadBuffer": "BOOL bReadBuffer ( FILE * pFile , long lStartBlock , const long * alBlockDepot , size_t tBlockDepotLen , size_t tBlockSize , unsigned char * aucBuffer , long lOffset , size_t tToRead ) { long lBegin , lIndex ; size_t tLen ; fail ( pFile == NULL ) ; fail ( lStartBlock < 0 ) ; fail ( alBlockDepot == NULL ) ; fail ( tBlockSize != BIG_BLOCK_SIZE && tBlockSize != SMALL_BLOCK_SIZE ) ; fail ( aucBuffer == NULL ) ; fail ( tToRead == 0 ) ; for ( lIndex = lStartBlock ; lIndex != END_OF_CHAIN && tToRead != 0 ; lIndex = alBlockDepot [ lIndex ] ) { if ( lIndex < 0 || lIndex >= ( long ) tBlockDepotLen ) { if ( tBlockSize >= BIG_BLOCK_SIZE ) { werr ( 1 , \"The Big Block Depot is corrupt\" ) ; } else { werr ( 1 , \"The Small Block Depot is corrupt\" ) ; } } if ( lOffset >= ( long ) tBlockSize ) { lOffset -= ( long ) tBlockSize ; continue ; } lBegin = lDepotOffset ( lIndex , tBlockSize ) + lOffset ; tLen = min ( tBlockSize - ( size_t ) lOffset , tToRead ) ; lOffset = 0 ; if ( ! bReadBytes ( aucBuffer , tLen , lBegin , pFile ) ) { werr ( 0 , \"Read big block %ld not possible\" , lBegin ) ; return FALSE ; } aucBuffer += tLen ; tToRead -= tLen ; } DBG_DEC_C ( tToRead != 0 , tToRead ) ; return tToRead == 0 ; }",
    "resources/antiword/Win32-only/misc.c@uiColor2Color": "unsigned int uiColor2Color ( int iWordColor ) { static const unsigned int auiColorTable [ ] = { /*  0 */ 0x00000000U , /* Automatic */ /*  1 */ 0x00000000U , /* Black */ /*  2 */ 0xff000000U , /* Blue */ /*  3 */ 0xffff0000U , /* Turquoise */ /*  4 */ 0x00ff0000U , /* Bright Green */ /*  5 */ 0xff00ff00U , /* Pink */ /*  6 */ 0x0000ff00U , /* Red */ /*  7 */ 0x00ffff00U , /* Yellow */ /*  8 */ 0xffffff00U , /* White */ /*  9 */ 0x80000000U , /* Dark Blue */ /* 10 */ 0x80800000U , /* Teal */ /* 11 */ 0x00800000U , /* Green */ /* 12 */ 0x80008000U , /* Violet */ /* 13 */ 0x00008000U , /* Dark Red */ /* 14 */ 0x00808000U , /* Dark Yellow */ /* 15 */ 0x80808000U , /* Gray 50% */ /* 16 */ 0xc0c0c000U , /* Gray 25% */ } ; if ( iWordColor < 0 || iWordColor >= ( int ) elementsof ( auiColorTable ) ) { return auiColorTable [ 0 ] ; } return auiColorTable [ iWordColor ] ; }",
    "resources/antiword/Win32-only/misc.c@iFindSplit": "static int iFindSplit ( const char * szString , int iStringLen ) { int iSplit ; iSplit = iStringLen - 1 ; while ( iSplit >= 1 ) { if ( szString [ iSplit ] == ' ' || ( szString [ iSplit ] == '-' && szString [ iSplit - 1 ] != ' ' ) ) { return iSplit ; } iSplit -- ; } return - 1 ; }",
    "resources/antiword/Win32-only/misc.c@pSplitList": "output_type * pSplitList ( output_type * pAnchor ) { output_type * pCurr , * pLeftOver ; int iIndex ; fail ( pAnchor == NULL ) ; for ( pCurr = pAnchor ; pCurr -> pNext != NULL ; pCurr = pCurr -> pNext ) ; /* EMPTY */ iIndex = - 1 ; for ( ; pCurr != NULL ; pCurr = pCurr -> pPrev ) { iIndex = iFindSplit ( pCurr -> szStorage , pCurr -> iNextFree ) ; if ( iIndex >= 0 ) { break ; } } if ( pCurr == NULL || iIndex < 0 ) { /* No split, no leftover */ return NULL ; } /* Split over the iIndex-th character */ NO_DBG_MSG ( \"pLeftOver\" ) ; pLeftOver = xmalloc ( sizeof ( * pLeftOver ) ) ; pLeftOver -> tStorageSize = ( size_t ) ( pCurr -> iNextFree - iIndex ) ; pLeftOver -> szStorage = xmalloc ( pLeftOver -> tStorageSize ) ; pLeftOver -> iNextFree = pCurr -> iNextFree - iIndex - 1 ; ( void ) strncpy ( pLeftOver -> szStorage , pCurr -> szStorage + iIndex + 1 , ( size_t ) pLeftOver -> iNextFree ) ; pLeftOver -> szStorage [ pLeftOver -> iNextFree ] = '\\0' ; NO_DBG_MSG ( pLeftOver -> szStorage ) ; pLeftOver -> iColor = pCurr -> iColor ; pLeftOver -> ucFontstyle = pCurr -> ucFontstyle ; pLeftOver -> tFontRef = pCurr -> tFontRef ; pLeftOver -> sFontsize = pCurr -> sFontsize ; pLeftOver -> lStringWidth = lComputeStringWidth ( pLeftOver -> szStorage , pLeftOver -> iNextFree , pLeftOver -> tFontRef , pLeftOver -> sFontsize ) ; pLeftOver -> pPrev = NULL ; pLeftOver -> pNext = pCurr -> pNext ; if ( pLeftOver -> pNext != NULL ) { pLeftOver -> pNext -> pPrev = pLeftOver ; } fail ( ! bCheckDoubleLinkedList ( pLeftOver ) ) ; NO_DBG_MSG ( \"pAnchor\" ) ; NO_DBG_HEX ( pCurr -> szStorage [ iIndex ] ) ; while ( iIndex >= 0 && isspace ( pCurr -> szStorage [ iIndex ] ) ) { iIndex -- ; } pCurr -> iNextFree = iIndex + 1 ; pCurr -> szStorage [ pCurr -> iNextFree ] = '\\0' ; NO_DBG_MSG ( pCurr -> szStorage ) ; pCurr -> lStringWidth = lComputeStringWidth ( pCurr -> szStorage , pCurr -> iNextFree , pCurr -> tFontRef , pCurr -> sFontsize ) ; pCurr -> pNext = NULL ; fail ( ! bCheckDoubleLinkedList ( pAnchor ) ) ; return pLeftOver ; }",
    "resources/antiword/Win32-only/misc.c@iInteger2Roman": "int iInteger2Roman ( int iNumber , BOOL bUpperCase , char * szOutput ) { char * outp , * p , * q ; int iNextVal , iValue ; fail ( szOutput == NULL ) ; if ( iNumber <= 0 || iNumber >= 4000 ) { szOutput [ 0 ] = '\\0' ; return 0 ; } outp = szOutput ; p = bUpperCase ? \"M\\2D\\5C\\2L\\5X\\2V\\5I\" : \"m\\2d\\5c\\2l\\5x\\2v\\5i\" ; iValue = 1000 ; for ( ; ; ) { while ( iNumber >= iValue ) { * outp ++ = * p ; iNumber -= iValue ; } if ( iNumber <= 0 ) { * outp = '\\0' ; return outp - szOutput ; } q = p + 1 ; iNextVal = iValue / ( int ) * q ; if ( ( int ) * q == 2 ) { /* magic */ iNextVal /= ( int ) * ( q += 2 ) ; } if ( iNumber + iNextVal >= iValue ) { * outp ++ = * ++ q ; iNumber += iNextVal ; } else { p ++ ; iValue /= ( int ) ( * p ++ ) ; } } }",
    "resources/antiword/Win32-only/misc.c@iInteger2Alpha": "int iInteger2Alpha ( int iNumber , BOOL bUpperCase , char * szOutput ) { char * outp ; int iTmp ; fail ( szOutput == NULL ) ; outp = szOutput ; iTmp = bUpperCase ? 'A' : 'a' ; if ( iNumber <= 26 ) { iNumber -= 1 ; * outp ++ = ( char ) ( iTmp + iNumber ) ; } else if ( iNumber <= 26 + 26 * 26 ) { iNumber -= 26 + 1 ; * outp ++ = ( char ) ( iTmp + iNumber / 26 ) ; * outp ++ = ( char ) ( iTmp + iNumber % 26 ) ; } else if ( iNumber <= 26 + 26 * 26 + 26 * 26 * 26 ) { iNumber -= 26 + 26 * 26 + 1 ; * outp ++ = ( char ) ( iTmp + iNumber / ( 26 * 26 ) ) ; * outp ++ = ( char ) ( iTmp + iNumber / 26 % 26 ) ; * outp ++ = ( char ) ( iTmp + iNumber % 26 ) ; } * outp = '\\0' ; return outp - szOutput ; }",
    "resources/antiword/Win32-only/misc.c@unincpy": "char * unincpy ( char * s1 , const char * s2 , size_t n ) { char * dest ; unsigned long ulChar ; size_t len ; unsigned short usUni ; for ( dest = s1 , len = 0 ; len < n ; dest ++ , len ++ ) { usUni = usGetWord ( len * 2 , s2 ) ; if ( usUni == 0 ) { break ; } ulChar = ulTranslateCharacters ( usUni , 0 , FALSE , FALSE ) ; if ( ulChar == IGNORE_CHARACTER ) { ulChar = ( unsigned long ) '?' ; } * dest = ( char ) ulChar ; } for ( ; len < n ; len ++ ) { * dest ++ = '\\0' ; } return s1 ; }",
    "resources/antiword/Win32-only/misc.c@unilen": "size_t unilen ( const char * s ) { size_t tLen ; unsigned short usUni ; tLen = 0 ; for ( ; ; ) { usUni = usGetWord ( tLen * 2 , s ) ; if ( usUni == 0 ) { return tLen ; } tLen += 2 ; } }",
    "resources/antiword/Win32-only/misc.c@szBasename": "const char * szBasename ( const char * szFilename ) { const char * szTmp ; fail ( szFilename == NULL ) ; if ( szFilename == NULL || szFilename [ 0 ] == '\\0' ) { return \"null\" ; } szTmp = strrchr ( szFilename , FILE_SEPARATOR [ 0 ] ) ; if ( szTmp == NULL ) { return szFilename ; } return ++ szTmp ; }",
    "resources/antiword/Win32-only/misc.c@iGetVersionNumber": "int iGetVersionNumber ( const unsigned char * aucHeader ) { unsigned short usFib , usChse ; usFib = usGetWord ( 0x02 , aucHeader ) ; DBG_DEC ( usFib ) ; if ( usFib < 101 ) { /* This file is from a version of Word older than Word 6 */ return - 1 ; } usChse = usGetWord ( 0x14 , aucHeader ) ; DBG_DEC ( usChse ) ; bWord6MacFile = FALSE ; switch ( usFib ) { case 101 : case 102 : DBG_MSG ( \"Word 6 for Windows\" ) ; return 6 ; case 103 : case 104 : switch ( usChse ) { case 0 : DBG_MSG ( \"Word 7 for Win95\" ) ; return 7 ; case 256 : DBG_MSG ( \"Word 6 for Macintosh\" ) ; bWord6MacFile = TRUE ; return 6 ; default : DBG_FIXME ( ) ; if ( ucGetByte ( 0x05 , aucHeader ) == 0xe0 ) { DBG_MSG ( \"Word 7 for Win95\" ) ; return 7 ; } DBG_MSG ( \"Word 6 for Macintosh\" ) ; bWord6MacFile = TRUE ; return 6 ; } default : DBG_MSG_C ( usChse != 256 , \"Word97 for Win95/98/NT\" ) ; DBG_MSG_C ( usChse == 256 , \"Word98 for Macintosh\" ) ; return 8 ; } }",
    "resources/antiword/Win32-only/misc.c@bIsWord6MacFile": "BOOL bIsWord6MacFile ( void ) { return bWord6MacFile ; }",
    "resources/antiword/Win32-only/misc.c@lComputeLeading": "long lComputeLeading ( int iFontsize ) { long lLeading ; lLeading = iFontsize * 500L ; if ( iFontsize < 18 ) { /* Small text: 112% */ lLeading *= 112 ; } else if ( iFontsize < 28 ) { /* Normal text: 124% */ lLeading *= 124 ; } else if ( iFontsize < 48 ) { /* Small headlines: 104% */ lLeading *= 104 ; } else { /* Large headlines: 100% */ lLeading *= 100 ; } lLeading = lMilliPoints2DrawUnits ( lLeading ) ; lLeading += 50 ; lLeading /= 100 ; return lLeading ; }",
    "resources/antiword/asc85enc.c@vOutputByte": "static void vOutputByte ( ULONG ulChar , FILE * pOutFile ) { if ( iOutBytes == 1 && cCharPrev == '%' && ulChar == ( ULONG ) '%' ) { if ( putc ( '\\n' , pOutFile ) != EOF ) { iOutBytes = 0 ; } } if ( putc ( ( int ) ulChar , pOutFile ) == EOF ) { return ; } iOutBytes ++ ; if ( iOutBytes > 63 ) { if ( putc ( '\\n' , pOutFile ) != EOF ) { iOutBytes = 0 ; } } cCharPrev = ( char ) ulChar ; }",
    "resources/antiword/asc85enc.c@vASCII85EncodeByte": "void vASCII85EncodeByte ( FILE * pOutFile , int iByte ) { static ULONG ulBuffer [ 4 ] = { 0 , 0 , 0 , 0 } ; static int iInBuffer = 0 ; ULONG ulValue , ulTmp ; int iIndex ; fail ( pOutFile == NULL ) ; fail ( iInBuffer < 0 ) ; fail ( iInBuffer > 3 ) ; if ( iByte == EOF ) { /* End Of File, time to clean up */ if ( iInBuffer > 0 && iInBuffer < 4 ) { /* Encode the remaining bytes */ ulValue = 0 ; for ( iIndex = iInBuffer - 1 ; iIndex >= 0 ; iIndex -- ) { ulValue |= ulBuffer [ iIndex ] << ( 8 * ( 3 - iIndex ) ) ; } for ( iIndex = 4 ; iIndex >= 4 - iInBuffer ; iIndex -- ) { ulTmp = ulValue / aulPower85 [ iIndex ] ; vOutputByte ( ulTmp + '!' , pOutFile ) ; ulValue -= ulTmp * aulPower85 [ iIndex ] ; } } /* Add the End Of Data marker */ ( void ) putc ( '~' , pOutFile ) ; ( void ) putc ( '>' , pOutFile ) ; ( void ) putc ( '\\n' , pOutFile ) ; /* Reset the control variables */ iInBuffer = 0 ; iOutBytes = 0 ; cCharPrev = '\\0' ; return ; } ulBuffer [ iInBuffer ] = ( ULONG ) iByte & 0xff ; iInBuffer ++ ; if ( iInBuffer >= 4 ) { ulValue = ( ulBuffer [ 0 ] << 24 ) | ( ulBuffer [ 1 ] << 16 ) | ( ulBuffer [ 2 ] << 8 ) | ulBuffer [ 3 ] ; if ( ulValue == 0 ) { vOutputByte ( ( ULONG ) 'z' , pOutFile ) ; /* Shortcut for 0 */ } else { for ( iIndex = 4 ; iIndex >= 0 ; iIndex -- ) { ulTmp = ulValue / aulPower85 [ iIndex ] ; vOutputByte ( ulTmp + '!' , pOutFile ) ; ulValue -= ulTmp * aulPower85 [ iIndex ] ; } } /* Reset the buffer */ iInBuffer = 0 ; } }",
    "resources/antiword/asc85enc.c@vASCII85EncodeArray": "void vASCII85EncodeArray ( FILE * pInFile , FILE * pOutFile , size_t tLength ) { size_t tCount ; int iByte ; fail ( pInFile == NULL ) ; fail ( pOutFile == NULL ) ; DBG_DEC ( tLength ) ; for ( tCount = 0 ; tCount < tLength ; tCount ++ ) { iByte = iNextByte ( pInFile ) ; if ( iByte == EOF ) { break ; } vASCII85EncodeByte ( pOutFile , iByte ) ; } }",
    "resources/antiword/asc85enc.c@vASCII85EncodeFile": "void vASCII85EncodeFile ( FILE * pInFile , FILE * pOutFile , size_t tLength ) { fail ( pInFile == NULL ) ; fail ( pOutFile == NULL ) ; fail ( tLength == 0 ) ; vASCII85EncodeArray ( pInFile , pOutFile , tLength ) ; vASCII85EncodeByte ( pOutFile , EOF ) ; }",
    "resources/antiword/stylesheet.c@vDestroyStylesheetList": "void vDestroyStylesheetList ( void ) { DBG_MSG ( \"vDestroyStylesheetList\" ) ; tStdCount = 0 ; atStyleInfo = xfree ( atStyleInfo ) ; atFontInfo = xfree ( atFontInfo ) ; abFilled = xfree ( abFilled ) ; }",
    "resources/antiword/stylesheet.c@vGetDefaultStyle": "static void vGetDefaultStyle ( style_block_type * pStyle ) { ( void ) memset ( pStyle , 0 , sizeof ( * pStyle ) ) ; pStyle -> usIstd = ISTD_INVALID ; pStyle -> usIstdNext = ISTD_INVALID ; pStyle -> usStartAt = 1 ; pStyle -> ucListLevel = 9 ; }",
    "resources/antiword/stylesheet.c@vGetDefaultFont": "static void vGetDefaultFont ( font_block_type * pFont , USHORT usDefaultFontNumber ) { ( void ) memset ( pFont , 0 , sizeof ( * pFont ) ) ; pFont -> usFontSize = DEFAULT_FONT_SIZE ; if ( usDefaultFontNumber <= ( USHORT ) UCHAR_MAX ) { pFont -> ucFontNumber = ( UCHAR ) usDefaultFontNumber ; } else { DBG_DEC ( usDefaultFontNumber ) ; DBG_FIXME ( ) ; pFont -> ucFontNumber = 0 ; } }",
    "resources/antiword/stylesheet.c@iGetStyleIndex": "static int iGetStyleIndex ( USHORT usIstd ) { int iIndex ; fail ( abFilled == NULL ) ; if ( usIstd == ISTD_INVALID || abFilled == NULL ) { return - 1 ; } for ( iIndex = 0 ; iIndex < ( int ) tStdCount ; iIndex ++ ) { if ( abFilled [ iIndex ] && atStyleInfo [ iIndex ] . usIstd == usIstd ) { /* The record is filled and the istd matches */ return iIndex ; } } return - 1 ; }",
    "resources/antiword/stylesheet.c@vGetBuildinStyle": "static void vGetBuildinStyle ( UCHAR ucStc , style_block_type * pStyle ) { fail ( pStyle == NULL ) ; /* Start with de defaults */ vGetDefaultStyle ( pStyle ) ; /* Add the build-in style info */ switch ( ucStc ) { case 246 : case 247 : case 248 : case 249 : case 250 : case 255 : pStyle -> sLeftIndent = 720 ; break ; case 251 : case 252 : pStyle -> sLeftIndent = 360 ; break ; case 253 : pStyle -> usBeforeIndent = 120 ; break ; case 254 : pStyle -> usBeforeIndent = 240 ; break ; default : if ( ucStc >= 233 && ucStc <= 239 ) { pStyle -> sLeftIndent = ( 239 - ( short ) ucStc ) * 360 ; } if ( ucStc >= 225 && ucStc <= 232 ) { pStyle -> sLeftIndent = ( 232 - ( short ) ucStc ) * 720 ; pStyle -> sRightIndent = 720 ; } break ; } }",
    "resources/antiword/stylesheet.c@vGetBuildinFont": "static void vGetBuildinFont ( UCHAR ucStc , font_block_type * pFont ) { fail ( pFont == NULL ) ; /* Start with de defaults */ vGetDefaultFont ( pFont , 0 ) ; /* Add the build-in fontstyle info */ switch ( ucStc ) { case 223 : case 244 : pFont -> usFontSize = 16 ; break ; case 246 : case 247 : case 248 : pFont -> usFontStyle |= FONT_ITALIC ; break ; case 249 : pFont -> usFontStyle |= FONT_UNDERLINE ; break ; case 250 : pFont -> usFontStyle |= FONT_BOLD ; break ; case 251 : pFont -> usFontStyle |= FONT_UNDERLINE ; pFont -> usFontSize = 24 ; break ; case 252 : pFont -> usFontStyle |= FONT_BOLD ; pFont -> usFontSize = 24 ; break ; case 253 : pFont -> ucFontNumber = 2 ; pFont -> usFontStyle |= FONT_BOLD ; pFont -> usFontSize = 24 ; break ; case 254 : pFont -> ucFontNumber = 2 ; pFont -> usFontStyle |= ( FONT_BOLD | FONT_UNDERLINE ) ; pFont -> usFontSize = 24 ; break ; default : break ; } }",
    "resources/antiword/stylesheet.c@usStc2istd": "USHORT usStc2istd ( UCHAR ucStc ) { /* Old nil style to new nil style */ if ( ucStc == 222 ) { return STI_NIL ; } /* Heading 1 through 9 must become istd 1 through 9 */ /* so 254 through 246 must become 1 through 9 and vice versa */ if ( ( ucStc >= 1 && ucStc <= 9 ) || ( ucStc >= 246 && ucStc <= 254 ) ) { return 255 - ( USHORT ) ucStc ; } return ( USHORT ) ucStc ; }",
    "resources/antiword/stylesheet.c@vGet2Stylesheet": "void vGet2Stylesheet ( FILE * pFile , int iWordVersion , const UCHAR * aucHeader ) { style_block_type * pStyle ; font_block_type * pFont ; UCHAR * aucBuffer ; ULONG ulBeginStshInfo ; size_t tStshInfoLen , tName , tChpx , tPapx , tMaxIndex ; int iStIndex , iChpxIndex , iPapxIndex , iSt , iChpx , iPapx ; int iStd , iIndex , iBaseStyleIndex , iCounter ; USHORT usBaseStyle ; UCHAR ucStc , ucStcNext , ucStcBase ; fail ( pFile == NULL || aucHeader == NULL ) ; fail ( iWordVersion != 1 && iWordVersion != 2 ) ; ulBeginStshInfo = ulGetLong ( 0x5e , aucHeader ) ; /* fcStshf */ NO_DBG_HEX ( ulBeginStshInfo ) ; tStshInfoLen = ( size_t ) usGetWord ( 0x62 , aucHeader ) ; /* cbStshf */ NO_DBG_DEC ( tStshInfoLen ) ; aucBuffer = xmalloc ( tStshInfoLen ) ; if ( ! bReadBytes ( aucBuffer , tStshInfoLen , ulBeginStshInfo , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tStshInfoLen ) ; fail ( 2 > tStshInfoLen ) ; iStd = ( int ) usGetWord ( 0 , aucBuffer ) ; fail ( 2 + 2 > tStshInfoLen ) ; tName = ( size_t ) usGetWord ( 2 , aucBuffer ) ; fail ( 2 + tName + 2 > tStshInfoLen ) ; tChpx = ( size_t ) usGetWord ( 2 + tName , aucBuffer ) ; fail ( 2 + tName + tChpx + 2 > tStshInfoLen ) ; tPapx = ( size_t ) usGetWord ( 2 + tName + tChpx , aucBuffer ) ; fail ( 2 + tName + tChpx + tPapx + 2 > tStshInfoLen ) ; tStdCount = ( size_t ) usGetWord ( 2 + tName + tChpx + tPapx , aucBuffer ) ; NO_DBG_HEX ( tStdCount ) ; atStyleInfo = xcalloc ( tStdCount , sizeof ( style_block_type ) ) ; atFontInfo = xcalloc ( tStdCount , sizeof ( font_block_type ) ) ; abFilled = xcalloc ( tStdCount , sizeof ( BOOL ) ) ; do { iCounter = 0 ; iStIndex = 2 + 2 ; iChpxIndex = 2 + ( int ) tName + 2 ; iPapxIndex = 2 + ( int ) tName + ( int ) tChpx + 2 ; tMaxIndex = 2 + tName + tChpx + tPapx + 2 ; /* Read the styles one-by-one */ for ( iIndex = 0 ; iIndex < ( int ) tStdCount ; iIndex ++ ) { pStyle = & atStyleInfo [ iIndex ] ; pFont = & atFontInfo [ iIndex ] ; iSt = ( int ) ucGetByte ( iStIndex , aucBuffer ) ; iChpx = ( int ) ucGetByte ( iChpxIndex , aucBuffer ) ; iPapx = ( int ) ucGetByte ( iPapxIndex , aucBuffer ) ; NO_DBG_HEX ( iSt ) ; NO_DBG_HEX ( iChpx ) ; NO_DBG_HEX ( iPapx ) ; if ( iSt == 0xff || tMaxIndex + 1 >= tStshInfoLen ) { /* Undefined style or no information */ iStIndex ++ ; iChpxIndex ++ ; iPapxIndex ++ ; tMaxIndex += 2 ; if ( ! abFilled [ iIndex ] ) { DBG_HEX_C ( iChpx != 0xff , iChpx ) ; DBG_HEX_C ( iPapx != 0xff , iPapx ) ; vGetDefaultStyle ( pStyle ) ; vGetDefaultFont ( pFont , 0 ) ; abFilled [ iIndex ] = TRUE ; } continue ; } NO_DBG_STRN ( aucBuffer + iStIndex + 1 , iSt ) ; iStIndex += iSt + 1 ; ucStcNext = ucGetByte ( tMaxIndex , aucBuffer ) ; ucStcBase = ucGetByte ( tMaxIndex + 1 , aucBuffer ) ; ucStc = ( UCHAR ) ( ( iIndex - iStd ) & 0xff ) ; NO_DBG_DEC ( ucStc ) ; if ( iChpx == 0xff || iPapx == 0xff ) { /* Use a build-in style */ iChpxIndex ++ ; iPapxIndex ++ ; tMaxIndex += 2 ; if ( ! abFilled [ iIndex ] ) { DBG_HEX_C ( iChpx != 0xff , iChpx ) ; DBG_HEX_C ( iPapx != 0xff , iPapx ) ; vGetBuildinStyle ( ucStc , pStyle ) ; pStyle -> usIstd = usStc2istd ( ucStc ) ; pStyle -> usIstdNext = usStc2istd ( ucStcNext ) ; vGetBuildinFont ( ucStc , pFont ) ; abFilled [ iIndex ] = TRUE ; } continue ; } if ( abFilled [ iIndex ] ) { /* This record has already been filled */ iChpxIndex += iChpx + 1 ; iPapxIndex += iPapx + 1 ; tMaxIndex += 2 ; continue ; } usBaseStyle = usStc2istd ( ucStcBase ) ; if ( usBaseStyle == STI_NIL ) { /* Based on the Nil style */ vGetDefaultStyle ( pStyle ) ; vGetDefaultFont ( pFont , 0 ) ; } else { iBaseStyleIndex = iGetStyleIndex ( usBaseStyle ) ; NO_DBG_DEC ( iBaseStyleIndex ) ; if ( iBaseStyleIndex < 0 ) { /* This style is not known yet */ iChpxIndex += iChpx + 1 ; iPapxIndex += iPapx + 1 ; tMaxIndex += 2 ; continue ; } fail ( iBaseStyleIndex >= ( int ) tStdCount ) ; fail ( ! abFilled [ iBaseStyleIndex ] ) ; /* Based on the specified base style */ * pStyle = atStyleInfo [ iBaseStyleIndex ] ; * pFont = atFontInfo [ iBaseStyleIndex ] ; } pStyle -> usIstd = usStc2istd ( ucStc ) ; pStyle -> usIstdNext = usStc2istd ( ucStcNext ) ; abFilled [ iIndex ] = TRUE ; iCounter ++ ; /* Add the changes if any */ switch ( iChpx ) { case 0x00 : case 0xff : iChpxIndex ++ ; break ; default : NO_DBG_PRINT_BLOCK ( aucBuffer + iChpxIndex + 1 , iChpx ) ; if ( iWordVersion == 1 ) { vGet1FontInfo ( 0 , aucBuffer + iChpxIndex + 1 , ( size_t ) iChpx , pFont ) ; } else { vGet2FontInfo ( 0 , aucBuffer + iChpxIndex + 1 , ( size_t ) iChpx , pFont ) ; } iChpxIndex += iChpx + 1 ; break ; } switch ( iPapx ) { case 0x00 : case 0xff : iPapxIndex ++ ; break ; default : NO_DBG_PRINT_BLOCK ( aucBuffer + iPapxIndex + 8 , iPapx - 7 ) ; vGet2StyleInfo ( 0 , aucBuffer + iPapxIndex + 8 , iPapx - 7 , pStyle ) ; iPapxIndex += iPapx + 1 ; break ; } tMaxIndex += 2 ; } NO_DBG_DEC ( iCounter ) ; } while ( iCounter > 0 ) ; /* Fill records that are still empty */ for ( iIndex = 0 ; iIndex < ( int ) tStdCount ; iIndex ++ ) { if ( ! abFilled [ iIndex ] ) { NO_DBG_DEC ( iIndex ) ; vGetDefaultStyle ( & atStyleInfo [ iIndex ] ) ; vGetDefaultFont ( & atFontInfo [ iIndex ] , 0 ) ; } } /* Clean up before you leave */ abFilled = xfree ( abFilled ) ; aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/stylesheet.c@vGet6Stylesheet": "void vGet6Stylesheet ( FILE * pFile , ULONG ulStartBlock , const ULONG * aulBBD , size_t tBBDLen , const UCHAR * aucHeader ) { style_block_type * pStyle ; font_block_type * pFont ; UCHAR * aucBuffer ; ULONG ulBeginStshInfo ; size_t tStshInfoLen , tOffset , tStdLen , tStdBaseInFile ; size_t tPos , tNameLen , tUpxLen ; int iIndex , iBaseStyleIndex , iCounter ; USHORT usTmp , usUpxCount , usStyleType , usBaseStyle ; USHORT usFtcStandardChpStsh ; fail ( pFile == NULL || aucHeader == NULL ) ; fail ( ulStartBlock > MAX_BLOCKNUMBER && ulStartBlock != END_OF_CHAIN ) ; fail ( aulBBD == NULL ) ; ulBeginStshInfo = ulGetLong ( 0x60 , aucHeader ) ; /* fcStshf */ NO_DBG_HEX ( ulBeginStshInfo ) ; tStshInfoLen = ( size_t ) ulGetLong ( 0x64 , aucHeader ) ; /* lcbStshf */ NO_DBG_DEC ( tStshInfoLen ) ; aucBuffer = xmalloc ( tStshInfoLen ) ; if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucBuffer , ulBeginStshInfo , tStshInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tStshInfoLen ) ; tStdCount = ( size_t ) usGetWord ( 2 , aucBuffer ) ; NO_DBG_DEC ( tStdCount ) ; tStdBaseInFile = ( size_t ) usGetWord ( 4 , aucBuffer ) ; usFtcStandardChpStsh = usGetWord ( 14 , aucBuffer ) ; NO_DBG_DEC ( usFtcStandardChpStsh ) ; atStyleInfo = xcalloc ( tStdCount , sizeof ( style_block_type ) ) ; atFontInfo = xcalloc ( tStdCount , sizeof ( font_block_type ) ) ; abFilled = xcalloc ( tStdCount , sizeof ( BOOL ) ) ; do { iCounter = 0 ; /* Read the styles one-by-one */ for ( iIndex = 0 , tOffset = 2 + ( size_t ) usGetWord ( 0 , aucBuffer ) ; iIndex < ( int ) tStdCount ; iIndex ++ , tOffset += 2 + tStdLen ) { NO_DBG_DEC ( tOffset ) ; tStdLen = ( size_t ) usGetWord ( tOffset , aucBuffer ) ; NO_DBG_DEC ( tStdLen ) ; if ( abFilled [ iIndex ] ) { /* This record has already been filled */ continue ; } pStyle = & atStyleInfo [ iIndex ] ; pFont = & atFontInfo [ iIndex ] ; if ( tStdLen == 0 ) { /* Empty record */ vGetDefaultStyle ( pStyle ) ; vGetDefaultFont ( pFont , usFtcStandardChpStsh ) ; abFilled [ iIndex ] = TRUE ; continue ; } usTmp = usGetWord ( tOffset + 4 , aucBuffer ) ; usStyleType = usTmp % 16 ; usBaseStyle = usTmp / 16 ; NO_DBG_DEC ( usStyleType ) ; NO_DBG_DEC ( usBaseStyle ) ; if ( usBaseStyle == STI_NIL || usBaseStyle == STI_USER ) { /* Based on the Nil style */ vGetDefaultStyle ( pStyle ) ; vGetDefaultFont ( pFont , usFtcStandardChpStsh ) ; } else { iBaseStyleIndex = iGetStyleIndex ( usBaseStyle ) ; NO_DBG_DEC ( iBaseStyleIndex ) ; if ( iBaseStyleIndex < 0 ) { /* This base style is not known yet */ continue ; } fail ( iBaseStyleIndex >= ( int ) tStdCount ) ; fail ( ! abFilled [ iBaseStyleIndex ] ) ; /* Based on the specified base style */ * pStyle = atStyleInfo [ iBaseStyleIndex ] ; pStyle -> usIstd = ISTD_INVALID ; * pFont = atFontInfo [ iBaseStyleIndex ] ; } abFilled [ iIndex ] = TRUE ; iCounter ++ ; /* STD */ usTmp = usGetWord ( tOffset + 6 , aucBuffer ) ; usUpxCount = usTmp % 16 ; pStyle -> usIstdNext = usTmp / 16 ; ; NO_DBG_DEC ( usUpxCount ) ; tPos = 2 + tStdBaseInFile ; NO_DBG_DEC ( tPos ) ; tNameLen = ( size_t ) ucGetByte ( tOffset + tPos , aucBuffer ) ; NO_DBG_DEC ( tNameLen ) ; NO_DBG_STRN ( aucBuffer + tOffset + tPos + 1 , tNameLen ) ; tNameLen ++ ; /* Include the ASCII NULL character */ tPos += 1 + tNameLen ; if ( odd ( tPos ) ) { tPos ++ ; } NO_DBG_DEC ( tPos ) ; if ( tPos >= tStdLen ) { continue ; } tUpxLen = ( size_t ) usGetWord ( tOffset + tPos , aucBuffer ) ; NO_DBG_DEC ( tUpxLen ) ; if ( tPos + tUpxLen > tStdLen ) { /* UPX length too large to be a record */ DBG_DEC_C ( tPos + tUpxLen > tStdLen , tPos + tUpxLen ) ; continue ; } if ( usStyleType == SGC_PAP && usUpxCount >= 1 ) { if ( tUpxLen >= 2 ) { NO_DBG_PRINT_BLOCK ( aucBuffer + tOffset + tPos + 2 , tUpxLen ) ; pStyle -> usIstd = usGetWord ( tOffset + tPos + 2 , aucBuffer ) ; NO_DBG_DEC ( pStyle -> usIstd ) ; NO_DBG_DEC ( pStyle -> usIstdNext ) ; vGet6StyleInfo ( 0 , aucBuffer + tOffset + tPos + 4 , tUpxLen - 2 , pStyle ) ; NO_DBG_DEC ( pStyle -> sLeftIndent ) ; NO_DBG_DEC ( pStyle -> sRightIndent ) ; NO_DBG_HEX ( pStyle -> ucAlignment ) ; } tPos += 2 + tUpxLen ; if ( odd ( tPos ) ) { tPos ++ ; } NO_DBG_DEC ( tPos ) ; tUpxLen = ( size_t ) usGetWord ( tOffset + tPos , aucBuffer ) ; NO_DBG_DEC ( tUpxLen ) ; } if ( tUpxLen == 0 || tPos + tUpxLen > tStdLen ) { /* Too small or too large to be a record */ DBG_DEC_C ( tPos + tUpxLen > tStdLen , tPos + tUpxLen ) ; continue ; } if ( ( usStyleType == SGC_PAP && usUpxCount >= 2 ) || ( usStyleType == SGC_CHP && usUpxCount >= 1 ) ) { NO_DBG_PRINT_BLOCK ( aucBuffer + tOffset + tPos + 2 , tUpxLen ) ; vGet6FontInfo ( 0 , ISTD_INVALID , aucBuffer + tOffset + tPos + 2 , ( int ) tUpxLen , pFont ) ; NO_DBG_DEC ( pFont -> usFontSize ) ; NO_DBG_DEC ( pFont -> ucFontcolor ) ; NO_DBG_HEX ( pFont -> usFontStyle ) ; } } NO_DBG_DEC ( iCounter ) ; } while ( iCounter > 0 ) ; /* Fill records that are still empty */ for ( iIndex = 0 ; iIndex < ( int ) tStdCount ; iIndex ++ ) { if ( ! abFilled [ iIndex ] ) { NO_DBG_DEC ( iIndex ) ; vGetDefaultStyle ( & atStyleInfo [ iIndex ] ) ; vGetDefaultFont ( & atFontInfo [ iIndex ] , usFtcStandardChpStsh ) ; } } /* Clean up before you leave */ abFilled = xfree ( abFilled ) ; aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/stylesheet.c@vGet8Stylesheet": "void vGet8Stylesheet ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { style_block_type * pStyle ; font_block_type * pFont ; const ULONG * aulBlockDepot ; UCHAR * aucBuffer ; ULONG ulBeginStshInfo ; size_t tStshInfoLen , tBlockDepotLen , tOffset , tStdLen , tStdBaseInFile ; size_t tBlockSize , tPos , tNameLen , tUpxLen ; int iIndex , iBaseStyleIndex , iCounter ; USHORT usTmp , usUpxCount , usStyleType , usBaseStyle ; USHORT usFtcStandardChpStsh ; fail ( pFile == NULL || pPPS == NULL || aucHeader == NULL ) ; fail ( aulBBD == NULL || aulSBD == NULL ) ; ulBeginStshInfo = ulGetLong ( 0xa2 , aucHeader ) ; /* fcStshf */ NO_DBG_HEX ( ulBeginStshInfo ) ; tStshInfoLen = ( size_t ) ulGetLong ( 0xa6 , aucHeader ) ; /* lcbStshf */ NO_DBG_DEC ( tStshInfoLen ) ; NO_DBG_DEC ( pPPS -> tTable . ulSB ) ; NO_DBG_HEX ( pPPS -> tTable . ulSize ) ; if ( pPPS -> tTable . ulSize == 0 ) { DBG_MSG ( \"No stylesheet information\" ) ; return ; } if ( pPPS -> tTable . ulSize < MIN_SIZE_FOR_BBD_USE ) { /* Use the Small Block Depot */ aulBlockDepot = aulSBD ; tBlockDepotLen = tSBDLen ; tBlockSize = SMALL_BLOCK_SIZE ; } else { /* Use the Big Block Depot */ aulBlockDepot = aulBBD ; tBlockDepotLen = tBBDLen ; tBlockSize = BIG_BLOCK_SIZE ; } aucBuffer = xmalloc ( tStshInfoLen ) ; if ( ! bReadBuffer ( pFile , pPPS -> tTable . ulSB , aulBlockDepot , tBlockDepotLen , tBlockSize , aucBuffer , ulBeginStshInfo , tStshInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tStshInfoLen ) ; tStdCount = ( size_t ) usGetWord ( 2 , aucBuffer ) ; NO_DBG_DEC ( tStdCount ) ; tStdBaseInFile = ( size_t ) usGetWord ( 4 , aucBuffer ) ; usFtcStandardChpStsh = usGetWord ( 14 , aucBuffer ) ; NO_DBG_DEC ( usFtcStandardChpStsh ) ; atStyleInfo = xcalloc ( tStdCount , sizeof ( style_block_type ) ) ; atFontInfo = xcalloc ( tStdCount , sizeof ( font_block_type ) ) ; abFilled = xcalloc ( tStdCount , sizeof ( BOOL ) ) ; do { iCounter = 0 ; /* Read the styles one-by-one */ for ( iIndex = 0 , tOffset = 2 + ( size_t ) usGetWord ( 0 , aucBuffer ) ; iIndex < ( int ) tStdCount ; iIndex ++ , tOffset += 2 + tStdLen ) { NO_DBG_DEC ( tOffset ) ; tStdLen = ( size_t ) usGetWord ( tOffset , aucBuffer ) ; NO_DBG_DEC ( tStdLen ) ; if ( abFilled [ iIndex ] ) { /* This record has already been filled */ continue ; } pStyle = & atStyleInfo [ iIndex ] ; pFont = & atFontInfo [ iIndex ] ; if ( tStdLen == 0 ) { /* Empty record */ vGetDefaultStyle ( pStyle ) ; vGetDefaultFont ( pFont , usFtcStandardChpStsh ) ; abFilled [ iIndex ] = TRUE ; continue ; } usTmp = usGetWord ( tOffset + 4 , aucBuffer ) ; usStyleType = usTmp % 16 ; usBaseStyle = usTmp / 16 ; NO_DBG_DEC ( usStyleType ) ; NO_DBG_DEC ( usBaseStyle ) ; if ( usBaseStyle == STI_NIL || usBaseStyle == STI_USER ) { /* Based on the Nil style */ vGetDefaultStyle ( pStyle ) ; vGetDefaultFont ( pFont , usFtcStandardChpStsh ) ; } else { iBaseStyleIndex = iGetStyleIndex ( usBaseStyle ) ; NO_DBG_DEC ( iBaseStyleIndex ) ; if ( iBaseStyleIndex < 0 ) { /* This base style is not known yet */ continue ; } fail ( iBaseStyleIndex >= ( int ) tStdCount ) ; fail ( ! abFilled [ iBaseStyleIndex ] ) ; /* Based on the specified base style */ * pStyle = atStyleInfo [ iBaseStyleIndex ] ; pStyle -> usIstd = ISTD_INVALID ; * pFont = atFontInfo [ iBaseStyleIndex ] ; } abFilled [ iIndex ] = TRUE ; iCounter ++ ; /* STD */ usTmp = usGetWord ( tOffset + 6 , aucBuffer ) ; usUpxCount = usTmp % 16 ; pStyle -> usIstdNext = usTmp / 16 ; NO_DBG_DEC ( usUpxCount ) ; tPos = 2 + tStdBaseInFile ; NO_DBG_DEC ( tPos ) ; tNameLen = ( size_t ) usGetWord ( tOffset + tPos , aucBuffer ) ; NO_DBG_DEC ( tNameLen ) ; tNameLen *= 2 ; /* From Unicode characters to bytes */ NO_DBG_UNICODE_N ( aucBuffer + tOffset + tPos + 2 , tNameLen ) ; tNameLen += 2 ; /* Include the Unicode NULL character */ tPos += 2 + tNameLen ; if ( odd ( tPos ) ) { tPos ++ ; } NO_DBG_DEC ( tPos ) ; if ( tPos >= tStdLen ) { continue ; } tUpxLen = ( size_t ) usGetWord ( tOffset + tPos , aucBuffer ) ; NO_DBG_DEC ( tUpxLen ) ; if ( tPos + tUpxLen > tStdLen ) { /* UPX length too large to be a record */ DBG_DEC_C ( tPos + tUpxLen > tStdLen , tPos + tUpxLen ) ; continue ; } if ( usStyleType == SGC_PAP && usUpxCount >= 1 ) { if ( tUpxLen >= 2 ) { NO_DBG_PRINT_BLOCK ( aucBuffer + tOffset + tPos + 2 , tUpxLen ) ; pStyle -> usIstd = usGetWord ( tOffset + tPos + 2 , aucBuffer ) ; NO_DBG_DEC ( pStyle -> usIstd ) ; NO_DBG_DEC ( pStyle -> usIstdNext ) ; vGet8StyleInfo ( 0 , aucBuffer + tOffset + tPos + 4 , tUpxLen - 2 , pStyle ) ; NO_DBG_DEC ( pStyle -> sLeftIndent ) ; NO_DBG_DEC ( pStyle -> sRightIndent ) ; NO_DBG_HEX ( pStyle -> ucAlignment ) ; } tPos += 2 + tUpxLen ; if ( odd ( tPos ) ) { tPos ++ ; } NO_DBG_DEC ( tPos ) ; tUpxLen = ( size_t ) usGetWord ( tOffset + tPos , aucBuffer ) ; NO_DBG_DEC ( tUpxLen ) ; } if ( tUpxLen == 0 || tPos + tUpxLen > tStdLen ) { /* Too small or too large to be a record */ DBG_DEC_C ( tPos + tUpxLen > tStdLen , tPos + tUpxLen ) ; continue ; } if ( ( usStyleType == SGC_PAP && usUpxCount >= 2 ) || ( usStyleType == SGC_CHP && usUpxCount >= 1 ) ) { NO_DBG_PRINT_BLOCK ( aucBuffer + tOffset + tPos + 2 , tUpxLen ) ; vGet8FontInfo ( 0 , ISTD_INVALID , aucBuffer + tOffset + tPos + 2 , ( int ) tUpxLen , pFont ) ; NO_DBG_DEC ( pFont -> usFontSize ) ; NO_DBG_DEC ( pFont -> ucFontcolor ) ; NO_DBG_HEX ( pFont -> usFontStyle ) ; } } NO_DBG_DEC ( iCounter ) ; } while ( iCounter > 0 ) ; /* Fill records that are still empty */ for ( iIndex = 0 ; iIndex < ( int ) tStdCount ; iIndex ++ ) { if ( ! abFilled [ iIndex ] ) { NO_DBG_DEC ( iIndex ) ; vGetDefaultStyle ( & atStyleInfo [ iIndex ] ) ; vGetDefaultFont ( & atFontInfo [ iIndex ] , usFtcStandardChpStsh ) ; } } /* Clean up before you leave */ abFilled = xfree ( abFilled ) ; aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/stylesheet.c@vFillStyleFromStylesheet": "void vFillStyleFromStylesheet ( USHORT usIstd , style_block_type * pStyle ) { int iIndex ; fail ( pStyle == NULL ) ; if ( usIstd != ISTD_INVALID && usIstd != STI_NIL && usIstd != STI_USER ) { for ( iIndex = 0 ; iIndex < ( int ) tStdCount ; iIndex ++ ) { if ( atStyleInfo [ iIndex ] . usIstd == usIstd ) { /* Right index found; return style */ * pStyle = atStyleInfo [ iIndex ] ; return ; } } } vGetDefaultStyle ( pStyle ) ; pStyle -> usIstd = usIstd ; }",
    "resources/antiword/stylesheet.c@vFillFontFromStylesheet": "void vFillFontFromStylesheet ( USHORT usIstd , font_block_type * pFont ) { int iIndex ; fail ( pFont == NULL ) ; if ( usIstd != ISTD_INVALID && usIstd != STI_NIL && usIstd != STI_USER ) { for ( iIndex = 0 ; iIndex < ( int ) tStdCount ; iIndex ++ ) { if ( atStyleInfo [ iIndex ] . usIstd == usIstd ) { /* Right index found; return font */ * pFont = atFontInfo [ iIndex ] ; return ; } } } vGetDefaultFont ( pFont , 0 ) ; }",
    "resources/antiword/fail.c@__fail": "void __fail ( char * szExpression , char * szFilename , int iLineNumber ) { if ( szExpression == NULL || szFilename == NULL ) { werr ( 1 , \"Internal error: no expression\" ) ; } # if defined ( DEBUG ) fprintf ( stderr , \"%s[%3d]: Internal error in '%s'\\n\" , szFilename , iLineNumber , szExpression ) ; # endif /* DEBUG */ werr ( 1 , \"Internal error in '%s' in file %s at line %d\" , szExpression , szFilename , iLineNumber ) ; }",
    "resources/antiword/draw.c@tCreateMainWindow": "static window_handle tCreateMainWindow ( void ) { window_handle tMainWindow ; TRACE_MSG ( \"tCreateMainWindow\" ) ; tMainWindow = Window_Create ( \"MainWindow\" , template_TITLEMIN ) ; if ( tMainWindow == 0 ) { werr ( 1 , \"I can't find the 'MainWindow' template\" ) ; } return tMainWindow ; }",
    "resources/antiword/draw.c@tCreateScaleWindow": "static window_handle tCreateScaleWindow ( void ) { window_handle tScaleWindow ; TRACE_MSG ( \"tCreateScaleWindow\" ) ; tScaleWindow = Window_Create ( \"ScaleView\" , template_TITLEMIN ) ; if ( tScaleWindow == 0 ) { werr ( 1 , \"I can't find the 'ScaleView' template\" ) ; } return tScaleWindow ; }",
    "resources/antiword/draw.c@pCreateDiagram": "diagram_type * pCreateDiagram ( const char * szTask , const char * szFilename ) { diagram_type * pDiag ; options_type tOptions ; window_handle tMainWindow , tScaleWindow ; wimp_box tBox ; TRACE_MSG ( \"pCreateDiagram\" ) ; fail ( szTask == NULL || szTask [ 0 ] == '\\0' ) ; /* Create the main window */ tMainWindow = tCreateMainWindow ( ) ; /* Create the scale view window */ tScaleWindow = tCreateScaleWindow ( ) ; /* Get the necessary memory */ pDiag = xmalloc ( sizeof ( diagram_type ) ) ; if ( flex_alloc ( ( flex_ptr ) & pDiag -> tInfo . data , INITIAL_SIZE ) != 1 ) { werr ( 1 , \"Memory allocation failed, unable to continue\" ) ; } /* Initialize the diagram */ vGetOptions ( & tOptions ) ; pDiag -> tMainWindow = tMainWindow ; pDiag -> tScaleWindow = tScaleWindow ; pDiag -> iScaleFactorCurr = tOptions . iScaleFactor ; pDiag -> iScaleFactorTemp = tOptions . iScaleFactor ; pDiag -> tMemorySize = INITIAL_SIZE ; tBox . min . x = 0 ; tBox . min . y = - ( Drawfile_ScreenToDraw ( 32 + 3 ) * 8 + 1 ) ; tBox . max . x = Drawfile_ScreenToDraw ( 16 ) * MIN_SCREEN_WIDTH + 1 ; tBox . max . y = 0 ; Error_CheckFatal ( Drawfile_CreateDiagram ( & pDiag -> tInfo , pDiag -> tMemorySize , szTask , tBox ) ) ; DBG_DEC ( pDiag -> tInfo . length ) ; pDiag -> lXleft = 0 ; pDiag -> lYtop = 0 ; strncpy ( pDiag -> szFilename , szBasename ( szFilename ) , sizeof ( pDiag -> szFilename ) - 1 ) ; pDiag -> szFilename [ sizeof ( pDiag -> szFilename ) - 1 ] = '\\0' ; /* Return success */ return pDiag ; }",
    "resources/antiword/draw.c@bDestroyDiagram": "",
    "resources/antiword/draw.c@vExtendDiagramSize": "static void vExtendDiagramSize ( diagram_type * pDiag , size_t tSize ) { TRACE_MSG ( \"vExtendDiagramSize\" ) ; fail ( pDiag == NULL || tSize % 4 != 0 ) ; while ( pDiag -> tInfo . length + tSize > pDiag -> tMemorySize ) { if ( flex_extend ( ( flex_ptr ) & pDiag -> tInfo . data , pDiag -> tMemorySize + EXTENSION_SIZE ) != 1 ) { werr ( 1 , \"Memory extend failed, unable to continue\" ) ; } pDiag -> tMemorySize += EXTENSION_SIZE ; NO_DBG_DEC ( pDiag -> tMemorySize ) ; } TRACE_MSG ( \"end of vExtendDiagramSize\" ) ; }",
    "resources/antiword/draw.c@vPrologue2": "void vPrologue2 ( diagram_type * pDiag , int iWordVersion ) { drawfile_object * pNew ; const font_table_type * pTmp ; char * pcTmp ; size_t tRealSize , tSize ; int iCount ; TRACE_MSG ( \"vPrologue2\" ) ; fail ( pDiag == NULL ) ; if ( tGetFontTableLength ( ) == 0 ) { return ; } tRealSize = offsetof ( drawfile_object , data ) ; pTmp = NULL ; while ( ( pTmp = pGetNextFontTableRecord ( pTmp ) ) != NULL ) { tRealSize += 2 + strlen ( pTmp -> szOurFontname ) ; } DBG_DEC ( tRealSize ) ; tSize = ROUND4 ( tRealSize ) ; vExtendDiagramSize ( pDiag , tSize ) ; pNew = xmalloc ( tSize ) ; memset ( pNew , 0 , tSize ) ; pNew -> type = drawfile_TYPE_FONT_TABLE ; pNew -> size = tSize ; pcTmp = ( char * ) & pNew -> data . font_table . font_def [ 0 ] . font_ref ; iCount = 0 ; pTmp = NULL ; while ( ( pTmp = pGetNextFontTableRecord ( pTmp ) ) != NULL ) { * pcTmp = ++ iCount ; pcTmp ++ ; strcpy ( pcTmp , pTmp -> szOurFontname ) ; pcTmp += 1 + strlen ( pTmp -> szOurFontname ) ; } Error_CheckFatal ( Drawfile_AppendObject ( & pDiag -> tInfo , pDiag -> tMemorySize , pNew , TRUE ) ) ; pNew = xfree ( pNew ) ; }",
    "resources/antiword/draw.c@vSubstring2Diagram": "void vSubstring2Diagram ( diagram_type * pDiag , char * szString , size_t tStringLength , long lStringWidth , UCHAR ucFontColor , USHORT usFontstyle , drawfile_fontref tFontRef , USHORT usFontSize , USHORT usMaxFontSize ) { drawfile_object * pNew ; long lSizeX , lSizeY , lOffset , l20 , lYMove ; size_t tRealSize , tSize ; TRACE_MSG ( \"vSubstring2Diagram\" ) ; fail ( pDiag == NULL || szString == NULL ) ; fail ( pDiag -> lXleft < 0 ) ; fail ( tStringLength != strlen ( szString ) ) ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; fail ( usMaxFontSize < MIN_FONT_SIZE || usMaxFontSize > MAX_FONT_SIZE ) ; fail ( usFontSize > usMaxFontSize ) ; if ( szString [ 0 ] == '\\0' || tStringLength == 0 ) { return ; } if ( tFontRef == 0 ) { lOffset = Drawfile_ScreenToDraw ( 2 ) ; l20 = Drawfile_ScreenToDraw ( 32 + 3 ) ; lSizeX = Drawfile_ScreenToDraw ( 16 ) ; lSizeY = Drawfile_ScreenToDraw ( 32 ) ; } else { lOffset = lToBaseLine ( usMaxFontSize ) ; l20 = lWord2DrawUnits20 ( usMaxFontSize ) ; lSizeX = lWord2DrawUnits00 ( usFontSize ) ; lSizeY = lWord2DrawUnits00 ( usFontSize ) ; } lYMove = 0 ; /* Up for superscript */ if ( bIsSuperscript ( usFontstyle ) ) { lYMove = lMilliPoints2DrawUnits ( ( ( ( long ) usFontSize + 1 ) / 2 ) * 375 ) ; } /* Down for subscript */ if ( bIsSubscript ( usFontstyle ) ) { lYMove = - lMilliPoints2DrawUnits ( ( long ) usFontSize * 125 ) ; } tRealSize = offsetof ( drawfile_object , data ) ; tRealSize += sizeof ( drawfile_text ) + tStringLength ; tSize = ROUND4 ( tRealSize ) ; vExtendDiagramSize ( pDiag , tSize ) ; pNew = xmalloc ( tSize ) ; memset ( pNew , 0 , tSize ) ; pNew -> type = drawfile_TYPE_TEXT ; pNew -> size = tSize ; pNew -> data . text . bbox . min . x = ( int ) pDiag -> lXleft ; pNew -> data . text . bbox . min . y = ( int ) ( pDiag -> lYtop + lYMove ) ; pNew -> data . text . bbox . max . x = ( int ) ( pDiag -> lXleft + lStringWidth ) ; pNew -> data . text . bbox . max . y = ( int ) ( pDiag -> lYtop + l20 + lYMove ) ; pNew -> data . text . fill . value = ( int ) ulColor2Color ( ucFontColor ) ; pNew -> data . text . bg_hint . value = 0xffffff00 ; /* White */ pNew -> data . text . style . font_ref = tFontRef ; pNew -> data . text . style . reserved [ 0 ] = 0 ; pNew -> data . text . style . reserved [ 1 ] = 0 ; pNew -> data . text . style . reserved [ 2 ] = 0 ; pNew -> data . text . xsize = ( int ) lSizeX ; pNew -> data . text . ysize = ( int ) lSizeY ; pNew -> data . text . base . x = ( int ) pDiag -> lXleft ; pNew -> data . text . base . y = ( int ) ( pDiag -> lYtop + lOffset + lYMove ) ; strncpy ( pNew -> data . text . text , szString , tStringLength ) ; pNew -> data . text . text [ tStringLength ] = '\\0' ; Error_CheckFatal ( Drawfile_AppendObject ( & pDiag -> tInfo , pDiag -> tMemorySize , pNew , TRUE ) ) ; pNew = xfree ( pNew ) ; /*draw_translateText(&pDiag->tInfo);*/ pDiag -> lXleft += lStringWidth ; TRACE_MSG ( \"leaving vSubstring2Diagram\" ) ; }",
    "resources/antiword/draw.c@vImage2Diagram": "void vImage2Diagram ( diagram_type * pDiag , const imagedata_type * pImg , UCHAR * pucImage , size_t tImageSize ) { drawfile_object * pNew ; long lWidth , lHeight ; size_t tRealSize , tSize ; TRACE_MSG ( \"vImage2Diagram\" ) ; fail ( pDiag == NULL ) ; fail ( pImg == NULL ) ; fail ( pDiag -> lXleft < 0 ) ; fail ( pImg -> eImageType != imagetype_is_dib && pImg -> eImageType != imagetype_is_jpeg ) ; DBG_DEC_C ( pDiag -> lXleft != 0 , pDiag -> lXleft ) ; lWidth = lPoints2DrawUnits ( pImg -> iHorSizeScaled ) ; lHeight = lPoints2DrawUnits ( pImg -> iVerSizeScaled ) ; DBG_DEC ( lWidth ) ; DBG_DEC ( lHeight ) ; pDiag -> lYtop -= lHeight ; tRealSize = offsetof ( drawfile_object , data ) ; switch ( pImg -> eImageType ) { case imagetype_is_dib : tRealSize += sizeof ( drawfile_sprite ) + tImageSize ; tSize = ROUND4 ( tRealSize ) ; vExtendDiagramSize ( pDiag , tSize ) ; pNew = xmalloc ( tSize ) ; memset ( pNew , 0 , tSize ) ; pNew -> type = drawfile_TYPE_SPRITE ; pNew -> size = tSize ; pNew -> data . sprite . bbox . min . x = ( int ) pDiag -> lXleft ; pNew -> data . sprite . bbox . min . y = ( int ) pDiag -> lYtop ; pNew -> data . sprite . bbox . max . x = ( int ) ( pDiag -> lXleft + lWidth ) ; pNew -> data . sprite . bbox . max . y = ( int ) ( pDiag -> lYtop + lHeight ) ; memcpy ( & pNew -> data . sprite . header , pucImage , tImageSize ) ; break ; case imagetype_is_jpeg : # if defined ( DEBUG ) ( void ) bGetJpegInfo ( pucImage , tImageSize ) ; # endif /* DEBUG */ tRealSize += sizeof ( drawfile_jpeg ) + tImageSize ; tSize = ROUND4 ( tRealSize ) ; vExtendDiagramSize ( pDiag , tSize ) ; pNew = xmalloc ( tSize ) ; memset ( pNew , 0 , tSize ) ; pNew -> type = drawfile_TYPE_JPEG ; pNew -> size = tSize ; pNew -> data . jpeg . bbox . min . x = ( int ) pDiag -> lXleft ; pNew -> data . jpeg . bbox . min . y = ( int ) pDiag -> lYtop ; pNew -> data . jpeg . bbox . max . x = ( int ) ( pDiag -> lXleft + lWidth ) ; pNew -> data . jpeg . bbox . max . y = ( int ) ( pDiag -> lYtop + lHeight ) ; pNew -> data . jpeg . width = ( int ) lWidth ; pNew -> data . jpeg . height = ( int ) lHeight ; pNew -> data . jpeg . xdpi = 90 ; pNew -> data . jpeg . ydpi = 90 ; pNew -> data . jpeg . trfm . entries [ 0 ] [ 0 ] = 0x10000 ; pNew -> data . jpeg . trfm . entries [ 0 ] [ 1 ] = 0 ; pNew -> data . jpeg . trfm . entries [ 1 ] [ 0 ] = 0 ; pNew -> data . jpeg . trfm . entries [ 1 ] [ 1 ] = 0x10000 ; pNew -> data . jpeg . trfm . entries [ 2 ] [ 0 ] = ( int ) pDiag -> lXleft ; pNew -> data . jpeg . trfm . entries [ 2 ] [ 1 ] = ( int ) pDiag -> lYtop ; pNew -> data . jpeg . len = tImageSize ; memcpy ( pNew -> data . jpeg . data , pucImage , tImageSize ) ; break ; default : DBG_DEC ( pImg -> eImageType ) ; pNew = NULL ; break ; } Error_CheckFatal ( Drawfile_AppendObject ( & pDiag -> tInfo , pDiag -> tMemorySize , pNew , TRUE ) ) ; pNew = xfree ( pNew ) ; pDiag -> lXleft = 0 ; }",
    "resources/antiword/draw.c@bAddDummyImage": "",
    "resources/antiword/draw.c@vMove2NextLine": "void vMove2NextLine ( diagram_type * pDiag , drawfile_fontref tFontRef , USHORT usFontSize ) { long l20 ; TRACE_MSG ( \"vMove2NextLine\" ) ; fail ( pDiag == NULL ) ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; if ( tFontRef == 0 ) { l20 = Drawfile_ScreenToDraw ( 32 + 3 ) ; } else { l20 = lWord2DrawUnits20 ( usFontSize ) ; } pDiag -> lYtop -= l20 ; }",
    "resources/antiword/draw.c@vStartOfParagraph1": "void vStartOfParagraph1 ( diagram_type * pDiag , long lBeforeIndentation ) { TRACE_MSG ( \"vStartOfParagraph1\" ) ; fail ( pDiag == NULL ) ; fail ( lBeforeIndentation < 0 ) ; pDiag -> lXleft = 0 ; pDiag -> lYtop -= lMilliPoints2DrawUnits ( lBeforeIndentation ) ; }",
    "resources/antiword/draw.c@vStartOfParagraph2": "void vStartOfParagraph2 ( diagram_type * pDiag ) { TRACE_MSG ( \"vStartOfParagraph2\" ) ; }",
    "resources/antiword/draw.c@vEndOfParagraph": "void vEndOfParagraph ( diagram_type * pDiag , drawfile_fontref tFontRef , USHORT usFontSize , long lAfterIndentation ) { TRACE_MSG ( \"vEndOfParagraph\" ) ; fail ( pDiag == NULL ) ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; fail ( lAfterIndentation < 0 ) ; pDiag -> lXleft = 0 ; pDiag -> lYtop -= lMilliPoints2DrawUnits ( lAfterIndentation ) ; }",
    "resources/antiword/draw.c@vEndOfPage": "void vEndOfPage ( diagram_type * pDiag , long lAfterIndentation , BOOL bNewSection ) { TRACE_MSG ( \"vEndOfPage\" ) ; fail ( pDiag == NULL ) ; fail ( lAfterIndentation < 0 ) ; pDiag -> lXleft = 0 ; pDiag -> lYtop -= lMilliPoints2DrawUnits ( lAfterIndentation ) ; }",
    "resources/antiword/draw.c@vSetHeaders": "void vSetHeaders ( diagram_type * pDiag , USHORT usIstd ) { TRACE_MSG ( \"vSetHeaders\" ) ; }",
    "resources/antiword/draw.c@vStartOfList": "void vStartOfList ( diagram_type * pDiag , UCHAR ucNFC , BOOL bIsEndOfTable ) { TRACE_MSG ( \"vStartOfList\" ) ; }",
    "resources/antiword/draw.c@vEndOfList": "void vEndOfList ( diagram_type * pDiag ) { TRACE_MSG ( \"vEndOfList\" ) ; }",
    "resources/antiword/draw.c@vStartOfListItem": "void vStartOfListItem ( diagram_type * pDiag , BOOL bNoMarks ) { TRACE_MSG ( \"vStartOfListItem\" ) ; }",
    "resources/antiword/draw.c@vEndOfTable": "void vEndOfTable ( diagram_type * pDiag ) { TRACE_MSG ( \"vEndOfTable\" ) ; }",
    "resources/antiword/draw.c@bAddTableRow": "",
    "resources/antiword/draw.c@vForceRedraw": "static void vForceRedraw ( diagram_type * pDiag ) { window_state tWindowState ; window_redrawblock tRedraw ; int x0 , y0 , x1 , y1 ; TRACE_MSG ( \"vForceRedraw\" ) ; fail ( pDiag == NULL ) ; DBG_DEC ( pDiag -> iScaleFactorCurr ) ; /* Read the size of the current diagram */ Drawfile_QueryBox ( & pDiag -> tInfo , & tRedraw . rect , TRUE ) ; /* Adjust the size of the work area */ x0 = tRedraw . rect . min . x * pDiag -> iScaleFactorCurr / 100 - 1 ; y0 = tRedraw . rect . min . y * pDiag -> iScaleFactorCurr / 100 - 1 ; x1 = tRedraw . rect . max . x * pDiag -> iScaleFactorCurr / 100 + 1 ; y1 = tRedraw . rect . max . y * pDiag -> iScaleFactorCurr / 100 + 1 ; /* Work area extension */ x0 -= WORKAREA_EXTENSION ; y0 -= WORKAREA_EXTENSION ; x1 += WORKAREA_EXTENSION ; y1 += WORKAREA_EXTENSION ; Window_SetExtent ( pDiag -> tMainWindow , x0 , y0 , x1 , y1 ) ; /* Widen the box slightly to be sure all the edges are drawn */ x0 -= 5 ; y0 -= 5 ; x1 += 5 ; y1 += 5 ; /* Force the redraw */ Window_ForceRedraw ( pDiag -> tMainWindow , x0 , y0 , x1 , y1 ) ; /* Reopen the window to show the correct size */ Error_CheckFatal ( Wimp_GetWindowState ( pDiag -> tMainWindow , & tWindowState ) ) ; tWindowState . openblock . behind = - 1 ; Error_CheckFatal ( Wimp_OpenWindow ( & tWindowState . openblock ) ) ; }",
    "resources/antiword/draw.c@vShowDiagram": "void vShowDiagram ( diagram_type * pDiag ) { wimp_box tRect ; int x0 , y0 , x1 , y1 ; TRACE_MSG ( \"vShowDiagram\" ) ; fail ( pDiag == NULL ) ; Window_Show ( pDiag -> tMainWindow , open_NEARLAST ) ; Drawfile_QueryBox ( & pDiag -> tInfo , & tRect , TRUE ) ; /* Work area extension */ x0 = tRect . min . x - WORKAREA_EXTENSION ; y0 = tRect . min . y - WORKAREA_EXTENSION ; x1 = tRect . max . x + WORKAREA_EXTENSION ; y1 = tRect . max . y + WORKAREA_EXTENSION ; Window_SetExtent ( pDiag -> tMainWindow , x0 , y0 , x1 , y1 ) ; vForceRedraw ( pDiag ) ; }",
    "resources/antiword/draw.c@vMainButtonClick": "void vMainButtonClick ( mouse_block * pMouse ) { caret_block tCaret ; window_state ws ; TRACE_MSG ( \"vMainButtonClick\" ) ; fail ( pMouse == NULL ) ; DBG_DEC ( pMouse -> button . data . select ) ; DBG_DEC ( pMouse -> button . data . adjust ) ; DBG_DEC ( pMouse -> window ) ; DBG_DEC ( pMouse -> icon ) ; if ( pMouse -> window >= 0 && pMouse -> icon == - 1 && ( pMouse -> button . data . select || pMouse -> button . data . adjust ) ) { /* Get the input focus */ Error_CheckFatal ( Wimp_GetWindowState ( pMouse -> window , & ws ) ) ; tCaret . window = pMouse -> window ; tCaret . icon = - 1 ; tCaret . offset . x = pMouse -> pos . x - ws . openblock . screenrect . min . x ; tCaret . offset . y = pMouse -> pos . y - ws . openblock . screenrect . max . y ; tCaret . height = ( int ) BIT ( 25 ) ; tCaret . index = 0 ; Error_CheckFatal ( Wimp_SetCaretPosition ( & tCaret ) ) ; } }",
    "resources/antiword/draw.c@bMainKeyPressed": "",
    "resources/antiword/draw.c@bRedrawMainWindow": "",
    "resources/antiword/draw.c@bScaleOpenAction": "",
    "resources/antiword/draw.c@vSetTitle": "void vSetTitle ( diagram_type * pDiag ) { char szTitle [ WINDOW_TITLE_LEN ] ; TRACE_MSG ( \"vSetTitle\" ) ; fail ( pDiag == NULL ) ; fail ( pDiag -> szFilename [ 0 ] == '\\0' ) ; ( void ) sprintf ( szTitle , \"%.*s at %d%%\" , FILENAME_TITLE_LEN , pDiag -> szFilename , pDiag -> iScaleFactorCurr % 1000 ) ; if ( strlen ( pDiag -> szFilename ) > FILENAME_TITLE_LEN ) { szTitle [ FILENAME_TITLE_LEN - 1 ] = OUR_ELLIPSIS ; } Window_SetTitle ( pDiag -> tMainWindow , szTitle ) ; }",
    "resources/antiword/draw.c@vScaleButtonClick": "void vScaleButtonClick ( mouse_block * pMouse , diagram_type * pDiag ) { BOOL bCloseWindow , bRedraw ; TRACE_MSG ( \"vScaleButtonClick\" ) ; fail ( pMouse == NULL || pDiag == NULL ) ; fail ( pMouse -> window != pDiag -> tScaleWindow ) ; bCloseWindow = FALSE ; bRedraw = FALSE ; switch ( pMouse -> icon ) { case SCALE_CANCEL_BUTTON : bCloseWindow = TRUE ; pDiag -> iScaleFactorTemp = pDiag -> iScaleFactorCurr ; break ; case SCALE_SCALE_BUTTON : bCloseWindow = TRUE ; bRedraw = pDiag -> iScaleFactorCurr != pDiag -> iScaleFactorTemp ; pDiag -> iScaleFactorCurr = pDiag -> iScaleFactorTemp ; break ; case SCALE_50_PCT : pDiag -> iScaleFactorTemp = 50 ; break ; case SCALE_75_PCT : pDiag -> iScaleFactorTemp = 75 ; break ; case SCALE_100_PCT : pDiag -> iScaleFactorTemp = 100 ; break ; case SCALE_150_PCT : pDiag -> iScaleFactorTemp = 150 ; break ; default : DBG_DEC ( pMouse -> icon ) ; break ; } if ( bCloseWindow ) { /* Close the scale window */ Error_CheckFatal ( Wimp_CloseWindow ( pMouse -> window ) ) ; if ( bRedraw ) { /* Redraw the main window */ vSetTitle ( pDiag ) ; vForceRedraw ( pDiag ) ; } } else { vUpdateWriteableNumber ( pMouse -> window , SCALE_SCALE_WRITEABLE , pDiag -> iScaleFactorTemp ) ; } }",
    "resources/antiword/draw.c@bScaleKeyPressed": "",
    "resources/antiword/pdf.c@tGetFontIndex": "static size_t tGetFontIndex ( drawfile_fontref tFontRef ) { const char * szFontname ; size_t tIndex ; /* Get the font name */ szFontname = szGetFontname ( tFontRef ) ; fail ( szFontname == NULL ) ; if ( szFontname == NULL ) { return 0 ; } /* Find the name in the table */ for ( tIndex = 0 ; tIndex < elementsof ( atFontname ) ; tIndex ++ ) { if ( STRCEQ ( atFontname [ tIndex ] . szPSname , szFontname ) ) { return tIndex ; } } /* Not found */ DBG_DEC ( tFontRef ) ; DBG_MSG ( szFontname ) ; return 0 ; }",
    "resources/antiword/pdf.c@vSetLocation": "static void vSetLocation ( int iLocationNumber ) { fail ( iLocationNumber <= 0 ) ; if ( ( size_t ) iLocationNumber >= tLocations ) { /* Extend and set to zero */ tLocations += EXTENSION_ARRAY_SIZE ; alLocation = xrealloc ( alLocation , tLocations * sizeof ( long ) ) ; memset ( alLocation + tLocations - EXTENSION_ARRAY_SIZE , 0 , EXTENSION_ARRAY_SIZE * sizeof ( long ) ) ; DBG_DEC ( tLocations ) ; } if ( iLocationNumber > iMaxLocationNumber ) { iMaxLocationNumber = iLocationNumber ; } DBG_DEC_C ( ( size_t ) iLocationNumber >= tLocations , iLocationNumber ) ; DBG_DEC_C ( ( size_t ) iLocationNumber >= tLocations , tLocations ) ; fail ( ( size_t ) iLocationNumber >= tLocations ) ; alLocation [ iLocationNumber ] = lFilePosition ; }",
    "resources/antiword/pdf.c@vFillNextPageObject": "static void vFillNextPageObject ( void ) { iPageCount ++ ; if ( ( size_t ) iPageCount >= tMaxPageObjects ) { /* Extend the array */ tMaxPageObjects += EXTENSION_ARRAY_SIZE ; aiPageObject = xrealloc ( aiPageObject , tMaxPageObjects * sizeof ( int ) ) ; DBG_DEC ( tMaxPageObjects ) ; } aiPageObject [ iPageCount ] = iObjectNumberCurr ; }",
    "resources/antiword/pdf.c@vFPprintf": "static void vFPprintf ( FILE * pOutFile , const char * szFormat , ... ) { va_list tArg ; va_start ( tArg , szFormat ) ; lFilePosition += vfprintf ( pOutFile , szFormat , tArg ) ; va_end ( tArg ) ; }",
    "resources/antiword/pdf.c@vCreateInfoDictionary": "void vCreateInfoDictionary ( diagram_type * pDiag , int iWordVersion ) { FILE * pOutFile ; const char * szTitle , * szAuthor , * szSubject , * szCreator ; const char * szCreationDate , * szModDate ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( iWordVersion < 0 ) ; fail ( szProducer == NULL || szProducer [ 0 ] == '\\0' ) ; szTitle = szGetTitle ( ) ; szAuthor = szGetAuthor ( ) ; szSubject = szGetSubject ( ) ; szCreationDate = szGetCreationDate ( ) ; szModDate = szGetModDate ( ) ; switch ( iWordVersion ) { case 0 : szCreator = \"Word for DOS\" ; break ; case 1 : szCreator = \"WinWord 1.x\" ; break ; case 2 : szCreator = \"WinWord 2.0\" ; break ; case 4 : szCreator = \"MacWord 4\" ; break ; case 5 : szCreator = \"MacWord 5\" ; break ; case 6 : szCreator = \"Word 6\" ; break ; case 7 : szCreator = \"Word 7/95\" ; break ; case 8 : szCreator = \"Word 97 or later\" ; break ; default : szCreator = NULL ; break ; } pOutFile = pDiag -> pOutFile ; vSetLocation ( 2 ) ; vFPprintf ( pOutFile , \"2 0 obj\\n\" ) ; vFPprintf ( pOutFile , \"<<\\n\" ) ; if ( szTitle != NULL && szTitle [ 0 ] != '\\0' ) { vFPprintf ( pOutFile , \"/Title (%s)\\n\" , szTitle ) ; } if ( szAuthor != NULL && szAuthor [ 0 ] != '\\0' ) { vFPprintf ( pOutFile , \"/Author (%s)\\n\" , szAuthor ) ; } if ( szSubject != NULL && szSubject [ 0 ] != '\\0' ) { vFPprintf ( pOutFile , \"/Subject (%s)\\n\" , szSubject ) ; } if ( szCreator != NULL && szCreator [ 0 ] != '\\0' ) { vFPprintf ( pOutFile , \"/Creator (%s)\\n\" , szCreator ) ; } vFPprintf ( pOutFile , \"/Producer (%s %s)\\n\" , szProducer , VERSIONSTRING ) ; if ( szCreationDate != NULL && szCreationDate [ 0 ] != '\\0' ) { vFPprintf ( pOutFile , \"/CreationDate (%s)\\n\" , szCreationDate ) ; } if ( szModDate != NULL && szModDate [ 0 ] != '\\0' ) { vFPprintf ( pOutFile , \"/ModDate (%s)\\n\" , szModDate ) ; } vFPprintf ( pOutFile , \">>\\n\" ) ; vFPprintf ( pOutFile , \"endobj\\n\" ) ; }",
    "resources/antiword/pdf.c@vAddHdrFtr": "static void vAddHdrFtr ( diagram_type * pDiag , const hdrftr_block_type * pHdrFtrInfo ) { output_type * pStart , * pPrev , * pNext ; fail ( pDiag == NULL ) ; fail ( pHdrFtrInfo == NULL ) ; vStartOfParagraphPDF ( pDiag , 0 ) ; pStart = pHdrFtrInfo -> pText ; while ( pStart != NULL ) { pNext = pStart ; while ( pNext != NULL && ( pNext -> tNextFree != 1 || ( pNext -> szStorage [ 0 ] != PAR_END && pNext -> szStorage [ 0 ] != HARD_RETURN ) ) ) { pNext = pNext -> pNext ; } if ( pNext == NULL ) { if ( bOutputContainsText ( pStart ) ) { vAlign2Window ( pDiag , pStart , lChar2MilliPoints ( DEFAULT_SCREEN_WIDTH ) , ALIGNMENT_LEFT ) ; } else { vMove2NextLinePDF ( pDiag , pStart -> usFontSize ) ; } break ; } fail ( pNext -> tNextFree != 1 ) ; fail ( pNext -> szStorage [ 0 ] != PAR_END && pNext -> szStorage [ 0 ] != HARD_RETURN ) ; if ( pStart != pNext ) { /* There is something to print */ pPrev = pNext -> pPrev ; fail ( pPrev -> pNext != pNext ) ; /* Cut the chain */ pPrev -> pNext = NULL ; if ( bOutputContainsText ( pStart ) ) { /* Print it */ vAlign2Window ( pDiag , pStart , lChar2MilliPoints ( DEFAULT_SCREEN_WIDTH ) , ALIGNMENT_LEFT ) ; } else { /* Just an empty line */ vMove2NextLinePDF ( pDiag , pStart -> usFontSize ) ; } /* Repair the chain */ pPrev -> pNext = pNext ; } if ( pNext -> szStorage [ 0 ] == PAR_END ) { vEndOfParagraphPDF ( pDiag , pNext -> usFontSize , ( long ) pNext -> usFontSize * 200 ) ; } pStart = pNext -> pNext ; } }",
    "resources/antiword/pdf.c@vAddHeader": "static void vAddHeader ( diagram_type * pDiag ) { const hdrftr_block_type * pHdrInfo ; const hdrftr_block_type * pFtrInfo ; fail ( pDiag == NULL ) ; NO_DBG_MSG ( \"vAddHeader\" ) ; pHdrInfo = pGetHdrFtrInfo ( iSectionIndex , TRUE , odd ( iPageCount ) , bFirstInSection ) ; pFtrInfo = pGetHdrFtrInfo ( iSectionIndex , FALSE , odd ( iPageCount ) , bFirstInSection ) ; /* Set the height of the footer of this page */ lFooterHeight = pFtrInfo == NULL ? 0 : pFtrInfo -> lHeight ; fail ( lFooterHeight < 0 ) ; if ( pHdrInfo == NULL || pHdrInfo -> pText == NULL || pHdrInfo -> lHeight <= 0 ) { fail ( pHdrInfo != NULL && pHdrInfo -> lHeight < 0 ) ; fail ( pHdrInfo != NULL && pHdrInfo -> pText != NULL && pHdrInfo -> lHeight == 0 ) ; return ; } vAddHdrFtr ( pDiag , pHdrInfo ) ; DBG_DEC_C ( pHdrInfo -> lHeight != lPageHeight - PS_TOP_MARGIN - pDiag -> lYtop , pHdrInfo -> lHeight ) ; DBG_DEC_C ( pHdrInfo -> lHeight != lPageHeight - PS_TOP_MARGIN - pDiag -> lYtop , lPageHeight - PS_TOP_MARGIN - pDiag -> lYtop ) ; }",
    "resources/antiword/pdf.c@vAddFooter": "static void vAddFooter ( diagram_type * pDiag ) { const hdrftr_block_type * pFtrInfo ; fail ( pDiag == NULL ) ; NO_DBG_MSG ( \"vAddFooter\" ) ; pFtrInfo = pGetHdrFtrInfo ( iSectionIndex , FALSE , odd ( iPageCount ) , bFirstInSection ) ; bFirstInSection = FALSE ; if ( pFtrInfo == NULL || pFtrInfo -> pText == NULL || pFtrInfo -> lHeight <= 0 ) { fail ( pFtrInfo != NULL && pFtrInfo -> lHeight < 0 ) ; fail ( pFtrInfo != NULL && pFtrInfo -> pText != NULL && pFtrInfo -> lHeight == 0 ) ; return ; } bInFtrSpace = TRUE ; DBG_DEC_C ( pFtrInfo -> lHeight != lFooterHeight , pFtrInfo -> lHeight ) ; DBG_DEC_C ( pFtrInfo -> lHeight != lFooterHeight , lFooterHeight ) ; DBG_DEC_C ( pDiag -> lYtop < lFooterHeight + PS_BOTTOM_MARGIN , pDiag -> lYtop ) ; DBG_DEC_C ( pDiag -> lYtop < lFooterHeight + PS_BOTTOM_MARGIN , lFooterHeight + PS_BOTTOM_MARGIN ) ; if ( pDiag -> lYtop > lFooterHeight + PS_BOTTOM_MARGIN ) { /* Move down to the start of the footer */ pDiag -> lYtop = lFooterHeight + PS_BOTTOM_MARGIN ; vMoveTo ( pDiag , 0 ) ; } else if ( pDiag -> lYtop < lFooterHeight + PS_BOTTOM_MARGIN / 2 ) { DBG_FIXME ( ) ; /*\n\t\t * Move up to the start of the footer, to prevent moving\n\t\t * of the bottom edge of the paper\n\t\t */ pDiag -> lYtop = lFooterHeight + PS_BOTTOM_MARGIN ; vMoveTo ( pDiag , 0 ) ; } DBG_FLT_C ( pDiag -> lYtop < lFooterHeight + PS_BOTTOM_MARGIN , dDrawUnits2Points ( lFooterHeight + PS_BOTTOM_MARGIN - pDiag -> lYtop ) ) ; vAddHdrFtr ( pDiag , pFtrInfo ) ; bInFtrSpace = FALSE ; }",
    "resources/antiword/pdf.c@vEndPageObject": "static void vEndPageObject ( FILE * pOutFile ) { long lStreamEnd ; if ( lStreamStart < 0 ) { /* There is no current page object */ return ; } vFPprintf ( pOutFile , \"ET\\n\" ) ; lStreamEnd = lFilePosition ; vFPprintf ( pOutFile , \"endstream\\n\" ) ; vFPprintf ( pOutFile , \"endobj\\n\" ) ; iObjectNumberCurr ++ ; vSetLocation ( iObjectNumberCurr ) ; vFPprintf ( pOutFile , \"%d 0 obj\\n\" , iObjectNumberCurr ) ; vFPprintf ( pOutFile , \"%lu\\n\" , lStreamEnd - lStreamStart ) ; vFPprintf ( pOutFile , \"endobj\\n\" ) ; }",
    "resources/antiword/pdf.c@vMove2NextPage": "static void vMove2NextPage ( diagram_type * pDiag , BOOL bNewSection ) { FILE * pOutFile ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; pOutFile = pDiag -> pOutFile ; vAddFooter ( pDiag ) ; /* End the old page object */ vEndPageObject ( pOutFile ) ; if ( bNewSection ) { iSectionIndex ++ ; bFirstInSection = TRUE ; } /* Start the new page object */ iObjectNumberCurr ++ ; vSetLocation ( iObjectNumberCurr ) ; vFillNextPageObject ( ) ; vFPprintf ( pOutFile , \"%d 0 obj\\n\" , iObjectNumberCurr ) ; vFPprintf ( pOutFile , \"<<\\n\" ) ; vFPprintf ( pOutFile , \"/Type /Page\\n\" ) ; vFPprintf ( pOutFile , \"/Parent 3 0 R\\n\" ) ; vFPprintf ( pOutFile , \"/Resources 17 0 R\\n\" ) ; vFPprintf ( pOutFile , \"/Contents %d 0 R\\n\" , iObjectNumberCurr + 1 ) ; vFPprintf ( pOutFile , \">>\\n\" ) ; vFPprintf ( pOutFile , \"endobj\\n\" ) ; /* Start the new text object */ iObjectNumberCurr ++ ; vSetLocation ( iObjectNumberCurr ) ; vFPprintf ( pOutFile , \"%d 0 obj\\n\" , iObjectNumberCurr ) ; vFPprintf ( pOutFile , \"<<\\n\" ) ; vFPprintf ( pOutFile , \"/Length %d 0 R\\n\" , iObjectNumberCurr + 1 ) ; vFPprintf ( pOutFile , \">>\\n\" ) ; vFPprintf ( pOutFile , \"stream\\n\" ) ; lStreamStart = lFilePosition ; vFPprintf ( pOutFile , \"BT\\n\" ) ; /* Set variables to their start of page values */ pDiag -> lYtop = lPageHeight - PS_TOP_MARGIN ; tFontRefCurr = ( drawfile_fontref ) - 1 ; usFontSizeCurr = 0 ; iFontColorCurr = - 1 ; lYtopCurr = - 1 ; vAddHeader ( pDiag ) ; }",
    "resources/antiword/pdf.c@vMoveTo": "static void vMoveTo ( diagram_type * pDiag , long lLastVerticalMovement ) { fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; if ( pDiag -> lYtop <= lFooterHeight + PS_BOTTOM_MARGIN && ! bInFtrSpace ) { vMove2NextPage ( pDiag , FALSE ) ; /* Repeat the last vertical movement on the new page */ pDiag -> lYtop -= lLastVerticalMovement ; } fail ( pDiag -> lYtop < lFooterHeight + PS_BOTTOM_MARGIN && ! bInFtrSpace ) ; DBG_DEC_C ( pDiag -> lYtop < PS_BOTTOM_MARGIN , pDiag -> lYtop ) ; fail ( pDiag -> lYtop < PS_BOTTOM_MARGIN / 3 ) ; if ( pDiag -> lYtop != lYtopCurr ) { vFPprintf ( pDiag -> pOutFile , \"1 0 0 1 %.2f %.2f Tm\\n\" , dDrawUnits2Points ( pDiag -> lXleft + PS_LEFT_MARGIN ) , dDrawUnits2Points ( pDiag -> lYtop ) ) ; lYtopCurr = pDiag -> lYtop ; } }",
    "resources/antiword/pdf.c@vProloguePDF": "void vProloguePDF ( diagram_type * pDiag , const char * szTask , const options_type * pOptions ) { FILE * pOutFile ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( pOptions == NULL ) ; pOutFile = pDiag -> pOutFile ; eEncoding = pOptions -> eEncoding ; /* Create an empty location array */ tLocations = INITIAL_LOCATION_SIZE ; alLocation = xcalloc ( tLocations , sizeof ( long ) ) ; /* Create an empty pageobject array */ tMaxPageObjects = INITIAL_PAGEOBJECT_SIZE ; aiPageObject = xcalloc ( tMaxPageObjects , sizeof ( int ) ) ; if ( pOptions -> iPageHeight == INT_MAX ) { lPageHeight = LONG_MAX ; } else { lPageHeight = lPoints2DrawUnits ( pOptions -> iPageHeight ) ; } DBG_DEC ( lPageHeight ) ; if ( pOptions -> iPageWidth == INT_MAX ) { lPageWidth = LONG_MAX ; } else { lPageWidth = lPoints2DrawUnits ( pOptions -> iPageWidth ) ; } DBG_DEC ( lPageWidth ) ; lFooterHeight = 0 ; bInFtrSpace = FALSE ; tFontRefCurr = ( drawfile_fontref ) - 1 ; usFontSizeCurr = 0 ; iFontColorCurr = - 1 ; lYtopCurr = - 1 ; iPageCount = 0 ; iImageCount = 0 ; iSectionIndex = 0 ; bFirstInSection = TRUE ; lFilePosition = 0 ; iMaxLocationNumber = 0 ; lStreamStart = - 1 ; iObjectNumberCurr = 17 ; pDiag -> lXleft = 0 ; pDiag -> lYtop = 0 ; szProducer = szTask ; vFPprintf ( pOutFile , \"%%PDF-1.3\\n\" ) ; vFPprintf ( pOutFile , \"%%%c%c%c%c\\n\" , 0xe2 , 0xe3 , 0xcf , 0xd3 ) ; /* Root catalog */ vSetLocation ( 1 ) ; vFPprintf ( pOutFile , \"1 0 obj\\n\" ) ; vFPprintf ( pOutFile , \"<<\\n\" ) ; vFPprintf ( pOutFile , \"/Type /Catalog\\n\" ) ; vFPprintf ( pOutFile , \"/Pages 3 0 R\\n\" ) ; vFPprintf ( pOutFile , \">>\\n\" ) ; vFPprintf ( pOutFile , \"endobj\\n\" ) ; }",
    "resources/antiword/pdf.c@vEpiloguePDF": "void vEpiloguePDF ( diagram_type * pDiag ) { FILE * pOutFile ; long lXref ; int iIndex ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; pOutFile = pDiag -> pOutFile ; vAddFooter ( pDiag ) ; /* End the old page object */ vEndPageObject ( pOutFile ) ; vSetLocation ( 3 ) ; vFPprintf ( pOutFile , \"3 0 obj\\n\" ) ; vFPprintf ( pOutFile , \"<<\\n\" ) ; vFPprintf ( pOutFile , \"/Type /Pages\\n\" ) ; vFPprintf ( pOutFile , \"/Count %d\\n\" , iPageCount ) ; vFPprintf ( pOutFile , \"/MediaBox [ 0 0 %.0f %.0f ]\\n\" , dDrawUnits2Points ( lPageWidth ) , dDrawUnits2Points ( lPageHeight ) ) ; vFPprintf ( pOutFile , \"/Kids [ \" ) ; for ( iIndex = 1 ; iIndex <= iPageCount ; iIndex ++ ) { vFPprintf ( pOutFile , \"\\t%d 0 R\\n\" , aiPageObject [ iIndex ] ) ; } vFPprintf ( pOutFile , \"]\\n\" ) ; vFPprintf ( pOutFile , \">>\\n\" ) ; vFPprintf ( pOutFile , \"endobj\\n\" ) ; lXref = lFilePosition ; vFPprintf ( pOutFile , \"xref\\n\" ) ; vFPprintf ( pOutFile , \"0 %d\\n\" , iMaxLocationNumber + 1 ) ; vFPprintf ( pOutFile , \"0000000000 65535 f \\n\" ) ; for ( iIndex = 1 ; iIndex <= iMaxLocationNumber ; iIndex ++ ) { vFPprintf ( pOutFile , \"%.10ld 00000 n \\n\" , alLocation [ iIndex ] ) ; } vFPprintf ( pOutFile , \"trailer\\n\" ) ; vFPprintf ( pOutFile , \"<<\\n\" ) ; vFPprintf ( pOutFile , \"/Size %d\\n\" , iMaxLocationNumber + 1 ) ; vFPprintf ( pOutFile , \"/Root 1 0 R\\n\" ) ; vFPprintf ( pOutFile , \"/Info 2 0 R\\n\" ) ; vFPprintf ( pOutFile , \">>\\n\" ) ; vFPprintf ( pOutFile , \"startxref\\n\" ) ; vFPprintf ( pOutFile , \"%ld\\n\" , lXref ) ; vFPprintf ( pOutFile , \"%%%%EOF\\n\" ) ; szProducer = NULL ; aiPageObject = xfree ( aiPageObject ) ; alLocation = xfree ( alLocation ) ; }",
    "resources/antiword/pdf.c@vPrintPalette": "static void vPrintPalette ( FILE * pOutFile , const imagedata_type * pImg ) { int iIndex ; fail ( pOutFile == NULL ) ; fail ( pImg == NULL ) ; fail ( pImg -> iColorsUsed < 2 ) ; fail ( pImg -> iColorsUsed > 256 ) ; vFPprintf ( pOutFile , \"\\t/ColorSpace [ /Indexed\\n\" ) ; vFPprintf ( pOutFile , \"\\t/Device%s %d\\n\" , pImg -> bColorImage ? \"RGB\" : \"Gray\" , pImg -> iColorsUsed - 1 ) ; vFPprintf ( pOutFile , \"<\" ) ; for ( iIndex = 0 ; iIndex < pImg -> iColorsUsed ; iIndex ++ ) { vFPprintf ( pOutFile , \"%02x\" , ( unsigned int ) pImg -> aucPalette [ iIndex ] [ 0 ] ) ; if ( pImg -> bColorImage ) { vFPprintf ( pOutFile , \"%02x%02x\" , ( unsigned int ) pImg -> aucPalette [ iIndex ] [ 1 ] , ( unsigned int ) pImg -> aucPalette [ iIndex ] [ 2 ] ) ; } if ( iIndex % 8 == 7 ) { vFPprintf ( pOutFile , \"\\n\" ) ; } else { vFPprintf ( pOutFile , \" \" ) ; } } vFPprintf ( pOutFile , \"> ]\\n\" ) ; }",
    "resources/antiword/pdf.c@vImageProloguePDF": "void vImageProloguePDF ( diagram_type * pDiag , const imagedata_type * pImg ) { FILE * pOutFile ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( pImg == NULL ) ; if ( pImg -> iVerSizeScaled <= 0 || pImg -> iHorSizeScaled <= 0 ) { return ; } iImageCount ++ ; DBG_DEC_C ( pDiag -> lXleft != 0 , pDiag -> lXleft ) ; pDiag -> lYtop -= lPoints2DrawUnits ( pImg -> iVerSizeScaled ) ; vMoveTo ( pDiag , lPoints2DrawUnits ( pImg -> iVerSizeScaled ) ) ; pOutFile = pDiag -> pOutFile ; vFPprintf ( pOutFile , \"ET\\n\" ) ; vFPprintf ( pOutFile , \"q %% Image %03d\\n\" , iImageCount ) ; if ( pImg -> eImageType == imagetype_is_dib ) { /* Scanning from left to right and bottom to top */ vFPprintf ( pOutFile , \"%d 0 0 %d %.2f %.2f cm\\n\" , pImg -> iHorSizeScaled , - pImg -> iVerSizeScaled , dDrawUnits2Points ( pDiag -> lXleft + PS_LEFT_MARGIN ) , dDrawUnits2Points ( pDiag -> lYtop ) + pImg -> iVerSizeScaled ) ; } else { /* Scanning from left to right and top to bottom */ vFPprintf ( pOutFile , \"%d 0 0 %d %.2f %.2f cm\\n\" , pImg -> iHorSizeScaled , pImg -> iVerSizeScaled , dDrawUnits2Points ( pDiag -> lXleft + PS_LEFT_MARGIN ) , dDrawUnits2Points ( pDiag -> lYtop ) ) ; } vFPprintf ( pOutFile , \"BI\\n\" ) ; vFPprintf ( pOutFile , \"\\t/Width %d\\n\" , pImg -> iWidth ) ; vFPprintf ( pOutFile , \"\\t/Height %d\\n\" , pImg -> iHeight ) ; switch ( pImg -> eImageType ) { case imagetype_is_jpeg : switch ( pImg -> iComponents ) { case 1 : vFPprintf ( pOutFile , \"\\t/ColorSpace /DeviceGray\\n\" ) ; break ; case 3 : vFPprintf ( pOutFile , \"\\t/ColorSpace /DeviceRGB\\n\" ) ; break ; case 4 : vFPprintf ( pOutFile , \"\\t/ColorSpace /DeviceCMYK\\n\" ) ; if ( pImg -> bAdobe ) { /*\n\t\t\t\t * Adobe-conforming CMYK file\n\t\t\t\t * applying workaround for color inversion\n\t\t\t\t */ vFPprintf ( pOutFile , \"\\t/Decode [1 0 1 0 1 0 1 0]\\n\" ) ; } break ; default : DBG_DEC ( pImg -> iComponents ) ; break ; } vFPprintf ( pOutFile , \"\\t/BitsPerComponent 8\\n\" ) ; vFPprintf ( pOutFile , \"\\t/Filter [ /ASCII85Decode /DCTDecode ]\\n\" ) ; break ; case imagetype_is_png : if ( pImg -> iComponents == 3 || pImg -> iComponents == 4 ) { vFPprintf ( pOutFile , \"\\t/ColorSpace /DeviceRGB\\n\" ) ; vFPprintf ( pOutFile , \"\\t/BitsPerComponent 8\\n\" ) ; } else if ( pImg -> iColorsUsed > 0 ) { vPrintPalette ( pOutFile , pImg ) ; fail ( pImg -> uiBitsPerComponent > 8 ) ; vFPprintf ( pOutFile , \"\\t/BitsPerComponent %u\\n\" , pImg -> uiBitsPerComponent ) ; } else { vFPprintf ( pOutFile , \"\\t/ColorSpace /DeviceGray\\n\" ) ; vFPprintf ( pOutFile , \"\\t/BitsPerComponent 8\\n\" ) ; } vFPprintf ( pOutFile , \"\\t/Filter [ /ASCII85Decode /FlateDecode ]\\n\" ) ; vFPprintf ( pOutFile , \"\\t/DecodeParms [ null <<\\n\" ) ; vFPprintf ( pOutFile , \"\\t\\t/Predictor 10\\n\" ) ; vFPprintf ( pOutFile , \"\\t\\t/Colors %d\\n\" , pImg -> iComponents ) ; vFPprintf ( pOutFile , \"\\t\\t/BitsPerComponent %u\\n\" , pImg -> uiBitsPerComponent ) ; vFPprintf ( pOutFile , \"\\t\\t/Columns %d\\n\" , pImg -> iWidth ) ; vFPprintf ( pOutFile , \"\\t\\t>> ]\\n\" ) ; break ; case imagetype_is_dib : if ( pImg -> uiBitsPerComponent <= 8 ) { vPrintPalette ( pOutFile , pImg ) ; } else { vFPprintf ( pOutFile , \"\\t/ColorSpace /DeviceRGB\\n\" ) ; } vFPprintf ( pOutFile , \"\\t/BitsPerComponent 8\\n\" ) ; vFPprintf ( pOutFile , \"\\t/Filter /ASCII85Decode\\n\" ) ; break ; default : vFPprintf ( pOutFile , \"\\t/ColorSpace /Device%s\\n\" , pImg -> bColorImage ? \"RGB\" : \"Gray\" ) ; vFPprintf ( pOutFile , \"\\t/BitsPerComponent 8\\n\" ) ; vFPprintf ( pOutFile , \"\\t/Filter /ASCIIHexDecode\\n\" ) ; break ; } vFPprintf ( pOutFile , \"ID\\n\" ) ; }",
    "resources/antiword/pdf.c@vImageEpiloguePDF": "void vImageEpiloguePDF ( diagram_type * pDiag ) { FILE * pOutFile ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; pOutFile = pDiag -> pOutFile ; /* Correction for the image bytes */ lFilePosition = ftell ( pOutFile ) ; vFPprintf ( pOutFile , \"EI\\n\" ) ; vFPprintf ( pOutFile , \"Q\\n\" ) ; vFPprintf ( pOutFile , \"BT\\n\" ) ; pDiag -> lXleft = 0 ; }",
    "resources/antiword/pdf.c@bAddDummyImagePDF": "",
    "resources/antiword/pdf.c@vAddFontsPDF": "void vAddFontsPDF ( diagram_type * pDiag ) { FILE * pOutFile ; size_t tIndex ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; pOutFile = pDiag -> pOutFile ; /* The font encoding */ vSetLocation ( 4 ) ; vFPprintf ( pOutFile , \"4 0 obj\\n\" ) ; vFPprintf ( pOutFile , \"<<\\n\" ) ; vFPprintf ( pOutFile , \"/Type /Encoding\\n\" ) ; vFPprintf ( pOutFile , \"/BaseEncoding /StandardEncoding\\n\" ) ; vFPprintf ( pOutFile , \"/Differences [\\n\" ) ; switch ( eEncoding ) { case encoding_latin_1 : for ( tIndex = 0 ; tIndex < elementsof ( iso_8859_1 ) ; tIndex ++ ) { vFPprintf ( pOutFile , \"%s\\n\" , iso_8859_1 [ tIndex ] ) ; } break ; case encoding_latin_2 : for ( tIndex = 0 ; tIndex < elementsof ( iso_8859_2 ) ; tIndex ++ ) { vFPprintf ( pOutFile , \"%s\\n\" , iso_8859_2 [ tIndex ] ) ; } break ; case encoding_cyrillic : werr ( 1 , \"The combination PDF and Cyrillic is not supported\" ) ; break ; case encoding_utf_8 : werr ( 1 , \"The combination PDF and UTF-8 is not supported\" ) ; break ; default : DBG_DEC ( eEncoding ) ; break ; } vFPprintf ( pOutFile , \"]\\n\" ) ; vFPprintf ( pOutFile , \">>\\n\" ) ; vFPprintf ( pOutFile , \"endobj\\n\" ) ; /* Twelve of the standard type 1 fonts */ for ( tIndex = 0 ; tIndex < 12 ; tIndex ++ ) { vSetLocation ( 5 + tIndex ) ; vFPprintf ( pOutFile , \"%u 0 obj\\n\" , 5 + tIndex ) ; vFPprintf ( pOutFile , \"<<\\n\" ) ; vFPprintf ( pOutFile , \"/Type /Font\\n\" ) ; vFPprintf ( pOutFile , \"/Subtype /Type1\\n\" ) ; vFPprintf ( pOutFile , \"/Name /F%u\\n\" , 1 + tIndex ) ; vFPprintf ( pOutFile , \"/BaseFont /%s\\n\" , atFontname [ tIndex ] . szPDFname ) ; vFPprintf ( pOutFile , \"/Encoding 4 0 R\\n\" ) ; vFPprintf ( pOutFile , \">>\\n\" ) ; vFPprintf ( pOutFile , \"endobj\\n\" ) ; } /* The Resources */ vSetLocation ( 17 ) ; vFPprintf ( pOutFile , \"17 0 obj\\n\" ) ; vFPprintf ( pOutFile , \"<<\\n\" ) ; vFPprintf ( pOutFile , \"/ProcSet [ /PDF /Text ]\\n\" ) ; vFPprintf ( pOutFile , \"/Font <<\\n\" ) ; for ( tIndex = 0 ; tIndex < 12 ; tIndex ++ ) { vFPprintf ( pOutFile , \"\\t/F%u %u 0 R\\n\" , 1 + tIndex , 5 + tIndex ) ; } vFPprintf ( pOutFile , \"\\t>>\\n\" ) ; vFPprintf ( pOutFile , \">>\\n\" ) ; vFPprintf ( pOutFile , \"endobj\\n\" ) ; vAddHeader ( pDiag ) ; }",
    "resources/antiword/pdf.c@vPrintPDF": "static void vPrintPDF ( FILE * pFile , const char * szString , size_t tStringLength , USHORT usFontstyle ) { const UCHAR * aucBytes ; double dMove ; size_t tCount ; fail ( szString == NULL ) ; if ( szString == NULL || szString [ 0 ] == '\\0' || tStringLength == 0 ) { return ; } DBG_DEC_C ( usFontSizeCurr < MIN_FONT_SIZE , usFontSizeCurr ) ; dMove = 0.0 ; /* Up for superscript */ if ( bIsSuperscript ( usFontstyle ) && usFontSizeCurr != 0 ) { dMove = ( double ) ( ( usFontSizeCurr + 1 ) / 2 ) * 0.375 ; vFPprintf ( pFile , \"%.2f Ts\\n\" , dMove ) ; } /* Down for subscript */ if ( bIsSubscript ( usFontstyle ) && usFontSizeCurr != 0 ) { dMove = ( double ) usFontSizeCurr * 0.125 ; vFPprintf ( pFile , \"%.2f Ts\\n\" , - dMove ) ; } /* Generate and print the PDF output */ aucBytes = ( UCHAR * ) szString ; vFPprintf ( pFile , \"(\" ) ; for ( tCount = 0 ; tCount < tStringLength ; tCount ++ ) { switch ( aucBytes [ tCount ] ) { case '(' : case ')' : case '\\\\' : vFPprintf ( pFile , \"\\\\%c\" , szString [ tCount ] ) ; break ; default : if ( aucBytes [ tCount ] < 0x20 || aucBytes [ tCount ] == 0x7f || ( aucBytes [ tCount ] >= 0x81 && aucBytes [ tCount ] < 0x8c ) ) { DBG_HEX ( aucBytes [ tCount ] ) ; vFPprintf ( pFile , \" \" ) ; } else if ( aucBytes [ tCount ] >= 0x80 ) { vFPprintf ( pFile , \"\\\\%03o\" , ( UINT ) aucBytes [ tCount ] ) ; } else { vFPprintf ( pFile , \"%c\" , szString [ tCount ] ) ; } break ; } } vFPprintf ( pFile , \") Tj\\n\" ) ; /* Undo the superscript/subscript move */ if ( dMove != 0.0 ) { vFPprintf ( pFile , \"0 Ts\\n\" ) ; } }",
    "resources/antiword/pdf.c@vSetColor": "static void vSetColor ( FILE * pFile , UCHAR ucFontColor ) { ULONG ulTmp , ulRed , ulGreen , ulBlue ; ulTmp = ulColor2Color ( ucFontColor ) ; ulRed = ( ulTmp & 0x0000ff00 ) >> 8 ; ulGreen = ( ulTmp & 0x00ff0000 ) >> 16 ; ulBlue = ( ulTmp & 0xff000000 ) >> 24 ; vFPprintf ( pFile , \"%.3f %.3f %.3f rg\\n\" , ulRed / 255.0 , ulGreen / 255.0 , ulBlue / 255.0 ) ; }",
    "resources/antiword/pdf.c@vMove2NextLinePDF": "void vMove2NextLinePDF ( diagram_type * pDiag , USHORT usFontSize ) { fail ( pDiag == NULL ) ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; pDiag -> lYtop -= lComputeLeading ( usFontSize ) ; }",
    "resources/antiword/pdf.c@vSubstringPDF": "void vSubstringPDF ( diagram_type * pDiag , char * szString , size_t tStringLength , long lStringWidth , UCHAR ucFontColor , USHORT usFontstyle , drawfile_fontref tFontRef , USHORT usFontSize , USHORT usMaxFontSize ) { size_t tFontIndex ; fail ( pDiag == NULL || szString == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( pDiag -> lXleft < 0 ) ; fail ( tStringLength != strlen ( szString ) ) ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; fail ( usMaxFontSize < MIN_FONT_SIZE || usMaxFontSize > MAX_FONT_SIZE ) ; fail ( usFontSize > usMaxFontSize ) ; if ( szString [ 0 ] == '\\0' || tStringLength == 0 ) { return ; } vMoveTo ( pDiag , lComputeLeading ( usMaxFontSize ) ) ; if ( tFontRef != tFontRefCurr || usFontSize != usFontSizeCurr ) { tFontIndex = tGetFontIndex ( tFontRef ) ; vFPprintf ( pDiag -> pOutFile , \"/F%u %.1f Tf\\n\" , 1 + tFontIndex , ( double ) usFontSize / 2.0 ) ; tFontRefCurr = tFontRef ; usFontSizeCurr = usFontSize ; } if ( ( int ) ucFontColor != iFontColorCurr ) { vSetColor ( pDiag -> pOutFile , ucFontColor ) ; iFontColorCurr = ( int ) ucFontColor ; } vPrintPDF ( pDiag -> pOutFile , szString , tStringLength , usFontstyle ) ; pDiag -> lXleft += lStringWidth ; }",
    "resources/antiword/pdf.c@vStartOfParagraphPDF": "void vStartOfParagraphPDF ( diagram_type * pDiag , long lBeforeIndentation ) { fail ( pDiag == NULL ) ; fail ( lBeforeIndentation < 0 ) ; pDiag -> lXleft = 0 ; pDiag -> lYtop -= lMilliPoints2DrawUnits ( lBeforeIndentation ) ; }",
    "resources/antiword/pdf.c@vEndOfParagraphPDF": "void vEndOfParagraphPDF ( diagram_type * pDiag , USHORT usFontSize , long lAfterIndentation ) { fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; fail ( lAfterIndentation < 0 ) ; if ( pDiag -> lXleft > 0 ) { /* To the start of the line */ vMove2NextLinePDF ( pDiag , usFontSize ) ; } pDiag -> lXleft = 0 ; pDiag -> lYtop -= lMilliPoints2DrawUnits ( lAfterIndentation ) ; }",
    "resources/antiword/pdf.c@vEndOfPagePDF": "void vEndOfPagePDF ( diagram_type * pDiag , BOOL bNewSection ) { vMove2NextPage ( pDiag , bNewSection ) ; }",
    "resources/antiword/utf8.c@bIsZeroWidthChar": "static BOOL bIsZeroWidthChar ( ULONG ucs ) { int low = 0 ; int high = elementsof ( combining ) - 1 ; int mid ; if ( ucs < ( ULONG ) combining [ low ] . first || ucs > ( ULONG ) combining [ high ] . last ) { return FALSE ; } while ( high >= low ) { mid = ( low + high ) / 2 ; if ( ucs > ( ULONG ) combining [ mid ] . last ) { low = mid + 1 ; } else if ( ucs < ( ULONG ) combining [ mid ] . first ) { high = mid - 1 ; } else { return TRUE ; } } return FALSE ; }",
    "resources/antiword/utf8.c@iWcWidth": "static int iWcWidth ( ULONG ucs ) { /* Test for 8-bit control characters */ if ( ucs == 0 ) { return 0 ; } if ( ucs < 0x20 || ( ucs >= 0x7f && ucs < 0xa0 ) ) { NO_DBG_HEX ( ucs ) ; return - 1 ; } /* Binary search in table of non-spacing characters */ if ( bIsZeroWidthChar ( ucs ) ) { return 0 ; } /* Ucs is not a combining or C0/C1 control character */ return 1 + ( ucs >= 0x1100 && ( ucs <= 0x115f || /* Hangul Jamo init. consonants */ ( ucs >= 0x2e80 && ucs <= 0xa4cf && ( ucs & ~ 0x0011 ) != 0x300a && ucs != 0x303f ) || /* CJK ... Yi */ ( ucs >= 0xac00 && ucs <= 0xd7a3 ) || /* Hangul Syllables */ ( ucs >= 0xf900 && ucs <= 0xfaff ) || /* CJK Compatibility Ideographs */ ( ucs >= 0xfe30 && ucs <= 0xfe6f ) || /* CJK Compatibility Forms */ ( ucs >= 0xff00 && ucs <= 0xff5f ) || /* Fullwidth Forms */ ( ucs >= 0xffe0 && ucs <= 0xffe6 ) || ( ucs >= 0x20000 && ucs <= 0x2ffff ) ) ) ; }",
    "resources/antiword/utf8.c@utf8_to_ucs": "static ULONG utf8_to_ucs ( const char * p , int iStrLen , int * piUtfLen ) { ULONG ulUcs ; int iIndex , iCharLen ; fail ( p == NULL || piUtfLen == NULL ) ; fail ( iStrLen < 1 ) ; ulUcs = ( ULONG ) ( UCHAR ) p [ 0 ] ; if ( ulUcs < 0x80 ) { * piUtfLen = 1 ; return ulUcs ; } if ( ulUcs < 0xe0 ) { iCharLen = 2 ; ulUcs &= 0x1f ; } else if ( ulUcs < 0xf0 ) { iCharLen = 3 ; ulUcs &= 0x0f ; } else if ( ulUcs < 0xf8 ) { iCharLen = 4 ; ulUcs &= 0x07 ; } else if ( ulUcs < 0xfc ) { iCharLen = 5 ; ulUcs &= 0x03 ; } else { iCharLen = 6 ; ulUcs &= 0x01 ; } for ( iIndex = 1 ; iIndex < iCharLen ; iIndex ++ ) { ulUcs <<= 6 ; if ( iIndex < iStrLen ) { ulUcs |= ( ULONG ) ( UCHAR ) p [ iIndex ] & 0x3f ; } } * piUtfLen = iCharLen ; return ulUcs ; }",
    "resources/antiword/utf8.c@utf8_strwidth": "long utf8_strwidth ( const char * pcString , size_t tNumchars ) { ULONG ulUcs ; long lTotal ; int iToGo , iWidth , iUtflen ; fail ( pcString == NULL || tNumchars > ( size_t ) INT_MAX ) ; lTotal = 0 ; iToGo = ( int ) tNumchars ; while ( iToGo > 0 && * pcString != '\\0' ) { ulUcs = utf8_to_ucs ( pcString , iToGo , & iUtflen ) ; iWidth = iWcWidth ( ulUcs ) ; if ( iWidth > 0 ) { lTotal += iWidth ; } pcString += iUtflen ; iToGo -= iUtflen ; } NO_DBG_DEC ( lTotal ) ; return lTotal ; }",
    "resources/antiword/utf8.c@utf8_chrlength": "int utf8_chrlength ( const char * p ) { int iUtflen ; fail ( p == NULL ) ; iUtflen = - 1 ; /* Just to make sure */ ( void ) utf8_to_ucs ( p , INT_MAX , & iUtflen ) ; NO_DBG_DEC ( iUtflen ) ; return iUtflen ; }",
    "resources/antiword/utf8.c@is_locale_utf8": "",
    "resources/antiword/unix.c@werr": "void werr ( int iFatal , const char * szFormat , ... ) { va_list tArg ; va_start ( tArg , szFormat ) ; ( void ) vfprintf ( stderr , szFormat , tArg ) ; va_end ( tArg ) ; fprintf ( stderr , \"\\n\" ) ; switch ( iFatal ) { case 0 : /* The message is just a warning, so no exit */ return ; case 1 : /* Fatal error with a standard exit */ exit ( EXIT_FAILURE ) ; default : /* Fatal error with a non-standard exit */ exit ( iFatal ) ; } }",
    "resources/antiword/unix.c@Hourglass_On": "void Hourglass_On ( void ) { }",
    "resources/antiword/unix.c@Hourglass_Off": "void Hourglass_Off ( void ) { }",
    "resources/antiword/wordlib.c@bCheckBytes": "static BOOL bCheckBytes ( FILE * pFile , const UCHAR * aucBytes , size_t tBytes ) { int iIndex , iChar ; fail ( pFile == NULL || aucBytes == NULL || tBytes == 0 ) ; rewind ( pFile ) ; for ( iIndex = 0 ; iIndex < ( int ) tBytes ; iIndex ++ ) { iChar = getc ( pFile ) ; if ( iChar == EOF || iChar != ( int ) aucBytes [ iIndex ] ) { NO_DBG_HEX ( iChar ) ; NO_DBG_HEX ( aucBytes [ iIndex ] ) ; return FALSE ; } } return TRUE ; }",
    "resources/antiword/wordlib.c@bIsWordForDosFile": "",
    "resources/antiword/wordlib.c@bIsWordFileWithOLE": "static BOOL bIsWordFileWithOLE ( FILE * pFile , long lFilesize ) { static UCHAR aucBytes [ ] = { 0xd0 , 0xcf , 0x11 , 0xe0 , 0xa1 , 0xb1 , 0x1a , 0xe1 } ; int iTailLen ; if ( pFile == NULL || lFilesize < 0 ) { DBG_MSG ( \"No proper file given\" ) ; return FALSE ; } if ( lFilesize < ( long ) BIG_BLOCK_SIZE * 3 ) { DBG_MSG ( \"This file is too small to be a Word document\" ) ; return FALSE ; } iTailLen = ( int ) ( lFilesize % BIG_BLOCK_SIZE ) ; switch ( iTailLen ) { case 0 : /* No tail, as it should be */ break ; case 1 : case 2 : /* Filesize mismatch or a buggy email program */ if ( ( int ) ( lFilesize % 3 ) == iTailLen ) { DBG_DEC ( lFilesize ) ; return FALSE ; } /*\n\t\t * Ignore extra bytes caused by buggy email programs.\n\t\t * They have bugs in their base64 encoding or decoding.\n\t\t * 3 bytes -> 4 ascii chars -> 3 bytes\n\t\t */ DBG_MSG ( \"Document with extra bytes\" ) ; break ; default : /* Wrong filesize for a Word document */ DBG_DEC ( lFilesize ) ; DBG_DEC ( iTailLen ) ; return FALSE ; } return bCheckBytes ( pFile , aucBytes , elementsof ( aucBytes ) ) ; }",
    "resources/antiword/wordlib.c@bIsRtfFile": "",
    "resources/antiword/wordlib.c@bIsWordPerfectFile": "",
    "resources/antiword/wordlib.c@bIsWinWord12File": "",
    "resources/antiword/wordlib.c@bIsMacWord45File": "",
    "resources/antiword/wordlib.c@iGuessVersionNumber": "int iGuessVersionNumber ( FILE * pFile , long lFilesize ) { if ( bIsWordForDosFile ( pFile , lFilesize ) ) { return 0 ; } if ( bIsWinWord12File ( pFile , lFilesize ) ) { return 2 ; } if ( bIsMacWord45File ( pFile ) ) { return 5 ; } if ( bIsWordFileWithOLE ( pFile , lFilesize ) ) { return 6 ; } return - 1 ; }",
    "resources/antiword/wordlib.c@iGetVersionNumber": "int iGetVersionNumber ( const UCHAR * aucHeader ) { USHORT usFib , usChse ; usFib = usGetWord ( 0x02 , aucHeader ) ; if ( usFib >= 0x1000 ) { /* To big: must be MacWord using Big Endian */ DBG_HEX ( usFib ) ; usFib = usGetWordBE ( 0x02 , aucHeader ) ; } DBG_DEC ( usFib ) ; bOldMacFile = FALSE ; switch ( usFib ) { case 0 : DBG_MSG ( \"Word for DOS\" ) ; return 0 ; case 28 : DBG_MSG ( \"Word 4 for Macintosh\" ) ; bOldMacFile = TRUE ; return 4 ; case 33 : DBG_MSG ( \"Word 1.x for Windows\" ) ; return 1 ; case 35 : DBG_MSG ( \"Word 5 for Macintosh\" ) ; bOldMacFile = TRUE ; return 5 ; case 45 : DBG_MSG ( \"Word 2 for Windows\" ) ; return 2 ; case 101 : case 102 : DBG_MSG ( \"Word 6 for Windows\" ) ; return 6 ; case 103 : case 104 : usChse = usGetWord ( 0x14 , aucHeader ) ; DBG_DEC ( usChse ) ; switch ( usChse ) { case 0 : DBG_MSG ( \"Word 7 for Win95\" ) ; return 7 ; case 256 : DBG_MSG ( \"Word 6 for Macintosh\" ) ; bOldMacFile = TRUE ; return 6 ; default : DBG_FIXME ( ) ; if ( ( int ) ucGetByte ( 0x05 , aucHeader ) == 0xe0 ) { DBG_MSG ( \"Word 7 for Win95\" ) ; return 7 ; } DBG_MSG ( \"Word 6 for Macintosh\" ) ; bOldMacFile = TRUE ; return 6 ; } default : usChse = usGetWord ( 0x14 , aucHeader ) ; DBG_DEC ( usChse ) ; if ( usFib < 192 ) { /* Unknown or unsupported version of Word */ DBG_DEC ( usFib ) ; return - 1 ; } DBG_MSG_C ( usChse != 256 , \"Word97 for Win95/98/NT\" ) ; DBG_MSG_C ( usChse == 256 , \"Word98 for Macintosh\" ) ; return 8 ; } }",
    "resources/antiword/wordlib.c@bIsOldMacFile": "",
    "resources/antiword/wordlib.c@iInitDocument": "int iInitDocument ( FILE * pFile , long lFilesize ) { int iGuess , iWordVersion ; iGuess = iGuessVersionNumber ( pFile , lFilesize ) ; switch ( iGuess ) { case 0 : iWordVersion = iInitDocumentDOS ( pFile , lFilesize ) ; break ; case 2 : iWordVersion = iInitDocumentWIN ( pFile , lFilesize ) ; break ; case 5 : iWordVersion = iInitDocumentMAC ( pFile , lFilesize ) ; break ; case 6 : iWordVersion = iInitDocumentOLE ( pFile , lFilesize ) ; break ; default : DBG_DEC ( iGuess ) ; iWordVersion = - 1 ; break ; } return iWordVersion ; }",
    "resources/antiword/wordlib.c@vFreeDocument": "void vFreeDocument ( void ) { DBG_MSG ( \"vFreeDocument\" ) ; /* Free the memory */ vDestroyTextBlockList ( ) ; vDestroyDataBlockList ( ) ; vDestroyListInfoList ( ) ; vDestroyRowInfoList ( ) ; vDestroyStyleInfoList ( ) ; vDestroyFontInfoList ( ) ; vDestroyStylesheetList ( ) ; vDestroyPictInfoList ( ) ; vDestroyDocumentInfoList ( ) ; vDestroySectionInfoList ( ) ; vDestroyHdrFtrInfoList ( ) ; vDestroyPropModList ( ) ; vDestroyNotesInfoLists ( ) ; vDestroyFontTable ( ) ; vDestroySummaryInfo ( ) ; }",
    "resources/antiword/hdrftrlist.c@vDestroyHdrFtrInfoList": "void vDestroyHdrFtrInfoList ( void ) { hdrftr_mem_type * pRecord ; output_type * pCurr , * pNext ; size_t tHdrFtr , tIndex ; DBG_MSG ( \"vDestroyHdrFtrInfoList\" ) ; /* Free the Header/footer Information List */ for ( tHdrFtr = 0 ; tHdrFtr < tHdrFtrLen ; tHdrFtr ++ ) { pRecord = pHdrFtrList + tHdrFtr ; for ( tIndex = 0 ; tIndex < elementsof ( pRecord -> atElement ) ; tIndex ++ ) { if ( ! pRecord -> atElement [ tIndex ] . bTextOriginal ) { continue ; } pCurr = pRecord -> atElement [ tIndex ] . tInfo . pText ; while ( pCurr != NULL ) { pCurr -> szStorage = xfree ( pCurr -> szStorage ) ; pNext = pCurr -> pNext ; pCurr = xfree ( pCurr ) ; pCurr = pNext ; } } } pHdrFtrList = xfree ( pHdrFtrList ) ; /* Reset all control variables */ tHdrFtrLen = 0 ; }",
    "resources/antiword/hdrftrlist.c@vCreat8HdrFtrInfoList": "void vCreat8HdrFtrInfoList ( const ULONG * aulCharPos , size_t tLength ) { hdrftr_mem_type * pListMember ; size_t tHdrFtr , tIndex , tMainIndex ; fail ( aulCharPos == NULL ) ; DBG_DEC ( tLength ) ; if ( tLength <= 1 ) { return ; } tHdrFtrLen = tLength / 12 ; if ( tLength % 12 != 0 && tLength % 12 != 1 ) { tHdrFtrLen ++ ; } DBG_DEC ( tHdrFtrLen ) ; pHdrFtrList = xcalloc ( tHdrFtrLen , sizeof ( hdrftr_mem_type ) ) ; for ( tHdrFtr = 0 ; tHdrFtr < tHdrFtrLen ; tHdrFtr ++ ) { pListMember = pHdrFtrList + tHdrFtr ; for ( tIndex = 0 , tMainIndex = tHdrFtr * 12 ; tIndex < 6 && tMainIndex < tLength ; tIndex ++ , tMainIndex ++ ) { pListMember -> atElement [ tIndex ] . tInfo . pText = NULL ; pListMember -> atElement [ tIndex ] . ulCharPosStart = aulCharPos [ tMainIndex ] ; if ( tMainIndex + 1 < tLength ) { pListMember -> atElement [ tIndex ] . ulCharPosNext = aulCharPos [ tMainIndex + 1 ] ; } else { pListMember -> atElement [ tIndex ] . ulCharPosNext = aulCharPos [ tMainIndex ] ; } } } }",
    "resources/antiword/hdrftrlist.c@vCreat6HdrFtrInfoList": "void vCreat6HdrFtrInfoList ( const ULONG * aulCharPos , size_t tLength ) { static const size_t atIndex [ ] = { SIZE_T_MAX , SIZE_T_MAX , FTR_FIRST_PAGE , HDR_FIRST_PAGE , FTR_ODD_PAGES , FTR_EVEN_PAGES , HDR_ODD_PAGES , HDR_EVEN_PAGES , } ; hdrftr_mem_type * pListMember ; size_t tHdrFtr , tTmp , tIndex , tMainIndex , tBit ; UCHAR ucDopSpecification , ucSepSpecification ; fail ( aulCharPos == NULL ) ; DBG_DEC ( tLength ) ; if ( tLength <= 1 ) { return ; } tHdrFtrLen = tGetNumberOfSections ( ) ; if ( tHdrFtrLen == 0 ) { tHdrFtrLen = 1 ; } DBG_DEC ( tHdrFtrLen ) ; pHdrFtrList = xcalloc ( tHdrFtrLen , sizeof ( hdrftr_mem_type ) ) ; /* Get the start index in aulCharPos */ ucDopSpecification = ucGetDopHdrFtrSpecification ( ) ; DBG_HEX ( ucDopSpecification & 0xe0 ) ; tMainIndex = 0 ; for ( tBit = 7 ; tBit >= 5 ; tBit -- ) { if ( ( ucDopSpecification & BIT ( tBit ) ) != 0 ) { tMainIndex ++ ; } } DBG_DEC ( tMainIndex ) ; for ( tHdrFtr = 0 ; tHdrFtr < tHdrFtrLen ; tHdrFtr ++ ) { ucSepSpecification = ucGetSepHdrFtrSpecification ( tHdrFtr ) ; DBG_HEX ( ucSepSpecification & 0xfc ) ; pListMember = pHdrFtrList + tHdrFtr ; for ( tTmp = 0 ; tTmp < elementsof ( pListMember -> atElement ) ; tTmp ++ ) { pListMember -> atElement [ tTmp ] . tInfo . pText = NULL ; } for ( tBit = 7 ; tBit >= 2 ; tBit -- ) { if ( tMainIndex >= tLength ) { break ; } if ( ( ucSepSpecification & BIT ( tBit ) ) == 0 ) { continue ; } tIndex = atIndex [ tBit ] ; fail ( tIndex >= 6 ) ; pListMember -> atElement [ tIndex ] . ulCharPosStart = aulCharPos [ tMainIndex ] ; if ( tMainIndex + 1 < tLength ) { pListMember -> atElement [ tIndex ] . ulCharPosNext = aulCharPos [ tMainIndex + 1 ] ; } else { pListMember -> atElement [ tIndex ] . ulCharPosNext = aulCharPos [ tMainIndex ] ; } tMainIndex ++ ; } } }",
    "resources/antiword/hdrftrlist.c@vCreat2HdrFtrInfoList": "void vCreat2HdrFtrInfoList ( const ULONG * aulCharPos , size_t tLength ) { vCreat6HdrFtrInfoList ( aulCharPos , tLength ) ; }",
    "resources/antiword/hdrftrlist.c@pGetHdrFtrInfo": "const hdrftr_block_type * pGetHdrFtrInfo ( int iSectionIndex , BOOL bWantHeader , BOOL bOddPage , BOOL bFirstInSection ) { hdrftr_mem_type * pCurr ; fail ( iSectionIndex < 0 ) ; fail ( pHdrFtrList == NULL && tHdrFtrLen != 0 ) ; if ( pHdrFtrList == NULL || tHdrFtrLen == 0 ) { /* No information */ return NULL ; } if ( iSectionIndex < 0 ) { iSectionIndex = 0 ; } else if ( iSectionIndex >= ( int ) tHdrFtrLen ) { iSectionIndex = ( int ) ( tHdrFtrLen - 1 ) ; } pCurr = pHdrFtrList + iSectionIndex ; if ( bFirstInSection ) { if ( bWantHeader ) { return & pCurr -> atElement [ HDR_FIRST_PAGE ] . tInfo ; } else { return & pCurr -> atElement [ FTR_FIRST_PAGE ] . tInfo ; } } else { if ( bWantHeader ) { if ( bOddPage ) { return & pCurr -> atElement [ HDR_ODD_PAGES ] . tInfo ; } else { return & pCurr -> atElement [ HDR_EVEN_PAGES ] . tInfo ; } } else { if ( bOddPage ) { return & pCurr -> atElement [ FTR_ODD_PAGES ] . tInfo ; } else { return & pCurr -> atElement [ FTR_EVEN_PAGES ] . tInfo ; } } } }",
    "resources/antiword/hdrftrlist.c@lComputeHdrFtrHeight": "static long lComputeHdrFtrHeight ( const output_type * pAnchor ) { const output_type * pCurr ; long lTotal ; USHORT usFontSizeMax ; lTotal = 0 ; usFontSizeMax = 0 ; for ( pCurr = pAnchor ; pCurr != NULL ; pCurr = pCurr -> pNext ) { if ( pCurr -> tNextFree == 1 ) { if ( pCurr -> szStorage [ 0 ] == PAR_END ) { /* End of a paragraph */ lTotal += lComputeLeading ( usFontSizeMax ) ; lTotal += lMilliPoints2DrawUnits ( ( long ) pCurr -> usFontSize * 200 ) ; usFontSizeMax = 0 ; continue ; } if ( pCurr -> szStorage [ 0 ] == HARD_RETURN ) { /* End of a line */ lTotal += lComputeLeading ( usFontSizeMax ) ; usFontSizeMax = 0 ; continue ; } } if ( pCurr -> usFontSize > usFontSizeMax ) { usFontSizeMax = pCurr -> usFontSize ; } } if ( usFontSizeMax != 0 ) { /* Height of the last paragraph */ lTotal += lComputeLeading ( usFontSizeMax ) ; } return lTotal ; }",
    "resources/antiword/hdrftrlist.c@vPrepareHdrFtrText": "void vPrepareHdrFtrText ( FILE * pFile ) { hdrftr_mem_type * pCurr , * pPrev ; hdrftr_local_type * pTmp ; output_type * pText ; size_t tHdrFtr , tIndex ; fail ( pFile == NULL ) ; fail ( pHdrFtrList == NULL && tHdrFtrLen != 0 ) ; if ( pHdrFtrList == NULL || tHdrFtrLen == 0 ) { /* No information */ return ; } /* Fill text, text height and useful-ness */ for ( tHdrFtr = 0 ; tHdrFtr < tHdrFtrLen ; tHdrFtr ++ ) { pCurr = pHdrFtrList + tHdrFtr ; for ( tIndex = 0 ; tIndex < elementsof ( pHdrFtrList -> atElement ) ; tIndex ++ ) { pTmp = & pCurr -> atElement [ tIndex ] ; pTmp -> bUseful = pTmp -> ulCharPosStart != pTmp -> ulCharPosNext ; if ( pTmp -> bUseful ) { pText = pHdrFtrDecryptor ( pFile , pTmp -> ulCharPosStart , pTmp -> ulCharPosNext ) ; pTmp -> tInfo . pText = pText ; pTmp -> tInfo . lHeight = lComputeHdrFtrHeight ( pText ) ; pTmp -> bTextOriginal = pText != NULL ; } else { pTmp -> tInfo . pText = NULL ; pTmp -> tInfo . lHeight = 0 ; pTmp -> bTextOriginal = FALSE ; } } } /* Replace not-useful records by using inheritance */ if ( pHdrFtrList -> atElement [ HDR_FIRST_PAGE ] . bUseful ) { pTmp = & pHdrFtrList -> atElement [ HDR_ODD_PAGES ] ; if ( ! pTmp -> bUseful ) { * pTmp = pHdrFtrList -> atElement [ HDR_FIRST_PAGE ] ; pTmp -> bTextOriginal = FALSE ; } pTmp = & pHdrFtrList -> atElement [ HDR_EVEN_PAGES ] ; if ( ! pTmp -> bUseful ) { * pTmp = pHdrFtrList -> atElement [ HDR_FIRST_PAGE ] ; pTmp -> bTextOriginal = FALSE ; } } if ( pHdrFtrList -> atElement [ FTR_FIRST_PAGE ] . bUseful ) { pTmp = & pHdrFtrList -> atElement [ FTR_ODD_PAGES ] ; if ( ! pTmp -> bUseful ) { * pTmp = pHdrFtrList -> atElement [ FTR_FIRST_PAGE ] ; pTmp -> bTextOriginal = FALSE ; } pTmp = & pHdrFtrList -> atElement [ FTR_EVEN_PAGES ] ; if ( ! pTmp -> bUseful ) { * pTmp = pHdrFtrList -> atElement [ FTR_FIRST_PAGE ] ; pTmp -> bTextOriginal = FALSE ; } } for ( tHdrFtr = 1 , pCurr = & pHdrFtrList [ 1 ] ; tHdrFtr < tHdrFtrLen ; tHdrFtr ++ , pCurr ++ ) { pPrev = pCurr - 1 ; for ( tIndex = 0 ; tIndex < elementsof ( pHdrFtrList -> atElement ) ; tIndex ++ ) { if ( ! pCurr -> atElement [ tIndex ] . bUseful && pPrev -> atElement [ tIndex ] . bUseful ) { pCurr -> atElement [ tIndex ] = pPrev -> atElement [ tIndex ] ; pCurr -> atElement [ tIndex ] . bTextOriginal = FALSE ; } } } }",
    "resources/antiword/png2sprt.c@bTranslatePNG": "",
    "resources/antiword/summary.c@vDestroySummaryInfo": "void vDestroySummaryInfo ( void ) { TRACE_MSG ( \"vDestroySummaryInfo\" ) ; szTitle = xfree ( szTitle ) ; szSubject = xfree ( szSubject ) ; szAuthor = xfree ( szAuthor ) ; tCreateDtm = ( time_t ) - 1 ; tLastSaveDtm = ( time_t ) - 1 ; szAppName = xfree ( szAppName ) ; szManager = xfree ( szManager ) ; szCompany = xfree ( szCompany ) ; usLid = ( USHORT ) - 1 ; }",
    "resources/antiword/summary.c@tConvertDosDate": "static time_t tConvertDosDate ( const char * szDosDate ) { struct tm tTime ; const char * pcTmp ; time_t tResult ; memset ( & tTime , 0 , sizeof ( tTime ) ) ; pcTmp = szDosDate ; /* Get the month */ if ( ! isdigit ( * pcTmp ) ) { return ( time_t ) - 1 ; } tTime . tm_mon = ( int ) ( * pcTmp - '0' ) ; pcTmp ++ ; if ( isdigit ( * pcTmp ) ) { tTime . tm_mon *= 10 ; tTime . tm_mon += ( int ) ( * pcTmp - '0' ) ; pcTmp ++ ; } /* Get the first separater */ if ( isalnum ( * pcTmp ) ) { return ( time_t ) - 1 ; } pcTmp ++ ; /* Get the day */ if ( ! isdigit ( * pcTmp ) ) { return ( time_t ) - 1 ; } tTime . tm_mday = ( int ) ( * pcTmp - '0' ) ; pcTmp ++ ; if ( isdigit ( * pcTmp ) ) { tTime . tm_mday *= 10 ; tTime . tm_mday += ( int ) ( * pcTmp - '0' ) ; pcTmp ++ ; } /* Get the second separater */ if ( isalnum ( * pcTmp ) ) { return ( time_t ) - 1 ; } pcTmp ++ ; /* Get the year */ if ( ! isdigit ( * pcTmp ) ) { return ( time_t ) - 1 ; } tTime . tm_year = ( int ) ( * pcTmp - '0' ) ; pcTmp ++ ; if ( isdigit ( * pcTmp ) ) { tTime . tm_year *= 10 ; tTime . tm_year += ( int ) ( * pcTmp - '0' ) ; pcTmp ++ ; } /* Check the values */ if ( tTime . tm_mon == 0 || tTime . tm_mday == 0 || tTime . tm_mday > 31 ) { return ( time_t ) - 1 ; } /* Correct the values */ tTime . tm_mon -- ; /* From 01-12 to 00-11 */ if ( tTime . tm_year < 80 ) { tTime . tm_year += 100 ; /* 00 means 2000 is 100 */ } tTime . tm_isdst = - 1 ; tResult = mktime ( & tTime ) ; NO_DBG_MSG ( ctime ( & tResult ) ) ; return tResult ; }",
    "resources/antiword/summary.c@szLpstr": "static char * szLpstr ( ULONG ulOffset , const UCHAR * aucBuffer ) { char * szStart , * szResult , * szTmp ; size_t tSize ; tSize = ( size_t ) ulGetLong ( ulOffset + 4 , aucBuffer ) ; NO_DBG_DEC ( tSize ) ; if ( tSize == 0 ) { return NULL ; } /* Remove white space from the start of the string */ szStart = ( char * ) aucBuffer + ulOffset + 8 ; NO_DBG_MSG ( szStart ) ; fail ( strlen ( szStart ) >= tSize ) ; while ( isspace ( * szStart ) ) { szStart ++ ; } if ( szStart [ 0 ] == '\\0' ) { return NULL ; } szResult = xstrdup ( szStart ) ; /* Remove white space from the end of the string */ szTmp = szResult + strlen ( szResult ) - 1 ; while ( isspace ( * szTmp ) ) { * szTmp = '\\0' ; szTmp -- ; } NO_DBG_MSG ( szResult ) ; return szResult ; }",
    "resources/antiword/summary.c@tFiletime": "static time_t tFiletime ( ULONG ulOffset , const UCHAR * aucBuffer ) { double dHi , dLo , dTmp ; ULONG ulHi , ulLo ; time_t tResult ; ulLo = ulGetLong ( ulOffset + 4 , aucBuffer ) ; ulHi = ulGetLong ( ulOffset + 8 , aucBuffer ) ; NO_DBG_HEX ( ulHi ) ; NO_DBG_HEX ( ulLo ) ; /* Move the starting point from 01 Jan 1601 to 01 Jan 1970 */ dHi = ( double ) ulHi - ( double ) TIME_OFFSET_HI ; dLo = ( double ) ulLo - ( double ) TIME_OFFSET_LO ; NO_DBG_FLT ( dHi ) ; NO_DBG_FLT ( dLo ) ; /* Combine the values and divide by 10^7 to get seconds */ dTmp = dLo / 10000000.0 ; /* 10^7 */ dTmp += dHi * 429.4967926 ; /* 2^32 / 10^7 */ NO_DBG_FLT ( dTmp ) ; /* Make a time_t */ if ( dTmp - 0.5 < TIME_T_MIN || dTmp + 0.5 > TIME_T_MAX ) { return ( time_t ) - 1 ; } tResult = dTmp < 0.0 ? ( time_t ) ( dTmp - 0.5 ) : ( time_t ) ( dTmp + 0.5 ) ; NO_DBG_MSG ( ctime ( & tResult ) ) ; return tResult ; }",
    "resources/antiword/summary.c@vAnalyseSummaryInfo": "static void vAnalyseSummaryInfo ( const UCHAR * aucBuffer ) { ULONG ulOffset ; size_t tIndex , tCount , tPropID , tPropType ; tCount = ( size_t ) ulGetLong ( 4 , aucBuffer ) ; DBG_DEC ( tCount ) ; for ( tIndex = 0 ; tIndex < tCount ; tIndex ++ ) { tPropID = ( size_t ) ulGetLong ( 8 + tIndex * 8 , aucBuffer ) ; ulOffset = ulGetLong ( 12 + tIndex * 8 , aucBuffer ) ; NO_DBG_DEC ( tPropID ) ; NO_DBG_HEX ( ulOffset ) ; tPropType = ( size_t ) ulGetLong ( ulOffset , aucBuffer ) ; NO_DBG_DEC ( tPropType ) ; switch ( tPropID ) { case PID_TITLE : if ( tPropType == VT_LPSTR && szTitle == NULL ) { szTitle = szLpstr ( ulOffset , aucBuffer ) ; } break ; case PID_SUBJECT : if ( tPropType == VT_LPSTR && szSubject == NULL ) { szSubject = szLpstr ( ulOffset , aucBuffer ) ; } break ; case PID_AUTHOR : if ( tPropType == VT_LPSTR && szAuthor == NULL ) { szAuthor = szLpstr ( ulOffset , aucBuffer ) ; } break ; case PID_CREATE_DTM : if ( tPropType == VT_FILETIME && tCreateDtm == ( time_t ) - 1 ) { tCreateDtm = tFiletime ( ulOffset , aucBuffer ) ; } break ; case PID_LASTSAVE_DTM : if ( tPropType == VT_FILETIME && tLastSaveDtm == ( time_t ) - 1 ) { tLastSaveDtm = tFiletime ( ulOffset , aucBuffer ) ; } break ; case PID_APPNAME : if ( tPropType == VT_LPSTR && szAppName == NULL ) { szAppName = szLpstr ( ulOffset , aucBuffer ) ; } break ; default : break ; } } }",
    "resources/antiword/summary.c@vAnalyseDocumentSummaryInfo": "static void vAnalyseDocumentSummaryInfo ( const UCHAR * aucBuffer ) { ULONG ulOffset ; size_t tIndex , tCount , tPropID , tPropType ; tCount = ( size_t ) ulGetLong ( 4 , aucBuffer ) ; DBG_DEC ( tCount ) ; for ( tIndex = 0 ; tIndex < tCount ; tIndex ++ ) { tPropID = ( size_t ) ulGetLong ( 8 + tIndex * 8 , aucBuffer ) ; ulOffset = ulGetLong ( 12 + tIndex * 8 , aucBuffer ) ; NO_DBG_DEC ( tPropID ) ; NO_DBG_HEX ( ulOffset ) ; tPropType = ( size_t ) ulGetLong ( ulOffset , aucBuffer ) ; NO_DBG_DEC ( tPropType ) ; switch ( tPropID ) { case PIDD_MANAGER : if ( tPropType == VT_LPSTR && szManager == NULL ) { szManager = szLpstr ( ulOffset , aucBuffer ) ; } break ; case PIDD_COMPANY : if ( tPropType == VT_LPSTR && szCompany == NULL ) { szCompany = szLpstr ( ulOffset , aucBuffer ) ; } break ; default : break ; } } }",
    "resources/antiword/summary.c@pucAnalyseSummaryInfoHeader": "static UCHAR * pucAnalyseSummaryInfoHeader ( FILE * pFile , ULONG ulStartBlock , ULONG ulSize , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen ) { const ULONG * aulBlockDepot ; UCHAR * aucBuffer ; size_t tBlockDepotLen , tBlockSize , tSectionCount , tLength ; ULONG ulTmp , ulOffset ; USHORT usLittleEndian , usEmpty , usOS , usVersion ; UCHAR aucHdr [ P_HEADER_SZ ] , aucSecLst [ P_SECTION_MAX_SZ ] ; if ( ulSize < MIN_SIZE_FOR_BBD_USE ) { /* Use the Small Block Depot */ aulBlockDepot = aulSBD ; tBlockDepotLen = tSBDLen ; tBlockSize = SMALL_BLOCK_SIZE ; } else { /* Use the Big Block Depot */ aulBlockDepot = aulBBD ; tBlockDepotLen = tBBDLen ; tBlockSize = BIG_BLOCK_SIZE ; } if ( tBlockDepotLen == 0 ) { DBG_MSG ( \"The Block Depot length is zero\" ) ; return NULL ; } /* Read the Summery Information header */ if ( ! bReadBuffer ( pFile , ulStartBlock , aulBlockDepot , tBlockDepotLen , tBlockSize , aucHdr , 0 , P_HEADER_SZ ) ) { return NULL ; } NO_DBG_PRINT_BLOCK ( aucHdr , P_HEADER_SZ ) ; /* Analyse the Summery Information header */ usLittleEndian = usGetWord ( 0 , aucHdr ) ; if ( usLittleEndian != 0xfffe ) { DBG_HEX ( usLittleEndian ) ; DBG_MSG_C ( usLittleEndian == 0xfeff , \"Big endian\" ) ; return NULL ; } usEmpty = usGetWord ( 2 , aucHdr ) ; if ( usEmpty != 0x0000 ) { DBG_DEC ( usEmpty ) ; return NULL ; } ulTmp = ulGetLong ( 4 , aucHdr ) ; DBG_HEX ( ulTmp ) ; usOS = ( USHORT ) ( ulTmp >> 16 ) ; usVersion = ( USHORT ) ( ulTmp & 0xffff ) ; switch ( usOS ) { case 0 : DBG_MSG ( \"Win16\" ) ; DBG_HEX ( usVersion ) ; break ; case 1 : DBG_MSG ( \"MacOS\" ) ; DBG_HEX ( usVersion ) ; break ; case 2 : DBG_MSG ( \"Win32\" ) ; DBG_HEX ( usVersion ) ; break ; default : DBG_DEC ( usOS ) ; DBG_HEX ( usVersion ) ; break ; } tSectionCount = ( size_t ) ulGetLong ( 24 , aucHdr ) ; DBG_DEC_C ( tSectionCount != 1 && tSectionCount != 2 , tSectionCount ) ; if ( tSectionCount != 1 && tSectionCount != 2 ) { return NULL ; } /* Read the Summery Information Section Lists */ if ( ! bReadBuffer ( pFile , ulStartBlock , aulBlockDepot , tBlockDepotLen , tBlockSize , aucSecLst , P_HEADER_SZ , P_SECTION_SZ ( tSectionCount ) ) ) { return NULL ; } NO_DBG_PRINT_BLOCK ( aucSecLst , P_SECTION_SZ ( tSectionCount ) ) ; ulTmp = ulGetLong ( 0 , aucSecLst ) ; DBG_HEX ( ulTmp ) ; ulTmp = ulGetLong ( 4 , aucSecLst ) ; DBG_HEX ( ulTmp ) ; ulTmp = ulGetLong ( 8 , aucSecLst ) ; DBG_HEX ( ulTmp ) ; ulTmp = ulGetLong ( 12 , aucSecLst ) ; DBG_HEX ( ulTmp ) ; ulOffset = ulGetLong ( 16 , aucSecLst ) ; DBG_DEC_C ( ulOffset != P_HEADER_SZ + P_SECTIONLIST_SZ && ulOffset != P_HEADER_SZ + 2 * P_SECTIONLIST_SZ , ulOffset ) ; fail ( ulOffset != P_HEADER_SZ + P_SECTIONLIST_SZ && ulOffset != P_HEADER_SZ + 2 * P_SECTIONLIST_SZ ) ; tLength = ( size_t ) ulGetLong ( tSectionCount * P_SECTIONLIST_SZ , aucSecLst ) ; NO_DBG_HEX ( tLength ) ; fail ( ulOffset + tLength > ulSize ) ; /* Read the Summery Information */ aucBuffer = xmalloc ( tLength ) ; if ( ! bReadBuffer ( pFile , ulStartBlock , aulBlockDepot , tBlockDepotLen , tBlockSize , aucBuffer , ulOffset , tLength ) ) { aucBuffer = xfree ( aucBuffer ) ; return NULL ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tLength ) ; return aucBuffer ; }",
    "resources/antiword/summary.c@vSet0SummaryInfo": "void vSet0SummaryInfo ( FILE * pFile , const UCHAR * aucHeader ) { UCHAR * aucBuffer ; ULONG ulBeginSumdInfo , ulBeginNextBlock ; size_t tLen ; USHORT usCodepage , usOffset ; TRACE_MSG ( \"vSet0SummaryInfo\" ) ; fail ( pFile == NULL || aucHeader == NULL ) ; /* First check the header */ usCodepage = usGetWord ( 0x7e , aucHeader ) ; DBG_DEC ( usCodepage ) ; switch ( usCodepage ) { case 850 : usLid = 0x0809 ; break ; /* Latin1 -> British English */ case 862 : usLid = 0x040d ; break ; /* Hebrew */ case 866 : usLid = 0x0419 ; break ; /* Russian */ case 0 : case 437 : default : usLid = 0x0409 ; break ; /* ASCII -> American English */ } /* Second check the summary information block */ ulBeginSumdInfo = 128 * ( ULONG ) usGetWord ( 0x1c , aucHeader ) ; DBG_HEX ( ulBeginSumdInfo ) ; ulBeginNextBlock = 128 * ( ULONG ) usGetWord ( 0x6a , aucHeader ) ; DBG_HEX ( ulBeginNextBlock ) ; if ( ulBeginSumdInfo >= ulBeginNextBlock || ulBeginNextBlock == 0 ) { /* There is no summary information block */ return ; } tLen = ( size_t ) ( ulBeginNextBlock - ulBeginSumdInfo ) ; aucBuffer = xmalloc ( tLen ) ; /* Read the summary information block */ if ( ! bReadBytes ( aucBuffer , tLen , ulBeginSumdInfo , pFile ) ) { return ; } usOffset = usGetWord ( 0 , aucBuffer ) ; if ( aucBuffer [ usOffset ] != 0 ) { NO_DBG_MSG ( aucBuffer + usOffset ) ; szTitle = xstrdup ( ( char * ) aucBuffer + usOffset ) ; } usOffset = usGetWord ( 2 , aucBuffer ) ; if ( aucBuffer [ usOffset ] != 0 ) { NO_DBG_MSG ( aucBuffer + usOffset ) ; szAuthor = xstrdup ( ( char * ) aucBuffer + usOffset ) ; } usOffset = usGetWord ( 12 , aucBuffer ) ; if ( aucBuffer [ usOffset ] != 0 ) { NO_DBG_STRN ( aucBuffer + usOffset , 8 ) ; tLastSaveDtm = tConvertDosDate ( ( char * ) aucBuffer + usOffset ) ; } usOffset = usGetWord ( 14 , aucBuffer ) ; if ( aucBuffer [ usOffset ] != 0 ) { NO_DBG_STRN ( aucBuffer + usOffset , 8 ) ; tCreateDtm = tConvertDosDate ( ( char * ) aucBuffer + usOffset ) ; } aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/summary.c@vSet2SummaryInfo": "void vSet2SummaryInfo ( FILE * pFile , int iWordVersion , const UCHAR * aucHeader ) { UCHAR * aucBuffer ; ULONG ulBeginSumdInfo , ulBeginDocpInfo , ulTmp ; size_t tSumdInfoLen , tDocpInfoLen , tLen , tCounter , tStart ; TRACE_MSG ( \"vSet2SummaryInfo\" ) ; fail ( pFile == NULL || aucHeader == NULL ) ; fail ( iWordVersion != 1 && iWordVersion != 2 ) ; /* First check the header */ usLid = usGetWord ( 0x06 , aucHeader ) ; /* Language IDentification */ DBG_HEX ( usLid ) ; if ( usLid < 999 && iWordVersion == 1 ) { switch ( usLid ) { case 1 : usLid = 0x0409 ; break ; /* American English */ case 2 : usLid = 0x0c0c ; break ; /* Canadian French */ case 31 : usLid = 0x0413 ; break ; /* Dutch */ case 33 : usLid = 0x040c ; break ; /* French */ case 34 : usLid = 0x040a ; break ; /* Spanish */ case 36 : usLid = 0x040e ; break ; /* Hungarian */ case 39 : usLid = 0x0410 ; break ; /* Italian */ case 44 : usLid = 0x0809 ; break ; /* British English */ case 45 : usLid = 0x0406 ; break ; /* Danish */ case 46 : usLid = 0x041f ; break ; /* Swedish */ case 47 : usLid = 0x0414 ; break ; /* Norwegian */ case 48 : usLid = 0x0415 ; break ; /* Polish */ case 49 : usLid = 0x0407 ; break ; /* German */ case 351 : usLid = 0x0816 ; break ; /* Portuguese */ case 358 : usLid = 0x040b ; break ; /* Finnish */ default : DBG_DEC ( usLid ) ; DBG_FIXME ( ) ; usLid = 0x0409 ; /* American English */ break ; } } if ( iWordVersion != 2 ) { /* Unknown where to find the associated strings */ return ; } /* Second check the associated strings */ ulBeginSumdInfo = ulGetLong ( 0x118 , aucHeader ) ; /* fcSttbfAssoc */ DBG_HEX ( ulBeginSumdInfo ) ; tSumdInfoLen = ( size_t ) usGetWord ( 0x11c , aucHeader ) ; /* cbSttbfAssoc */ DBG_DEC ( tSumdInfoLen ) ; if ( tSumdInfoLen == 0 ) { /* There is no summary information */ return ; } aucBuffer = xmalloc ( tSumdInfoLen ) ; if ( ! bReadBytes ( aucBuffer , tSumdInfoLen , ulBeginSumdInfo , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tSumdInfoLen ) ; tLen = ( size_t ) ucGetByte ( 0 , aucBuffer ) ; DBG_DEC_C ( tSumdInfoLen != tLen , tSumdInfoLen ) ; DBG_DEC_C ( tSumdInfoLen != tLen , tLen ) ; tStart = 1 ; for ( tCounter = 0 ; tCounter < 17 ; tCounter ++ ) { if ( tStart >= tSumdInfoLen ) { break ; } tLen = ( size_t ) ucGetByte ( tStart , aucBuffer ) ; if ( tLen != 0 ) { NO_DBG_DEC ( tCounter ) ; NO_DBG_STRN ( aucBuffer + tStart + 1 , tLen ) ; switch ( tCounter ) { case 3 : szTitle = xmalloc ( tLen + 1 ) ; strncpy ( szTitle , ( char * ) aucBuffer + tStart + 1 , tLen ) ; szTitle [ tLen ] = '\\0' ; break ; case 4 : szSubject = xmalloc ( tLen + 1 ) ; strncpy ( szSubject , ( char * ) aucBuffer + tStart + 1 , tLen ) ; szSubject [ tLen ] = '\\0' ; break ; case 7 : szAuthor = xmalloc ( tLen + 1 ) ; strncpy ( szAuthor , ( char * ) aucBuffer + tStart + 1 , tLen ) ; szAuthor [ tLen ] = '\\0' ; break ; default : break ; } } tStart += tLen + 1 ; } aucBuffer = xfree ( aucBuffer ) ; /* Third check the document properties */ ulBeginDocpInfo = ulGetLong ( 0x112 , aucHeader ) ; /* fcDop */ DBG_HEX ( ulBeginDocpInfo ) ; tDocpInfoLen = ( size_t ) usGetWord ( 0x116 , aucHeader ) ; /* cbDop */ DBG_DEC ( tDocpInfoLen ) ; if ( tDocpInfoLen < 12 ) { return ; } aucBuffer = xmalloc ( tDocpInfoLen ) ; if ( ! bReadBytes ( aucBuffer , tDocpInfoLen , ulBeginDocpInfo , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } ulTmp = ulGetLong ( 0x14 , aucBuffer ) ; /* dttmCreated */ tCreateDtm = tConvertDTTM ( ulTmp ) ; ulTmp = ulGetLong ( 0x18 , aucBuffer ) ; /* dttmRevised */ tLastSaveDtm = tConvertDTTM ( ulTmp ) ; aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/summary.c@vSetSummaryInfoOLE": "static void vSetSummaryInfoOLE ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen ) { UCHAR * pucBuffer ; fail ( pFile == NULL || pPPS == NULL ) ; fail ( aulBBD == NULL || aulSBD == NULL ) ; /* Summary Information */ pucBuffer = pucAnalyseSummaryInfoHeader ( pFile , pPPS -> tSummaryInfo . ulSB , pPPS -> tSummaryInfo . ulSize , aulBBD , tBBDLen , aulSBD , tSBDLen ) ; if ( pucBuffer != NULL ) { vAnalyseSummaryInfo ( pucBuffer ) ; pucBuffer = xfree ( pucBuffer ) ; } /* Document Summary Information */ pucBuffer = pucAnalyseSummaryInfoHeader ( pFile , pPPS -> tDocSummaryInfo . ulSB , pPPS -> tDocSummaryInfo . ulSize , aulBBD , tBBDLen , aulSBD , tSBDLen ) ; if ( pucBuffer != NULL ) { vAnalyseDocumentSummaryInfo ( pucBuffer ) ; pucBuffer = xfree ( pucBuffer ) ; } }",
    "resources/antiword/summary.c@vSet6SummaryInfo": "void vSet6SummaryInfo ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { TRACE_MSG ( \"vSet6SummaryInfo\" ) ; /* Header Information */ usLid = usGetWord ( 0x06 , aucHeader ) ; /* Language IDentification */ DBG_HEX ( usLid ) ; /* Summery Information */ vSetSummaryInfoOLE ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen ) ; }",
    "resources/antiword/summary.c@vSet8SummaryInfo": "void vSet8SummaryInfo ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { USHORT usTmp ; TRACE_MSG ( \"vSet8SummaryInfo\" ) ; /* Header Information */ usTmp = usGetWord ( 0x0a , aucHeader ) ; if ( usTmp & BIT ( 14 ) ) { /* Language IDentification Far East */ usLid = usGetWord ( 0x3c , aucHeader ) ; } else { /* Language IDentification */ usLid = usGetWord ( 0x06 , aucHeader ) ; } DBG_HEX ( usLid ) ; /* Summery Information */ vSetSummaryInfoOLE ( pFile , pPPS , aulBBD , tBBDLen , aulSBD , tSBDLen ) ; }",
    "resources/antiword/summary.c@szGetTitle": "const char * szGetTitle ( void ) { return szTitle ; }",
    "resources/antiword/summary.c@szGetSubject": "const char * szGetSubject ( void ) { return szSubject ; }",
    "resources/antiword/summary.c@szGetAuthor": "const char * szGetAuthor ( void ) { return szAuthor ; }",
    "resources/antiword/summary.c@szGetLastSaveDtm": "const char * szGetLastSaveDtm ( void ) { static char szTime [ 12 ] ; struct tm * pTime ; if ( tLastSaveDtm == ( time_t ) - 1 ) { return NULL ; } pTime = localtime ( & tLastSaveDtm ) ; if ( pTime == NULL ) { return NULL ; } sprintf ( szTime , \"%04d-%02d-%02d\" , pTime -> tm_year + 1900 , pTime -> tm_mon + 1 , pTime -> tm_mday ) ; return szTime ; }",
    "resources/antiword/summary.c@szGetModDate": "const char * szGetModDate ( void ) { static char szTime [ 20 ] ; struct tm * pTime ; if ( tLastSaveDtm == ( time_t ) - 1 ) { return NULL ; } pTime = localtime ( & tLastSaveDtm ) ; if ( pTime == NULL ) { return NULL ; } sprintf ( szTime , \"D:%04d%02d%02d%02d%02d\" , pTime -> tm_year + 1900 , pTime -> tm_mon + 1 , pTime -> tm_mday , pTime -> tm_hour , pTime -> tm_min ) ; return szTime ; }",
    "resources/antiword/summary.c@szGetCreationDate": "const char * szGetCreationDate ( void ) { static char szTime [ 20 ] ; struct tm * pTime ; if ( tCreateDtm == ( time_t ) - 1 ) { return NULL ; } pTime = localtime ( & tCreateDtm ) ; if ( pTime == NULL ) { return NULL ; } sprintf ( szTime , \"D:%04d%02d%02d%02d%02d\" , pTime -> tm_year + 1900 , pTime -> tm_mon + 1 , pTime -> tm_mday , pTime -> tm_hour , pTime -> tm_min ) ; return szTime ; }",
    "resources/antiword/summary.c@szGetCompany": "const char * szGetCompany ( void ) { return szCompany ; }",
    "resources/antiword/summary.c@szGetLanguage": "const char * szGetLanguage ( void ) { if ( usLid == ( USHORT ) - 1 ) { /* No Language IDentification */ return NULL ; } if ( usLid < 999 ) { /* This is a Locale, not a Language IDentification */ DBG_DEC ( usLid ) ; return NULL ; } /* Exceptions to the general rule */ switch ( usLid ) { case 0x0404 : return \"zh_TW\" ; /* Traditional Chinese */ case 0x0804 : return \"zh_CN\" ; /* Simplified Chinese */ case 0x0c04 : return \"zh_HK\" ; /* Hong Kong Chinese */ case 0x1004 : return \"zh_SG\" ; /* Singapore Chinese */ case 0x0807 : return \"de_CH\" ; /* Swiss German */ case 0x0409 : return \"en_US\" ; /* American English */ case 0x0809 : return \"en_GB\" ; /* British English */ case 0x0c09 : return \"en_AU\" ; /* Australian English */ case 0x080a : return \"es_MX\" ; /* Mexican Spanish */ case 0x080c : return \"fr_BE\" ; /* Belgian French */ case 0x0c0c : return \"fr_CA\" ; /* Canadian French */ case 0x100c : return \"fr_CH\" ; /* Swiss French */ case 0x0810 : return \"it_CH\" ; /* Swiss Italian */ case 0x0813 : return \"nl_BE\" ; /* Belgian Dutch */ case 0x0416 : return \"pt_BR\" ; /* Brazilian Portuguese */ case 0x081a : case 0x0c1a : return \"sr\" ; /* Serbian */ case 0x081d : return \"sv_FI\" ; /* Finland Swedish */ default : break ; } /* The general rule */ switch ( usLid & 0x00ff ) { case 0x01 : return \"ar\" ; /* Arabic */ case 0x02 : return \"bg\" ; /* Bulgarian */ case 0x03 : return \"ca\" ; /* Catalan */ case 0x04 : return \"zh\" ; /* Chinese */ case 0x05 : return \"cs\" ; /* Czech */ case 0x06 : return \"da\" ; /* Danish */ case 0x07 : return \"de\" ; /* German */ case 0x08 : return \"el\" ; /* Greek */ case 0x09 : return \"en\" ; /* English */ case 0x0a : return \"es\" ; /* Spanish */ case 0x0b : return \"fi\" ; /* Finnish */ case 0x0c : return \"fr\" ; /* French */ case 0x0d : return \"he\" ; /* Hebrew */ case 0x0e : return \"hu\" ; /* Hungarian */ case 0x0f : return \"is\" ; /* Icelandic */ case 0x10 : return \"it\" ; /* Italian */ case 0x11 : return \"ja\" ; /* Japanese */ case 0x12 : return \"ko\" ; /* Korean */ case 0x13 : return \"nl\" ; /* Dutch */ case 0x14 : return \"no\" ; /* Norwegian */ case 0x15 : return \"pl\" ; /* Polish */ case 0x16 : return \"pt\" ; /* Portuguese */ case 0x17 : return \"rm\" ; /* Rhaeto-Romance */ case 0x18 : return \"ro\" ; /* Romanian */ case 0x19 : return \"ru\" ; /* Russian */ case 0x1a : return \"hr\" ; /* Croatian */ case 0x1b : return \"sk\" ; /* Slovak */ case 0x1c : return \"sq\" ; /* Albanian */ case 0x1d : return \"sv\" ; /* Swedish */ case 0x1e : return \"th\" ; /* Thai */ case 0x1f : return \"tr\" ; /* Turkish */ case 0x20 : return \"ur\" ; /* Urdu */ case 0x21 : return \"id\" ; /* Indonesian */ case 0x22 : return \"uk\" ; /* Ukrainian */ case 0x23 : return \"be\" ; /* Belarusian */ case 0x24 : return \"sl\" ; /* Slovenian */ case 0x25 : return \"et\" ; /* Estonian */ case 0x26 : return \"lv\" ; /* Latvian */ case 0x27 : return \"lt\" ; /* Lithuanian */ case 0x29 : return \"fa\" ; /* Farsi */ case 0x2a : return \"vi\" ; /* Viet Nam */ case 0x2b : return \"hy\" ; /* Armenian */ case 0x2c : return \"az\" ; /* Azeri */ case 0x2d : return \"eu\" ; /* Basque */ case 0x2f : return \"mk\" ; /* Macedonian */ case 0x36 : return \"af\" ; /* Afrikaans */ case 0x37 : return \"ka\" ; /* Georgian */ case 0x38 : return \"fo\" ; /* Faeroese */ case 0x39 : return \"hi\" ; /* Hindi */ case 0x3e : return \"ms\" ; /* Malay */ case 0x3f : return \"kk\" ; /* Kazakh */ default : DBG_HEX ( usLid ) ; DBG_FIXME ( ) ; return NULL ; } }",
    "resources/antiword/jpeg2eps.c@bTranslateJPEG": "",
    "resources/antiword/depot.c@vDestroySmallBlockList": "void vDestroySmallBlockList ( void ) { DBG_MSG ( \"vDestroySmallBlockList\" ) ; aulSmallBlockList = xfree ( aulSmallBlockList ) ; tSmallBlockListLen = 0 ; }",
    "resources/antiword/depot.c@bCreateSmallBlockList": "",
    "resources/antiword/depot.c@ulDepotOffset": "ULONG ulDepotOffset ( ULONG ulIndex , size_t tBlockSize ) { ULONG ulTmp ; size_t tTmp ; fail ( ulIndex >= ULONG_MAX / BIG_BLOCK_SIZE ) ; switch ( tBlockSize ) { case BIG_BLOCK_SIZE : return ( ulIndex + 1 ) * BIG_BLOCK_SIZE ; case SMALL_BLOCK_SIZE : tTmp = ( size_t ) ( ulIndex / SIZE_RATIO ) ; ulTmp = ulIndex % SIZE_RATIO ; if ( aulSmallBlockList == NULL || tTmp >= tSmallBlockListLen ) { DBG_HEX ( aulSmallBlockList ) ; DBG_DEC ( tSmallBlockListLen ) ; DBG_DEC ( tTmp ) ; return 0 ; } return ( ( aulSmallBlockList [ tTmp ] + 1 ) * SIZE_RATIO + ulTmp ) * SMALL_BLOCK_SIZE ; default : DBG_DEC ( tBlockSize ) ; DBG_FIXME ( ) ; return 0 ; } }",
    "resources/antiword/postscript.c@vAddPageSetup": "static void vAddPageSetup ( FILE * pOutFile ) { if ( bUseLandscape ) { fprintf ( pOutFile , \"%%%%BeginPageSetup\\n\" ) ; fprintf ( pOutFile , \"90 rotate\\n\" ) ; fprintf ( pOutFile , \"0.00 %.2f translate\\n\" , - dDrawUnits2Points ( lPageHeight ) ) ; fprintf ( pOutFile , \"%%%%EndPageSetup\\n\" ) ; } }",
    "resources/antiword/postscript.c@vAddHdrFtr": "static void vAddHdrFtr ( diagram_type * pDiag , const hdrftr_block_type * pHdrFtrInfo ) { output_type * pStart , * pPrev , * pNext ; fail ( pDiag == NULL ) ; fail ( pHdrFtrInfo == NULL ) ; vStartOfParagraphPS ( pDiag , 0 ) ; pStart = pHdrFtrInfo -> pText ; while ( pStart != NULL ) { pNext = pStart ; while ( pNext != NULL && ( pNext -> tNextFree != 1 || ( pNext -> szStorage [ 0 ] != PAR_END && pNext -> szStorage [ 0 ] != HARD_RETURN ) ) ) { pNext = pNext -> pNext ; } if ( pNext == NULL ) { if ( bOutputContainsText ( pStart ) ) { vAlign2Window ( pDiag , pStart , lChar2MilliPoints ( DEFAULT_SCREEN_WIDTH ) , ALIGNMENT_LEFT ) ; } else { vMove2NextLinePS ( pDiag , pStart -> usFontSize ) ; } break ; } fail ( pNext -> tNextFree != 1 ) ; fail ( pNext -> szStorage [ 0 ] != PAR_END && pNext -> szStorage [ 0 ] != HARD_RETURN ) ; if ( pStart != pNext ) { /* There is something to print */ pPrev = pNext -> pPrev ; fail ( pPrev -> pNext != pNext ) ; /* Cut the chain */ pPrev -> pNext = NULL ; if ( bOutputContainsText ( pStart ) ) { /* Print it */ vAlign2Window ( pDiag , pStart , lChar2MilliPoints ( DEFAULT_SCREEN_WIDTH ) , ALIGNMENT_LEFT ) ; } else { /* Just an empty line */ vMove2NextLinePS ( pDiag , pStart -> usFontSize ) ; } /* Repair the chain */ pPrev -> pNext = pNext ; } if ( pNext -> szStorage [ 0 ] == PAR_END ) { vEndOfParagraphPS ( pDiag , pNext -> usFontSize , ( long ) pNext -> usFontSize * 200 ) ; } pStart = pNext -> pNext ; } }",
    "resources/antiword/postscript.c@vAddHeader": "static void vAddHeader ( diagram_type * pDiag ) { const hdrftr_block_type * pHdrInfo ; const hdrftr_block_type * pFtrInfo ; fail ( pDiag == NULL ) ; NO_DBG_MSG ( \"vAddHeader\" ) ; pHdrInfo = pGetHdrFtrInfo ( iSectionIndex , TRUE , odd ( iPageCount ) , bFirstInSection ) ; pFtrInfo = pGetHdrFtrInfo ( iSectionIndex , FALSE , odd ( iPageCount ) , bFirstInSection ) ; /* Set the height of the footer of this page */ lFooterHeight = pFtrInfo == NULL ? 0 : pFtrInfo -> lHeight ; fail ( lFooterHeight < 0 ) ; if ( pHdrInfo == NULL || pHdrInfo -> pText == NULL || pHdrInfo -> lHeight <= 0 ) { fail ( pHdrInfo != NULL && pHdrInfo -> lHeight < 0 ) ; fail ( pHdrInfo != NULL && pHdrInfo -> pText != NULL && pHdrInfo -> lHeight == 0 ) ; return ; } vAddHdrFtr ( pDiag , pHdrInfo ) ; DBG_DEC_C ( pHdrInfo -> lHeight != lPageHeight - PS_TOP_MARGIN - pDiag -> lYtop , pHdrInfo -> lHeight ) ; DBG_DEC_C ( pHdrInfo -> lHeight != lPageHeight - PS_TOP_MARGIN - pDiag -> lYtop , lPageHeight - PS_TOP_MARGIN - pDiag -> lYtop ) ; # if 0 /* defined(DEBUG) */ fprintf ( pDiag -> pOutFile , \"(HEADER: FileOffset 0x%04lx-0x%04lx; Height %ld-%ld) show\\n\" , ulCharPos2FileOffset ( pHdrInfo -> ulCharPosStart ) , ulCharPos2FileOffset ( pHdrInfo -> ulCharPosNext ) , pHdrInfo -> lHeight , lPageHeight - PS_TOP_MARGIN - pDiag -> lYtop ) ; # endif }",
    "resources/antiword/postscript.c@vAddFooter": "static void vAddFooter ( diagram_type * pDiag ) { const hdrftr_block_type * pFtrInfo ; fail ( pDiag == NULL ) ; NO_DBG_MSG ( \"vAddFooter\" ) ; pFtrInfo = pGetHdrFtrInfo ( iSectionIndex , FALSE , odd ( iPageCount ) , bFirstInSection ) ; bFirstInSection = FALSE ; if ( pFtrInfo == NULL || pFtrInfo -> pText == NULL || pFtrInfo -> lHeight <= 0 ) { fail ( pFtrInfo != NULL && pFtrInfo -> lHeight < 0 ) ; fail ( pFtrInfo != NULL && pFtrInfo -> pText != NULL && pFtrInfo -> lHeight == 0 ) ; return ; } bInFtrSpace = TRUE ; DBG_DEC_C ( pFtrInfo -> lHeight != lFooterHeight , pFtrInfo -> lHeight ) ; DBG_DEC_C ( pFtrInfo -> lHeight != lFooterHeight , lFooterHeight ) ; DBG_DEC_C ( pDiag -> lYtop < lFooterHeight + PS_BOTTOM_MARGIN , pDiag -> lYtop ) ; DBG_DEC_C ( pDiag -> lYtop < lFooterHeight + PS_BOTTOM_MARGIN , lFooterHeight + PS_BOTTOM_MARGIN ) ; if ( pDiag -> lYtop > lFooterHeight + PS_BOTTOM_MARGIN ) { /* Move down to the start of the footer */ pDiag -> lYtop = lFooterHeight + PS_BOTTOM_MARGIN ; vMoveTo ( pDiag , 0 ) ; } else if ( pDiag -> lYtop < lFooterHeight + PS_BOTTOM_MARGIN / 2 ) { DBG_FIXME ( ) ; /*\n\t\t * Move up to the start of the footer, to prevent moving\n\t\t * of the bottom edge of the paper\n\t\t */ pDiag -> lYtop = lFooterHeight + PS_BOTTOM_MARGIN ; vMoveTo ( pDiag , 0 ) ; } DBG_FLT_C ( pDiag -> lYtop < lFooterHeight + PS_BOTTOM_MARGIN , dDrawUnits2Points ( lFooterHeight + PS_BOTTOM_MARGIN - pDiag -> lYtop ) ) ; # if 0 /* defined(DEBUG) */ fprintf ( pDiag -> pOutFile , \"(FOOTER: FileOffset 0x%04lx-0x%04lx; Bottom %ld-%ld) show\\n\" , ulCharPos2FileOffset ( pFtrInfo -> ulCharPosStart ) , ulCharPos2FileOffset ( pFtrInfo -> ulCharPosNext ) , pDiag -> lYtop , pFtrInfo -> lHeight + PS_BOTTOM_MARGIN ) ; # endif vAddHdrFtr ( pDiag , pFtrInfo ) ; bInFtrSpace = FALSE ; }",
    "resources/antiword/postscript.c@vMove2NextPage": "static void vMove2NextPage ( diagram_type * pDiag , BOOL bNewSection ) { fail ( pDiag == NULL ) ; vAddFooter ( pDiag ) ; fprintf ( pDiag -> pOutFile , \"showpage\\n\" ) ; iPageCount ++ ; fprintf ( pDiag -> pOutFile , \"%%%%Page: %d %d\\n\" , iPageCount , iPageCount ) ; if ( bNewSection ) { iSectionIndex ++ ; bFirstInSection = TRUE ; } vAddPageSetup ( pDiag -> pOutFile ) ; pDiag -> lYtop = lPageHeight - PS_TOP_MARGIN ; lYtopCurr = - 1 ; vAddHeader ( pDiag ) ; }",
    "resources/antiword/postscript.c@vMoveTo": "static void vMoveTo ( diagram_type * pDiag , long lLastVerticalMovement ) { fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; if ( pDiag -> lYtop <= lFooterHeight + PS_BOTTOM_MARGIN && ! bInFtrSpace ) { vMove2NextPage ( pDiag , FALSE ) ; /* Repeat the last vertical movement on the new page */ pDiag -> lYtop -= lLastVerticalMovement ; } fail ( pDiag -> lYtop < lFooterHeight + PS_BOTTOM_MARGIN && ! bInFtrSpace ) ; DBG_DEC_C ( pDiag -> lYtop < PS_BOTTOM_MARGIN , pDiag -> lYtop ) ; fail ( pDiag -> lYtop < PS_BOTTOM_MARGIN / 3 ) ; if ( pDiag -> lYtop != lYtopCurr ) { fprintf ( pDiag -> pOutFile , \"%.2f %.2f moveto\\n\" , dDrawUnits2Points ( pDiag -> lXleft + PS_LEFT_MARGIN ) , dDrawUnits2Points ( pDiag -> lYtop ) ) ; lYtopCurr = pDiag -> lYtop ; } }",
    "resources/antiword/postscript.c@vProloguePS": "void vProloguePS ( diagram_type * pDiag , const char * szTask , const char * szFilename , const options_type * pOptions ) { FILE * pOutFile ; const char * szTmp ; time_t tTime ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( szTask == NULL || szTask [ 0 ] == '\\0' ) ; fail ( pOptions == NULL ) ; pOutFile = pDiag -> pOutFile ; bUseLandscape = pOptions -> bUseLandscape ; eEncoding = pOptions -> eEncoding ; eImageLevel = pOptions -> eImageLevel ; if ( pOptions -> iPageHeight == INT_MAX ) { lPageHeight = LONG_MAX ; } else { lPageHeight = lPoints2DrawUnits ( pOptions -> iPageHeight ) ; } DBG_DEC ( lPageHeight ) ; if ( pOptions -> iPageWidth == INT_MAX ) { lPageWidth = LONG_MAX ; } else { lPageWidth = lPoints2DrawUnits ( pOptions -> iPageWidth ) ; } DBG_DEC ( lPageWidth ) ; lFooterHeight = 0 ; bInFtrSpace = FALSE ; tFontRefCurr = ( drawfile_fontref ) - 1 ; usFontSizeCurr = 0 ; iFontColorCurr = - 1 ; lYtopCurr = - 1 ; iPageCount = 0 ; iImageCount = 0 ; iSectionIndex = 0 ; bFirstInSection = TRUE ; pDiag -> lXleft = 0 ; pDiag -> lYtop = lPageHeight - PS_TOP_MARGIN ; szCreator = szTask ; fprintf ( pOutFile , \"%%!PS-Adobe-2.0\\n\" ) ; fprintf ( pOutFile , \"%%%%Title: %s\\n\" , szBasename ( szFilename ) ) ; fprintf ( pOutFile , \"%%%%Creator: %s %s\\n\" , szCreator , VERSIONSTRING ) ; szTmp = getenv ( \"LOGNAME\" ) ; if ( szTmp == NULL || szTmp [ 0 ] == '\\0' ) { szTmp = getenv ( \"USER\" ) ; if ( szTmp == NULL || szTmp [ 0 ] == '\\0' ) { szTmp = \"unknown\" ; } } fprintf ( pOutFile , \"%%%%For: %.50s\\n\" , szTmp ) ; errno = 0 ; tTime = time ( NULL ) ; if ( tTime == ( time_t ) - 1 && errno != 0 ) { szCreationDate = NULL ; } else { szCreationDate = ctime ( & tTime ) ; } if ( szCreationDate == NULL || szCreationDate [ 0 ] == '\\0' ) { szCreationDate = \"unknown\\n\" ; } fprintf ( pOutFile , \"%%%%CreationDate: %s\" , szCreationDate ) ; if ( bUseLandscape ) { fprintf ( pOutFile , \"%%%%Orientation: Landscape\\n\" ) ; fprintf ( pOutFile , \"%%%%BoundingBox: 0 0 %.0f %.0f\\n\" , dDrawUnits2Points ( lPageHeight ) , dDrawUnits2Points ( lPageWidth ) ) ; } else { fprintf ( pOutFile , \"%%%%Orientation: Portrait\\n\" ) ; fprintf ( pOutFile , \"%%%%BoundingBox: 0 0 %.0f %.0f\\n\" , dDrawUnits2Points ( lPageWidth ) , dDrawUnits2Points ( lPageHeight ) ) ; } }",
    "resources/antiword/postscript.c@vEpiloguePS": "void vEpiloguePS ( diagram_type * pDiag ) { fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; if ( pDiag -> lYtop < lPageHeight - PS_TOP_MARGIN ) { vAddFooter ( pDiag ) ; fprintf ( pDiag -> pOutFile , \"showpage\\n\" ) ; } fprintf ( pDiag -> pOutFile , \"%%%%Trailer\\n\" ) ; fprintf ( pDiag -> pOutFile , \"%%%%Pages: %d\\n\" , iPageCount ) ; fprintf ( pDiag -> pOutFile , \"%%%%EOF\\n\" ) ; szCreationDate = NULL ; szCreator = NULL ; }",
    "resources/antiword/postscript.c@vPrintPalette": "static void vPrintPalette ( FILE * pOutFile , const imagedata_type * pImg ) { int iIndex ; fail ( pOutFile == NULL ) ; fail ( pImg == NULL ) ; fail ( pImg -> iColorsUsed < 2 ) ; fail ( pImg -> iColorsUsed > 256 ) ; fprintf ( pOutFile , \"[ /Indexed\\n\" ) ; fprintf ( pOutFile , \"\\t/Device%s %d\\n\" , pImg -> bColorImage ? \"RGB\" : \"Gray\" , pImg -> iColorsUsed - 1 ) ; fprintf ( pOutFile , \"<\" ) ; for ( iIndex = 0 ; iIndex < pImg -> iColorsUsed ; iIndex ++ ) { fprintf ( pOutFile , \"%02x\" , ( unsigned int ) pImg -> aucPalette [ iIndex ] [ 0 ] ) ; if ( pImg -> bColorImage ) { fprintf ( pOutFile , \"%02x%02x\" , ( unsigned int ) pImg -> aucPalette [ iIndex ] [ 1 ] , ( unsigned int ) pImg -> aucPalette [ iIndex ] [ 2 ] ) ; } if ( iIndex % 8 == 7 ) { fprintf ( pOutFile , \"\\n\" ) ; } else { fprintf ( pOutFile , \" \" ) ; } } fprintf ( pOutFile , \">\\n\" ) ; fprintf ( pOutFile , \"] setcolorspace\\n\" ) ; }",
    "resources/antiword/postscript.c@vImageProloguePS": "void vImageProloguePS ( diagram_type * pDiag , const imagedata_type * pImg ) { FILE * pOutFile ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( pImg == NULL ) ; if ( pImg -> iVerSizeScaled <= 0 || pImg -> iHorSizeScaled <= 0 ) { return ; } fail ( szCreationDate == NULL ) ; fail ( szCreator == NULL ) ; fail ( eImageLevel == level_no_images ) ; iImageCount ++ ; DBG_DEC_C ( pDiag -> lXleft != 0 , pDiag -> lXleft ) ; pDiag -> lYtop -= lPoints2DrawUnits ( pImg -> iVerSizeScaled ) ; vMoveTo ( pDiag , lPoints2DrawUnits ( pImg -> iVerSizeScaled ) ) ; pOutFile = pDiag -> pOutFile ; fprintf ( pOutFile , \"BeginEPSF\\n\" ) ; fprintf ( pOutFile , \"%%%%BeginDocument: image%03d.eps\\n\" , iImageCount ) ; fprintf ( pOutFile , \"%%!PS-Adobe-2.0 EPSF-2.0\\n\" ) ; fprintf ( pOutFile , \"%%%%Creator: %s %s\\n\" , szCreator , VERSIONSTRING ) ; fprintf ( pOutFile , \"%%%%Title: Image %03d\\n\" , iImageCount ) ; fprintf ( pOutFile , \"%%%%CreationDate: %s\" , szCreationDate ) ; fprintf ( pOutFile , \"%%%%BoundingBox: 0 0 %d %d\\n\" , pImg -> iHorSizeScaled , pImg -> iVerSizeScaled ) ; fprintf ( pOutFile , \"%%%%DocumentData: Clean7Bit\\n\" ) ; fprintf ( pOutFile , \"%%%%LanguageLevel: 2\\n\" ) ; fprintf ( pOutFile , \"%%%%EndComments\\n\" ) ; fprintf ( pOutFile , \"%%%%BeginProlog\\n\" ) ; fprintf ( pOutFile , \"%%%%EndProlog\\n\" ) ; fprintf ( pOutFile , \"%%%%Page: 1 1\\n\" ) ; fprintf ( pOutFile , \"save\\n\" ) ; switch ( pImg -> eImageType ) { case imagetype_is_jpeg : fprintf ( pOutFile , \"/Data1 currentfile \" ) ; fprintf ( pOutFile , \"/ASCII85Decode filter def\\n\" ) ; fprintf ( pOutFile , \"/Data Data1 << \" ) ; fprintf ( pOutFile , \">> /DCTDecode filter def\\n\" ) ; switch ( pImg -> iComponents ) { case 1 : fprintf ( pOutFile , \"/DeviceGray setcolorspace\\n\" ) ; break ; case 3 : fprintf ( pOutFile , \"/DeviceRGB setcolorspace\\n\" ) ; break ; case 4 : fprintf ( pOutFile , \"/DeviceCMYK setcolorspace\\n\" ) ; break ; default : DBG_DEC ( pImg -> iComponents ) ; break ; } break ; case imagetype_is_png : if ( eImageLevel == level_gs_special ) { fprintf ( pOutFile , \"/Data2 currentfile /ASCII85Decode filter def\\n\" ) ; fprintf ( pOutFile , \"/Data1 Data2 << >> /FlateDecode filter def\\n\" ) ; fprintf ( pOutFile , \"/Data Data1 <<\\n\" ) ; fprintf ( pOutFile , \"\\t/Colors %d\\n\" , pImg -> iComponents ) ; fprintf ( pOutFile , \"\\t/BitsPerComponent %u\\n\" , pImg -> uiBitsPerComponent ) ; fprintf ( pOutFile , \"\\t/Columns %d\\n\" , pImg -> iWidth ) ; fprintf ( pOutFile , \">> /PNGPredictorDecode filter def\\n\" ) ; } else { fprintf ( pOutFile , \"/Data1 currentfile /ASCII85Decode filter def\\n\" ) ; fprintf ( pOutFile , \"/Data Data1 << >> /FlateDecode filter def\\n\" ) ; } if ( pImg -> iComponents == 3 || pImg -> iComponents == 4 ) { fprintf ( pOutFile , \"/DeviceRGB setcolorspace\\n\" ) ; } else if ( pImg -> iColorsUsed > 0 ) { vPrintPalette ( pOutFile , pImg ) ; } else { fprintf ( pOutFile , \"/DeviceGray setcolorspace\\n\" ) ; } break ; case imagetype_is_dib : fprintf ( pOutFile , \"/Data currentfile \" ) ; fprintf ( pOutFile , \"/ASCII85Decode filter def\\n\" ) ; if ( pImg -> uiBitsPerComponent <= 8 ) { vPrintPalette ( pOutFile , pImg ) ; } else { fprintf ( pOutFile , \"/DeviceRGB setcolorspace\\n\" ) ; } break ; default : fprintf ( pOutFile , \"/Data currentfile \" ) ; fprintf ( pOutFile , \"/ASCIIHexDecode filter def\\n\" ) ; fprintf ( pOutFile , \"/Device%s setcolorspace\\n\" , pImg -> bColorImage ? \"RGB\" : \"Gray\" ) ; break ; } /* Translate to lower left corner of image */ fprintf ( pOutFile , \"%.2f %.2f translate\\n\" , dDrawUnits2Points ( pDiag -> lXleft + PS_LEFT_MARGIN ) , dDrawUnits2Points ( pDiag -> lYtop ) ) ; fprintf ( pOutFile , \"%d %d scale\\n\" , pImg -> iHorSizeScaled , pImg -> iVerSizeScaled ) ; fprintf ( pOutFile , \"{ <<\\n\" ) ; fprintf ( pOutFile , \"\\t/ImageType 1\\n\" ) ; fprintf ( pOutFile , \"\\t/Width %d\\n\" , pImg -> iWidth ) ; fprintf ( pOutFile , \"\\t/Height %d\\n\" , pImg -> iHeight ) ; if ( pImg -> eImageType == imagetype_is_dib ) { /* Scanning from left to right and bottom to top */ fprintf ( pOutFile , \"\\t/ImageMatrix [ %d 0 0 %d 0 0 ]\\n\" , pImg -> iWidth , pImg -> iHeight ) ; } else { /* Scanning from left to right and top to bottom */ fprintf ( pOutFile , \"\\t/ImageMatrix [ %d 0 0 %d 0 %d ]\\n\" , pImg -> iWidth , - pImg -> iHeight , pImg -> iHeight ) ; } fprintf ( pOutFile , \"\\t/DataSource Data\\n\" ) ; switch ( pImg -> eImageType ) { case imagetype_is_jpeg : fprintf ( pOutFile , \"\\t/BitsPerComponent 8\\n\" ) ; switch ( pImg -> iComponents ) { case 1 : fprintf ( pOutFile , \"\\t/Decode [0 1]\\n\" ) ; break ; case 3 : fprintf ( pOutFile , \"\\t/Decode [0 1 0 1 0 1]\\n\" ) ; break ; case 4 : if ( pImg -> bAdobe ) { /*\n\t\t\t\t * Adobe-conforming CMYK file\n\t\t\t\t * applying workaround for color inversion\n\t\t\t\t */ fprintf ( pOutFile , \"\\t/Decode [1 0 1 0 1 0 1 0]\\n\" ) ; } else { fprintf ( pOutFile , \"\\t/Decode [0 1 0 1 0 1 0 1]\\n\" ) ; } break ; default : DBG_DEC ( pImg -> iComponents ) ; break ; } break ; case imagetype_is_png : if ( pImg -> iComponents == 3 ) { fprintf ( pOutFile , \"\\t/BitsPerComponent 8\\n\" ) ; fprintf ( pOutFile , \"\\t/Decode [0 1 0 1 0 1]\\n\" ) ; } else if ( pImg -> iColorsUsed > 0 ) { fail ( pImg -> uiBitsPerComponent > 8 ) ; fprintf ( pOutFile , \"\\t/BitsPerComponent %u\\n\" , pImg -> uiBitsPerComponent ) ; fprintf ( pOutFile , \"\\t/Decode [0 %d]\\n\" , ( 1 << pImg -> uiBitsPerComponent ) - 1 ) ; } else { fprintf ( pOutFile , \"\\t/BitsPerComponent 8\\n\" ) ; fprintf ( pOutFile , \"\\t/Decode [0 1]\\n\" ) ; } break ; case imagetype_is_dib : fprintf ( pOutFile , \"\\t/BitsPerComponent 8\\n\" ) ; if ( pImg -> uiBitsPerComponent <= 8 ) { fprintf ( pOutFile , \"\\t/Decode [0 255]\\n\" ) ; } else { fprintf ( pOutFile , \"\\t/Decode [0 1 0 1 0 1]\\n\" ) ; } break ; default : fprintf ( pOutFile , \"\\t/BitsPerComponent 8\\n\" ) ; if ( pImg -> bColorImage ) { fprintf ( pOutFile , \"\\t/Decode [0 1 0 1 0 1]\\n\" ) ; } else { fprintf ( pOutFile , \"\\t/Decode [0 1]\\n\" ) ; } break ; } fprintf ( pOutFile , \"  >> image\\n\" ) ; fprintf ( pOutFile , \"  Data closefile\\n\" ) ; fprintf ( pOutFile , \"  showpage\\n\" ) ; fprintf ( pOutFile , \"  restore\\n\" ) ; fprintf ( pOutFile , \"} exec\\n\" ) ; }",
    "resources/antiword/postscript.c@vImageEpiloguePS": "void vImageEpiloguePS ( diagram_type * pDiag ) { FILE * pOutFile ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; pOutFile = pDiag -> pOutFile ; fprintf ( pOutFile , \"%%%%EOF\\n\" ) ; fprintf ( pOutFile , \"%%%%EndDocument\\n\" ) ; fprintf ( pOutFile , \"EndEPSF\\n\" ) ; pDiag -> lXleft = 0 ; }",
    "resources/antiword/postscript.c@bAddDummyImagePS": "",
    "resources/antiword/postscript.c@vAddFontsPS": "void vAddFontsPS ( diagram_type * pDiag ) { FILE * pOutFile ; const font_table_type * pTmp , * pTmp2 ; size_t tIndex ; int iLineLen , iOurFontnameLen ; BOOL bFound ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; pOutFile = pDiag -> pOutFile ; iLineLen = fprintf ( pOutFile , \"%%%%DocumentFonts:\" ) ; if ( tGetFontTableLength ( ) == 0 ) { iLineLen += fprintf ( pOutFile , \" Courier\" ) ; } else { pTmp = NULL ; while ( ( pTmp = pGetNextFontTableRecord ( pTmp ) ) != NULL ) { /* Print the document fonts */ bFound = FALSE ; pTmp2 = NULL ; while ( ( pTmp2 = pGetNextFontTableRecord ( pTmp2 ) ) != NULL && pTmp2 < pTmp ) { bFound = STREQ ( pTmp2 -> szOurFontname , pTmp -> szOurFontname ) ; if ( bFound ) { break ; } } iOurFontnameLen = ( int ) strlen ( pTmp -> szOurFontname ) ; if ( bFound || iOurFontnameLen <= 0 ) { continue ; } if ( iLineLen + iOurFontnameLen > 76 ) { fprintf ( pOutFile , \"\\n%%%%+\" ) ; iLineLen = 3 ; } iLineLen += fprintf ( pOutFile , \" %s\" , pTmp -> szOurFontname ) ; } } fprintf ( pOutFile , \"\\n\" ) ; fprintf ( pOutFile , \"%%%%Pages: (atend)\\n\" ) ; fprintf ( pOutFile , \"%%%%EndComments\\n\" ) ; fprintf ( pOutFile , \"%%%%BeginProlog\\n\" ) ; switch ( eEncoding ) { case encoding_latin_1 : for ( tIndex = 0 ; tIndex < elementsof ( iso_8859_1_data ) ; tIndex ++ ) { fprintf ( pOutFile , \"%s\\n\" , iso_8859_1_data [ tIndex ] ) ; } fprintf ( pOutFile , \"\\n\" ) ; for ( tIndex = 0 ; tIndex < elementsof ( iso_8859_x_func ) ; tIndex ++ ) { fprintf ( pOutFile , \"%s\\n\" , iso_8859_x_func [ tIndex ] ) ; } break ; case encoding_latin_2 : for ( tIndex = 0 ; tIndex < elementsof ( iso_8859_2_data ) ; tIndex ++ ) { fprintf ( pOutFile , \"%s\\n\" , iso_8859_2_data [ tIndex ] ) ; } fprintf ( pOutFile , \"\\n\" ) ; for ( tIndex = 0 ; tIndex < elementsof ( iso_8859_x_func ) ; tIndex ++ ) { fprintf ( pOutFile , \"%s\\n\" , iso_8859_x_func [ tIndex ] ) ; } break ; case encoding_cyrillic : for ( tIndex = 0 ; tIndex < elementsof ( iso_8859_5_data ) ; tIndex ++ ) { fprintf ( pOutFile , \"%s\\n\" , iso_8859_5_data [ tIndex ] ) ; } fprintf ( pOutFile , \"\\n\" ) ; for ( tIndex = 0 ; tIndex < elementsof ( iso_8859_x_func ) ; tIndex ++ ) { fprintf ( pOutFile , \"%s\\n\" , iso_8859_x_func [ tIndex ] ) ; } break ; case encoding_utf_8 : werr ( 1 , \"The combination PostScript and UTF-8 is not supported\" ) ; break ; default : DBG_DEC ( eEncoding ) ; break ; } /* The rest of the functions */ for ( tIndex = 0 ; tIndex < elementsof ( misc_func ) ; tIndex ++ ) { fprintf ( pOutFile , \"%s\\n\" , misc_func [ tIndex ] ) ; } fprintf ( pOutFile , \"%%%%EndProlog\\n\" ) ; iPageCount = 1 ; fprintf ( pDiag -> pOutFile , \"%%%%Page: %d %d\\n\" , iPageCount , iPageCount ) ; vAddPageSetup ( pDiag -> pOutFile ) ; vAddHeader ( pDiag ) ; }",
    "resources/antiword/postscript.c@vPrintPS": "static void vPrintPS ( FILE * pFile , const char * szString , size_t tStringLength , USHORT usFontstyle ) { double dSuperscriptMove , dSubscriptMove ; const UCHAR * ucBytes ; size_t tCount ; fail ( szString == NULL ) ; if ( szString == NULL || szString [ 0 ] == '\\0' || tStringLength == 0 ) { return ; } DBG_DEC_C ( usFontSizeCurr < MIN_FONT_SIZE , usFontSizeCurr ) ; dSuperscriptMove = 0.0 ; dSubscriptMove = 0.0 ; /* Up for superscript */ if ( bIsSuperscript ( usFontstyle ) && usFontSizeCurr != 0 ) { dSuperscriptMove = ( double ) ( ( usFontSizeCurr + 1 ) / 2 ) * 0.375 ; fprintf ( pFile , \"0 %.2f rmoveto\\n\" , dSuperscriptMove ) ; } /* Down for subscript */ if ( bIsSubscript ( usFontstyle ) && usFontSizeCurr != 0 ) { dSubscriptMove = ( double ) usFontSizeCurr * 0.125 ; fprintf ( pFile , \"0 %.2f rmoveto\\n\" , - dSubscriptMove ) ; } /* Generate and print the PostScript output */ ucBytes = ( UCHAR * ) szString ; ( void ) putc ( '(' , pFile ) ; for ( tCount = 0 ; tCount < tStringLength ; tCount ++ ) { switch ( ucBytes [ tCount ] ) { case '(' : case ')' : case '\\\\' : ( void ) putc ( '\\\\' , pFile ) ; ( void ) putc ( szString [ tCount ] , pFile ) ; break ; default : if ( ucBytes [ tCount ] < 0x20 || ( ucBytes [ tCount ] >= 0x7f && ucBytes [ tCount ] < 0x8c ) ) { DBG_HEX ( ucBytes [ tCount ] ) ; ( void ) putc ( ' ' , pFile ) ; } else if ( ucBytes [ tCount ] >= 0x80 ) { fprintf ( pFile , \"\\\\%03o\" , ( UINT ) ucBytes [ tCount ] ) ; } else { ( void ) putc ( szString [ tCount ] , pFile ) ; } break ; } } fprintf ( pFile , \") \" ) ; if ( ( bIsStrike ( usFontstyle ) || bIsMarkDel ( usFontstyle ) ) && usFontSizeCurr != 0 ) { fprintf ( pFile , \"%.2f %.2f LineShow\\n\" , ( double ) usFontSizeCurr * 0.02 , ( double ) usFontSizeCurr * 0.12 ) ; } else if ( bIsUnderline ( usFontstyle ) && usFontSizeCurr != 0 ) { fprintf ( pFile , \"%.2f %.2f LineShow\\n\" , ( double ) usFontSizeCurr * 0.02 , ( double ) usFontSizeCurr * - 0.06 ) ; } else { fprintf ( pFile , \"show\\n\" ) ; } /* Undo the superscript move */ if ( bIsSuperscript ( usFontstyle ) && usFontSizeCurr != 0 ) { fprintf ( pFile , \"0 %.2f rmoveto\\n\" , - dSuperscriptMove ) ; } /* Undo the subscript move */ if ( bIsSubscript ( usFontstyle ) && usFontSizeCurr != 0 ) { fprintf ( pFile , \"0 %.2f rmoveto\\n\" , dSubscriptMove ) ; } }",
    "resources/antiword/postscript.c@vSetColor": "static void vSetColor ( FILE * pFile , UCHAR ucFontColor ) { ULONG ulTmp , ulRed , ulGreen , ulBlue ; ulTmp = ulColor2Color ( ucFontColor ) ; ulRed = ( ulTmp & 0x0000ff00 ) >> 8 ; ulGreen = ( ulTmp & 0x00ff0000 ) >> 16 ; ulBlue = ( ulTmp & 0xff000000 ) >> 24 ; fprintf ( pFile , \"%.3f %.3f %.3f setrgbcolor\\n\" , ulRed / 255.0 , ulGreen / 255.0 , ulBlue / 255.0 ) ; }",
    "resources/antiword/postscript.c@vMove2NextLinePS": "void vMove2NextLinePS ( diagram_type * pDiag , USHORT usFontSize ) { fail ( pDiag == NULL ) ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; pDiag -> lYtop -= lComputeLeading ( usFontSize ) ; }",
    "resources/antiword/postscript.c@vSubstringPS": "void vSubstringPS ( diagram_type * pDiag , char * szString , size_t tStringLength , long lStringWidth , UCHAR ucFontColor , USHORT usFontstyle , drawfile_fontref tFontRef , USHORT usFontSize , USHORT usMaxFontSize ) { const char * szOurFontname ; fail ( pDiag == NULL || szString == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( pDiag -> lXleft < 0 ) ; fail ( tStringLength != strlen ( szString ) ) ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; fail ( usMaxFontSize < MIN_FONT_SIZE || usMaxFontSize > MAX_FONT_SIZE ) ; fail ( usFontSize > usMaxFontSize ) ; if ( szString [ 0 ] == '\\0' || tStringLength == 0 ) { return ; } if ( tFontRef != tFontRefCurr || usFontSize != usFontSizeCurr ) { szOurFontname = szGetFontname ( tFontRef ) ; fail ( szOurFontname == NULL ) ; fprintf ( pDiag -> pOutFile , \"%.1f /%s /%s-ISO-8859-x ChgFnt\\n\" , ( double ) usFontSize / 2.0 , szOurFontname , szOurFontname ) ; tFontRefCurr = tFontRef ; usFontSizeCurr = usFontSize ; } if ( ( int ) ucFontColor != iFontColorCurr ) { vSetColor ( pDiag -> pOutFile , ucFontColor ) ; iFontColorCurr = ( int ) ucFontColor ; } vMoveTo ( pDiag , lComputeLeading ( usMaxFontSize ) ) ; vPrintPS ( pDiag -> pOutFile , szString , tStringLength , usFontstyle ) ; pDiag -> lXleft += lStringWidth ; }",
    "resources/antiword/postscript.c@vStartOfParagraphPS": "void vStartOfParagraphPS ( diagram_type * pDiag , long lBeforeIndentation ) { fail ( pDiag == NULL ) ; fail ( lBeforeIndentation < 0 ) ; pDiag -> lXleft = 0 ; pDiag -> lYtop -= lMilliPoints2DrawUnits ( lBeforeIndentation ) ; }",
    "resources/antiword/postscript.c@vEndOfParagraphPS": "void vEndOfParagraphPS ( diagram_type * pDiag , USHORT usFontSize , long lAfterIndentation ) { fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; fail ( lAfterIndentation < 0 ) ; if ( pDiag -> lXleft > 0 ) { /* To the start of the line */ vMove2NextLinePS ( pDiag , usFontSize ) ; } pDiag -> lXleft = 0 ; pDiag -> lYtop -= lMilliPoints2DrawUnits ( lAfterIndentation ) ; }",
    "resources/antiword/postscript.c@vEndOfPagePS": "void vEndOfPagePS ( diagram_type * pDiag , BOOL bNewSection ) { vMove2NextPage ( pDiag , bNewSection ) ; }",
    "resources/antiword/main_u.c@vUsage": "static void vUsage ( void ) { fprintf ( stderr , \"\\tName: %s\\n\" , szTask ) ; fprintf ( stderr , \"\\tPurpose: \" PURPOSESTRING \"\\n\" ) ; fprintf ( stderr , \"\\tAuthor: \" AUTHORSTRING \"\\n\" ) ; fprintf ( stderr , \"\\tVersion: \" VERSIONSTRING ) ; # if defined ( __dos ) fprintf ( stderr , VERSIONSTRING2 ) ; # endif /* __dos */ fprintf ( stderr , \"\\n\" ) ; fprintf ( stderr , \"\\tStatus: \" STATUSSTRING \"\\n\" ) ; fprintf ( stderr , \"\\tUsage: %s [switches] wordfile1 [wordfile2 ...]\\n\" , szTask ) ; fprintf ( stderr , \"\\tSwitches: [-f|-t|-a papersize|-p papersize|-x dtd]\" \"[-m mapping][-w #][-i #][-Ls]\\n\" ) ; fprintf ( stderr , \"\\t\\t-f formatted text output\\n\" ) ; fprintf ( stderr , \"\\t\\t-t text output (default)\\n\" ) ; fprintf ( stderr , \"\\t\\t-a <paper size name> Adobe PDF output\\n\" ) ; fprintf ( stderr , \"\\t\\t-p <paper size name> PostScript output\\n\" ) ; fprintf ( stderr , \"\\t\\t   paper size like: a4, letter or legal\\n\" ) ; fprintf ( stderr , \"\\t\\t-x <dtd> XML output\\n\" ) ; fprintf ( stderr , \"\\t\\t   like: db (DocBook)\\n\" ) ; fprintf ( stderr , \"\\t\\t-m <mapping> character mapping file\\n\" ) ; fprintf ( stderr , \"\\t\\t-w <width> in characters of text output\\n\" ) ; fprintf ( stderr , \"\\t\\t-i <level> image level (PostScript only)\\n\" ) ; fprintf ( stderr , \"\\t\\t-L use landscape mode (PostScript only)\\n\" ) ; fprintf ( stderr , \"\\t\\t-r Show removed text\\n\" ) ; fprintf ( stderr , \"\\t\\t-s Show hidden (by Word) text\\n\" ) ; }",
    "resources/antiword/main_u.c@pStdin2TmpFile": "static FILE * pStdin2TmpFile ( long * lFilesize ) { FILE * pTmpFile ; size_t tSize ; BOOL bFailure ; UCHAR aucBytes [ BUFSIZ ] ; DBG_MSG ( \"pStdin2TmpFile\" ) ; fail ( lFilesize == NULL ) ; /* Open the temporary file */ pTmpFile = tmpfile ( ) ; if ( pTmpFile == NULL ) { return NULL ; } # if defined ( __dos ) /* Stdin must be read as a binary stream */ setmode ( fileno ( stdin ) , O_BINARY ) ; # endif /* __dos */ /* Copy stdin to the temporary file */ * lFilesize = 0 ; bFailure = TRUE ; for ( ; ; ) { tSize = fread ( aucBytes , 1 , sizeof ( aucBytes ) , stdin ) ; if ( tSize == 0 ) { bFailure = feof ( stdin ) == 0 ; break ; } if ( fwrite ( aucBytes , 1 , tSize , pTmpFile ) != tSize ) { bFailure = TRUE ; break ; } * lFilesize += ( long ) tSize ; } # if defined ( __dos ) /* Switch stdin back to a text stream */ setmode ( fileno ( stdin ) , O_TEXT ) ; # endif /* __dos */ /* Deal with the result of the copy action */ if ( bFailure ) { * lFilesize = 0 ; ( void ) fclose ( pTmpFile ) ; return NULL ; } rewind ( pTmpFile ) ; return pTmpFile ; }",
    "resources/antiword/main_u.c@bProcessFile": "static BOOL bProcessFile ( const char * szFilename ) { FILE * pFile ; diagram_type * pDiag ; long lFilesize ; int iWordVersion ; BOOL bResult ; fail ( szFilename == NULL || szFilename [ 0 ] == '\\0' ) ; DBG_MSG ( szFilename ) ; if ( szFilename [ 0 ] == '-' && szFilename [ 1 ] == '\\0' ) { pFile = pStdin2TmpFile ( & lFilesize ) ; if ( pFile == NULL ) { werr ( 0 , \"I can't save the standard input to a file\" ) ; return FALSE ; } } else { pFile = fopen ( szFilename , \"rb\" ) ; if ( pFile == NULL ) { werr ( 0 , \"I can't open '%s' for reading\" , szFilename ) ; return FALSE ; } lFilesize = lGetFilesize ( szFilename ) ; if ( lFilesize < 0 ) { ( void ) fclose ( pFile ) ; werr ( 0 , \"I can't get the size of '%s'\" , szFilename ) ; return FALSE ; } } iWordVersion = iGuessVersionNumber ( pFile , lFilesize ) ; if ( iWordVersion < 0 || iWordVersion == 3 ) { if ( bIsRtfFile ( pFile ) ) { werr ( 0 , \"%s is not a Word Document.\" \" It is probably a Rich Text Format file\" , szFilename ) ; } if ( bIsWordPerfectFile ( pFile ) ) { werr ( 0 , \"%s is not a Word Document.\" \" It is probably a Word Perfect file\" , szFilename ) ; } else { # if defined ( __dos ) werr ( 0 , \"%s is not a Word Document or the filename\" \" is not in the 8+3 format.\" , szFilename ) ; # else werr ( 0 , \"%s is not a Word Document.\" , szFilename ) ; # endif /* __dos */ } ( void ) fclose ( pFile ) ; return FALSE ; } /* Reset any reading done during file testing */ rewind ( pFile ) ; pDiag = pCreateDiagram ( szTask , szFilename ) ; if ( pDiag == NULL ) { ( void ) fclose ( pFile ) ; return FALSE ; } bResult = bWordDecryptor ( pFile , lFilesize , pDiag ) ; vDestroyDiagram ( pDiag ) ; ( void ) fclose ( pFile ) ; return bResult ; }",
    "resources/antiword/main_u.c@main": "int main ( int argc , char * * argv ) { options_type tOptions ; const char * szWordfile ; int iFirst , iIndex , iGoodCount ; BOOL bUsage , bMultiple , bUseTXT , bUseXML ; if ( argc <= 0 ) { return EXIT_FAILURE ; } szTask = szBasename ( argv [ 0 ] ) ; if ( argc <= 1 ) { iFirst = 1 ; bUsage = TRUE ; } else { iFirst = iReadOptions ( argc , argv ) ; bUsage = iFirst <= 0 ; } if ( bUsage ) { vUsage ( ) ; return iFirst < 0 ? EXIT_FAILURE : EXIT_SUCCESS ; } # if defined ( N_PLAT_NLM ) && ! defined ( _VA_LIST ) nwinit ( ) ; # endif /* N_PLAT_NLM && !_VA_LIST */ vGetOptions ( & tOptions ) ; # if ! defined ( __dos ) if ( is_locale_utf8 ( ) ) { # if defined ( __STDC_ISO_10646__ ) /*\n\t\t * If the user wants UTF-8 and the envirionment variables\n\t\t * support UTF-8, than set the locale accordingly\n\t\t */ if ( tOptions . eEncoding == encoding_utf_8 ) { if ( setlocale ( LC_CTYPE , \"\" ) == NULL ) { werr ( 1 , \"Can't set the UTF-8 locale! \" \"Check LANG, LC_CTYPE, LC_ALL.\" ) ; } DBG_MSG ( \"The UTF-8 locale has been set\" ) ; } else { ( void ) setlocale ( LC_CTYPE , \"C\" ) ; } # endif /* __STDC_ISO_10646__ */ } else { if ( setlocale ( LC_CTYPE , \"\" ) == NULL ) { werr ( 0 , \"Can't set the locale! Will use defaults\" ) ; ( void ) setlocale ( LC_CTYPE , \"C\" ) ; } DBG_MSG ( \"The locale has been set\" ) ; } # endif /* !__dos */ bMultiple = argc - iFirst > 1 ; bUseTXT = tOptions . eConversionType == conversion_text || tOptions . eConversionType == conversion_fmt_text ; bUseXML = tOptions . eConversionType == conversion_xml ; iGoodCount = 0 ; # if defined ( __dos ) if ( tOptions . eConversionType == conversion_pdf ) { /* PDF must be written as a binary stream */ setmode ( fileno ( stdout ) , O_BINARY ) ; } # endif /* __dos */ if ( bUseXML ) { fprintf ( stdout , \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\" \"<!DOCTYPE %s PUBLIC \\\"-//OASIS//DTD DocBook XML V4.1.2//EN\\\"\\n\" \"\\t\\\"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd\\\">\\n\" , bMultiple ? \"set\" : \"book\" ) ; if ( bMultiple ) { fprintf ( stdout , \"<set>\\n\" ) ; } } for ( iIndex = iFirst ; iIndex < argc ; iIndex ++ ) { if ( bMultiple && bUseTXT ) { szWordfile = szBasename ( argv [ iIndex ] ) ; fprintf ( stdout , \"::::::::::::::\\n\" ) ; fprintf ( stdout , \"%s\\n\" , szWordfile ) ; fprintf ( stdout , \"::::::::::::::\\n\" ) ; } if ( bProcessFile ( argv [ iIndex ] ) ) { iGoodCount ++ ; } } if ( bMultiple && bUseXML ) { fprintf ( stdout , \"</set>\\n\" ) ; } DBG_DEC ( iGoodCount ) ; return iGoodCount <= 0 ? EXIT_FAILURE : EXIT_SUCCESS ; }",
    "resources/antiword/fonts.c@iGetFontByNumber": "int iGetFontByNumber ( UCHAR ucWordFontNumber , USHORT usFontStyle ) { int iIndex ; for ( iIndex = 0 ; iIndex < ( int ) tFontTableRecords ; iIndex ++ ) { if ( ucWordFontNumber == pFontTable [ iIndex ] . ucWordFontNumber && usFontStyle == pFontTable [ iIndex ] . usFontStyle && pFontTable [ iIndex ] . szOurFontname [ 0 ] != '\\0' ) { return iIndex ; } } DBG_DEC ( ucWordFontNumber ) ; DBG_HEX ( usFontStyle ) ; return - 1 ; }",
    "resources/antiword/fonts.c@szGetOurFontname": "const char * szGetOurFontname ( int iIndex ) { if ( iIndex < 0 || iIndex >= ( int ) tFontTableRecords ) { return NULL ; } return pFontTable [ iIndex ] . szOurFontname ; }",
    "resources/antiword/fonts.c@iFontname2Fontnumber": "int iFontname2Fontnumber ( const char * szOurFontname , USHORT usFontStyle ) { int iIndex ; for ( iIndex = 0 ; iIndex < ( int ) tFontTableRecords ; iIndex ++ ) { if ( pFontTable [ iIndex ] . usFontStyle == usFontStyle && STREQ ( pFontTable [ iIndex ] . szOurFontname , szOurFontname ) ) { return ( int ) pFontTable [ iIndex ] . ucWordFontNumber ; } } return - 1 ; }",
    "resources/antiword/fonts.c@szGetDefaultFont": "static const char * szGetDefaultFont ( UCHAR ucFFN , int iEmphasis ) { UCHAR ucPrq , ucFf ; fail ( iEmphasis < 0 || iEmphasis > 3 ) ; ucPrq = ucFFN & 0x03 ; ucFf = ( ucFFN & 0x70 ) >> 4 ; NO_DBG_DEC ( ucPrq ) ; NO_DBG_DEC ( ucFf ) ; if ( ucPrq == PITCH_FIXED ) { /* Set to the default monospaced font */ switch ( iEmphasis ) { case 1 : return FONT_MONOSPACED_BOLD ; case 2 : return FONT_MONOSPACED_ITALIC ; case 3 : return FONT_MONOSPACED_BOLDITALIC ; default : return FONT_MONOSPACED_PLAIN ; } } else if ( ucFf == FAMILY_ROMAN ) { /* Set to the default serif font */ switch ( iEmphasis ) { case 1 : return FONT_SERIF_BOLD ; case 2 : return FONT_SERIF_ITALIC ; case 3 : return FONT_SERIF_BOLDITALIC ; default : return FONT_SERIF_PLAIN ; } } else if ( ucFf == FAMILY_SWISS ) { /* Set to the default sans serif font */ switch ( iEmphasis ) { case 1 : return FONT_SANS_SERIF_BOLD ; case 2 : return FONT_SANS_SERIF_ITALIC ; case 3 : return FONT_SANS_SERIF_BOLDITALIC ; default : return FONT_SANS_SERIF_PLAIN ; } } else { /* Set to the default default font */ switch ( iEmphasis ) { case 1 : return FONT_SERIF_BOLD ; case 2 : return FONT_SERIF_ITALIC ; case 3 : return FONT_SERIF_BOLDITALIC ; default : return FONT_SERIF_PLAIN ; } } }",
    "resources/antiword/fonts.c@bFontEqual": "static BOOL bFontEqual ( const UCHAR * aucWord , const char * szTable , int iBytesPerChar ) { const UCHAR * pucTmp ; const char * pcTmp ; fail ( aucWord == NULL || szTable == NULL ) ; fail ( iBytesPerChar != 1 && iBytesPerChar != 2 ) ; for ( pucTmp = aucWord , pcTmp = szTable ; * pucTmp != 0 ; pucTmp += iBytesPerChar , pcTmp ++ ) { if ( ulToUpper ( ( ULONG ) * pucTmp ) != ulToUpper ( ( ULONG ) ( UCHAR ) * pcTmp ) ) { return FALSE ; } } return * pcTmp == '\\0' ; }",
    "resources/antiword/fonts.c@vFontname2Table": "static void vFontname2Table ( const UCHAR * aucFont , const UCHAR * aucAltFont , int iBytesPerChar , int iEmphasis , UCHAR ucFFN , const char * szWordFont , const char * szOurFont , font_table_type * pFontTableRecord ) { BOOL bMatchFound ; fail ( aucFont == NULL || aucFont [ 0 ] == 0 ) ; fail ( aucAltFont != NULL && aucAltFont [ 0 ] == 0 ) ; fail ( iBytesPerChar != 1 && iBytesPerChar != 2 ) ; fail ( iEmphasis < 0 || iEmphasis > 3 ) ; fail ( szWordFont == NULL || szWordFont [ 0 ] == '\\0' ) ; fail ( szOurFont == NULL || szOurFont [ 0 ] == '\\0' ) ; fail ( pFontTableRecord == NULL ) ; bMatchFound = bFontEqual ( aucFont , szWordFont , iBytesPerChar ) ; if ( ! bMatchFound && aucAltFont != NULL ) { bMatchFound = bFontEqual ( aucAltFont , szWordFont , iBytesPerChar ) ; } if ( ! bMatchFound && pFontTableRecord -> szWordFontname [ 0 ] == '\\0' && szWordFont [ 0 ] == '*' && szWordFont [ 1 ] == '\\0' ) { /*\n\t\t * szWordFont contains a \"*\", so szOurFont will contain the\n\t\t * \"default default\" font. See if we can do better than that.\n\t\t */ szOurFont = szGetDefaultFont ( ucFFN , iEmphasis ) ; bMatchFound = TRUE ; } if ( bMatchFound ) { switch ( iBytesPerChar ) { case 1 : ( void ) strncpy ( pFontTableRecord -> szWordFontname , ( const char * ) aucFont , sizeof ( pFontTableRecord -> szWordFontname ) - 1 ) ; break ; case 2 : ( void ) unincpy ( pFontTableRecord -> szWordFontname , aucFont , sizeof ( pFontTableRecord -> szWordFontname ) - 1 ) ; break ; default : DBG_FIXME ( ) ; pFontTableRecord -> szWordFontname [ 0 ] = '\\0' ; break ; } pFontTableRecord -> szWordFontname [ sizeof ( pFontTableRecord -> szWordFontname ) - 1 ] = '\\0' ; ( void ) strncpy ( pFontTableRecord -> szOurFontname , szOurFont , sizeof ( pFontTableRecord -> szOurFontname ) - 1 ) ; pFontTableRecord -> szOurFontname [ sizeof ( pFontTableRecord -> szOurFontname ) - 1 ] = '\\0' ; NO_DBG_MSG ( pFontTableRecord -> szWordFontname ) ; NO_DBG_MSG ( pFontTableRecord -> szOurFontname ) ; pFontTableRecord -> ucFFN = ucFFN ; pFontTableRecord -> ucEmphasis = ( UCHAR ) iEmphasis ; } }",
    "resources/antiword/fonts.c@vCreateFontTable": "static void vCreateFontTable ( void ) { font_table_type * pTmp ; int iNbr ; if ( tFontTableRecords == 0 ) { pFontTable = xfree ( pFontTable ) ; return ; } /* Create the font table */ pFontTable = xcalloc ( tFontTableRecords , sizeof ( * pFontTable ) ) ; /* Initialize the font table */ for ( iNbr = 0 , pTmp = pFontTable ; pTmp < pFontTable + tFontTableRecords ; iNbr ++ , pTmp ++ ) { pTmp -> ucWordFontNumber = ( UCHAR ) ( iNbr / 4 ) ; switch ( iNbr % 4 ) { case 0 : pTmp -> usFontStyle = FONT_REGULAR ; break ; case 1 : pTmp -> usFontStyle = FONT_BOLD ; break ; case 2 : pTmp -> usFontStyle = FONT_ITALIC ; break ; case 3 : pTmp -> usFontStyle = FONT_BOLD | FONT_ITALIC ; break ; default : DBG_DEC ( iNbr ) ; break ; } } }",
    "resources/antiword/fonts.c@vMinimizeFontTable": "static void vMinimizeFontTable ( void ) { font_block_type tFontNext ; const style_block_type * pStyle ; const font_block_type * pFont ; font_table_type * pTmp ; int iUnUsed ; BOOL bMustAddTableFont ; NO_DBG_MSG ( \"vMinimizeFontTable\" ) ; if ( tFontTableRecords == 0 ) { pFontTable = xfree ( pFontTable ) ; return ; } /* See if we must add a font for our tables */ bMustAddTableFont = TRUE ; # if 0 DBG_MSG ( \"Before\" ) ; DBG_DEC ( tFontTableRecords ) ; for ( pTmp = pFontTable ; pTmp < pFontTable + tFontTableRecords ; pTmp ++ ) { DBG_DEC ( pTmp -> ucWordFontNumber ) ; DBG_HEX ( pTmp -> usFontStyle ) ; DBG_MSG ( pTmp -> szWordFontname ) ; DBG_MSG ( pTmp -> szOurFontname ) ; } # endif /* DEBUG */ /* See which fonts/styles we really need */ /* Default font/style is by definition in use */ pFontTable [ 0 ] . ucInUse = 1 ; /* Make InUse 1 for all the fonts/styles that WILL be used */ pFont = NULL ; while ( ( pFont = pGetNextFontInfoListItem ( pFont ) ) != NULL ) { pTmp = pFontTable + 4 * ( int ) pFont -> ucFontNumber ; if ( bIsBold ( pFont -> usFontStyle ) ) { pTmp ++ ; } if ( bIsItalic ( pFont -> usFontStyle ) ) { pTmp += 2 ; } if ( pTmp >= pFontTable + tFontTableRecords ) { continue ; } if ( STREQ ( pTmp -> szOurFontname , TABLE_FONT ) ) { /* The table font is already present */ bMustAddTableFont = FALSE ; } pTmp -> ucInUse = 1 ; } /* Make InUse 1 for all the fonts/styles that MIGHT be used */ pStyle = NULL ; while ( ( pStyle = pGetNextStyleInfoListItem ( pStyle ) ) != NULL ) { vFillFontFromStylesheet ( pStyle -> usIstdNext , & tFontNext ) ; vCorrectFontValues ( & tFontNext ) ; pTmp = pFontTable + 4 * ( int ) tFontNext . ucFontNumber ; if ( bIsBold ( tFontNext . usFontStyle ) ) { pTmp ++ ; } if ( bIsItalic ( tFontNext . usFontStyle ) ) { pTmp += 2 ; } if ( pTmp >= pFontTable + tFontTableRecords ) { continue ; } if ( STREQ ( pTmp -> szOurFontname , TABLE_FONT ) ) { /* The table font is already present */ bMustAddTableFont = FALSE ; } pTmp -> ucInUse = 1 ; } /* Remove the unused font entries from the font table */ iUnUsed = 0 ; for ( pTmp = pFontTable ; pTmp < pFontTable + tFontTableRecords ; pTmp ++ ) { if ( pTmp -> ucInUse == 0 ) { iUnUsed ++ ; continue ; } if ( iUnUsed > 0 ) { fail ( pTmp - iUnUsed <= pFontTable ) ; * ( pTmp - iUnUsed ) = * pTmp ; } } fail ( iUnUsed < 0 ) ; fail ( tFontTableRecords <= ( size_t ) iUnUsed ) ; tFontTableRecords -= ( size_t ) iUnUsed ; if ( bMustAddTableFont ) { pTmp = pFontTable + tFontTableRecords ; fail ( pTmp <= pFontTable ) ; pTmp -> ucWordFontNumber = ( pTmp - 1 ) -> ucWordFontNumber + 1 ; pTmp -> usFontStyle = FONT_REGULAR ; pTmp -> ucInUse = 1 ; strcpy ( pTmp -> szWordFontname , \"Extra Table Font\" ) ; strcpy ( pTmp -> szOurFontname , TABLE_FONT ) ; tFontTableRecords ++ ; iUnUsed -- ; } if ( iUnUsed > 0 ) { /* Resize the font table */ pFontTable = xrealloc ( pFontTable , tFontTableRecords * sizeof ( * pFontTable ) ) ; } # if defined ( DEBUG ) DBG_MSG ( \"After\" ) ; DBG_DEC ( tFontTableRecords ) ; for ( pTmp = pFontTable ; pTmp < pFontTable + tFontTableRecords ; pTmp ++ ) { DBG_DEC ( pTmp -> ucWordFontNumber ) ; DBG_HEX ( pTmp -> usFontStyle ) ; DBG_MSG ( pTmp -> szWordFontname ) ; DBG_MSG ( pTmp -> szOurFontname ) ; } # endif /* DEBUG */ }",
    "resources/antiword/fonts.c@bReadFontFile": "static BOOL bReadFontFile ( FILE * pFontTableFile , char * szWordFont , int * piItalic , int * piBold , char * szOurFont , int * piSpecial ) { char * pcTmp ; int iFields ; char szLine [ FONT_LINE_LENGTH ] ; fail ( szWordFont == NULL || szOurFont == NULL ) ; fail ( piItalic == NULL || piBold == NULL || piSpecial == NULL ) ; while ( fgets ( szLine , ( int ) sizeof ( szLine ) , pFontTableFile ) != NULL ) { if ( szLine [ 0 ] == '#' || szLine [ 0 ] == '\\n' || szLine [ 0 ] == '\\r' ) { continue ; } iFields = sscanf ( szLine , \"%[^,],%d,%d,%1s%[^,],%d\" , szWordFont , piItalic , piBold , & szOurFont [ 0 ] , & szOurFont [ 1 ] , piSpecial ) ; if ( iFields != 6 ) { pcTmp = strchr ( szLine , '\\r' ) ; if ( pcTmp != NULL ) { * pcTmp = '\\0' ; } pcTmp = strchr ( szLine , '\\n' ) ; if ( pcTmp != NULL ) { * pcTmp = '\\0' ; } DBG_DEC ( iFields ) ; werr ( 0 , \"Syntax error in: '%s'\" , szLine ) ; continue ; } if ( strlen ( szWordFont ) >= sizeof ( pFontTable [ 0 ] . szWordFontname ) ) { werr ( 0 , \"Word fontname too long: '%s'\" , szWordFont ) ; continue ; } if ( strlen ( szOurFont ) >= sizeof ( pFontTable [ 0 ] . szOurFontname ) ) { werr ( 0 , \"Local fontname too long: '%s'\" , szOurFont ) ; continue ; } /* The current line passed all the tests */ return TRUE ; } return FALSE ; }",
    "resources/antiword/fonts.c@vCreate0FontTable": "void vCreate0FontTable ( void ) { FILE * pFontTableFile ; font_table_type * pTmp ; UCHAR * aucFont ; int iBold , iItalic , iSpecial , iEmphasis , iFtc ; UCHAR ucPrq , ucFf , ucFFN ; char szWordFont [ FONT_LINE_LENGTH ] , szOurFont [ FONT_LINE_LENGTH ] ; tFontTableRecords = 0 ; pFontTable = xfree ( pFontTable ) ; pFontTableFile = pOpenFontTableFile ( ) ; if ( pFontTableFile == NULL ) { /* No translation table file, no translation table */ return ; } /* Get the maximum number of entries in the font table */ tFontTableRecords = 64 ; tFontTableRecords *= 4 ; /* Plain, Bold, Italic and Bold/italic */ tFontTableRecords ++ ; /* One extra for the table-font */ vCreateFontTable ( ) ; /* Read the font translation file */ iItalic = 0 ; iBold = 0 ; iSpecial = 0 ; while ( bReadFontFile ( pFontTableFile , szWordFont , & iItalic , & iBold , szOurFont , & iSpecial ) ) { iEmphasis = 0 ; if ( iBold != 0 ) { iEmphasis ++ ; } if ( iItalic != 0 ) { iEmphasis += 2 ; } for ( iFtc = 0 , pTmp = pFontTable + iEmphasis ; pTmp < pFontTable + tFontTableRecords ; iFtc ++ , pTmp += 4 ) { if ( iFtc >= 16 && iFtc <= 55 ) { ucPrq = PITCH_VARIABLE ; ucFf = FAMILY_ROMAN ; aucFont = ( UCHAR * ) \"Times\" ; } else { ucPrq = PITCH_FIXED ; ucFf = FAMILY_MODERN ; aucFont = ( UCHAR * ) \"Courier\" ; } ucFFN = ( ucFf << 4 ) | ucPrq ; vFontname2Table ( aucFont , NULL , 1 , iEmphasis , ucFFN , szWordFont , szOurFont , pTmp ) ; } } ( void ) fclose ( pFontTableFile ) ; vMinimizeFontTable ( ) ; }",
    "resources/antiword/fonts.c@vCreate2FontTable": "void vCreate2FontTable ( FILE * pFile , int iWordVersion , const UCHAR * aucHeader ) { FILE * pFontTableFile ; font_table_type * pTmp ; UCHAR * aucFont ; UCHAR * aucBuffer ; ULONG ulBeginFontInfo ; size_t tFontInfoLen ; int iPos , iOff , iRecLen ; int iBold , iItalic , iSpecial , iEmphasis ; UCHAR ucFFN ; char szWordFont [ FONT_LINE_LENGTH ] , szOurFont [ FONT_LINE_LENGTH ] ; fail ( pFile == NULL || aucHeader == NULL ) ; fail ( iWordVersion != 1 && iWordVersion != 2 ) ; tFontTableRecords = 0 ; pFontTable = xfree ( pFontTable ) ; pFontTableFile = pOpenFontTableFile ( ) ; if ( pFontTableFile == NULL ) { /* No translation table file, no translation table */ return ; } ulBeginFontInfo = ulGetLong ( 0xb2 , aucHeader ) ; /* fcSttbfffn */ DBG_HEX ( ulBeginFontInfo ) ; tFontInfoLen = ( size_t ) usGetWord ( 0xb6 , aucHeader ) ; /* cbSttbfffn */ DBG_DEC ( tFontInfoLen ) ; if ( ulBeginFontInfo > ( ULONG ) LONG_MAX || tFontInfoLen == 0 ) { /* Don't ask me why this is needed */ DBG_HEX_C ( tFontInfoLen != 0 , ulBeginFontInfo ) ; ( void ) fclose ( pFontTableFile ) ; return ; } aucBuffer = xmalloc ( tFontInfoLen ) ; if ( ! bReadBytes ( aucBuffer , tFontInfoLen , ulBeginFontInfo , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; ( void ) fclose ( pFontTableFile ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tFontInfoLen ) ; DBG_DEC ( usGetWord ( 0 , aucBuffer ) ) ; /* Compute the maximum number of entries in the font table */ if ( iWordVersion == 1 ) { fail ( tFontInfoLen < 2 ) ; /* WinWord 1 has three implicit fonts */ tFontTableRecords = 3 ; iOff = 2 ; } else { fail ( tFontInfoLen < 6 ) ; /* WinWord 2 and up have no implicit fonts */ tFontTableRecords = 0 ; iOff = 3 ; } iPos = 2 ; while ( iPos + iOff < ( int ) tFontInfoLen ) { iRecLen = ( int ) ucGetByte ( iPos , aucBuffer ) ; NO_DBG_DEC ( iRecLen ) ; NO_DBG_MSG ( aucBuffer + iPos + iOff ) ; iPos += iRecLen + 1 ; tFontTableRecords ++ ; } tFontTableRecords *= 4 ; /* Plain, Bold, Italic and Bold/Italic */ tFontTableRecords ++ ; /* One extra for the table-font */ vCreateFontTable ( ) ; /* Add the tree implicit fonts (in four variations) */ if ( iWordVersion == 1 ) { fail ( tFontTableRecords < 13 ) ; vFontname2Table ( ( UCHAR * ) \"Tms Rmn\" , NULL , 1 , 0 , ( UCHAR ) ( ( FAMILY_ROMAN << 4 ) | PITCH_VARIABLE ) , \"*\" , \"Times-Roman\" , pFontTable + 0 ) ; vFontname2Table ( ( UCHAR * ) \"Tms Rmn\" , NULL , 1 , 1 , ( UCHAR ) ( ( FAMILY_ROMAN << 4 ) | PITCH_VARIABLE ) , \"*\" , \"Times-Bold\" , pFontTable + 1 ) ; vFontname2Table ( ( UCHAR * ) \"Tms Rmn\" , NULL , 1 , 2 , ( UCHAR ) ( ( FAMILY_ROMAN << 4 ) | PITCH_VARIABLE ) , \"*\" , \"Times-Italic\" , pFontTable + 2 ) ; vFontname2Table ( ( UCHAR * ) \"Tms Rmn\" , NULL , 1 , 3 , ( UCHAR ) ( ( FAMILY_ROMAN << 4 ) | PITCH_VARIABLE ) , \"*\" , \"Times-BoldItalic\" , pFontTable + 3 ) ; vFontname2Table ( ( UCHAR * ) \"Symbol\" , NULL , 1 , 0 , ( UCHAR ) ( ( FAMILY_ROMAN << 4 ) | PITCH_VARIABLE ) , \"*\" , \"Times-Roman\" , pFontTable + 4 ) ; vFontname2Table ( ( UCHAR * ) \"Symbol\" , NULL , 1 , 1 , ( UCHAR ) ( ( FAMILY_ROMAN << 4 ) | PITCH_VARIABLE ) , \"*\" , \"Times-Bold\" , pFontTable + 5 ) ; vFontname2Table ( ( UCHAR * ) \"Symbol\" , NULL , 1 , 2 , ( UCHAR ) ( ( FAMILY_ROMAN << 4 ) | PITCH_VARIABLE ) , \"*\" , \"Times-Italic\" , pFontTable + 6 ) ; vFontname2Table ( ( UCHAR * ) \"Symbol\" , NULL , 1 , 3 , ( UCHAR ) ( ( FAMILY_ROMAN << 4 ) | PITCH_VARIABLE ) , \"*\" , \"Times-BoldItalic\" , pFontTable + 7 ) ; vFontname2Table ( ( UCHAR * ) \"Helv\" , NULL , 1 , 0 , ( UCHAR ) ( ( FAMILY_SWISS << 4 ) | PITCH_VARIABLE ) , \"*\" , \"Helvetica\" , pFontTable + 8 ) ; vFontname2Table ( ( UCHAR * ) \"Helv\" , NULL , 1 , 1 , ( UCHAR ) ( ( FAMILY_SWISS << 4 ) | PITCH_VARIABLE ) , \"*\" , \"Helvetica-Bold\" , pFontTable + 9 ) ; vFontname2Table ( ( UCHAR * ) \"Helv\" , NULL , 1 , 2 , ( UCHAR ) ( ( FAMILY_SWISS << 4 ) | PITCH_VARIABLE ) , \"*\" , \"Helvetica-Oblique\" , pFontTable + 10 ) ; vFontname2Table ( ( UCHAR * ) \"Helv\" , NULL , 1 , 3 , ( UCHAR ) ( ( FAMILY_SWISS << 4 ) | PITCH_VARIABLE ) , \"*\" , \"Helvetica-BoldOblique\" , pFontTable + 11 ) ; } /* Read the font translation file */ iItalic = 0 ; iBold = 0 ; iSpecial = 0 ; while ( bReadFontFile ( pFontTableFile , szWordFont , & iItalic , & iBold , szOurFont , & iSpecial ) ) { iEmphasis = 0 ; if ( iBold != 0 ) { iEmphasis ++ ; } if ( iItalic != 0 ) { iEmphasis += 2 ; } pTmp = pFontTable + iEmphasis ; iPos = 2 ; while ( iPos + iOff < ( int ) tFontInfoLen ) { iRecLen = ( int ) ucGetByte ( iPos , aucBuffer ) ; ucFFN = ucGetByte ( iPos + 1 , aucBuffer ) ; aucFont = aucBuffer + iPos + iOff ; vFontname2Table ( aucFont , NULL , 1 , iEmphasis , ucFFN , szWordFont , szOurFont , pTmp ) ; pTmp += 4 ; iPos += iRecLen + 1 ; } } ( void ) fclose ( pFontTableFile ) ; aucBuffer = xfree ( aucBuffer ) ; vMinimizeFontTable ( ) ; }",
    "resources/antiword/fonts.c@vCreate6FontTable": "void vCreate6FontTable ( FILE * pFile , ULONG ulStartBlock , const ULONG * aulBBD , size_t tBBDLen , const UCHAR * aucHeader ) { FILE * pFontTableFile ; font_table_type * pTmp ; UCHAR * aucFont , * aucAltFont ; UCHAR * aucBuffer ; ULONG ulBeginFontInfo ; size_t tFontInfoLen ; int iPos , iRecLen , iOffsetAltName ; int iBold , iItalic , iSpecial , iEmphasis ; UCHAR ucFFN ; char szWordFont [ FONT_LINE_LENGTH ] , szOurFont [ FONT_LINE_LENGTH ] ; fail ( pFile == NULL || aucHeader == NULL ) ; fail ( ulStartBlock > MAX_BLOCKNUMBER && ulStartBlock != END_OF_CHAIN ) ; fail ( aulBBD == NULL ) ; tFontTableRecords = 0 ; pFontTable = xfree ( pFontTable ) ; pFontTableFile = pOpenFontTableFile ( ) ; if ( pFontTableFile == NULL ) { /* No translation table file, no translation table */ return ; } ulBeginFontInfo = ulGetLong ( 0xd0 , aucHeader ) ; /* fcSttbfffn */ DBG_HEX ( ulBeginFontInfo ) ; tFontInfoLen = ( size_t ) ulGetLong ( 0xd4 , aucHeader ) ; /* lcbSttbfffn */ DBG_DEC ( tFontInfoLen ) ; fail ( tFontInfoLen < 9 ) ; aucBuffer = xmalloc ( tFontInfoLen ) ; if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucBuffer , ulBeginFontInfo , tFontInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; ( void ) fclose ( pFontTableFile ) ; return ; } DBG_DEC ( usGetWord ( 0 , aucBuffer ) ) ; /* Compute the maximum number of entries in the font table */ tFontTableRecords = 0 ; iPos = 2 ; while ( iPos + 6 < ( int ) tFontInfoLen ) { iRecLen = ( int ) ucGetByte ( iPos , aucBuffer ) ; NO_DBG_DEC ( iRecLen ) ; iOffsetAltName = ( int ) ucGetByte ( iPos + 5 , aucBuffer ) ; NO_DBG_MSG ( aucBuffer + iPos + 6 ) ; NO_DBG_MSG_C ( iOffsetAltName > 0 , aucBuffer + iPos + 6 + iOffsetAltName ) ; iPos += iRecLen + 1 ; tFontTableRecords ++ ; } tFontTableRecords *= 4 ; /* Plain, Bold, Italic and Bold/italic */ tFontTableRecords ++ ; /* One extra for the table-font */ vCreateFontTable ( ) ; /* Read the font translation file */ iItalic = 0 ; iBold = 0 ; iSpecial = 0 ; while ( bReadFontFile ( pFontTableFile , szWordFont , & iItalic , & iBold , szOurFont , & iSpecial ) ) { iEmphasis = 0 ; if ( iBold != 0 ) { iEmphasis ++ ; } if ( iItalic != 0 ) { iEmphasis += 2 ; } pTmp = pFontTable + iEmphasis ; iPos = 2 ; while ( iPos + 6 < ( int ) tFontInfoLen ) { iRecLen = ( int ) ucGetByte ( iPos , aucBuffer ) ; ucFFN = ucGetByte ( iPos + 1 , aucBuffer ) ; aucFont = aucBuffer + iPos + 6 ; iOffsetAltName = ( int ) ucGetByte ( iPos + 5 , aucBuffer ) ; if ( iOffsetAltName <= 0 ) { aucAltFont = NULL ; } else { aucAltFont = aucFont + iOffsetAltName ; NO_DBG_MSG ( aucFont ) ; NO_DBG_MSG ( aucAltFont ) ; } vFontname2Table ( aucFont , aucAltFont , 1 , iEmphasis , ucFFN , szWordFont , szOurFont , pTmp ) ; pTmp += 4 ; iPos += iRecLen + 1 ; } } ( void ) fclose ( pFontTableFile ) ; aucBuffer = xfree ( aucBuffer ) ; vMinimizeFontTable ( ) ; }",
    "resources/antiword/fonts.c@vCreate8FontTable": "void vCreate8FontTable ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { FILE * pFontTableFile ; font_table_type * pTmp ; const ULONG * aulBlockDepot ; UCHAR * aucFont , * aucAltFont ; UCHAR * aucBuffer ; ULONG ulBeginFontInfo ; size_t tFontInfoLen , tBlockDepotLen , tBlockSize ; int iPos , iRecLen , iOffsetAltName ; int iBold , iItalic , iSpecial , iEmphasis ; UCHAR ucFFN ; char szWordFont [ FONT_LINE_LENGTH ] , szOurFont [ FONT_LINE_LENGTH ] ; fail ( pFile == NULL || pPPS == NULL || aucHeader == NULL ) ; fail ( aulBBD == NULL || aulSBD == NULL ) ; tFontTableRecords = 0 ; pFontTable = xfree ( pFontTable ) ; pFontTableFile = pOpenFontTableFile ( ) ; if ( pFontTableFile == NULL ) { /* No translation table file, no translation table */ return ; } ulBeginFontInfo = ulGetLong ( 0x112 , aucHeader ) ; /* fcSttbfffn */ DBG_HEX ( ulBeginFontInfo ) ; tFontInfoLen = ( size_t ) ulGetLong ( 0x116 , aucHeader ) ; /* lcbSttbfffn */ DBG_DEC ( tFontInfoLen ) ; fail ( tFontInfoLen < 46 ) ; DBG_DEC ( pPPS -> tTable . ulSB ) ; DBG_HEX ( pPPS -> tTable . ulSize ) ; if ( pPPS -> tTable . ulSize == 0 ) { DBG_MSG ( \"No fontname table\" ) ; ( void ) fclose ( pFontTableFile ) ; return ; } if ( pPPS -> tTable . ulSize < MIN_SIZE_FOR_BBD_USE ) { /* Use the Small Block Depot */ aulBlockDepot = aulSBD ; tBlockDepotLen = tSBDLen ; tBlockSize = SMALL_BLOCK_SIZE ; } else { /* Use the Big Block Depot */ aulBlockDepot = aulBBD ; tBlockDepotLen = tBBDLen ; tBlockSize = BIG_BLOCK_SIZE ; } aucBuffer = xmalloc ( tFontInfoLen ) ; if ( ! bReadBuffer ( pFile , pPPS -> tTable . ulSB , aulBlockDepot , tBlockDepotLen , tBlockSize , aucBuffer , ulBeginFontInfo , tFontInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; ( void ) fclose ( pFontTableFile ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tFontInfoLen ) ; /* Get the maximum number of entries in the font table */ tFontTableRecords = ( size_t ) usGetWord ( 0 , aucBuffer ) ; tFontTableRecords *= 4 ; /* Plain, Bold, Italic and Bold/italic */ tFontTableRecords ++ ; /* One extra for the table-font */ vCreateFontTable ( ) ; /* Read the font translation file */ iItalic = 0 ; iBold = 0 ; iSpecial = 0 ; while ( bReadFontFile ( pFontTableFile , szWordFont , & iItalic , & iBold , szOurFont , & iSpecial ) ) { iEmphasis = 0 ; if ( iBold != 0 ) { iEmphasis ++ ; } if ( iItalic != 0 ) { iEmphasis += 2 ; } pTmp = pFontTable + iEmphasis ; iPos = 4 ; while ( iPos + 40 < ( int ) tFontInfoLen ) { iRecLen = ( int ) ucGetByte ( iPos , aucBuffer ) ; ucFFN = ucGetByte ( iPos + 1 , aucBuffer ) ; aucFont = aucBuffer + iPos + 40 ; iOffsetAltName = ( int ) unilen ( aucFont ) ; if ( iPos + 40 + iOffsetAltName + 4 >= iRecLen ) { aucAltFont = NULL ; } else { aucAltFont = aucFont + iOffsetAltName + 2 ; NO_DBG_UNICODE ( aucFont ) ; NO_DBG_UNICODE ( aucAltFont ) ; } vFontname2Table ( aucFont , aucAltFont , 2 , iEmphasis , ucFFN , szWordFont , szOurFont , pTmp ) ; pTmp += 4 ; iPos += iRecLen + 1 ; } } ( void ) fclose ( pFontTableFile ) ; aucBuffer = xfree ( aucBuffer ) ; vMinimizeFontTable ( ) ; }",
    "resources/antiword/fonts.c@vDestroyFontTable": "void vDestroyFontTable ( void ) { DBG_MSG ( \"vDestroyFontTable\" ) ; tFontTableRecords = 0 ; pFontTable = xfree ( pFontTable ) ; }",
    "resources/antiword/fonts.c@pGetNextFontTableRecord": "const font_table_type * pGetNextFontTableRecord ( const font_table_type * pRecordCurr ) { size_t tIndexCurr ; if ( pRecordCurr == NULL ) { /* No current record, so start with the first one */ return & pFontTable [ 0 ] ; } if ( pRecordCurr < pFontTable || pRecordCurr >= pFontTable + tFontTableRecords ) { /* Not a pointer in the array */ DBG_HEX ( pRecordCurr ) ; DBG_HEX ( pFontTable ) ; return NULL ; } tIndexCurr = ( size_t ) ( pRecordCurr - pFontTable ) ; if ( tIndexCurr + 1 < tFontTableRecords ) { /* There is a next record, so return it */ return & pFontTable [ tIndexCurr + 1 ] ; } /* There is no next record */ return NULL ; }",
    "resources/antiword/fonts.c@tGetFontTableLength": "size_t tGetFontTableLength ( void ) { return tFontTableRecords ; }",
    "resources/antiword/fonts.c@vCorrect4PDF": "static void vCorrect4PDF ( void ) { font_table_type * pTmp ; const char * szOurFont ; for ( pTmp = pFontTable ; pTmp < pFontTable + tFontTableRecords ; pTmp ++ ) { if ( STRCEQ ( pTmp -> szOurFontname , FONT_MONOSPACED_PLAIN ) || STRCEQ ( pTmp -> szOurFontname , FONT_MONOSPACED_BOLD ) || STRCEQ ( pTmp -> szOurFontname , FONT_MONOSPACED_ITALIC ) || STRCEQ ( pTmp -> szOurFontname , FONT_MONOSPACED_BOLDITALIC ) || STRCEQ ( pTmp -> szOurFontname , FONT_SERIF_PLAIN ) || STRCEQ ( pTmp -> szOurFontname , FONT_SERIF_BOLD ) || STRCEQ ( pTmp -> szOurFontname , FONT_SERIF_ITALIC ) || STRCEQ ( pTmp -> szOurFontname , FONT_SERIF_BOLDITALIC ) || STRCEQ ( pTmp -> szOurFontname , FONT_SANS_SERIF_PLAIN ) || STRCEQ ( pTmp -> szOurFontname , FONT_SANS_SERIF_BOLD ) || STRCEQ ( pTmp -> szOurFontname , FONT_SANS_SERIF_ITALIC ) || STRCEQ ( pTmp -> szOurFontname , FONT_SANS_SERIF_BOLDITALIC ) ) { /* Already a default font */ continue ; } szOurFont = szGetDefaultFont ( pTmp -> ucFFN , ( int ) pTmp -> ucEmphasis ) ; ( void ) strncpy ( pTmp -> szOurFontname , szOurFont , sizeof ( pTmp -> szOurFontname ) - 1 ) ; pTmp -> szOurFontname [ sizeof ( pTmp -> szOurFontname ) - 1 ] = '\\0' ; } }",
    "resources/antiword/fonts.c@vCorrect4CyrPS": "static void vCorrect4CyrPS ( void ) { font_table_type * pTmp ; const char * szOurFont ; UCHAR ucFFN ; ucFFN = ( FAMILY_UNKNOWN << 4 ) | PITCH_FIXED ; for ( pTmp = pFontTable ; pTmp < pFontTable + tFontTableRecords ; pTmp ++ ) { szOurFont = szGetDefaultFont ( ucFFN , ( int ) pTmp -> ucEmphasis ) ; ( void ) strncpy ( pTmp -> szOurFontname , szOurFont , sizeof ( pTmp -> szOurFontname ) - 1 ) ; pTmp -> szOurFontname [ sizeof ( pTmp -> szOurFontname ) - 1 ] = '\\0' ; } }",
    "resources/antiword/fonts.c@vCorrectFontTable": "void vCorrectFontTable ( conversion_type eConversionType , encoding_type eEncoding ) { # if ! defined ( __riscos ) if ( eConversionType == conversion_pdf ) { vCorrect4PDF ( ) ; } if ( eConversionType == conversion_ps && eEncoding == encoding_cyrillic ) { vCorrect4CyrPS ( ) ; } # endif /* __riscos */ }",
    "resources/antiword/fonts.c@lComputeSpaceWidth": "long lComputeSpaceWidth ( drawfile_fontref tFontRef , USHORT usFontSize ) { char szSpace [ ] = \" \" ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; return lComputeStringWidth ( szSpace , 1 , tFontRef , usFontSize ) ; }",
    "resources/antiword/fontlist.c@vDestroyFontInfoList": "void vDestroyFontInfoList ( void ) { font_mem_type * pCurr , * pNext ; DBG_MSG ( \"vDestroyFontInfoList\" ) ; /* Free the Font Information List */ pCurr = pAnchor ; while ( pCurr != NULL ) { pNext = pCurr -> pNext ; pCurr = xfree ( pCurr ) ; pCurr = pNext ; } pAnchor = NULL ; /* Reset all control variables */ pFontLast = NULL ; }",
    "resources/antiword/fontlist.c@vCorrectFontValues": "void vCorrectFontValues ( font_block_type * pFontBlock ) { UINT uiRealSize ; USHORT usRealStyle ; uiRealSize = pFontBlock -> usFontSize ; usRealStyle = pFontBlock -> usFontStyle ; if ( bIsSmallCapitals ( pFontBlock -> usFontStyle ) ) { /* Small capitals become normal capitals in a smaller font */ uiRealSize = ( uiRealSize * 4 + 2 ) / 5 ; usRealStyle &= ~ FONT_SMALL_CAPITALS ; usRealStyle |= FONT_CAPITALS ; } if ( bIsSuperscript ( pFontBlock -> usFontStyle ) || bIsSubscript ( pFontBlock -> usFontStyle ) ) { /* Superscript and subscript use a smaller fontsize */ uiRealSize = ( uiRealSize * 2 + 1 ) / 3 ; } if ( uiRealSize < MIN_FONT_SIZE ) { DBG_DEC ( uiRealSize ) ; uiRealSize = MIN_FONT_SIZE ; } else if ( uiRealSize > MAX_FONT_SIZE ) { DBG_DEC ( uiRealSize ) ; uiRealSize = MAX_FONT_SIZE ; } pFontBlock -> usFontSize = ( USHORT ) uiRealSize ; if ( pFontBlock -> ucFontColor == 8 ) { /* White text to light gray text */ pFontBlock -> ucFontColor = 16 ; } pFontBlock -> usFontStyle = usRealStyle ; }",
    "resources/antiword/fontlist.c@vAdd2FontInfoList": "void vAdd2FontInfoList ( const font_block_type * pFontBlock ) { font_mem_type * pListMember ; fail ( pFontBlock == NULL ) ; NO_DBG_MSG ( \"bAdd2FontInfoList\" ) ; if ( pFontBlock -> ulFileOffset == FC_INVALID ) { /*\n\t\t * This offset is really past the end of the file,\n\t\t * so don't waste any memory by storing it.\n\t\t */ return ; } NO_DBG_HEX ( pFontBlock -> ulFileOffset ) ; NO_DBG_DEC_C ( pFontBlock -> ucFontNumber != 0 , pFontBlock -> ucFontNumber ) ; NO_DBG_DEC_C ( pFontBlock -> usFontSize != DEFAULT_FONT_SIZE , pFontBlock -> usFontSize ) ; NO_DBG_DEC_C ( pFontBlock -> ucFontColor != 0 , pFontBlock -> ucFontColor ) ; NO_DBG_HEX_C ( pFontBlock -> usFontStyle != 0x00 , pFontBlock -> usFontStyle ) ; if ( pFontLast != NULL && pFontLast -> tInfo . ulFileOffset == pFontBlock -> ulFileOffset ) { /*\n\t\t * If two consecutive fonts share the same\n\t\t * offset, remember only the last font\n\t\t */ fail ( pFontLast -> pNext != NULL ) ; pFontLast -> tInfo = * pFontBlock ; return ; } /* Create list member */ pListMember = xmalloc ( sizeof ( font_mem_type ) ) ; /* Fill the list member */ pListMember -> tInfo = * pFontBlock ; pListMember -> pNext = NULL ; /* Correct the values where needed */ vCorrectFontValues ( & pListMember -> tInfo ) ; /* Add the new member to the list */ if ( pAnchor == NULL ) { pAnchor = pListMember ; } else { fail ( pFontLast == NULL ) ; pFontLast -> pNext = pListMember ; } pFontLast = pListMember ; }",
    "resources/antiword/fontlist.c@pGetNextFontInfoListItem": "const font_block_type * pGetNextFontInfoListItem ( const font_block_type * pCurr ) { const font_mem_type * pRecord ; size_t tOffset ; if ( pCurr == NULL ) { if ( pAnchor == NULL ) { /* There are no records */ return NULL ; } /* The first record is the only one without a predecessor */ return & pAnchor -> tInfo ; } tOffset = offsetof ( font_mem_type , tInfo ) ; /* Many casts to prevent alignment warnings */ pRecord = ( font_mem_type * ) ( void * ) ( ( char * ) pCurr - tOffset ) ; fail ( pCurr != & pRecord -> tInfo ) ; if ( pRecord -> pNext == NULL ) { /* The last record has no successor */ return NULL ; } return & pRecord -> pNext -> tInfo ; }",
    "resources/antiword/main_ros.c@bBarInfo": "static BOOL bBarInfo ( event_pollblock * pEvent , void * pvReference ) { diagram_type * pDiag ; TRACE_MSG ( \"bBarInfo\" ) ; fail ( pEvent == NULL ) ; fail ( pEvent -> type != event_SEND ) ; fail ( pEvent -> data . message . header . action != message_MENUWARN ) ; fail ( pvReference == NULL ) ; pDiag = ( diagram_type * ) pvReference ; if ( menu_currentopen != pDiag -> pSaveMenu || pEvent -> data . message . data . menuwarn . selection [ 0 ] != ICONBAR_INFO_FIELD ) { return FALSE ; } Dialog2_OpenDialogMenuLeaf ( pEvent , pInfoBox ) ; return TRUE ; }",
    "resources/antiword/main_ros.c@vBarInfoSetText": "static void vBarInfoSetText ( dialog2_block * pBox ) { TRACE_MSG ( \"vBarInfoSetText\" ) ; fail ( pBox == NULL ) ; fail ( pBox != pInfoBox ) ; Icon_SetText ( pBox -> window , PURPOSE_INFO_FIELD , PURPOSESTRING ) ; Icon_SetText ( pBox -> window , AUTHOR_INFO_FIELD , AUTHORSTRING ) ; Icon_SetText ( pBox -> window , VERSION_INFO_FIELD , VERSIONSTRING ) ; Icon_SetText ( pBox -> window , STATUS_INFO_FIELD , STATUSSTRING ) ; }",
    "resources/antiword/main_ros.c@bMouseButtonClick": "static BOOL bMouseButtonClick ( event_pollblock * pEvent , void * pvReference ) { diagram_type * pDiag ; menu_ptr pMenu ; int iPosY ; TRACE_MSG ( \"bMouseButtonClick\" ) ; fail ( pEvent == NULL ) ; fail ( pEvent -> type != event_CLICK ) ; fail ( pvReference == NULL ) ; pDiag = ( diagram_type * ) pvReference ; if ( pEvent -> data . mouse . button . data . menu ) { pMenu = pDiag -> pSaveMenu ; iPosY = ( pMenu == tDummyDiagram . pSaveMenu ) ? - 1 : pEvent -> data . mouse . pos . y ; Menu_Show ( pMenu , pEvent -> data . mouse . pos . x , iPosY ) ; return TRUE ; } if ( pEvent -> data . mouse . window == pDiag -> tMainWindow && pEvent -> data . mouse . icon == - 1 ) { vMainButtonClick ( & pEvent -> data . mouse ) ; return TRUE ; } if ( pEvent -> data . mouse . window == pDiag -> tScaleWindow && pEvent -> data . mouse . icon >= 0 ) { vScaleButtonClick ( & pEvent -> data . mouse , pDiag ) ; return TRUE ; } return FALSE ; }",
    "resources/antiword/main_ros.c@bAutoRedrawWindow": "static BOOL bAutoRedrawWindow ( event_pollblock * pEvent , void * pvReference ) { return TRUE ; }",
    "resources/antiword/main_ros.c@bSaveSelect": "static BOOL bSaveSelect ( event_pollblock * pEvent , void * pvReference ) { TRACE_MSG ( \"bSaveSelect\" ) ; fail ( pEvent == NULL ) ; fail ( pEvent -> type != event_MENU ) ; fail ( pvReference == NULL ) ; DBG_DEC ( pEvent -> data . selection [ 0 ] ) ; switch ( pEvent -> data . selection [ 0 ] ) { case SAVEMENU_SCALEVIEW : return bScaleOpenAction ( pEvent , pvReference ) ; case SAVEMENU_SAVEDRAW : return bSaveDrawfile ( pEvent , pvReference ) ; case SAVEMENU_SAVETEXT : return bSaveTextfile ( pEvent , pvReference ) ; default : DBG_DEC ( pEvent -> data . selection [ 0 ] ) ; return FALSE ; } }",
    "resources/antiword/main_ros.c@pCreateTextWindow": "static diagram_type * pCreateTextWindow ( const char * szFilename ) { diagram_type * pDiag ; TRACE_MSG ( \"pCreateTextWindow\" ) ; fail ( szFilename == NULL || szFilename [ 0 ] == '\\0' ) ; /* Create the diagram */ pDiag = pCreateDiagram ( szTask + 1 , szFilename ) ; if ( pDiag == NULL ) { werr ( 0 , \"Sorry, no new diagram object\" ) ; return NULL ; } /* Prepare a save menu for this diagram */ pDiag -> pSaveMenu = Menu_New ( szTask + 1 , \">Scale view,\" \">Save (Drawfile)   F3,\" \">Save (Text only) \\213F3\" ) ; if ( pDiag -> pSaveMenu == NULL ) { werr ( 1 , \"Sorry, no Savemenu object\" ) ; } Menu_Warn ( pDiag -> pSaveMenu , SAVEMENU_SCALEVIEW , TRUE , bScaleOpenAction , pDiag ) ; Menu_Warn ( pDiag -> pSaveMenu , SAVEMENU_SAVEDRAW , TRUE , bSaveDrawfile , pDiag ) ; Menu_Warn ( pDiag -> pSaveMenu , SAVEMENU_SAVETEXT , TRUE , bSaveTextfile , pDiag ) ; /* Claim events for the main window */ Event_Claim ( event_REDRAW , pDiag -> tMainWindow , icon_ANY , bRedrawMainWindow , pDiag ) ; Event_Claim ( event_CLOSE , pDiag -> tMainWindow , icon_ANY , bDestroyDiagram , pDiag ) ; Event_Claim ( event_CLICK , pDiag -> tMainWindow , icon_ANY , bMouseButtonClick , pDiag ) ; Event_Claim ( event_KEY , pDiag -> tMainWindow , icon_ANY , bMainKeyPressed , pDiag ) ; /* Claim events for the scale window */ Event_Claim ( event_REDRAW , pDiag -> tScaleWindow , icon_ANY , bAutoRedrawWindow , NULL ) ; Event_Claim ( event_CLICK , pDiag -> tScaleWindow , icon_ANY , bMouseButtonClick , pDiag ) ; Event_Claim ( event_KEY , pDiag -> tScaleWindow , icon_ANY , bScaleKeyPressed , pDiag ) ; /* Set the window title */ vSetTitle ( pDiag ) ; return pDiag ; }",
    "resources/antiword/main_ros.c@vProcessFile": "static void vProcessFile ( const char * szFilename , int iFiletype ) { options_type tOptions ; FILE * pFile ; diagram_type * pDiag ; long lFilesize ; int iWordVersion ; TRACE_MSG ( \"vProcessFile\" ) ; fail ( szFilename == NULL || szFilename [ 0 ] == '\\0' ) ; DBG_MSG ( szFilename ) ; pFile = fopen ( szFilename , \"rb\" ) ; if ( pFile == NULL ) { werr ( 0 , \"I can't open '%s' for reading\" , szFilename ) ; return ; } lFilesize = lGetFilesize ( szFilename ) ; if ( lFilesize < 0 ) { ( void ) fclose ( pFile ) ; werr ( 0 , \"I can't get the size of '%s'\" , szFilename ) ; return ; } iWordVersion = iGuessVersionNumber ( pFile , lFilesize ) ; if ( iWordVersion < 0 || iWordVersion == 3 ) { if ( bIsRtfFile ( pFile ) ) { werr ( 0 , \"%s is not a Word Document.\" \" It is probably a Rich Text Format file\" , szFilename ) ; } if ( bIsWordPerfectFile ( pFile ) ) { werr ( 0 , \"%s is not a Word Document.\" \" It is probably a Word Perfect file\" , szFilename ) ; } else { werr ( 0 , \"%s is not a Word Document.\" , szFilename ) ; } ( void ) fclose ( pFile ) ; return ; } /* Reset any reading done during file-testing */ rewind ( pFile ) ; if ( iFiletype != FILETYPE_MSWORD ) { vGetOptions ( & tOptions ) ; if ( tOptions . bAutofiletypeAllowed ) { vSetFiletype ( szFilename , FILETYPE_MSWORD ) ; } } pDiag = pCreateTextWindow ( szFilename ) ; if ( pDiag == NULL ) { ( void ) fclose ( pFile ) ; return ; } ( void ) bWordDecryptor ( pFile , lFilesize , pDiag ) ; Error_CheckFatal ( Drawfile_VerifyDiagram ( & pDiag -> tInfo ) ) ; vShowDiagram ( pDiag ) ; TRACE_MSG ( \"After vShowDiagram\" ) ; TRACE_MSG ( \"before debug print\" ) ; DBG_HEX ( pFile ) ; TRACE_MSG ( \"before fclose\" ) ; ( void ) fclose ( pFile ) ; TRACE_MSG ( \"after fclose\" ) ; }",
    "resources/antiword/main_ros.c@vSendAck": "static void vSendAck ( event_pollblock * pEvent ) { message_block tMessage ; TRACE_MSG ( \"vSendAck\" ) ; fail ( pEvent == NULL ) ; fail ( pEvent -> type != event_SEND && pEvent -> type != event_SENDWANTACK ) ; fail ( pEvent -> data . message . header . action != message_DATALOAD && pEvent -> data . message . header . action != message_DATAOPEN ) ; tMessage . header . action = message_DATALOADACK ; tMessage . header . size = sizeof ( tMessage ) ; tMessage . header . yourref = pEvent -> data . message . header . myref ; Error_CheckFatal ( Wimp_SendMessage ( event_SEND , & tMessage , pEvent -> data . message . header . sender , 0 ) ) ; }",
    "resources/antiword/main_ros.c@bEventMsgHandler": "static BOOL bEventMsgHandler ( event_pollblock * pEvent , void * pvReference ) { TRACE_MSG ( \"bEventMsgHandler\" ) ; fail ( pEvent == NULL ) ; switch ( pEvent -> type ) { case event_SEND : case event_SENDWANTACK : switch ( pEvent -> data . message . header . action ) { case message_CLOSEDOWN : exit ( EXIT_SUCCESS ) ; break ; case message_DATALOAD : case message_DATAOPEN : vProcessFile ( pEvent -> data . message . data . dataload . filename , pEvent -> data . message . data . dataload . filetype ) ; vSendAck ( pEvent ) ; break ; default : DBG_DEC ( pEvent -> data . message . header . action ) ; break ; } return TRUE ; default : DBG_DEC ( pEvent -> type ) ; return FALSE ; } }",
    "resources/antiword/main_ros.c@bMenuSelect": "static BOOL bMenuSelect ( event_pollblock * pEvent , void * pvReference ) { TRACE_MSG ( \"bMenuSelect\" ) ; fail ( pEvent == NULL ) ; fail ( pEvent -> type != event_MENU ) ; DBG_DEC ( pEvent -> data . selection [ 0 ] ) ; switch ( pEvent -> data . selection [ 0 ] ) { case ICONBAR_INFO_FIELD : return bBarInfo ( pEvent , pvReference ) ; case ICONBAR_CHOICES_FIELD : vChoicesOpenAction ( tChoicesWindow ) ; Window_BringToFront ( tChoicesWindow ) ; break ; case ICONBAR_QUIT_FIELD : TRACE_MSG ( \"before exit\" ) ; exit ( EXIT_SUCCESS ) ; break ; default : DBG_DEC ( pEvent -> data . selection [ 0 ] ) ; break ; } return TRUE ; }",
    "resources/antiword/main_ros.c@bMenuClick": "static BOOL bMenuClick ( event_pollblock * pEvent , void * pvReference ) { TRACE_MSG ( \"bMenuClick\" ) ; fail ( pEvent == NULL ) ; fail ( pEvent -> type != event_MENU ) ; if ( menu_currentopen == tDummyDiagram . pSaveMenu ) { return bMenuSelect ( pEvent , pvReference ) ; } else if ( pvReference == NULL ) { return FALSE ; } return bSaveSelect ( pEvent , pvReference ) ; }",
    "resources/antiword/main_ros.c@vTemplates": "static void vTemplates ( void ) { TRACE_MSG ( \"vTemplates\" ) ; Template_Initialise ( ) ; Template_LoadFile ( \"Templates\" ) ; tChoicesWindow = Window_Create ( \"Choices\" , template_TITLEMIN ) ; if ( tChoicesWindow == 0 ) { werr ( 1 , \"I can't find the 'Choices' template\" ) ; } /* Claim events for the choices window */ Event_Claim ( event_REDRAW , tChoicesWindow , icon_ANY , bAutoRedrawWindow , NULL ) ; Event_Claim ( event_CLICK , tChoicesWindow , icon_ANY , bChoicesMouseClick , NULL ) ; Event_Claim ( event_KEY , tChoicesWindow , icon_ANY , bChoicesKeyPressed , NULL ) ; }",
    "resources/antiword/main_ros.c@vInitialise": "static void vInitialise ( void ) { int aiMessages [ ] = { 0 } ; icon_handle tBarIcon ; TRACE_MSG ( \"vInitialise\" ) ; Resource_Initialise ( szTask + 1 ) ; Event_Initialise3 ( szTask + 1 , 310 , aiMessages ) ; EventMsg_Initialise ( ) ; Screen_CacheModeInfo ( ) ; # if defined ( __GNUC__ ) flex_init ( szTask + 1 , 0 , 0 ) ; flex_set_budge ( 1 ) ; # endif /* __GNUC__ */ vTemplates ( ) ; /* Prepare iconbar menu */ tDummyDiagram . tInfo . data = NULL ; tDummyDiagram . tInfo . length = 0 ; tDummyDiagram . pSaveMenu = Menu_New ( szTask + 1 , \">Info,Choices...,Quit\" ) ; if ( tDummyDiagram . pSaveMenu == NULL ) { werr ( 1 , \"Sorry, no Barmenu object\" ) ; } pInfoBox = Dialog2_CreateDialogBlock ( \"ProgInfo\" , - 1 , - 1 , vBarInfoSetText , NULL , NULL ) ; if ( pInfoBox == NULL ) { werr ( 1 , \"Sorry, no Infobox object\" ) ; } Menu_Warn ( tDummyDiagram . pSaveMenu , ICONBAR_INFO_FIELD , TRUE , bBarInfo , & tDummyDiagram ) ; /* Create an icon on the icon bar */ tBarIcon = Icon_BarIcon ( szTask , iconbar_RIGHT ) ; Event_Claim ( event_CLICK , window_ICONBAR , tBarIcon , bMouseButtonClick , & tDummyDiagram ) ; /* Generic claims */ Event_Claim ( event_OPEN , window_ANY , icon_ANY , Handler_OpenWindow , NULL ) ; Event_Claim ( event_CLOSE , window_ANY , icon_ANY , Handler_CloseWindow , NULL ) ; Event_Claim ( event_MENU , window_ANY , icon_ANY , bMenuClick , NULL ) ; EventMsg_Claim ( message_DATALOAD , window_ICONBAR , bEventMsgHandler , NULL ) ; EventMsg_Claim ( message_MODECHANGE , window_ANY , Handler_ModeChange , NULL ) ; }",
    "resources/antiword/main_ros.c@main": "int main ( int argc , char * * argv ) { int iFirst , iFiletype ; TRACE_MSG ( \"main\" ) ; vInitialise ( ) ; iFirst = iReadOptions ( argc , argv ) ; if ( iFirst != 1 ) { return EXIT_FAILURE ; } if ( argc > 1 ) { iFiletype = iGetFiletype ( argv [ 1 ] ) ; if ( iFiletype < 0 ) { return EXIT_FAILURE ; } vProcessFile ( argv [ 1 ] , iFiletype ) ; TRACE_MSG ( \"main after vProcessFile\" ) ; } for ( ; ; ) { Event_Poll ( ) ; } }",
    "resources/antiword/xmalloc.c@xmalloc": "void * xmalloc ( size_t tSize ) { void * pvTmp ; TRACE_MSG ( \"xmalloc\" ) ; if ( tSize == 0 ) { tSize = 1 ; } pvTmp = malloc ( tSize ) ; if ( pvTmp == NULL ) { DBG_MSG ( \"xmalloc returned NULL\" ) ; DBG_DEC ( tSize ) ; werr ( 1 , szMessage ) ; } return pvTmp ; }",
    "resources/antiword/xmalloc.c@xcalloc": "void * xcalloc ( size_t tNmemb , size_t tSize ) { void * pvTmp ; TRACE_MSG ( \"xcalloc\" ) ; # if defined ( __dos ) && ! defined ( __DJGPP__ ) if ( ( ULONG ) tNmemb * ( ULONG ) tSize > 0xffffUL ) { DBG_DEC ( ( ULONG ) tNmemb * ( ULONG ) tSize ) ; werr ( 1 , szDosMessage ) ; } # endif /* __dos && !__DJGPP__ */ if ( tNmemb == 0 || tSize == 0 ) { tNmemb = 1 ; tSize = 1 ; } pvTmp = calloc ( tNmemb , tSize ) ; if ( pvTmp == NULL ) { DBG_MSG ( \"xcalloc returned NULL\" ) ; werr ( 1 , szMessage ) ; } return pvTmp ; }",
    "resources/antiword/xmalloc.c@xrealloc": "void * xrealloc ( void * pvArg , size_t tSize ) { void * pvTmp ; TRACE_MSG ( \"xrealloc\" ) ; pvTmp = realloc ( pvArg , tSize ) ; if ( pvTmp == NULL ) { DBG_MSG ( \"realloc returned NULL\" ) ; werr ( 1 , szMessage ) ; } return pvTmp ; }",
    "resources/antiword/xmalloc.c@xstrdup": "char * xstrdup ( const char * szArg ) { char * szTmp ; TRACE_MSG ( \"xstrdup\" ) ; szTmp = xmalloc ( strlen ( szArg ) + 1 ) ; strcpy ( szTmp , szArg ) ; return szTmp ; }",
    "resources/antiword/xmalloc.c@xfree": "void * xfree ( void * pvArg ) { TRACE_MSG ( \"xfree\" ) ; if ( pvArg != NULL ) { free ( pvArg ) ; } return NULL ; }",
    "resources/antiword/text.c@vPrologueTXT": "void vPrologueTXT ( diagram_type * pDiag , const options_type * pOptions ) { fail ( pDiag == NULL ) ; fail ( pOptions == NULL ) ; eEncoding = pOptions -> eEncoding ; pDiag -> lXleft = 0 ; pDiag -> lYtop = 0 ; lYtopCurr = 0 ; }",
    "resources/antiword/text.c@vEpilogueTXT": "void vEpilogueTXT ( FILE * pOutFile ) { fail ( pOutFile == NULL ) ; fprintf ( pOutFile , \"\\n\" ) ; }",
    "resources/antiword/text.c@vPrintTXT": "static void vPrintTXT ( FILE * pFile , const char * szString , size_t tStringLength ) { const UCHAR * ucBytes ; size_t tCount ; fail ( szString == NULL ) ; if ( szString == NULL || szString [ 0 ] == '\\0' || tStringLength == 0 ) { return ; } if ( eEncoding == encoding_utf_8 ) { fprintf ( pFile , \"%.*s\" , ( int ) tStringLength , szString ) ; return ; } if ( ucNbsp == 0 ) { ucNbsp = ucGetNbspCharacter ( ) ; DBG_HEX_C ( ucNbsp != 0xa0 , ucNbsp ) ; } ucBytes = ( UCHAR * ) szString ; for ( tCount = 0 ; tCount < tStringLength ; tCount ++ ) { if ( ucBytes [ tCount ] == ucNbsp ) { ( void ) putc ( ' ' , pFile ) ; } else { ( void ) putc ( szString [ tCount ] , pFile ) ; } } }",
    "resources/antiword/text.c@vMoveTo": "static void vMoveTo ( diagram_type * pDiag ) { int iCount , iNbr ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; if ( pDiag -> lYtop != lYtopCurr ) { iNbr = iDrawUnits2Char ( pDiag -> lXleft ) ; for ( iCount = 0 ; iCount < iNbr ; iCount ++ ) { ( void ) putc ( FILLER_CHAR , pDiag -> pOutFile ) ; } lYtopCurr = pDiag -> lYtop ; } }",
    "resources/antiword/text.c@vMove2NextLineTXT": "void vMove2NextLineTXT ( diagram_type * pDiag ) { fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; pDiag -> lYtop ++ ; ( void ) fprintf ( pDiag -> pOutFile , \"\\n\" ) ; }",
    "resources/antiword/text.c@vSubstringTXT": "void vSubstringTXT ( diagram_type * pDiag , const char * szString , size_t tStringLength , long lStringWidth ) { fail ( pDiag == NULL || szString == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( pDiag -> lXleft < 0 ) ; fail ( tStringLength != strlen ( szString ) ) ; if ( szString [ 0 ] == '\\0' || tStringLength == 0 ) { return ; } vMoveTo ( pDiag ) ; vPrintTXT ( pDiag -> pOutFile , szString , tStringLength ) ; pDiag -> lXleft += lStringWidth ; }",
    "resources/antiword/text.c@vStartOfParagraphTXT": "void vStartOfParagraphTXT ( diagram_type * pDiag , long lBeforeIndentation ) { fail ( pDiag == NULL ) ; fail ( lBeforeIndentation < 0 ) ; if ( lBeforeIndentation >= lTwips2MilliPoints ( HEADING_GAP ) ) { /* A large gap is replaced by an empty line */ vMove2NextLineTXT ( pDiag ) ; } }",
    "resources/antiword/text.c@vEndOfParagraphTXT": "void vEndOfParagraphTXT ( diagram_type * pDiag , long lAfterIndentation ) { fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( lAfterIndentation < 0 ) ; if ( pDiag -> lXleft > 0 ) { /* To the start of the line */ vMove2NextLineTXT ( pDiag ) ; } if ( lAfterIndentation >= lTwips2MilliPoints ( HEADING_GAP ) ) { /* A large gap is replaced by an empty line */ vMove2NextLineTXT ( pDiag ) ; } }",
    "resources/antiword/text.c@vEndOfPageTXT": "void vEndOfPageTXT ( diagram_type * pDiag , long lAfterIndentation ) { vEndOfParagraphTXT ( pDiag , lAfterIndentation ) ; }",
    "resources/antiword/rowlist.c@vDestroyRowInfoList": "void vDestroyRowInfoList ( void ) { row_desc_type * pCurr , * pNext ; DBG_MSG ( \"vDestroyRowInfoList\" ) ; /* Free the Row Information List */ pCurr = pAnchor ; while ( pCurr != NULL ) { pNext = pCurr -> pNext ; pCurr = xfree ( pCurr ) ; pCurr = pNext ; } pAnchor = NULL ; /* Reset all control variables */ pRowLast = NULL ; pRowCurrent = NULL ; }",
    "resources/antiword/rowlist.c@vAdd2RowInfoList": "void vAdd2RowInfoList ( const row_block_type * pRowBlock ) { row_desc_type * pListMember ; short * psTmp ; int iIndex ; fail ( pRowBlock == NULL ) ; if ( pRowBlock -> ulFileOffsetStart == FC_INVALID || pRowBlock -> ulFileOffsetEnd == FC_INVALID || pRowBlock -> ulFileOffsetStart == pRowBlock -> ulFileOffsetEnd ) { DBG_HEX_C ( pRowBlock -> ulFileOffsetStart != FC_INVALID , pRowBlock -> ulFileOffsetStart ) ; DBG_HEX_C ( pRowBlock -> ulFileOffsetEnd != FC_INVALID , pRowBlock -> ulFileOffsetEnd ) ; return ; } NO_DBG_HEX ( pRowBlock -> ulFileOffsetStart ) ; NO_DBG_HEX ( pRowBlock -> ulFileOffsetEnd ) ; NO_DBG_DEC ( pRowBlock -> ucNumberOfColumns ) ; /* Create the new list member */ pListMember = xmalloc ( sizeof ( row_desc_type ) ) ; /* Fill the new list member */ pListMember -> tInfo = * pRowBlock ; pListMember -> pNext = NULL ; /* Correct the values where needed */ for ( iIndex = 0 , psTmp = pListMember -> tInfo . asColumnWidth ; iIndex < ( int ) pListMember -> tInfo . ucNumberOfColumns ; iIndex ++ , psTmp ++ ) { if ( * psTmp < 0 ) { * psTmp = 0 ; DBG_MSG ( \"The column width was negative\" ) ; } } /* Add the new member to the list */ if ( pAnchor == NULL ) { pAnchor = pListMember ; pRowCurrent = pListMember ; } else { fail ( pRowLast == NULL ) ; pRowLast -> pNext = pListMember ; } pRowLast = pListMember ; }",
    "resources/antiword/rowlist.c@pGetNextRowInfoListItem": "const row_block_type * pGetNextRowInfoListItem ( void ) { const row_block_type * pItem ; if ( pRowCurrent == NULL ) { return NULL ; } pItem = & pRowCurrent -> tInfo ; pRowCurrent = pRowCurrent -> pNext ; return pItem ; }",
    "resources/antiword/imgexam.c@bFillPaletteDIB": "static BOOL bFillPaletteDIB ( FILE * pFile , imagedata_type * pImg , BOOL bNewFormat ) { int iIndex ; BOOL bIsColorPalette ; fail ( pFile == NULL ) ; fail ( pImg == NULL ) ; if ( pImg -> uiBitsPerComponent > 8 ) { /* No palette, image uses more than 256 colors */ return TRUE ; } if ( pImg -> iColorsUsed <= 0 ) { /* Not specified, so compute the number of colors used */ pImg -> iColorsUsed = 1 << pImg -> uiBitsPerComponent ; } fail ( pImg -> iColorsUsed > 256 ) ; if ( pImg -> iColorsUsed > 256 ) { pImg -> iColorsUsed = 256 ; } bIsColorPalette = FALSE ; for ( iIndex = 0 ; iIndex < pImg -> iColorsUsed ; iIndex ++ ) { /* From BGR order to RGB order */ pImg -> aucPalette [ iIndex ] [ 2 ] = ( UCHAR ) iNextByte ( pFile ) ; pImg -> aucPalette [ iIndex ] [ 1 ] = ( UCHAR ) iNextByte ( pFile ) ; pImg -> aucPalette [ iIndex ] [ 0 ] = ( UCHAR ) iNextByte ( pFile ) ; if ( bNewFormat ) { ( void ) iNextByte ( pFile ) ; } NO_DBG_PRINT_BLOCK ( pImg -> aucPalette [ iIndex ] , 3 ) ; if ( pImg -> aucPalette [ iIndex ] [ 0 ] != pImg -> aucPalette [ iIndex ] [ 1 ] || pImg -> aucPalette [ iIndex ] [ 1 ] != pImg -> aucPalette [ iIndex ] [ 2 ] ) { bIsColorPalette = TRUE ; } } return bIsColorPalette ; }",
    "resources/antiword/imgexam.c@bExamineDIB": "static BOOL bExamineDIB ( FILE * pFile , imagedata_type * pImg ) { size_t tHeaderSize ; int iPlanes , iCompression ; tHeaderSize = ( size_t ) ulNextLong ( pFile ) ; switch ( tHeaderSize ) { case 12 : pImg -> iWidth = ( int ) usNextWord ( pFile ) ; pImg -> iHeight = ( int ) usNextWord ( pFile ) ; iPlanes = ( int ) usNextWord ( pFile ) ; pImg -> uiBitsPerComponent = ( UINT ) usNextWord ( pFile ) ; iCompression = BI_RGB ; pImg -> iColorsUsed = 0 ; break ; case 40 : case 64 : pImg -> iWidth = ( int ) ulNextLong ( pFile ) ; pImg -> iHeight = ( int ) ulNextLong ( pFile ) ; iPlanes = ( int ) usNextWord ( pFile ) ; pImg -> uiBitsPerComponent = ( UINT ) usNextWord ( pFile ) ; iCompression = ( int ) ulNextLong ( pFile ) ; ( void ) tSkipBytes ( pFile , 12 ) ; pImg -> iColorsUsed = ( int ) ulNextLong ( pFile ) ; ( void ) tSkipBytes ( pFile , tHeaderSize - 36 ) ; break ; default : DBG_DEC ( tHeaderSize ) ; return FALSE ; } DBG_DEC ( pImg -> iWidth ) ; DBG_DEC ( pImg -> iHeight ) ; DBG_DEC ( pImg -> uiBitsPerComponent ) ; DBG_DEC ( iCompression ) ; DBG_DEC ( pImg -> iColorsUsed ) ; /* Do some sanity checks with the parameters */ if ( iPlanes != 1 ) { DBG_DEC ( iPlanes ) ; return FALSE ; } if ( pImg -> iWidth <= 0 || pImg -> iHeight <= 0 ) { DBG_DEC ( pImg -> iWidth ) ; DBG_DEC ( pImg -> iHeight ) ; return FALSE ; } if ( pImg -> uiBitsPerComponent != 1 && pImg -> uiBitsPerComponent != 4 && pImg -> uiBitsPerComponent != 8 && pImg -> uiBitsPerComponent != 24 ) { DBG_DEC ( pImg -> uiBitsPerComponent ) ; return FALSE ; } if ( iCompression != BI_RGB && ( pImg -> uiBitsPerComponent == 1 || pImg -> uiBitsPerComponent == 24 ) ) { return FALSE ; } if ( iCompression == BI_RLE8 && pImg -> uiBitsPerComponent == 4 ) { return FALSE ; } if ( iCompression == BI_RLE4 && pImg -> uiBitsPerComponent == 8 ) { return FALSE ; } switch ( iCompression ) { case BI_RGB : pImg -> eCompression = compression_none ; break ; case BI_RLE4 : pImg -> eCompression = compression_rle4 ; break ; case BI_RLE8 : pImg -> eCompression = compression_rle8 ; break ; default : DBG_DEC ( iCompression ) ; return FALSE ; } pImg -> bColorImage = bFillPaletteDIB ( pFile , pImg , tHeaderSize > 12 ) ; if ( pImg -> uiBitsPerComponent <= 8 ) { pImg -> iComponents = 1 ; } else { pImg -> iComponents = ( int ) ( pImg -> uiBitsPerComponent / 8 ) ; } return TRUE ; }",
    "resources/antiword/imgexam.c@iNextMarker": "static int iNextMarker ( FILE * pFile ) { int iMarker ; do { do { iMarker = iNextByte ( pFile ) ; } while ( iMarker != 0xff && iMarker != EOF ) ; if ( iMarker == EOF ) { return EOF ; } do { iMarker = iNextByte ( pFile ) ; } while ( iMarker == 0xff ) ; } while ( iMarker == 0x00 ) ; /* repeat if ff/00 */ return iMarker ; }",
    "resources/antiword/imgexam.c@bExamineJPEG": "static BOOL bExamineJPEG ( FILE * pFile , imagedata_type * pImg ) { size_t tLength ; int iMarker , iIndex ; char appstring [ 10 ] ; BOOL bSOFDone ; tLength = 0 ; bSOFDone = FALSE ; /* process JPEG markers */ while ( ! bSOFDone && ( iMarker = iNextMarker ( pFile ) ) != ( int ) M_EOI ) { switch ( iMarker ) { case EOF : DBG_MSG ( \"Error: unexpected end of JPEG file\" ) ; return FALSE ; /* The following are not officially supported in PostScript level 2 */ case M_SOF2 : case M_SOF3 : case M_SOF5 : case M_SOF6 : case M_SOF7 : case M_SOF9 : case M_SOF10 : case M_SOF11 : case M_SOF13 : case M_SOF14 : case M_SOF15 : DBG_HEX ( iMarker ) ; return FALSE ; case M_SOF0 : case M_SOF1 : tLength = ( size_t ) usNextWordBE ( pFile ) ; pImg -> uiBitsPerComponent = ( UINT ) iNextByte ( pFile ) ; pImg -> iHeight = ( int ) usNextWordBE ( pFile ) ; pImg -> iWidth = ( int ) usNextWordBE ( pFile ) ; pImg -> iComponents = iNextByte ( pFile ) ; bSOFDone = TRUE ; break ; case M_APP14 : /*\n\t\t * Check for Adobe application marker. It is known (per Adobe's\n\t\t * TN5116) to contain the string \"Adobe\" at the start of the\n\t\t * APP14 marker.\n\t\t */ tLength = ( size_t ) usNextWordBE ( pFile ) ; if ( tLength < 12 ) { ( void ) tSkipBytes ( pFile , tLength - 2 ) ; } else { for ( iIndex = 0 ; iIndex < 5 ; iIndex ++ ) { appstring [ iIndex ] = ( char ) iNextByte ( pFile ) ; } appstring [ 5 ] = '\\0' ; if ( STREQ ( appstring , \"Adobe\" ) ) { pImg -> bAdobe = TRUE ; } ( void ) tSkipBytes ( pFile , tLength - 7 ) ; } break ; case M_SOI : /* ignore markers without parameters */ case M_EOI : case M_TEM : case M_RST0 : case M_RST1 : case M_RST2 : case M_RST3 : case M_RST4 : case M_RST5 : case M_RST6 : case M_RST7 : break ; default : /* skip variable length markers */ tLength = ( size_t ) usNextWordBE ( pFile ) ; ( void ) tSkipBytes ( pFile , tLength - 2 ) ; break ; } } DBG_DEC ( pImg -> iWidth ) ; DBG_DEC ( pImg -> iHeight ) ; DBG_DEC ( pImg -> uiBitsPerComponent ) ; DBG_DEC ( pImg -> iComponents ) ; /* Do some sanity checks with the parameters */ if ( pImg -> iHeight <= 0 || pImg -> iWidth <= 0 || pImg -> iComponents <= 0 ) { DBG_DEC ( pImg -> iHeight ) ; DBG_DEC ( pImg -> iWidth ) ; DBG_DEC ( pImg -> iComponents ) ; return FALSE ; } /* Some broken JPEG files have this but they print anyway... */ if ( pImg -> iComponents * 3 + 8 != ( int ) tLength ) { DBG_MSG ( \"Warning: SOF marker has incorrect length - ignored\" ) ; } if ( pImg -> uiBitsPerComponent != 8 ) { DBG_DEC ( pImg -> uiBitsPerComponent ) ; DBG_MSG ( \"Not supported in PostScript level 2\" ) ; return FALSE ; } if ( pImg -> iComponents != 1 && pImg -> iComponents != 3 && pImg -> iComponents != 4 ) { DBG_DEC ( pImg -> iComponents ) ; return FALSE ; } pImg -> bColorImage = pImg -> iComponents >= 3 ; pImg -> iColorsUsed = 0 ; pImg -> eCompression = compression_jpeg ; return TRUE ; }",
    "resources/antiword/imgexam.c@bFillPalettePNG": "static BOOL bFillPalettePNG ( FILE * pFile , imagedata_type * pImg , size_t tLength ) { int iIndex , iEntries ; fail ( pFile == NULL ) ; fail ( pImg == NULL ) ; if ( pImg -> uiBitsPerComponent > 8 ) { /* No palette, image uses more than 256 colors */ return TRUE ; } if ( ! pImg -> bColorImage ) { /* Only color images can have a palette */ return FALSE ; } if ( tLength % 3 != 0 ) { /* Each palette entry takes three bytes */ DBG_DEC ( tLength ) ; return FALSE ; } iEntries = ( int ) ( tLength / 3 ) ; DBG_DEC ( iEntries ) ; pImg -> iColorsUsed = 1 << pImg -> uiBitsPerComponent ; DBG_DEC ( pImg -> iColorsUsed ) ; if ( iEntries > 256 ) { DBG_DEC ( iEntries ) ; return FALSE ; } for ( iIndex = 0 ; iIndex < iEntries ; iIndex ++ ) { pImg -> aucPalette [ iIndex ] [ 0 ] = ( UCHAR ) iNextByte ( pFile ) ; pImg -> aucPalette [ iIndex ] [ 1 ] = ( UCHAR ) iNextByte ( pFile ) ; pImg -> aucPalette [ iIndex ] [ 2 ] = ( UCHAR ) iNextByte ( pFile ) ; NO_DBG_PRINT_BLOCK ( pImg -> aucPalette [ iIndex ] , 3 ) ; } for ( ; iIndex < pImg -> iColorsUsed ; iIndex ++ ) { pImg -> aucPalette [ iIndex ] [ 0 ] = 0 ; pImg -> aucPalette [ iIndex ] [ 1 ] = 0 ; pImg -> aucPalette [ iIndex ] [ 2 ] = 0 ; } return TRUE ; }",
    "resources/antiword/imgexam.c@bExaminePNG": "static BOOL bExaminePNG ( FILE * pFile , imagedata_type * pImg ) { size_t tLength ; ULONG ulLong1 , ulLong2 , ulName ; int iIndex , iTmp ; int iCompressionMethod , iFilterMethod , iInterlaceMethod ; int iColor , iIncrement ; BOOL bHasPalette , bHasAlpha ; UCHAR aucBuf [ 4 ] ; /* Check signature */ ulLong1 = ulNextLongBE ( pFile ) ; ulLong2 = ulNextLongBE ( pFile ) ; if ( ulLong1 != 0x89504e47UL || ulLong2 != 0x0d0a1a0aUL ) { DBG_HEX ( ulLong1 ) ; DBG_HEX ( ulLong2 ) ; return FALSE ; } ulName = 0x00 ; bHasPalette = FALSE ; /* Examine chunks */ while ( ulName != PNG_CN_IEND ) { tLength = ( size_t ) ulNextLongBE ( pFile ) ; ulName = 0x00 ; for ( iIndex = 0 ; iIndex < ( int ) elementsof ( aucBuf ) ; iIndex ++ ) { aucBuf [ iIndex ] = ( UCHAR ) iNextByte ( pFile ) ; if ( ! isalpha ( aucBuf [ iIndex ] ) ) { DBG_HEX ( aucBuf [ iIndex ] ) ; return FALSE ; } ulName <<= 8 ; ulName |= aucBuf [ iIndex ] ; } switch ( ulName ) { case PNG_CN_IHDR : /* Header chunck */ if ( tLength < 13 ) { DBG_DEC ( tLength ) ; return FALSE ; } pImg -> iWidth = ( int ) ulNextLongBE ( pFile ) ; pImg -> iHeight = ( int ) ulNextLongBE ( pFile ) ; pImg -> uiBitsPerComponent = ( UINT ) iNextByte ( pFile ) ; iTmp = iNextByte ( pFile ) ; NO_DBG_HEX ( iTmp ) ; pImg -> bColorImage = ( iTmp & PNG_CB_COLOR ) != 0 ; bHasPalette = ( iTmp & PNG_CB_PALETTE ) != 0 ; bHasAlpha = ( iTmp & PNG_CB_ALPHA ) != 0 ; if ( bHasPalette && pImg -> uiBitsPerComponent > 8 ) { /* This should not happen */ return FALSE ; } pImg -> iComponents = ( bHasPalette || ! pImg -> bColorImage ) ? 1 : 3 ; if ( bHasAlpha ) { pImg -> iComponents ++ ; } iCompressionMethod = iNextByte ( pFile ) ; if ( iCompressionMethod != 0 ) { DBG_DEC ( iCompressionMethod ) ; return FALSE ; } iFilterMethod = iNextByte ( pFile ) ; if ( iFilterMethod != 0 ) { DBG_DEC ( iFilterMethod ) ; return FALSE ; } iInterlaceMethod = iNextByte ( pFile ) ; if ( iInterlaceMethod != 0 ) { DBG_DEC ( iInterlaceMethod ) ; return FALSE ; } pImg -> iColorsUsed = 0 ; ( void ) tSkipBytes ( pFile , tLength - 13 + 4 ) ; break ; case PNG_CN_PLTE : if ( ! bHasPalette ) { return FALSE ; } if ( ! bFillPalettePNG ( pFile , pImg , tLength ) ) { return FALSE ; } ( void ) tSkipBytes ( pFile , 4 ) ; break ; default : ( void ) tSkipBytes ( pFile , tLength + 4 ) ; break ; } } DBG_DEC ( pImg -> iWidth ) ; DBG_DEC ( pImg -> iHeight ) ; DBG_DEC ( pImg -> uiBitsPerComponent ) ; DBG_DEC ( pImg -> iColorsUsed ) ; DBG_DEC ( pImg -> iComponents ) ; /* Do some sanity checks with the parameters */ if ( pImg -> iWidth <= 0 || pImg -> iHeight <= 0 ) { return FALSE ; } if ( pImg -> uiBitsPerComponent != 1 && pImg -> uiBitsPerComponent != 2 && pImg -> uiBitsPerComponent != 4 && pImg -> uiBitsPerComponent != 8 && pImg -> uiBitsPerComponent != 16 ) { DBG_DEC ( pImg -> uiBitsPerComponent ) ; return FALSE ; } if ( pImg -> iComponents != 1 && pImg -> iComponents != 3 ) { /* Not supported */ DBG_DEC ( pImg -> iComponents ) ; return FALSE ; } if ( pImg -> uiBitsPerComponent > 8 ) { /* Not supported */ DBG_DEC ( pImg -> uiBitsPerComponent ) ; return FALSE ; } if ( pImg -> iColorsUsed == 0 && pImg -> iComponents == 1 && pImg -> uiBitsPerComponent <= 4 ) { /*\n\t\t * No palette is supplied, but PostScript needs one in these\n\t\t * cases, so we add a default palette here\n\t\t */ pImg -> iColorsUsed = 1 << pImg -> uiBitsPerComponent ; iIncrement = 0xff / ( pImg -> iColorsUsed - 1 ) ; for ( iIndex = 0 , iColor = 0x00 ; iIndex < pImg -> iColorsUsed ; iIndex ++ , iColor += iIncrement ) { pImg -> aucPalette [ iIndex ] [ 0 ] = ( UCHAR ) iColor ; pImg -> aucPalette [ iIndex ] [ 1 ] = ( UCHAR ) iColor ; pImg -> aucPalette [ iIndex ] [ 2 ] = ( UCHAR ) iColor ; } /* Just to be sure */ pImg -> bColorImage = FALSE ; } pImg -> eCompression = compression_zlib ; return TRUE ; }",
    "resources/antiword/imgexam.c@bExamineWMF": "static BOOL bExamineWMF ( FILE * pFile , imagedata_type * pImg ) { ULONG ulFileSize , ulMaxRecord , ulMagic ; USHORT usType , usHeaderSize , usVersion , usNoObjects ; usType = usNextWord ( pFile ) ; usHeaderSize = usNextWord ( pFile ) ; ulMagic = ( ( ULONG ) usHeaderSize << 16 ) | ( ULONG ) usType ; usVersion = usNextWord ( pFile ) ; ulFileSize = ulNextLong ( pFile ) ; usNoObjects = usNextWord ( pFile ) ; ulMaxRecord = ulNextLong ( pFile ) ; DBG_HEX ( ulMagic ) ; DBG_DEC ( usType ) ; DBG_DEC ( usHeaderSize ) ; DBG_HEX ( usVersion ) ; DBG_DEC ( ulFileSize ) ; DBG_DEC ( usNoObjects ) ; DBG_DEC ( ulMaxRecord ) ; return FALSE ; }",
    "resources/antiword/imgexam.c@vImage2Papersize": "static void vImage2Papersize ( imagedata_type * pImg ) { static int iNetPageHeight = - 1 ; static int iNetPageWidth = - 1 ; options_type tOptions ; double dVerFactor , dHorFactor , dFactor ; DBG_MSG ( \"vImage2Papersize\" ) ; fail ( pImg == NULL ) ; if ( iNetPageHeight < 0 || iNetPageWidth < 0 ) { /* Get the page dimensions from the options */ vGetOptions ( & tOptions ) ; /* Add 999 to err on the save side */ iNetPageHeight = tOptions . iPageHeight - ( lDrawUnits2MilliPoints ( PS_TOP_MARGIN + PS_BOTTOM_MARGIN ) + 999 ) / 1000 ; iNetPageWidth = tOptions . iPageWidth - ( lDrawUnits2MilliPoints ( PS_LEFT_MARGIN + PS_RIGHT_MARGIN ) + 999 ) / 1000 ; DBG_DEC ( iNetPageHeight ) ; DBG_DEC ( iNetPageWidth ) ; } if ( pImg -> iVerSizeScaled < iNetPageHeight && pImg -> iHorSizeScaled < iNetPageWidth ) { /* The image fits on the paper */ return ; } dVerFactor = ( double ) iNetPageHeight / ( double ) pImg -> iVerSizeScaled ; dHorFactor = ( double ) iNetPageWidth / ( double ) pImg -> iHorSizeScaled ; dFactor = min ( dVerFactor , dHorFactor ) ; DBG_FLT ( dFactor ) ; /* Round down, just to be on the save side */ pImg -> iVerSizeScaled = ( int ) ( pImg -> iVerSizeScaled * dFactor ) ; pImg -> iHorSizeScaled = ( int ) ( pImg -> iHorSizeScaled * dFactor ) ; }",
    "resources/antiword/imgexam.c@tFind6Image": "static size_t tFind6Image ( FILE * pFile , size_t tPosition , size_t tLength , imagetype_enum * peImageType ) { ULONG ulMarker ; size_t tRecordLength , tToSkip ; USHORT usMarker ; fail ( pFile == NULL ) ; fail ( peImageType == NULL ) ; * peImageType = imagetype_is_unknown ; if ( tPosition + 18 >= tLength ) { return ( size_t ) - 1 ; } ulMarker = ulNextLong ( pFile ) ; if ( ulMarker != 0x00090001 ) { DBG_HEX ( ulMarker ) ; return ( size_t ) - 1 ; } usMarker = usNextWord ( pFile ) ; if ( usMarker != 0x0300 ) { DBG_HEX ( usMarker ) ; return ( size_t ) - 1 ; } ( void ) tSkipBytes ( pFile , 10 ) ; usMarker = usNextWord ( pFile ) ; if ( usMarker != 0x0000 ) { DBG_HEX ( usMarker ) ; return ( size_t ) - 1 ; } tPosition += 18 ; while ( tPosition + 6 <= tLength ) { tRecordLength = ( size_t ) ulNextLong ( pFile ) ; usMarker = usNextWord ( pFile ) ; tPosition += 6 ; NO_DBG_DEC ( tRecordLength ) ; NO_DBG_HEX ( usMarker ) ; switch ( usMarker ) { case 0x0000 : DBG_HEX ( ulGetDataOffset ( pFile ) ) ; return ( size_t ) - 1 ; case 0x0b41 : DBG_MSG ( \"DIB\" ) ; * peImageType = imagetype_is_dib ; tPosition += tSkipBytes ( pFile , 20 ) ; return tPosition ; case 0x0f43 : DBG_MSG ( \"DIB\" ) ; * peImageType = imagetype_is_dib ; tPosition += tSkipBytes ( pFile , 22 ) ; return tPosition ; default : if ( tRecordLength < 3 ) { break ; } if ( tRecordLength > SIZE_T_MAX / 2 ) { /*\n\t\t\t\t * No need to compute the number of bytes\n\t\t\t\t * to skip\n\t\t\t\t */ DBG_DEC ( tRecordLength ) ; DBG_HEX ( tRecordLength ) ; DBG_FIXME ( ) ; return ( size_t ) - 1 ; } tToSkip = tRecordLength * 2 - 6 ; if ( tToSkip > tLength - tPosition ) { /* You can't skip this number of bytes */ DBG_DEC ( tToSkip ) ; DBG_DEC ( tLength - tPosition ) ; return ( size_t ) - 1 ; } tPosition += tSkipBytes ( pFile , tToSkip ) ; break ; } } return ( size_t ) - 1 ; }",
    "resources/antiword/imgexam.c@tFind8Image": "static size_t tFind8Image ( FILE * pFile , size_t tPosition , size_t tLength , imagetype_enum * peImageType ) { size_t tRecordLength , tNameLen ; USHORT usRecordVersion , usRecordType , usRecordInstance ; USHORT usTmp ; fail ( pFile == NULL ) ; fail ( peImageType == NULL ) ; * peImageType = imagetype_is_unknown ; while ( tPosition + 8 <= tLength ) { usTmp = usNextWord ( pFile ) ; usRecordVersion = usTmp & 0x000f ; usRecordInstance = usTmp >> 4 ; usRecordType = usNextWord ( pFile ) ; tRecordLength = ( size_t ) ulNextLong ( pFile ) ; tPosition += 8 ; NO_DBG_HEX ( usRecordVersion ) ; NO_DBG_HEX ( usRecordInstance ) ; NO_DBG_HEX ( usRecordType ) ; NO_DBG_DEC ( tRecordLength ) ; switch ( usRecordType ) { case 0xf000 : case 0xf001 : case 0xf002 : case 0xf003 : case 0xf004 : case 0xf005 : break ; case 0xf007 : tPosition += tSkipBytes ( pFile , 33 ) ; tNameLen = ( size_t ) iNextByte ( pFile ) ; tPosition ++ ; DBG_DEC_C ( tNameLen != 0 , tNameLen ) ; tPosition += tSkipBytes ( pFile , 2 + tNameLen * 2 ) ; break ; case 0xf008 : tPosition += tSkipBytes ( pFile , 8 ) ; break ; case 0xf009 : tPosition += tSkipBytes ( pFile , 16 ) ; break ; case 0xf006 : case 0xf00a : case 0xf00b : case 0xf00d : case 0xf00e : case 0xf00f : case 0xf010 : case 0xf011 : case 0xf122 : tPosition += tSkipBytes ( pFile , tRecordLength ) ; break ; case 0xf01a : DBG_MSG ( \"EMF\" ) ; * peImageType = imagetype_is_emf ; tPosition += tSkipBytes ( pFile , 50 ) ; if ( ( usRecordInstance ^ MSOBI_EMF ) == 1 ) { tPosition += tSkipBytes ( pFile , 16 ) ; } return tPosition ; case 0xf01b : DBG_MSG ( \"WMF\" ) ; * peImageType = imagetype_is_wmf ; tPosition += tSkipBytes ( pFile , 50 ) ; if ( ( usRecordInstance ^ MSOBI_WMF ) == 1 ) { tPosition += tSkipBytes ( pFile , 16 ) ; } return tPosition ; case 0xf01c : DBG_MSG ( \"PICT\" ) ; * peImageType = imagetype_is_pict ; tPosition += tSkipBytes ( pFile , 50 ) ; if ( ( usRecordInstance ^ MSOBI_PICT ) == 1 ) { tPosition += tSkipBytes ( pFile , 16 ) ; } return tPosition ; case 0xf01d : DBG_MSG ( \"JPEG\" ) ; * peImageType = imagetype_is_jpeg ; tPosition += tSkipBytes ( pFile , 17 ) ; if ( ( usRecordInstance ^ MSOBI_JPEG ) == 1 ) { tPosition += tSkipBytes ( pFile , 16 ) ; } return tPosition ; case 0xf01e : DBG_MSG ( \"PNG\" ) ; * peImageType = imagetype_is_png ; tPosition += tSkipBytes ( pFile , 17 ) ; if ( ( usRecordInstance ^ MSOBI_PNG ) == 1 ) { tPosition += tSkipBytes ( pFile , 16 ) ; } return tPosition ; case 0xf01f : DBG_MSG ( \"DIB\" ) ; /* DIB is a BMP minus its 14 byte header */ * peImageType = imagetype_is_dib ; tPosition += tSkipBytes ( pFile , 17 ) ; if ( ( usRecordInstance ^ MSOBI_DIB ) == 1 ) { tPosition += tSkipBytes ( pFile , 16 ) ; } return tPosition ; case 0xf00c : default : DBG_HEX ( usRecordType ) ; DBG_DEC_C ( tRecordLength % 4 != 0 , tRecordLength ) ; DBG_FIXME ( ) ; return ( size_t ) - 1 ; } } return ( size_t ) - 1 ; }",
    "resources/antiword/imgexam.c@eExamineImage": "image_info_enum eExamineImage ( FILE * pFile , ULONG ulFileOffsetImage , imagedata_type * pImg ) { long lTmp ; size_t tWordHeaderLen , tLength , tPos ; int iType , iHorSize , iVerSize ; USHORT usHorScalingFactor , usVerScalingFactor ; if ( ulFileOffsetImage == FC_INVALID ) { return image_no_information ; } DBG_HEX ( ulFileOffsetImage ) ; if ( ! bSetDataOffset ( pFile , ulFileOffsetImage ) ) { return image_no_information ; } tLength = ( size_t ) ulNextLong ( pFile ) ; DBG_DEC ( tLength ) ; if ( tLength < 46 ) { /* Smaller than the smallest known header */ DBG_FIXME ( ) ; return image_no_information ; } tWordHeaderLen = ( size_t ) usNextWord ( pFile ) ; DBG_DEC ( tWordHeaderLen ) ; fail ( tWordHeaderLen != 46 && tWordHeaderLen != 58 && tWordHeaderLen != 68 ) ; if ( tLength < tWordHeaderLen ) { /* Smaller than the current header */ return image_no_information ; } iType = ( int ) usNextWord ( pFile ) ; DBG_DEC ( iType ) ; ( void ) tSkipBytes ( pFile , 28 - 8 ) ; lTmp = lTwips2MilliPoints ( usNextWord ( pFile ) ) ; iHorSize = ( int ) ( lTmp / 1000 ) ; if ( lTmp % 1000 != 0 ) { iHorSize ++ ; } DBG_DEC ( iHorSize ) ; lTmp = lTwips2MilliPoints ( usNextWord ( pFile ) ) ; iVerSize = ( int ) ( lTmp / 1000 ) ; if ( lTmp % 1000 != 0 ) { iVerSize ++ ; } DBG_DEC ( iVerSize ) ; usHorScalingFactor = usNextWord ( pFile ) ; DBG_DEC ( usHorScalingFactor ) ; usVerScalingFactor = usNextWord ( pFile ) ; DBG_DEC ( usVerScalingFactor ) ; /* Sanity checks */ lTmp = ( long ) iHorSize * ( long ) usHorScalingFactor ; if ( lTmp < 2835 ) { /* This image would be less than 1 millimeter wide */ DBG_DEC ( lTmp ) ; return image_no_information ; } lTmp = ( long ) iVerSize * ( long ) usVerScalingFactor ; if ( lTmp < 2835 ) { /* This image would be less than 1 millimeter high */ DBG_DEC ( lTmp ) ; return image_no_information ; } /* Skip the rest of the header */ ( void ) tSkipBytes ( pFile , tWordHeaderLen - 36 ) ; tPos = tWordHeaderLen ; ( void ) memset ( pImg , 0 , sizeof ( * pImg ) ) ; switch ( iType ) { case 7 : case 8 : tPos = tFind6Image ( pFile , tPos , tLength , & pImg -> eImageType ) ; if ( tPos == ( size_t ) - 1 ) { /* No image found */ return image_no_information ; } DBG_HEX ( tPos ) ; break ; case 94 : /* Word 6/7, no image just a pathname */ pImg -> eImageType = imagetype_is_external ; DBG_HEX ( ulFileOffsetImage + tPos ) ; break ; case 100 : tPos = tFind8Image ( pFile , tPos , tLength , & pImg -> eImageType ) ; if ( tPos == ( size_t ) - 1 ) { /* No image found */ return image_no_information ; } DBG_HEX ( tPos ) ; break ; case 102 : /* Word 8/9/10, no image just a pathname or URL */ pImg -> eImageType = imagetype_is_external ; DBG_HEX ( ulFileOffsetImage + tPos ) ; break ; default : DBG_DEC ( iType ) ; DBG_HEX ( ulFileOffsetImage + tPos ) ; DBG_FIXME ( ) ; return image_no_information ; } /* Minimal information is now available */ pImg -> tLength = tLength ; pImg -> tPosition = tPos ; pImg -> iHorSizeScaled = ( int ) ( ( ( long ) iHorSize * ( long ) usHorScalingFactor + 500 ) / 1000 ) ; pImg -> iVerSizeScaled = ( int ) ( ( ( long ) iVerSize * ( long ) usVerScalingFactor + 500 ) / 1000 ) ; # if ! defined ( __riscos ) vImage2Papersize ( pImg ) ; # endif /* !__riscos */ /* Image type specific examinations */ switch ( pImg -> eImageType ) { case imagetype_is_dib : if ( bExamineDIB ( pFile , pImg ) ) { return image_full_information ; } return image_minimal_information ; case imagetype_is_jpeg : if ( bExamineJPEG ( pFile , pImg ) ) { return image_full_information ; } return image_minimal_information ; case imagetype_is_png : if ( bExaminePNG ( pFile , pImg ) ) { return image_full_information ; } return image_minimal_information ; case imagetype_is_wmf : if ( bExamineWMF ( pFile , pImg ) ) { return image_full_information ; } return image_minimal_information ; case imagetype_is_emf : case imagetype_is_pict : case imagetype_is_external : return image_minimal_information ; case imagetype_is_unknown : default : return image_no_information ; } }",
    "resources/antiword/riscos.c@werr": "void werr ( int iFatal , const char * szFormat , ... ) { va_list tArg ; va_start ( tArg , szFormat ) ; Error_Report ( iFatal , ( char * ) szFormat , tArg ) ; va_end ( tArg ) ; switch ( iFatal ) { case 0 : /* The message is just a warning, so no exit */ return ; case 1 : /* Fatal error with a standard exit */ exit ( EXIT_FAILURE ) ; default : /* Fatal error with a non-standard exit */ exit ( iFatal ) ; } }",
    "resources/antiword/riscos.c@iGetFiletype": "int iGetFiletype ( const char * szFilename ) { os_error * e ; int iType ; fail ( szFilename == NULL || szFilename [ 0 ] == '\\0' ) ; e = SWI ( 2 , 7 , SWI_OS_File | XOS_Bit , 23 , szFilename , NULL , NULL , NULL , NULL , NULL , NULL , & iType ) ; if ( e == NULL ) { return iType ; } werr ( 0 , \"Get Filetype error %d: %s\" , e -> errnum , e -> errmess ) ; return - 1 ; }",
    "resources/antiword/riscos.c@vSetFiletype": "void vSetFiletype ( const char * szFilename , int iFiletype ) { os_error * e ; fail ( szFilename == NULL || szFilename [ 0 ] == '\\0' ) ; if ( iFiletype < 0x000 || iFiletype > 0xfff ) { return ; } e = SWI ( 3 , 0 , SWI_OS_File | XOS_Bit , 18 , szFilename , iFiletype ) ; if ( e != NULL ) { switch ( e -> errnum ) { case 0x000113 : /* ROM */ case 0x0104e1 : /* Read-only floppy DOSFS */ case 0x0108c9 : /* Read-only floppy ADFS */ case 0x013803 : /* Read-only ArcFS */ case 0x80344a : /* CD-ROM */ break ; default : werr ( 0 , \"Set Filetype error %d: %s\" , e -> errnum , e -> errmess ) ; break ; } } }",
    "resources/antiword/riscos.c@bMakeDirectory": "",
    "resources/antiword/riscos.c@iReadCurrentAlphabetNumber": "int iReadCurrentAlphabetNumber ( void ) { os_error * e ; int iAlphabetNumber ; e = SWI ( 2 , 2 , SWI_OS_Byte | XOS_Bit , 71 , 127 , NULL , & iAlphabetNumber ) ; if ( e == NULL ) { return iAlphabetNumber ; } werr ( 0 , \"Read alphabet error %d: %s\" , e -> errnum , e -> errmess ) ; return - 1 ; }",
    "resources/antiword/riscos.c@iGetRiscOsVersion": "int iGetRiscOsVersion ( void ) { os_error * e ; int iVersion ; e = SWI ( 3 , 2 , SWI_OS_Byte | XOS_Bit , 129 , 0 , 0xff , NULL , & iVersion ) ; if ( e != NULL ) { werr ( 0 , \"Read RISC OS version error %d: %s\" , e -> errnum , e -> errmess ) ; return 0 ; } switch ( iVersion ) { case 0xa0 : /* Arthur 1.20 */ return 120 ; case 0xa1 : /* RISC OS 2.00 */ return 200 ; case 0xa2 : /* RISC OS 2.01 */ return 201 ; case 0xa3 : /* RISC OS 3.00 */ return 300 ; case 0xa4 : /* RISC OS 3.1x */ return 310 ; case 0xa5 : /* RISC OS 3.50 */ return 350 ; case 0xa6 : /* RISC OS 3.60 */ return 360 ; case 0xa7 : /* RISC OS 3.7x */ return 370 ; case 0xa8 : /* RISC OS 4.0x */ return 400 ; default : if ( iVersion >= 0xa9 && iVersion <= 0xaf ) { /* RISC OS 4.10 and up */ return 410 ; } /* Unknown version */ return 0 ; } }",
    "resources/antiword/dib2eps.c@vDecode1bpp": "static void vDecode1bpp ( FILE * pInFile , FILE * pOutFile , const imagedata_type * pImg ) { size_t tPadding ; int iX , iY , iN , iByte , iTmp , iEighthWidth , iUse ; DBG_MSG ( \"vDecode1bpp\" ) ; fail ( pOutFile == NULL ) ; fail ( pImg == NULL ) ; fail ( pImg -> iColorsUsed < 1 || pImg -> iColorsUsed > 2 ) ; DBG_DEC ( pImg -> iWidth ) ; DBG_DEC ( pImg -> iHeight ) ; iEighthWidth = ( pImg -> iWidth + 7 ) / 8 ; tPadding = ( size_t ) ( ROUND4 ( iEighthWidth ) - iEighthWidth ) ; for ( iY = 0 ; iY < pImg -> iHeight ; iY ++ ) { for ( iX = 0 ; iX < iEighthWidth ; iX ++ ) { iByte = iNextByte ( pInFile ) ; if ( iByte == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } if ( iX == iEighthWidth - 1 && pImg -> iWidth % 8 != 0 ) { iUse = pImg -> iWidth % 8 ; } else { iUse = 8 ; } for ( iN = 0 ; iN < iUse ; iN ++ ) { switch ( iN ) { case 0 : iTmp = ( iByte & 0x80 ) / 128 ; break ; case 1 : iTmp = ( iByte & 0x40 ) / 64 ; break ; case 2 : iTmp = ( iByte & 0x20 ) / 32 ; break ; case 3 : iTmp = ( iByte & 0x10 ) / 16 ; break ; case 4 : iTmp = ( iByte & 0x08 ) / 8 ; break ; case 5 : iTmp = ( iByte & 0x04 ) / 4 ; break ; case 6 : iTmp = ( iByte & 0x02 ) / 2 ; break ; case 7 : iTmp = ( iByte & 0x01 ) ; break ; default : iTmp = 0 ; break ; } vASCII85EncodeByte ( pOutFile , iTmp ) ; } } ( void ) tSkipBytes ( pInFile , tPadding ) ; } vASCII85EncodeByte ( pOutFile , EOF ) ; }",
    "resources/antiword/dib2eps.c@vDecode4bpp": "static void vDecode4bpp ( FILE * pInFile , FILE * pOutFile , const imagedata_type * pImg ) { size_t tPadding ; int iX , iY , iN , iByte , iTmp , iHalfWidth , iUse ; DBG_MSG ( \"vDecode4bpp\" ) ; fail ( pInFile == NULL ) ; fail ( pOutFile == NULL ) ; fail ( pImg == NULL ) ; fail ( pImg -> iColorsUsed < 1 || pImg -> iColorsUsed > 16 ) ; DBG_DEC ( pImg -> iWidth ) ; DBG_DEC ( pImg -> iHeight ) ; iHalfWidth = ( pImg -> iWidth + 1 ) / 2 ; tPadding = ( size_t ) ( ROUND4 ( iHalfWidth ) - iHalfWidth ) ; for ( iY = 0 ; iY < pImg -> iHeight ; iY ++ ) { for ( iX = 0 ; iX < iHalfWidth ; iX ++ ) { iByte = iNextByte ( pInFile ) ; if ( iByte == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } if ( iX == iHalfWidth - 1 && odd ( pImg -> iWidth ) ) { iUse = 1 ; } else { iUse = 2 ; } for ( iN = 0 ; iN < iUse ; iN ++ ) { if ( odd ( iN ) ) { iTmp = iByte & 0x0f ; } else { iTmp = ( iByte & 0xf0 ) / 16 ; } vASCII85EncodeByte ( pOutFile , iTmp ) ; } } ( void ) tSkipBytes ( pInFile , tPadding ) ; } vASCII85EncodeByte ( pOutFile , EOF ) ; }",
    "resources/antiword/dib2eps.c@vDecode8bpp": "static void vDecode8bpp ( FILE * pInFile , FILE * pOutFile , const imagedata_type * pImg ) { size_t tPadding ; int iX , iY , iByte ; DBG_MSG ( \"vDecode8bpp\" ) ; fail ( pInFile == NULL ) ; fail ( pOutFile == NULL ) ; fail ( pImg == NULL ) ; fail ( pImg -> iColorsUsed < 1 || pImg -> iColorsUsed > 256 ) ; DBG_DEC ( pImg -> iWidth ) ; DBG_DEC ( pImg -> iHeight ) ; tPadding = ( size_t ) ( ROUND4 ( pImg -> iWidth ) - pImg -> iWidth ) ; for ( iY = 0 ; iY < pImg -> iHeight ; iY ++ ) { for ( iX = 0 ; iX < pImg -> iWidth ; iX ++ ) { iByte = iNextByte ( pInFile ) ; if ( iByte == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } vASCII85EncodeByte ( pOutFile , iByte ) ; } ( void ) tSkipBytes ( pInFile , tPadding ) ; } vASCII85EncodeByte ( pOutFile , EOF ) ; }",
    "resources/antiword/dib2eps.c@vDecode24bpp": "static void vDecode24bpp ( FILE * pInFile , FILE * pOutFile , const imagedata_type * pImg ) { size_t tPadding ; int iX , iY , iBlue , iGreen , iRed , iTripleWidth ; DBG_MSG ( \"vDecode24bpp\" ) ; fail ( pInFile == NULL ) ; fail ( pOutFile == NULL ) ; fail ( pImg == NULL ) ; fail ( ! pImg -> bColorImage ) ; DBG_DEC ( pImg -> iWidth ) ; DBG_DEC ( pImg -> iHeight ) ; iTripleWidth = pImg -> iWidth * 3 ; tPadding = ( size_t ) ( ROUND4 ( iTripleWidth ) - iTripleWidth ) ; for ( iY = 0 ; iY < pImg -> iHeight ; iY ++ ) { for ( iX = 0 ; iX < pImg -> iWidth ; iX ++ ) { /* Change from BGR order to RGB order */ iBlue = iNextByte ( pInFile ) ; if ( iBlue == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } iGreen = iNextByte ( pInFile ) ; if ( iGreen == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } iRed = iNextByte ( pInFile ) ; if ( iRed == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } vASCII85EncodeByte ( pOutFile , iRed ) ; vASCII85EncodeByte ( pOutFile , iGreen ) ; vASCII85EncodeByte ( pOutFile , iBlue ) ; } ( void ) tSkipBytes ( pInFile , tPadding ) ; } vASCII85EncodeByte ( pOutFile , EOF ) ; }",
    "resources/antiword/dib2eps.c@vDecodeRle4": "static void vDecodeRle4 ( FILE * pInFile , FILE * pOutFile , const imagedata_type * pImg ) { int iX , iY , iByte , iTmp , iRunLength , iRun ; BOOL bEOF , bEOL ; DBG_MSG ( \"vDecodeRle4\" ) ; fail ( pInFile == NULL ) ; fail ( pOutFile == NULL ) ; fail ( pImg == NULL ) ; fail ( pImg -> iColorsUsed < 1 || pImg -> iColorsUsed > 16 ) ; DBG_DEC ( pImg -> iWidth ) ; DBG_DEC ( pImg -> iHeight ) ; bEOF = FALSE ; for ( iY = 0 ; iY < pImg -> iHeight && ! bEOF ; iY ++ ) { bEOL = FALSE ; iX = 0 ; while ( ! bEOL ) { iRunLength = iNextByte ( pInFile ) ; if ( iRunLength == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } if ( iRunLength != 0 ) { /*\n\t\t\t\t * Encoded packet:\n\t\t\t\t * RunLength pixels, all the \"same\" value\n\t\t\t\t */ iByte = iNextByte ( pInFile ) ; if ( iByte == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } for ( iRun = 0 ; iRun < iRunLength ; iRun ++ ) { if ( odd ( iRun ) ) { iTmp = iByte & 0x0f ; } else { iTmp = ( iByte & 0xf0 ) / 16 ; } if ( iX < pImg -> iWidth ) { vASCII85EncodeByte ( pOutFile , iTmp ) ; } iX ++ ; } continue ; } /* Literal or escape */ iRunLength = iNextByte ( pInFile ) ; if ( iRunLength == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } if ( iRunLength == 0 ) { /* End of line escape */ bEOL = TRUE ; } else if ( iRunLength == 1 ) { /* End of file escape */ bEOF = TRUE ; bEOL = TRUE ; } else if ( iRunLength == 2 ) { /* Delta escape */ DBG_MSG ( \"RLE4: encountered delta escape\" ) ; bEOF = TRUE ; bEOL = TRUE ; } else { /* Literal packet */ iByte = 0 ; for ( iRun = 0 ; iRun < iRunLength ; iRun ++ ) { if ( odd ( iRun ) ) { iTmp = iByte & 0x0f ; } else { iByte = iNextByte ( pInFile ) ; if ( iByte == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } iTmp = ( iByte & 0xf0 ) / 16 ; } if ( iX < pImg -> iWidth ) { vASCII85EncodeByte ( pOutFile , iTmp ) ; } iX ++ ; } /* Padding if the number of bytes is odd */ if ( odd ( ( iRunLength + 1 ) / 2 ) ) { ( void ) tSkipBytes ( pInFile , 1 ) ; } } } DBG_DEC_C ( iX != pImg -> iWidth , iX ) ; } vASCII85EncodeByte ( pOutFile , EOF ) ; }",
    "resources/antiword/dib2eps.c@vDecodeRle8": "static void vDecodeRle8 ( FILE * pInFile , FILE * pOutFile , const imagedata_type * pImg ) { int iX , iY , iByte , iRunLength , iRun ; BOOL bEOF , bEOL ; DBG_MSG ( \"vDecodeRle8\" ) ; fail ( pInFile == NULL ) ; fail ( pOutFile == NULL ) ; fail ( pImg == NULL ) ; fail ( pImg -> iColorsUsed < 1 || pImg -> iColorsUsed > 256 ) ; DBG_DEC ( pImg -> iWidth ) ; DBG_DEC ( pImg -> iHeight ) ; bEOF = FALSE ; for ( iY = 0 ; iY < pImg -> iHeight && ! bEOF ; iY ++ ) { bEOL = FALSE ; iX = 0 ; while ( ! bEOL ) { iRunLength = iNextByte ( pInFile ) ; if ( iRunLength == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } if ( iRunLength != 0 ) { /*\n\t\t\t\t * Encoded packet:\n\t\t\t\t * RunLength pixels, all the same value\n\t\t\t\t */ iByte = iNextByte ( pInFile ) ; if ( iByte == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } for ( iRun = 0 ; iRun < iRunLength ; iRun ++ ) { if ( iX < pImg -> iWidth ) { vASCII85EncodeByte ( pOutFile , iByte ) ; } iX ++ ; } continue ; } /* Literal or escape */ iRunLength = iNextByte ( pInFile ) ; if ( iRunLength == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } if ( iRunLength == 0 ) { /* End of line escape */ bEOL = TRUE ; } else if ( iRunLength == 1 ) { /* End of file escape */ bEOF = TRUE ; bEOL = TRUE ; } else if ( iRunLength == 2 ) { /* Delta escape */ DBG_MSG ( \"RLE8: encountered delta escape\" ) ; bEOF = TRUE ; bEOL = TRUE ; } else { /* Literal packet */ for ( iRun = 0 ; iRun < iRunLength ; iRun ++ ) { iByte = iNextByte ( pInFile ) ; if ( iByte == EOF ) { vASCII85EncodeByte ( pOutFile , EOF ) ; return ; } if ( iX < pImg -> iWidth ) { vASCII85EncodeByte ( pOutFile , iByte ) ; } iX ++ ; } /* Padding if the number of bytes is odd */ if ( odd ( iRunLength ) ) { ( void ) tSkipBytes ( pInFile , 1 ) ; } } } DBG_DEC_C ( iX != pImg -> iWidth , iX ) ; } vASCII85EncodeByte ( pOutFile , EOF ) ; }",
    "resources/antiword/dib2eps.c@vDecodeDIB": "static void vDecodeDIB ( FILE * pInFile , FILE * pOutFile , const imagedata_type * pImg ) { size_t tHeaderSize ; fail ( pInFile == NULL ) ; fail ( pOutFile == NULL ) ; fail ( pImg == NULL ) ; /* Skip the bitmap info header */ tHeaderSize = ( size_t ) ulNextLong ( pInFile ) ; ( void ) tSkipBytes ( pInFile , tHeaderSize - 4 ) ; /* Skip the colortable */ if ( pImg -> uiBitsPerComponent <= 8 ) { ( void ) tSkipBytes ( pInFile , ( size_t ) ( pImg -> iColorsUsed * ( ( tHeaderSize > 12 ) ? 4 : 3 ) ) ) ; } switch ( pImg -> uiBitsPerComponent ) { case 1 : fail ( pImg -> eCompression != compression_none ) ; vDecode1bpp ( pInFile , pOutFile , pImg ) ; break ; case 4 : fail ( pImg -> eCompression != compression_none && pImg -> eCompression != compression_rle4 ) ; if ( pImg -> eCompression == compression_rle4 ) { vDecodeRle4 ( pInFile , pOutFile , pImg ) ; } else { vDecode4bpp ( pInFile , pOutFile , pImg ) ; } break ; case 8 : fail ( pImg -> eCompression != compression_none && pImg -> eCompression != compression_rle8 ) ; if ( pImg -> eCompression == compression_rle8 ) { vDecodeRle8 ( pInFile , pOutFile , pImg ) ; } else { vDecode8bpp ( pInFile , pOutFile , pImg ) ; } break ; case 24 : fail ( pImg -> eCompression != compression_none ) ; vDecode24bpp ( pInFile , pOutFile , pImg ) ; break ; default : DBG_DEC ( pImg -> uiBitsPerComponent ) ; break ; } }",
    "resources/antiword/dib2eps.c@bTranslateDIB": "",
    "resources/antiword/out2window.c@vString2Diagram": "static void vString2Diagram ( diagram_type * pDiag , output_type * pAnchor ) { output_type * pOutput ; long lWidth ; USHORT usMaxFontSize ; TRACE_MSG ( \"vString2Diagram\" ) ; fail ( pDiag == NULL ) ; fail ( pAnchor == NULL ) ; /* Compute the maximum fontsize in this string */ usMaxFontSize = MIN_FONT_SIZE ; for ( pOutput = pAnchor ; pOutput != NULL ; pOutput = pOutput -> pNext ) { if ( pOutput -> usFontSize > usMaxFontSize ) { usMaxFontSize = pOutput -> usFontSize ; } } /* Goto the next line */ vMove2NextLine ( pDiag , pAnchor -> tFontRef , usMaxFontSize ) ; /* Output all substrings */ for ( pOutput = pAnchor ; pOutput != NULL ; pOutput = pOutput -> pNext ) { lWidth = lMilliPoints2DrawUnits ( pOutput -> lStringWidth ) ; vSubstring2Diagram ( pDiag , pOutput -> szStorage , pOutput -> tNextFree , lWidth , pOutput -> ucFontColor , pOutput -> usFontStyle , pOutput -> tFontRef , pOutput -> usFontSize , usMaxFontSize ) ; } /* Goto the start of the line */ pDiag -> lXleft = 0 ; TRACE_MSG ( \"leaving vString2Diagram\" ) ; }",
    "resources/antiword/out2window.c@vSetLeftIndentation": "void vSetLeftIndentation ( diagram_type * pDiag , long lLeftIndentation ) { long lX ; TRACE_MSG ( \"vSetLeftIndentation\" ) ; fail ( pDiag == NULL ) ; fail ( lLeftIndentation < 0 ) ; lX = lMilliPoints2DrawUnits ( lLeftIndentation ) ; if ( lX > 0 ) { pDiag -> lXleft = lX ; } else { pDiag -> lXleft = 0 ; } }",
    "resources/antiword/out2window.c@lComputeNetWidth": "static long lComputeNetWidth ( output_type * pAnchor ) { output_type * pTmp ; long lNetWidth ; TRACE_MSG ( \"lComputeNetWidth\" ) ; fail ( pAnchor == NULL ) ; /* Step 1: Count all but the last sub-string */ lNetWidth = 0 ; for ( pTmp = pAnchor ; pTmp -> pNext != NULL ; pTmp = pTmp -> pNext ) { fail ( pTmp -> lStringWidth < 0 ) ; lNetWidth += pTmp -> lStringWidth ; } fail ( pTmp == NULL ) ; fail ( pTmp -> pNext != NULL ) ; /* Step 2: remove the white-space from the end of the string */ while ( pTmp -> tNextFree != 0 && isspace ( ( int ) ( UCHAR ) pTmp -> szStorage [ pTmp -> tNextFree - 1 ] ) ) { pTmp -> szStorage [ pTmp -> tNextFree - 1 ] = '\\0' ; pTmp -> tNextFree -- ; NO_DBG_DEC ( pTmp -> lStringWidth ) ; pTmp -> lStringWidth = lComputeStringWidth ( pTmp -> szStorage , pTmp -> tNextFree , pTmp -> tFontRef , pTmp -> usFontSize ) ; NO_DBG_DEC ( pTmp -> lStringWidth ) ; } /* Step 3: Count the last sub-string */ lNetWidth += pTmp -> lStringWidth ; return lNetWidth ; }",
    "resources/antiword/out2window.c@iComputeHoles": "static int iComputeHoles ( output_type * pAnchor ) { output_type * pTmp ; size_t tIndex ; int iCounter ; BOOL bWasSpace , bIsSpace ; TRACE_MSG ( \"iComputeHoles\" ) ; fail ( pAnchor == NULL ) ; iCounter = 0 ; bIsSpace = FALSE ; /* Count the holes */ for ( pTmp = pAnchor ; pTmp != NULL ; pTmp = pTmp -> pNext ) { fail ( pTmp -> tNextFree != strlen ( pTmp -> szStorage ) ) ; for ( tIndex = 0 ; tIndex <= pTmp -> tNextFree ; tIndex ++ ) { bWasSpace = bIsSpace ; bIsSpace = isspace ( ( int ) ( UCHAR ) pTmp -> szStorage [ tIndex ] ) ; if ( bWasSpace && ! bIsSpace ) { iCounter ++ ; } } } return iCounter ; }",
    "resources/antiword/out2window.c@vAlign2Window": "void vAlign2Window ( diagram_type * pDiag , output_type * pAnchor , long lScreenWidth , UCHAR ucAlignment ) { long lNetWidth , lLeftIndentation ; TRACE_MSG ( \"vAlign2Window\" ) ; fail ( pDiag == NULL || pAnchor == NULL ) ; fail ( lScreenWidth < lChar2MilliPoints ( MIN_SCREEN_WIDTH ) ) ; lNetWidth = lComputeNetWidth ( pAnchor ) ; if ( lScreenWidth > lChar2MilliPoints ( MAX_SCREEN_WIDTH ) || lNetWidth <= 0 ) { /*\n\t\t * Screenwidth is \"infinite\", so no alignment is possible\n\t\t * Don't bother to align an empty line\n\t\t */ vString2Diagram ( pDiag , pAnchor ) ; TRACE_MSG ( \"leaving vAlign2Window #1\" ) ; return ; } switch ( ucAlignment ) { case ALIGNMENT_CENTER : lLeftIndentation = ( lScreenWidth - lNetWidth ) / 2 ; DBG_DEC_C ( lLeftIndentation < 0 , lLeftIndentation ) ; if ( lLeftIndentation > 0 ) { vSetLeftIndentation ( pDiag , lLeftIndentation ) ; } break ; case ALIGNMENT_RIGHT : lLeftIndentation = lScreenWidth - lNetWidth ; DBG_DEC_C ( lLeftIndentation < 0 , lLeftIndentation ) ; if ( lLeftIndentation > 0 ) { vSetLeftIndentation ( pDiag , lLeftIndentation ) ; } break ; case ALIGNMENT_JUSTIFY : case ALIGNMENT_LEFT : default : break ; } vString2Diagram ( pDiag , pAnchor ) ; TRACE_MSG ( \"leaving vAlign2Window #2\" ) ; }",
    "resources/antiword/out2window.c@vJustify2Window": "void vJustify2Window ( diagram_type * pDiag , output_type * pAnchor , long lScreenWidth , long lRightIndentation , UCHAR ucAlignment ) { output_type * pTmp ; char * pcNew , * pcOld , * szStorage ; long lNetWidth , lSpaceWidth , lToAdd ; int iFillerLen , iHoles ; TRACE_MSG ( \"vJustify2Window\" ) ; fail ( pDiag == NULL || pAnchor == NULL ) ; fail ( lScreenWidth < MIN_SCREEN_WIDTH ) ; fail ( lRightIndentation > 0 ) ; if ( ucAlignment != ALIGNMENT_JUSTIFY ) { vAlign2Window ( pDiag , pAnchor , lScreenWidth , ucAlignment ) ; return ; } lNetWidth = lComputeNetWidth ( pAnchor ) ; if ( lScreenWidth > lChar2MilliPoints ( MAX_SCREEN_WIDTH ) || lNetWidth <= 0 ) { /*\n\t\t * Screenwidth is \"infinite\", so justify is not possible\n\t\t * Don't bother to justify an empty line\n\t\t */ vString2Diagram ( pDiag , pAnchor ) ; TRACE_MSG ( \"leaving vJustify2Window #1\" ) ; return ; } /* Justify */ fail ( ucAlignment != ALIGNMENT_JUSTIFY ) ; lSpaceWidth = lComputeStringWidth ( \" \" , 1 , pAnchor -> tFontRef , pAnchor -> usFontSize ) ; lToAdd = lScreenWidth - lNetWidth - lDrawUnits2MilliPoints ( pDiag -> lXleft ) + lRightIndentation ; # if defined ( DEBUG ) if ( lToAdd / lSpaceWidth < - 1 ) { DBG_DEC ( lSpaceWidth ) ; DBG_DEC ( lToAdd ) ; DBG_DEC ( lScreenWidth ) ; DBG_DEC ( lNetWidth ) ; DBG_DEC ( lDrawUnits2MilliPoints ( pDiag -> lXleft ) ) ; DBG_DEC ( pDiag -> lXleft ) ; DBG_DEC ( lRightIndentation ) ; } # endif /* DEBUG */ lToAdd /= lSpaceWidth ; DBG_DEC_C ( lToAdd < 0 , lToAdd ) ; if ( lToAdd <= 0 ) { vString2Diagram ( pDiag , pAnchor ) ; TRACE_MSG ( \"leaving vJustify2Window #2\" ) ; return ; } /* Justify by adding spaces */ iHoles = iComputeHoles ( pAnchor ) ; for ( pTmp = pAnchor ; pTmp != NULL ; pTmp = pTmp -> pNext ) { fail ( pTmp -> tNextFree != strlen ( pTmp -> szStorage ) ) ; fail ( lToAdd < 0 ) ; szStorage = xmalloc ( pTmp -> tNextFree + ( size_t ) lToAdd + 1 ) ; pcNew = szStorage ; for ( pcOld = pTmp -> szStorage ; * pcOld != '\\0' ; pcOld ++ ) { * pcNew ++ = * pcOld ; if ( * pcOld == ' ' && * ( pcOld + 1 ) != ' ' && iHoles > 0 ) { iFillerLen = ( int ) ( lToAdd / iHoles ) ; lToAdd -= iFillerLen ; iHoles -- ; for ( ; iFillerLen > 0 ; iFillerLen -- ) { * pcNew ++ = ' ' ; } } } * pcNew = '\\0' ; pTmp -> szStorage = xfree ( pTmp -> szStorage ) ; pTmp -> szStorage = szStorage ; pTmp -> tStorageSize = pTmp -> tNextFree + ( size_t ) lToAdd + 1 ; pTmp -> lStringWidth += ( pcNew - szStorage - ( long ) pTmp -> tNextFree ) * lSpaceWidth ; fail ( pcNew < szStorage ) ; pTmp -> tNextFree = ( size_t ) ( pcNew - szStorage ) ; fail ( pTmp -> tNextFree != strlen ( pTmp -> szStorage ) ) ; } DBG_DEC_C ( lToAdd != 0 , lToAdd ) ; vString2Diagram ( pDiag , pAnchor ) ; TRACE_MSG ( \"leaving vJustify2Window #3\" ) ; }",
    "resources/antiword/out2window.c@vResetStyles": "void vResetStyles ( void ) { TRACE_MSG ( \"vResetStyles\" ) ; ( void ) memset ( auiHdrCounter , 0 , sizeof ( auiHdrCounter ) ) ; }",
    "resources/antiword/out2window.c@tStyle2Window": "size_t tStyle2Window ( char * szLine , size_t tLineSize , const style_block_type * pStyle , const section_block_type * pSection ) { char * pcTxt ; size_t tIndex , tStyleIndex ; BOOL bNeedPrevLvl ; level_type_enum eNumType ; UCHAR ucNFC ; TRACE_MSG ( \"tStyle2Window\" ) ; fail ( szLine == NULL || pStyle == NULL || pSection == NULL ) ; if ( pStyle -> usIstd == 0 || pStyle -> usIstd > 9 ) { szLine [ 0 ] = '\\0' ; return 0 ; } /* Set the numbers */ tStyleIndex = ( size_t ) pStyle -> usIstd - 1 ; for ( tIndex = 0 ; tIndex < 9 ; tIndex ++ ) { if ( tIndex == tStyleIndex ) { auiHdrCounter [ tIndex ] ++ ; } else if ( tIndex > tStyleIndex ) { auiHdrCounter [ tIndex ] = 0 ; } else if ( auiHdrCounter [ tIndex ] == 0 ) { auiHdrCounter [ tIndex ] = 1 ; } } eNumType = eGetNumType ( pStyle -> ucNumLevel ) ; if ( eNumType != level_type_outline ) { szLine [ 0 ] = '\\0' ; return 0 ; } /* Print the numbers */ pcTxt = szLine ; bNeedPrevLvl = ( pSection -> usNeedPrevLvl & BIT ( tStyleIndex ) ) != 0 ; for ( tIndex = 0 ; tIndex <= tStyleIndex ; tIndex ++ ) { if ( tIndex == tStyleIndex || ( bNeedPrevLvl && tIndex < tStyleIndex ) ) { if ( pcTxt - szLine >= tLineSize - 25 ) { /* Prevent a possible buffer overflow */ DBG_DEC ( pcTxt - szLine ) ; DBG_DEC ( tLineSize - 25 ) ; DBG_FIXME ( ) ; szLine [ 0 ] = '\\0' ; return 0 ; } ucNFC = pSection -> aucNFC [ tIndex ] ; switch ( ucNFC ) { case LIST_ARABIC_NUM : case LIST_NUMBER_TXT : case LIST_ORDINAL_TXT : pcTxt += sprintf ( pcTxt , \"%u\" , auiHdrCounter [ tIndex ] ) ; break ; case LIST_UPPER_ROMAN : case LIST_LOWER_ROMAN : pcTxt += tNumber2Roman ( auiHdrCounter [ tIndex ] , ucNFC == LIST_UPPER_ROMAN , pcTxt ) ; break ; case LIST_UPPER_ALPHA : case LIST_LOWER_ALPHA : pcTxt += tNumber2Alpha ( auiHdrCounter [ tIndex ] , ucNFC == LIST_UPPER_ALPHA , pcTxt ) ; break ; case LIST_OUTLINE_NUM : pcTxt += sprintf ( pcTxt , \"%02u\" , auiHdrCounter [ tIndex ] ) ; break ; default : DBG_DEC ( ucNFC ) ; DBG_FIXME ( ) ; pcTxt += sprintf ( pcTxt , \"%u\" , auiHdrCounter [ tIndex ] ) ; break ; } if ( tIndex < tStyleIndex ) { * pcTxt ++ = '.' ; } else if ( tIndex == tStyleIndex ) { * pcTxt ++ = ' ' ; } } } * pcTxt = '\\0' ; NO_DBG_MSG_C ( ( int ) pStyle -> usIstd >= 1 && ( int ) pStyle -> usIstd <= 9 && eNumType != level_type_none && eNumType != level_type_outline , szLine ) ; NO_DBG_MSG_C ( szLine [ 0 ] != '\\0' , szLine ) ; fail ( pcTxt < szLine ) ; return ( size_t ) ( pcTxt - szLine ) ; }",
    "resources/antiword/out2window.c@vRemoveRowEnd": "static void vRemoveRowEnd ( char * szRowTxt ) { int iLastIndex ; TRACE_MSG ( \"vRemoveRowEnd\" ) ; fail ( szRowTxt == NULL || szRowTxt [ 0 ] == '\\0' ) ; iLastIndex = ( int ) strlen ( szRowTxt ) - 1 ; if ( szRowTxt [ iLastIndex ] == TABLE_SEPARATOR || szRowTxt [ iLastIndex ] == ( char ) 0x0a ) { szRowTxt [ iLastIndex ] = '\\0' ; iLastIndex -- ; } else { DBG_HEX ( szRowTxt [ iLastIndex ] ) ; } if ( iLastIndex >= 0 && szRowTxt [ iLastIndex ] == ( char ) 0x0a ) { szRowTxt [ iLastIndex ] = '\\0' ; iLastIndex -- ; } if ( iLastIndex >= 0 && szRowTxt [ iLastIndex ] == TABLE_SEPARATOR ) { szRowTxt [ iLastIndex ] = '\\0' ; return ; } DBG_DEC ( iLastIndex ) ; DBG_HEX ( szRowTxt [ iLastIndex ] ) ; DBG_MSG ( szRowTxt ) ; }",
    "resources/antiword/out2window.c@tComputeStringLengthMax": "static size_t tComputeStringLengthMax ( const char * szString , size_t tColumnWidthMax ) { const char * pcTmp ; size_t tLengthMax , tLenPrev , tLen , tWidth ; TRACE_MSG ( \"tComputeStringLengthMax\" ) ; fail ( szString == NULL ) ; fail ( tColumnWidthMax == 0 ) ; pcTmp = strchr ( szString , '\\n' ) ; if ( pcTmp != NULL ) { tLengthMax = ( size_t ) ( pcTmp - szString + 1 ) ; } else { tLengthMax = strlen ( szString ) ; } if ( tLengthMax == 0 ) { return 0 ; } tLen = 0 ; tWidth = 0 ; for ( ; ; ) { tLenPrev = tLen ; tLen += tGetCharacterLength ( szString + tLen ) ; DBG_DEC_C ( tLen > tLengthMax , tLen ) ; DBG_DEC_C ( tLen > tLengthMax , tLengthMax ) ; fail ( tLen > tLengthMax ) ; tWidth = tCountColumns ( szString , tLen ) ; if ( tWidth > tColumnWidthMax ) { return tLenPrev ; } if ( tLen >= tLengthMax ) { return tLengthMax ; } } }",
    "resources/antiword/out2window.c@tGetBreakingPoint": "static size_t tGetBreakingPoint ( const char * szString , size_t tLen , size_t tWidth , size_t tColumnWidthMax ) { int iIndex ; TRACE_MSG ( \"tGetBreakingPoint\" ) ; fail ( szString == NULL ) ; fail ( tLen > strlen ( szString ) ) ; fail ( tWidth > tColumnWidthMax ) ; if ( tWidth < tColumnWidthMax || ( tWidth == tColumnWidthMax && ( szString [ tLen ] == ' ' || szString [ tLen ] == '\\n' || szString [ tLen ] == '\\0' ) ) ) { /* The string already fits, do nothing */ return tLen ; } /* Search for a breaking point */ for ( iIndex = ( int ) tLen - 1 ; iIndex >= 0 ; iIndex -- ) { if ( szString [ iIndex ] == ' ' ) { return ( size_t ) iIndex ; } } /* No breaking point found, just fill the column */ return tLen ; }",
    "resources/antiword/out2window.c@tComputeColumnWidthMax": "static size_t tComputeColumnWidthMax ( short sWidth , long lCharWidth , double dFactor ) { size_t tColumnWidthMax ; TRACE_MSG ( \"tComputeColumnWidthMax\" ) ; fail ( sWidth < 0 ) ; fail ( lCharWidth <= 0 ) ; fail ( dFactor <= 0.0 ) ; tColumnWidthMax = ( size_t ) ( ( lTwips2MilliPoints ( sWidth ) * dFactor + lCharWidth / 2.0 ) / lCharWidth ) ; if ( tColumnWidthMax == 0 ) { /* Minimum column width */ return 1 ; } if ( tColumnWidthMax > 1 ) { /* Make room for the TABLE_SEPARATOR_CHAR */ tColumnWidthMax -- ; } NO_DBG_DEC ( tColumnWidthMax ) ; return tColumnWidthMax ; }",
    "resources/antiword/out2window.c@vTableRow2Window": "void vTableRow2Window ( diagram_type * pDiag , output_type * pOutput , const row_block_type * pRowInfo , conversion_type eConversionType , int iParagraphBreak ) { output_type tRow ; char * aszColTxt [ TABLE_COLUMN_MAX ] ; char * szLine , * pcTxt ; double dMagnify ; long lCharWidthLarge , lCharWidthSmall ; size_t tColumnWidthTotal , atColumnWidthMax [ TABLE_COLUMN_MAX ] ; size_t tSize , tColumnWidthMax , tWidth , tLen ; int iIndex , iNbrOfColumns , iTmp ; BOOL bNotReady ; TRACE_MSG ( \"vTableRow2Window\" ) ; fail ( pDiag == NULL || pOutput == NULL || pRowInfo == NULL ) ; fail ( pOutput -> szStorage == NULL ) ; fail ( pOutput -> pNext != NULL ) ; fail ( iParagraphBreak < 0 ) ; /* Character sizes */ lCharWidthLarge = lComputeStringWidth ( \"W\" , 1 , pOutput -> tFontRef , pOutput -> usFontSize ) ; NO_DBG_DEC ( lCharWidthLarge ) ; lCharWidthSmall = lComputeStringWidth ( \"i\" , 1 , pOutput -> tFontRef , pOutput -> usFontSize ) ; NO_DBG_DEC ( lCharWidthSmall ) ; /* For the time being: use a fixed width font */ fail ( lCharWidthLarge != lCharWidthSmall ) ; vRemoveRowEnd ( pOutput -> szStorage ) ; /* Split the row text into a set of column texts */ aszColTxt [ 0 ] = pOutput -> szStorage ; for ( iNbrOfColumns = 1 ; iNbrOfColumns < TABLE_COLUMN_MAX ; iNbrOfColumns ++ ) { aszColTxt [ iNbrOfColumns ] = strchr ( aszColTxt [ iNbrOfColumns - 1 ] , TABLE_SEPARATOR ) ; if ( aszColTxt [ iNbrOfColumns ] == NULL ) { break ; } * aszColTxt [ iNbrOfColumns ] = '\\0' ; aszColTxt [ iNbrOfColumns ] ++ ; NO_DBG_DEC ( iNbrOfColumns ) ; NO_DBG_MSG ( aszColTxt [ iNbrOfColumns ] ) ; } /* Work around a bug in Word */ while ( iNbrOfColumns > ( int ) pRowInfo -> ucNumberOfColumns && pRowInfo -> asColumnWidth [ iNbrOfColumns ] == 0 ) { iNbrOfColumns -- ; } DBG_DEC_C ( iNbrOfColumns != ( int ) pRowInfo -> ucNumberOfColumns , iNbrOfColumns ) ; DBG_DEC_C ( iNbrOfColumns != ( int ) pRowInfo -> ucNumberOfColumns , pRowInfo -> ucNumberOfColumns ) ; if ( iNbrOfColumns != ( int ) pRowInfo -> ucNumberOfColumns ) { werr ( 0 , \"Skipping an unmatched table row\" ) ; return ; } # if defined ( __FULL_TEXT_SEARCH ) /* No table formatting: use for full-text search (untested) */ for ( iIndex = 0 ; iIndex < iNbrOfColumns ; iIndex ++ ) { fprintf ( pDiag -> pOutFile , \"%s\\n\" , aszColTxt [ iIndex ] ) ; } # else if ( bAddTableRow ( pDiag , aszColTxt , iNbrOfColumns , pRowInfo -> asColumnWidth , pRowInfo -> ucBorderInfo ) ) { /* All work has been done */ return ; } /* Fill the table with maximum column widths */ if ( eConversionType == conversion_text || eConversionType == conversion_fmt_text ) { if ( iParagraphBreak == 0 || iParagraphBreak >= MAX_SCREEN_WIDTH ) { dMagnify = ( double ) MAX_SCREEN_WIDTH ; } else if ( iParagraphBreak <= MIN_SCREEN_WIDTH ) { dMagnify = ( double ) MIN_SCREEN_WIDTH ; } else { dMagnify = ( double ) iParagraphBreak ; } dMagnify /= ( double ) DEFAULT_SCREEN_WIDTH ; DBG_FLT_C ( dMagnify < 0.99 || dMagnify > 1.01 , dMagnify ) ; } else { dMagnify = 1.0 ; } tColumnWidthTotal = 0 ; for ( iIndex = 0 ; iIndex < iNbrOfColumns ; iIndex ++ ) { atColumnWidthMax [ iIndex ] = tComputeColumnWidthMax ( pRowInfo -> asColumnWidth [ iIndex ] , lCharWidthLarge , dMagnify ) ; tColumnWidthTotal += atColumnWidthMax [ iIndex ] ; } /*\n\t * Get enough space for the row.\n\t * Worst case: three bytes per UTF-8 character\n\t */ tSize = 3 * ( 1 + tColumnWidthTotal + ( size_t ) iNbrOfColumns + 3 ) ; szLine = xmalloc ( tSize ) ; do { /* Print one line of a table row */ bNotReady = FALSE ; pcTxt = szLine ; * pcTxt ++ = TABLE_SEPARATOR_CHAR ; for ( iIndex = 0 ; iIndex < iNbrOfColumns ; iIndex ++ ) { tColumnWidthMax = atColumnWidthMax [ iIndex ] ; if ( aszColTxt [ iIndex ] == NULL ) { /* Add an empty column */ for ( iTmp = 0 ; iTmp < ( int ) tColumnWidthMax ; iTmp ++ ) { * pcTxt ++ = ( char ) FILLER_CHAR ; } * pcTxt ++ = TABLE_SEPARATOR_CHAR ; * pcTxt = '\\0' ; continue ; } /* Compute the length and width of the column text */ tLen = tComputeStringLengthMax ( aszColTxt [ iIndex ] , tColumnWidthMax ) ; NO_DBG_DEC ( tLen ) ; while ( tLen != 0 && ( aszColTxt [ iIndex ] [ tLen - 1 ] == '\\n' || aszColTxt [ iIndex ] [ tLen - 1 ] == ' ' ) ) { aszColTxt [ iIndex ] [ tLen - 1 ] = ' ' ; tLen -- ; } tWidth = tCountColumns ( aszColTxt [ iIndex ] , tLen ) ; fail ( tWidth > tColumnWidthMax ) ; tLen = tGetBreakingPoint ( aszColTxt [ iIndex ] , tLen , tWidth , tColumnWidthMax ) ; tWidth = tCountColumns ( aszColTxt [ iIndex ] , tLen ) ; if ( tLen == 0 && * aszColTxt [ iIndex ] == '\\0' ) { /* No text at all */ aszColTxt [ iIndex ] = NULL ; } else { /* Add the text */ pcTxt += sprintf ( pcTxt , \"%.*s\" , ( int ) tLen , aszColTxt [ iIndex ] ) ; if ( tLen == 0 && * aszColTxt [ iIndex ] != ' ' ) { tLen = tGetCharacterLength ( aszColTxt [ iIndex ] ) ; DBG_CHR ( * aszColTxt [ iIndex ] ) ; DBG_FIXME ( ) ; fail ( tLen == 0 ) ; } aszColTxt [ iIndex ] += tLen ; while ( * aszColTxt [ iIndex ] == ' ' ) { aszColTxt [ iIndex ] ++ ; } if ( * aszColTxt [ iIndex ] == '\\0' ) { /* This row is now complete */ aszColTxt [ iIndex ] = NULL ; } else { /* This row needs more lines */ bNotReady = TRUE ; } } /* Fill up the rest */ for ( iTmp = 0 ; iTmp < ( int ) tColumnWidthMax - ( int ) tWidth ; iTmp ++ ) { * pcTxt ++ = ( char ) FILLER_CHAR ; } /* End of column */ * pcTxt ++ = TABLE_SEPARATOR_CHAR ; * pcTxt = '\\0' ; } /* Output the table row line */ * pcTxt = '\\0' ; tRow = * pOutput ; tRow . szStorage = szLine ; fail ( pcTxt < szLine ) ; tRow . tNextFree = ( size_t ) ( pcTxt - szLine ) ; tRow . lStringWidth = lComputeStringWidth ( tRow . szStorage , tRow . tNextFree , tRow . tFontRef , tRow . usFontSize ) ; vString2Diagram ( pDiag , & tRow ) ; TRACE_MSG ( \"after vString2Diagram in vTableRow2Window\" ) ; } while ( bNotReady ) ; /* Clean up before you leave */ szLine = xfree ( szLine ) ; TRACE_MSG ( \"leaving vTableRow2Window\" ) ; # endif /* __FULL_TEXT_SEARCH */ }",
    "resources/antiword/fmt_text.c@vPrologueFMT": "void vPrologueFMT ( diagram_type * pDiag , const options_type * pOptions ) { fail ( pDiag == NULL ) ; fail ( pOptions == NULL ) ; eEncoding = pOptions -> eEncoding ; pDiag -> lXleft = 0 ; pDiag -> lYtop = 0 ; lYtopCurr = 0 ; }",
    "resources/antiword/fmt_text.c@vPrintFMT": "static void vPrintFMT ( FILE * pFile , const char * szString , size_t tStringLength , USHORT usFontstyle ) { const UCHAR * pucByte , * pucStart , * pucLast , * pucNonSpace ; fail ( szString == NULL ) ; if ( szString == NULL || szString [ 0 ] == '\\0' || tStringLength == 0 ) { return ; } if ( eEncoding == encoding_utf_8 ) { fprintf ( pFile , \"%.*s\" , ( int ) tStringLength , szString ) ; return ; } if ( ucNbsp == 0 ) { ucNbsp = ucGetNbspCharacter ( ) ; DBG_HEX_C ( ucNbsp != 0xa0 , ucNbsp ) ; } pucStart = ( UCHAR * ) szString ; pucLast = pucStart + tStringLength - 1 ; pucNonSpace = pucLast ; while ( ( * pucNonSpace == ( UCHAR ) ' ' || * pucNonSpace == ucNbsp ) && pucNonSpace > pucStart ) { pucNonSpace -- ; } /* 1: The spaces at the start */ pucByte = pucStart ; while ( ( * pucByte == ( UCHAR ) ' ' || * pucByte == ucNbsp ) && pucByte <= pucLast ) { ( void ) putc ( ' ' , pFile ) ; pucByte ++ ; } if ( pucByte > pucLast ) { /* There is no text, just spaces */ return ; } /* 2: Start the *bold*, /italic/ and _underline_ */ if ( bIsBold ( usFontstyle ) ) { ( void ) putc ( '*' , pFile ) ; } if ( bIsItalic ( usFontstyle ) ) { ( void ) putc ( '/' , pFile ) ; } if ( bIsUnderline ( usFontstyle ) ) { ( void ) putc ( '_' , pFile ) ; } /* 3: The text itself */ while ( pucByte <= pucNonSpace ) { if ( * pucByte == ucNbsp ) { ( void ) putc ( ' ' , pFile ) ; } else { ( void ) putc ( ( char ) * pucByte , pFile ) ; } pucByte ++ ; } /* 4: End the *bold*, /italic/ and _underline_ */ if ( bIsUnderline ( usFontstyle ) ) { ( void ) putc ( '_' , pFile ) ; } if ( bIsItalic ( usFontstyle ) ) { ( void ) putc ( '/' , pFile ) ; } if ( bIsBold ( usFontstyle ) ) { ( void ) putc ( '*' , pFile ) ; } /* 5: The spaces at the end */ while ( pucByte <= pucLast ) { ( void ) putc ( ' ' , pFile ) ; pucByte ++ ; } }",
    "resources/antiword/fmt_text.c@vMoveTo": "static void vMoveTo ( diagram_type * pDiag ) { int iCount , iNbr ; fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; if ( pDiag -> lYtop != lYtopCurr ) { iNbr = iDrawUnits2Char ( pDiag -> lXleft ) ; for ( iCount = 0 ; iCount < iNbr ; iCount ++ ) { ( void ) putc ( FILLER_CHAR , pDiag -> pOutFile ) ; } lYtopCurr = pDiag -> lYtop ; } }",
    "resources/antiword/fmt_text.c@vSubstringFMT": "void vSubstringFMT ( diagram_type * pDiag , const char * szString , size_t tStringLength , long lStringWidth , USHORT usFontstyle ) { fail ( pDiag == NULL || szString == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( pDiag -> lXleft < 0 ) ; fail ( tStringLength != strlen ( szString ) ) ; if ( szString [ 0 ] == '\\0' || tStringLength == 0 ) { return ; } vMoveTo ( pDiag ) ; vPrintFMT ( pDiag -> pOutFile , szString , tStringLength , usFontstyle ) ; pDiag -> lXleft += lStringWidth ; }",
    "resources/antiword/stylelist.c@vDestroyStyleInfoList": "void vDestroyStyleInfoList ( void ) { style_mem_type * pCurr , * pNext ; DBG_MSG ( \"vDestroyStyleInfoList\" ) ; /* Free the Style Information List */ pCurr = pAnchor ; while ( pCurr != NULL ) { pNext = pCurr -> pNext ; pCurr = xfree ( pCurr ) ; pCurr = pNext ; } pAnchor = NULL ; /* Reset all control variables */ pStyleLast = NULL ; pMidPtr = NULL ; bMoveMidPtr = FALSE ; bInSequence = TRUE ; }",
    "resources/antiword/stylelist.c@vConvertListCharacter": "static void vConvertListCharacter ( UCHAR ucNFC , USHORT usListChar , char * szListChar ) { options_type tOptions ; size_t tLen ; fail ( szListChar == NULL ) ; fail ( szListChar [ 0 ] != '\\0' ) ; if ( usListChar < 0x80 && isprint ( ( int ) usListChar ) ) { DBG_CHR_C ( isalnum ( ( int ) usListChar ) , usListChar ) ; szListChar [ 0 ] = ( char ) usListChar ; szListChar [ 1 ] = '\\0' ; return ; } if ( ucNFC != LIST_SPECIAL && ucNFC != LIST_SPECIAL2 && ucNFC != LIST_BULLETS ) { szListChar [ 0 ] = '.' ; szListChar [ 1 ] = '\\0' ; return ; } if ( eConversionType == conversion_unknown || eEncoding == encoding_neutral ) { vGetOptions ( & tOptions ) ; eConversionType = tOptions . eConversionType ; eEncoding = tOptions . eEncoding ; } switch ( usListChar ) { case 0x0000 : case 0x00b7 : case 0x00fe : case 0xf021 : case 0xf043 : case 0xf06c : case 0xf093 : case 0xf0b7 : usListChar = 0x2022 ; /* BULLET */ break ; case 0x0096 : case 0xf02d : usListChar = 0x2013 ; /* EN DASH */ break ; case 0x00a8 : usListChar = 0x2666 ; /* BLACK DIAMOND SUIT */ break ; case 0x00de : usListChar = 0x21d2 ; /* RIGHTWARDS DOUBLE ARROW */ break ; case 0x00e0 : case 0xf074 : usListChar = 0x25ca ; /* LOZENGE */ break ; case 0x00e1 : usListChar = 0x2329 ; /* LEFT ANGLE BRACKET */ break ; case 0xf020 : usListChar = 0x0020 ; /* SPACE */ break ; case 0xf041 : usListChar = 0x270c ; /* VICTORY HAND */ break ; case 0xf066 : usListChar = 0x03d5 ; /* GREEK PHI SYMBOL */ break ; case 0xf06e : usListChar = 0x25a0 ; /* BLACK SQUARE */ break ; case 0xf06f : case 0xf070 : case 0xf0a8 : usListChar = 0x25a1 ; /* WHITE SQUARE */ break ; case 0xf071 : usListChar = 0x2751 ; /* LOWER RIGHT SHADOWED WHITE SQUARE */ break ; case 0xf075 : case 0xf077 : usListChar = 0x25c6 ; /* BLACK DIAMOND */ break ; case 0xf076 : usListChar = 0x2756 ; /* BLACK DIAMOND MINUS WHITE X */ break ; case 0xf0a7 : usListChar = 0x25aa ; /* BLACK SMALL SQUARE */ break ; case 0xf0d8 : usListChar = 0x27a2 ; /* RIGHTWARDS ARROWHEAD */ break ; case 0xf0e5 : usListChar = 0x2199 ; /* SOUTH WEST ARROW */ break ; case 0xf0f0 : usListChar = 0x21e8 ; /* RIGHTWARDS WHITE ARROW */ break ; case 0xf0fc : usListChar = 0x2713 ; /* CHECK MARK */ break ; default : if ( ( usListChar >= 0xe000 && usListChar < 0xf900 ) || ( usListChar < 0x80 && ! isprint ( ( int ) usListChar ) ) ) { /*\n\t\t\t * All remaining private area characters and all\n\t\t\t * remaining non-printable ASCII characters to their\n\t\t\t * default bullet character\n\t\t\t */ DBG_HEX ( usListChar ) ; DBG_FIXME ( ) ; if ( ucNFC == LIST_SPECIAL || ucNFC == LIST_SPECIAL2 ) { usListChar = 0x2190 ; /* LEFTWARDS ARROW */ } else { usListChar = 0x2022 ; /* BULLET */ } } break ; } if ( eEncoding == encoding_utf_8 ) { tLen = tUcs2Utf8 ( usListChar , szListChar , 4 ) ; szListChar [ tLen ] = '\\0' ; } else { switch ( usListChar ) { case 0x03d5 : case 0x25a1 : case 0x25c6 : case 0x25ca : case 0x2751 : szListChar [ 0 ] = 'o' ; break ; case 0x2013 : case 0x2500 : szListChar [ 0 ] = '-' ; break ; case 0x2190 : case 0x2199 : case 0x2329 : szListChar [ 0 ] = '<' ; break ; case 0x21d2 : szListChar [ 0 ] = '=' ; break ; case 0x21e8 : case 0x27a2 : szListChar [ 0 ] = '>' ; break ; case 0x25a0 : case 0x25aa : szListChar [ 0 ] = '.' ; break ; case 0x2666 : szListChar [ 0 ] = OUR_DIAMOND ; break ; case 0x270c : szListChar [ 0 ] = 'x' ; break ; case 0x2713 : szListChar [ 0 ] = 'V' ; break ; case 0x2756 : szListChar [ 0 ] = '*' ; break ; case 0x2022 : default : vGetBulletValue ( eConversionType , eEncoding , szListChar , 2 ) ; break ; } tLen = 1 ; } szListChar [ tLen ] = '\\0' ; }",
    "resources/antiword/stylelist.c@eGetNumType": "level_type_enum eGetNumType ( UCHAR ucNumLevel ) { switch ( ucNumLevel ) { case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : case 8 : case 9 : return level_type_outline ; case 10 : return level_type_numbering ; case 11 : return level_type_sequence ; case 12 : return level_type_pause ; default : return level_type_none ; } }",
    "resources/antiword/stylelist.c@vCorrectStyleValues": "void vCorrectStyleValues ( style_block_type * pStyleBlock ) { if ( pStyleBlock -> usBeforeIndent > 0x7fff ) { pStyleBlock -> usBeforeIndent = 0 ; } else if ( pStyleBlock -> usBeforeIndent > 2160 ) { /* 2160 twips = 1.5 inches or 38.1 mm */ DBG_DEC ( pStyleBlock -> usBeforeIndent ) ; pStyleBlock -> usBeforeIndent = 2160 ; } if ( pStyleBlock -> usIstd >= 1 && pStyleBlock -> usIstd <= 9 && pStyleBlock -> usBeforeIndent < HEADING_GAP ) { NO_DBG_DEC ( pStyleBlock -> usBeforeIndent ) ; pStyleBlock -> usBeforeIndent = HEADING_GAP ; } if ( pStyleBlock -> usAfterIndent > 0x7fff ) { pStyleBlock -> usAfterIndent = 0 ; } else if ( pStyleBlock -> usAfterIndent > 2160 ) { /* 2160 twips = 1.5 inches or 38.1 mm */ DBG_DEC ( pStyleBlock -> usAfterIndent ) ; pStyleBlock -> usAfterIndent = 2160 ; } if ( pStyleBlock -> usIstd >= 1 && pStyleBlock -> usIstd <= 9 && pStyleBlock -> usAfterIndent < HEADING_GAP ) { NO_DBG_DEC ( pStyleBlock -> usAfterIndent ) ; pStyleBlock -> usAfterIndent = HEADING_GAP ; } if ( pStyleBlock -> sLeftIndent < 0 ) { pStyleBlock -> sLeftIndent = 0 ; } if ( pStyleBlock -> sRightIndent > 0 ) { pStyleBlock -> sRightIndent = 0 ; } vConvertListCharacter ( pStyleBlock -> ucNFC , pStyleBlock -> usListChar , pStyleBlock -> szListChar ) ; }",
    "resources/antiword/stylelist.c@vAdd2StyleInfoList": "void vAdd2StyleInfoList ( const style_block_type * pStyleBlock ) { style_mem_type * pListMember ; fail ( pStyleBlock == NULL ) ; NO_DBG_MSG ( \"bAdd2StyleInfoList\" ) ; if ( pStyleBlock -> ulFileOffset == FC_INVALID ) { NO_DBG_DEC ( pStyleBlock -> usIstd ) ; return ; } NO_DBG_HEX ( pStyleBlock -> ulFileOffset ) ; NO_DBG_DEC_C ( pStyleBlock -> sLeftIndent != 0 , pStyleBlock -> sLeftIndent ) ; NO_DBG_DEC_C ( pStyleBlock -> sRightIndent != 0 , pStyleBlock -> sRightIndent ) ; NO_DBG_DEC_C ( pStyleBlock -> bNumPause , pStyleBlock -> bNumPause ) ; NO_DBG_DEC_C ( pStyleBlock -> usIstd != 0 , pStyleBlock -> usIstd ) ; NO_DBG_DEC_C ( pStyleBlock -> usStartAt != 1 , pStyleBlock -> usStartAt ) ; NO_DBG_DEC_C ( pStyleBlock -> usAfterIndent != 0 , pStyleBlock -> usAfterIndent ) ; NO_DBG_DEC_C ( pStyleBlock -> ucAlignment != 0 , pStyleBlock -> ucAlignment ) ; NO_DBG_DEC ( pStyleBlock -> ucNFC ) ; NO_DBG_HEX ( pStyleBlock -> usListChar ) ; if ( pStyleLast != NULL && pStyleLast -> tInfo . ulFileOffset == pStyleBlock -> ulFileOffset ) { /*\n\t\t * If two consecutive styles share the same\n\t\t * offset, remember only the last style\n\t\t */ fail ( pStyleLast -> pNext != NULL ) ; pStyleLast -> tInfo = * pStyleBlock ; /* Correct the values where needed */ vCorrectStyleValues ( & pStyleLast -> tInfo ) ; return ; } /* Create list member */ pListMember = xmalloc ( sizeof ( style_mem_type ) ) ; /* Fill the list member */ pListMember -> tInfo = * pStyleBlock ; pListMember -> pNext = NULL ; /* Add the sequence number */ pListMember -> ulSequenceNumber = ulGetSeqNumber ( pListMember -> tInfo . ulFileOffset ) ; /* Correct the values where needed */ vCorrectStyleValues ( & pListMember -> tInfo ) ; /* Add the new member to the list */ if ( pAnchor == NULL ) { pAnchor = pListMember ; /* For efficiency */ pMidPtr = pAnchor ; bMoveMidPtr = FALSE ; bInSequence = TRUE ; } else { fail ( pStyleLast == NULL ) ; pStyleLast -> pNext = pListMember ; /* For efficiency */ if ( bMoveMidPtr ) { pMidPtr = pMidPtr -> pNext ; bMoveMidPtr = FALSE ; } else { bMoveMidPtr = TRUE ; } if ( bInSequence ) { bInSequence = pListMember -> ulSequenceNumber > pStyleLast -> ulSequenceNumber ; } } pStyleLast = pListMember ; }",
    "resources/antiword/stylelist.c@pGetNextStyleInfoListItem": "const style_block_type * pGetNextStyleInfoListItem ( const style_block_type * pCurr ) { const style_mem_type * pRecord ; size_t tOffset ; if ( pCurr == NULL ) { if ( pAnchor == NULL ) { /* There are no records */ return NULL ; } /* The first record is the only one without a predecessor */ return & pAnchor -> tInfo ; } tOffset = offsetof ( style_mem_type , tInfo ) ; /* Many casts to prevent alignment warnings */ pRecord = ( style_mem_type * ) ( void * ) ( ( char * ) pCurr - tOffset ) ; fail ( pCurr != & pRecord -> tInfo ) ; if ( pRecord -> pNext == NULL ) { /* The last record has no successor */ return NULL ; } return & pRecord -> pNext -> tInfo ; }",
    "resources/antiword/stylelist.c@pGetNextTextStyle": "const style_block_type * pGetNextTextStyle ( const style_block_type * pCurr ) { const style_block_type * pRecord ; pRecord = pCurr ; do { pRecord = pGetNextStyleInfoListItem ( pRecord ) ; } while ( pRecord != NULL && ( pRecord -> eListID == hdrftr_list || pRecord -> eListID == macro_list || pRecord -> eListID == annotation_list ) ) ; return pRecord ; }",
    "resources/antiword/stylelist.c@usGetIstd": "USHORT usGetIstd ( ULONG ulFileOffset ) { const style_mem_type * pCurr , * pBest , * pStart ; ULONG ulSeq , ulBest ; ulSeq = ulGetSeqNumber ( ulFileOffset ) ; if ( ulSeq == FC_INVALID ) { return ISTD_NORMAL ; } NO_DBG_HEX ( ulFileOffset ) ; NO_DBG_DEC ( ulSeq ) ; if ( bInSequence && pMidPtr != NULL && ulSeq > pMidPtr -> ulSequenceNumber ) { /* The istd is in the second half of the chained list */ pStart = pMidPtr ; } else { pStart = pAnchor ; } pBest = NULL ; ulBest = 0 ; for ( pCurr = pStart ; pCurr != NULL ; pCurr = pCurr -> pNext ) { if ( pCurr -> ulSequenceNumber != FC_INVALID && ( pBest == NULL || pCurr -> ulSequenceNumber > ulBest ) && pCurr -> ulSequenceNumber <= ulSeq ) { pBest = pCurr ; ulBest = pCurr -> ulSequenceNumber ; } if ( bInSequence && pCurr -> ulSequenceNumber > ulSeq ) { break ; } } NO_DBG_DEC ( ulBest ) ; if ( pBest == NULL ) { return ISTD_NORMAL ; } NO_DBG_DEC ( pBest -> tInfo . usIstd ) ; return pBest -> tInfo . usIstd ; }",
    "resources/antiword/stylelist.c@bStyleImpliesList": "",
    "resources/antiword/prop8.c@iGet8InfoLength": "static int iGet8InfoLength ( int iByteNbr , const UCHAR * aucGrpprl ) { int iTmp , iDel , iAdd ; USHORT usOpCode ; usOpCode = usGetWord ( iByteNbr , aucGrpprl ) ; switch ( usOpCode & 0xe000 ) { case 0x0000 : case 0x2000 : return 3 ; case 0x4000 : case 0x8000 : case 0xa000 : return 4 ; case 0xe000 : return 5 ; case 0x6000 : return 6 ; case 0xc000 : iTmp = ( int ) ucGetByte ( iByteNbr + 2 , aucGrpprl ) ; if ( usOpCode == 0xc615 && iTmp == 255 ) { iDel = ( int ) ucGetByte ( iByteNbr + 3 , aucGrpprl ) ; iAdd = ( int ) ucGetByte ( iByteNbr + 4 + iDel * 4 , aucGrpprl ) ; iTmp = 2 + iDel * 4 + iAdd * 3 ; } return 3 + iTmp ; default : DBG_HEX ( usOpCode ) ; DBG_FIXME ( ) ; return 1 ; } }",
    "resources/antiword/prop8.c@aucFillInfoBuffer": "static UCHAR * aucFillInfoBuffer ( FILE * pFile , const pps_type * pTable , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , ULONG ulBeginInfo , size_t tInfoLen ) { const ULONG * aulBlockDepot ; UCHAR * aucBuffer ; size_t tBlockDepotLen , tBlockSize ; fail ( pFile == NULL || pTable == NULL ) ; fail ( aulBBD == NULL || aulSBD == NULL ) ; fail ( tInfoLen == 0 ) ; NO_DBG_DEC ( pTable -> ulSB ) ; NO_DBG_HEX ( pTable -> ulSize ) ; if ( pTable -> ulSize == 0 ) { DBG_MSG ( \"No information\" ) ; return NULL ; } if ( pTable -> ulSize < MIN_SIZE_FOR_BBD_USE ) { /* Use the Small Block Depot */ aulBlockDepot = aulSBD ; tBlockDepotLen = tSBDLen ; tBlockSize = SMALL_BLOCK_SIZE ; } else { /* Use the Big Block Depot */ aulBlockDepot = aulBBD ; tBlockDepotLen = tBBDLen ; tBlockSize = BIG_BLOCK_SIZE ; } aucBuffer = xmalloc ( tInfoLen ) ; if ( ! bReadBuffer ( pFile , pTable -> ulSB , aulBlockDepot , tBlockDepotLen , tBlockSize , aucBuffer , ulBeginInfo , tInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return NULL ; } return aucBuffer ; }",
    "resources/antiword/prop8.c@vGet8DopInfo": "void vGet8DopInfo ( FILE * pFile , const pps_type * pTable , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { document_block_type tDocument ; UCHAR * aucBuffer ; ULONG ulBeginDocpInfo , ulTmp ; size_t tDocpInfoLen ; USHORT usTmp ; fail ( pFile == NULL || pTable == NULL || aucHeader == NULL ) ; fail ( aulBBD == NULL || aulSBD == NULL ) ; ulBeginDocpInfo = ulGetLong ( 0x192 , aucHeader ) ; /* fcDop */ NO_DBG_HEX ( ulBeginSectInfo ) ; tDocpInfoLen = ( size_t ) ulGetLong ( 0x196 , aucHeader ) ; /* lcbDop */ NO_DBG_DEC ( tSectInfoLen ) ; if ( tDocpInfoLen < 28 ) { DBG_MSG ( \"No Document information\" ) ; return ; } aucBuffer = aucFillInfoBuffer ( pFile , pTable , aulBBD , tBBDLen , aulSBD , tSBDLen , ulBeginDocpInfo , tDocpInfoLen ) ; if ( aucBuffer == NULL ) { return ; } usTmp = usGetWord ( 0x00 , aucBuffer ) ; tDocument . ucHdrFtrSpecification = ( UCHAR ) ( usTmp >> 8 ) ; /* grpfIhdt */ tDocument . usDefaultTabWidth = usGetWord ( 0x0a , aucBuffer ) ; /* dxaTab */ ulTmp = ulGetLong ( 0x14 , aucBuffer ) ; /* dttmCreated */ tDocument . tCreateDate = tConvertDTTM ( ulTmp ) ; ulTmp = ulGetLong ( 0x18 , aucBuffer ) ; /* dttmRevised */ tDocument . tRevisedDate = tConvertDTTM ( ulTmp ) ; vCreateDocumentInfoList ( & tDocument ) ; aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/prop8.c@vGet8SectionInfo": "static void vGet8SectionInfo ( const UCHAR * aucGrpprl , size_t tBytes , section_block_type * pSection ) { UINT uiIndex ; int iFodoOff , iInfoLen , iSize , iTmp ; USHORT usCcol ; UCHAR ucTmp ; fail ( aucGrpprl == NULL || pSection == NULL ) ; iFodoOff = 0 ; while ( tBytes >= ( size_t ) iFodoOff + 2 ) { iInfoLen = 0 ; switch ( usGetWord ( iFodoOff , aucGrpprl ) ) { case 0x3009 : /* bkc */ ucTmp = ucGetByte ( iFodoOff + 2 , aucGrpprl ) ; DBG_DEC ( ucTmp ) ; pSection -> bNewPage = ucTmp != 0 && ucTmp != 1 ; break ; case 0x3014 : /* grpfIhdt */ pSection -> ucHdrFtrSpecification = ucGetByte ( iFodoOff + 2 , aucGrpprl ) ; break ; case 0x500b : /* ccolM1 */ usCcol = 1 + usGetWord ( iFodoOff + 2 , aucGrpprl ) ; DBG_DEC ( usCcol ) ; break ; case 0xd202 : /* olstAnm */ iSize = ( int ) ucGetByte ( iFodoOff + 2 , aucGrpprl ) ; DBG_DEC_C ( iSize != 212 , iSize ) ; for ( uiIndex = 0 , iTmp = iFodoOff + 3 ; uiIndex < 9 && iTmp < iFodoOff + 3 + iSize - 15 ; uiIndex ++ , iTmp += 16 ) { pSection -> aucNFC [ uiIndex ] = ucGetByte ( iTmp , aucGrpprl ) ; DBG_DEC ( pSection -> aucNFC [ uiIndex ] ) ; ucTmp = ucGetByte ( iTmp + 3 , aucGrpprl ) ; DBG_HEX ( ucTmp ) ; if ( ( ucTmp & BIT ( 2 ) ) != 0 ) { pSection -> usNeedPrevLvl |= ( USHORT ) BIT ( uiIndex ) ; } if ( ( ucTmp & BIT ( 3 ) ) != 0 ) { pSection -> usHangingIndent |= ( USHORT ) BIT ( uiIndex ) ; } } DBG_HEX ( pSection -> usNeedPrevLvl ) ; DBG_HEX ( pSection -> usHangingIndent ) ; break ; default : break ; } if ( iInfoLen <= 0 ) { iInfoLen = iGet8InfoLength ( iFodoOff , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; } iFodoOff += iInfoLen ; } }",
    "resources/antiword/prop8.c@vGet8SepInfo": "void vGet8SepInfo ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { section_block_type tSection ; ULONG * aulSectPage , * aulCharPos ; UCHAR * aucBuffer , * aucFpage ; ULONG ulBeginOfText , ulTextOffset , ulBeginSectInfo ; size_t tSectInfoLen , tIndex , tOffset , tLen , tBytes ; UCHAR aucTmp [ 2 ] ; fail ( pFile == NULL || pPPS == NULL || aucHeader == NULL ) ; fail ( aulBBD == NULL || aulSBD == NULL ) ; ulBeginOfText = ulGetLong ( 0x18 , aucHeader ) ; /* fcMin */ NO_DBG_HEX ( ulBeginOfText ) ; ulBeginSectInfo = ulGetLong ( 0xca , aucHeader ) ; /* fcPlcfsed */ NO_DBG_HEX ( ulBeginSectInfo ) ; tSectInfoLen = ( size_t ) ulGetLong ( 0xce , aucHeader ) ; /* lcbPlcfsed */ NO_DBG_DEC ( tSectInfoLen ) ; if ( tSectInfoLen < 4 ) { DBG_DEC ( tSectInfoLen ) ; return ; } aucBuffer = aucFillInfoBuffer ( pFile , & pPPS -> tTable , aulBBD , tBBDLen , aulSBD , tSBDLen , ulBeginSectInfo , tSectInfoLen ) ; if ( aucBuffer == NULL ) { return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tSectInfoLen ) ; /* Read the Section Descriptors */ tLen = ( tSectInfoLen - 4 ) / 16 ; /* Save the section offsets */ aulCharPos = xcalloc ( tLen , sizeof ( ULONG ) ) ; for ( tIndex = 0 , tOffset = 0 ; tIndex < tLen ; tIndex ++ , tOffset += 4 ) { ulTextOffset = ulGetLong ( tOffset , aucBuffer ) ; NO_DBG_HEX ( ulTextOffset ) ; aulCharPos [ tIndex ] = ulBeginOfText + ulTextOffset ; NO_DBG_HEX ( aulCharPos [ tIndex ] ) ; } /* Save the Sepx offsets */ aulSectPage = xcalloc ( tLen , sizeof ( ULONG ) ) ; for ( tIndex = 0 , tOffset = ( tLen + 1 ) * 4 ; tIndex < tLen ; tIndex ++ , tOffset += 12 ) { aulSectPage [ tIndex ] = ulGetLong ( tOffset + 2 , aucBuffer ) ; NO_DBG_HEX ( aulSectPage [ tIndex ] ) ; /* fcSepx */ } aucBuffer = xfree ( aucBuffer ) ; /* Read the Section Properties */ for ( tIndex = 0 ; tIndex < tLen ; tIndex ++ ) { if ( aulSectPage [ tIndex ] == FC_INVALID ) { vDefault2SectionInfoList ( aulCharPos [ tIndex ] ) ; continue ; } /* Get the number of bytes to read */ if ( ! bReadBuffer ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucTmp , aulSectPage [ tIndex ] , 2 ) ) { continue ; } tBytes = 2 + ( size_t ) usGetWord ( 0 , aucTmp ) ; NO_DBG_DEC ( tBytes ) ; /* Read the bytes */ aucFpage = xmalloc ( tBytes ) ; if ( ! bReadBuffer ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucFpage , aulSectPage [ tIndex ] , tBytes ) ) { aucFpage = xfree ( aucFpage ) ; continue ; } NO_DBG_PRINT_BLOCK ( aucFpage , tBytes ) ; /* Process the bytes */ vGetDefaultSection ( & tSection ) ; vGet8SectionInfo ( aucFpage + 2 , tBytes - 2 , & tSection ) ; vAdd2SectionInfoList ( & tSection , aulCharPos [ tIndex ] ) ; aucFpage = xfree ( aucFpage ) ; } aulCharPos = xfree ( aulCharPos ) ; aulSectPage = xfree ( aulSectPage ) ; }",
    "resources/antiword/prop8.c@vGet8HdrFtrInfo": "void vGet8HdrFtrInfo ( FILE * pFile , const pps_type * pTable , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { ULONG * aulCharPos ; UCHAR * aucBuffer ; ULONG ulHdrFtrOffset , ulBeginHdrFtrInfo ; size_t tHdrFtrInfoLen , tIndex , tOffset , tLen ; fail ( pFile == NULL || pTable == NULL || aucHeader == NULL ) ; fail ( aulBBD == NULL || aulSBD == NULL ) ; ulBeginHdrFtrInfo = ulGetLong ( 0xf2 , aucHeader ) ; /* fcPlcfhdd */ NO_DBG_HEX ( ulBeginHdrFtrInfo ) ; tHdrFtrInfoLen = ( size_t ) ulGetLong ( 0xf6 , aucHeader ) ; /* lcbPlcfhdd */ NO_DBG_DEC ( tHdrFtrInfoLen ) ; if ( tHdrFtrInfoLen < 8 ) { DBG_DEC_C ( tHdrFtrInfoLen != 0 , tHdrFtrInfoLen ) ; return ; } aucBuffer = aucFillInfoBuffer ( pFile , pTable , aulBBD , tBBDLen , aulSBD , tSBDLen , ulBeginHdrFtrInfo , tHdrFtrInfoLen ) ; if ( aucBuffer == NULL ) { return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tHdrFtrInfoLen ) ; tLen = tHdrFtrInfoLen / 4 - 1 ; DBG_DEC_C ( tLen % 12 != 1 && tLen % 12 != 7 , tLen ) ; /* Save the header/footer offsets */ aulCharPos = xcalloc ( tLen , sizeof ( ULONG ) ) ; for ( tIndex = 0 , tOffset = 0 ; tIndex < tLen ; tIndex ++ , tOffset += 4 ) { ulHdrFtrOffset = ulGetLong ( tOffset , aucBuffer ) ; NO_DBG_HEX ( ulHdrFtrOffset ) ; aulCharPos [ tIndex ] = ulHdrFtrOffset2CharPos ( ulHdrFtrOffset ) ; NO_DBG_HEX ( aulCharPos [ tIndex ] ) ; } vCreat8HdrFtrInfoList ( aulCharPos , tLen ) ; /* Clean up and leave */ aulCharPos = xfree ( aulCharPos ) ; aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/prop8.c@eGet8RowInfo": "row_info_enum eGet8RowInfo ( int iFodo , const UCHAR * aucGrpprl , int iBytes , row_block_type * pRow ) { int iFodoOff , iInfoLen ; int iIndex , iSize , iCol ; int iPosCurr , iPosPrev ; USHORT usTmp ; BOOL bFound2416_0 , bFound2416_1 , bFound2417_0 , bFound2417_1 ; BOOL bFound244b_0 , bFound244b_1 , bFound244c_0 , bFound244c_1 ; BOOL bFoundd608 ; fail ( iFodo < 0 || aucGrpprl == NULL || pRow == NULL ) ; iFodoOff = 0 ; bFound2416_0 = FALSE ; bFound2416_1 = FALSE ; bFound2417_0 = FALSE ; bFound2417_1 = FALSE ; bFound244b_0 = FALSE ; bFound244b_1 = FALSE ; bFound244c_0 = FALSE ; bFound244c_1 = FALSE ; bFoundd608 = FALSE ; while ( iBytes >= iFodoOff + 2 ) { iInfoLen = 0 ; switch ( usGetWord ( iFodo + iFodoOff , aucGrpprl ) ) { case 0x2416 : /* fInTable */ if ( odd ( ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ) ) { bFound2416_1 = TRUE ; } else { bFound2416_0 = TRUE ; } break ; case 0x2417 : /* fTtp */ if ( odd ( ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ) ) { bFound2417_1 = TRUE ; } else { bFound2417_0 = TRUE ; } break ; case 0x244b : /* sub-table fInTable */ if ( odd ( ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ) ) { bFound244b_1 = TRUE ; } else { bFound244b_0 = TRUE ; } break ; case 0x244c : /* sub-table fTtp */ if ( odd ( ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ) ) { bFound244c_1 = TRUE ; } else { bFound244c_0 = TRUE ; } break ; case 0x6424 : /* brcTop */ usTmp = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; usTmp &= 0xff00 ; NO_DBG_DEC ( usTmp >> 8 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_TOP ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_TOP ; } break ; case 0x6425 : /* brcLeft */ usTmp = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; usTmp &= 0xff00 ; NO_DBG_DEC ( usTmp >> 8 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_LEFT ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_LEFT ; } break ; case 0x6426 : /* brcBottom */ usTmp = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; usTmp &= 0xff00 ; NO_DBG_DEC ( usTmp >> 8 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_BOTTOM ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_BOTTOM ; } break ; case 0x6427 : /* brcRight */ usTmp = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; usTmp &= 0xff00 ; NO_DBG_DEC ( usTmp >> 8 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_RIGHT ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_RIGHT ; } break ; case 0xd606 : /* cDefTable10 */ DBG_MSG ( \"0xd606: sprmTDefTable10\" ) ; iSize = ( int ) usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; DBG_DEC ( iSize ) ; break ; case 0xd608 : /* cDefTable */ iSize = ( int ) usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; if ( iSize < 6 || iBytes < iFodoOff + 8 ) { DBG_DEC ( iSize ) ; DBG_DEC ( iFodoOff ) ; iInfoLen = 2 ; break ; } iCol = ( int ) ucGetByte ( iFodo + iFodoOff + 4 , aucGrpprl ) ; if ( iCol < 1 || iBytes < iFodoOff + 4 + ( iCol + 1 ) * 2 ) { DBG_DEC ( iCol ) ; DBG_DEC ( iFodoOff ) ; iInfoLen = 2 ; break ; } if ( iCol >= ( int ) elementsof ( pRow -> asColumnWidth ) ) { DBG_DEC ( iCol ) ; werr ( 1 , \"The number of columns is corrupt\" ) ; } pRow -> ucNumberOfColumns = ( UCHAR ) iCol ; iPosPrev = ( int ) ( short ) usGetWord ( iFodo + iFodoOff + 5 , aucGrpprl ) ; for ( iIndex = 0 ; iIndex < iCol ; iIndex ++ ) { iPosCurr = ( int ) ( short ) usGetWord ( iFodo + iFodoOff + 7 + iIndex * 2 , aucGrpprl ) ; pRow -> asColumnWidth [ iIndex ] = ( short ) ( iPosCurr - iPosPrev ) ; iPosPrev = iPosCurr ; } bFoundd608 = TRUE ; break ; default : break ; } if ( iInfoLen <= 0 ) { iInfoLen = iGet8InfoLength ( iFodo + iFodoOff , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; } iFodoOff += iInfoLen ; } if ( bFound2417_1 && bFoundd608 ) { return found_end_of_row ; } if ( bFound2417_0 && ! bFoundd608 ) { return found_not_end_of_row ; } if ( bFound2416_1 || bFound244b_1 ) { return found_a_cell ; } if ( bFound2416_0 || bFound244b_0 ) { return found_not_a_cell ; } return found_nothing ; }",
    "resources/antiword/prop8.c@vGet8StyleInfo": "void vGet8StyleInfo ( int iFodo , const UCHAR * aucGrpprl , int iBytes , style_block_type * pStyle ) { list_block_type tList6 ; const list_block_type * pList ; int iFodoOff , iInfoLen ; int iTmp , iDel , iAdd , iBefore ; USHORT usOpCode , usTmp ; short sTmp ; fail ( iFodo < 0 || aucGrpprl == NULL || pStyle == NULL ) ; NO_DBG_DEC_C ( pStyle -> usListIndex != 0 , pStyle -> usIstd ) ; NO_DBG_DEC_C ( pStyle -> usListIndex != 0 , pStyle -> usListIndex ) ; ( void ) memset ( & tList6 , 0 , sizeof ( tList6 ) ) ; iFodoOff = 0 ; while ( iBytes >= iFodoOff + 2 ) { iInfoLen = 0 ; usOpCode = usGetWord ( iFodo + iFodoOff , aucGrpprl ) ; switch ( usOpCode ) { case 0x2403 : /* jc */ pStyle -> ucAlignment = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; break ; case 0x260a : /* ilvl */ pStyle -> ucListLevel = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> ucListLevel ) ; pStyle -> ucNumLevel = pStyle -> ucListLevel ; break ; case 0x4600 : /* istd */ usTmp = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; NO_DBG_DEC ( usTmp ) ; break ; case 0x460b : /* ilfo */ pStyle -> usListIndex = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> usListIndex ) ; break ; case 0x4610 : /* Nest dxaLeft */ sTmp = ( short ) usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; pStyle -> sLeftIndent += sTmp ; if ( pStyle -> sLeftIndent < 0 ) { pStyle -> sLeftIndent = 0 ; } DBG_DEC ( sTmp ) ; DBG_DEC ( pStyle -> sLeftIndent ) ; break ; case 0xc60d : /* ChgTabsPapx */ case 0xc615 : /* ChgTabs */ iTmp = ( int ) ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; if ( iTmp < 2 ) { iInfoLen = 1 ; break ; } NO_DBG_DEC ( iTmp ) ; iDel = ( int ) ucGetByte ( iFodo + iFodoOff + 3 , aucGrpprl ) ; if ( iTmp < 2 + 2 * iDel ) { iInfoLen = 1 ; break ; } NO_DBG_DEC ( iDel ) ; iAdd = ( int ) ucGetByte ( iFodo + iFodoOff + 4 + 2 * iDel , aucGrpprl ) ; if ( iTmp < 2 + 2 * iDel + 2 * iAdd ) { iInfoLen = 1 ; break ; } NO_DBG_DEC ( iAdd ) ; break ; case 0x840e : /* dxaRight */ pStyle -> sRightIndent = ( short ) usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> sRightIndent ) ; break ; case 0x840f : /* dxaLeft */ pStyle -> sLeftIndent = ( short ) usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> sLeftIndent ) ; break ; case 0x8411 : /* dxaLeft1 */ pStyle -> sLeftIndent1 = ( short ) usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> sLeftIndent1 ) ; break ; case 0xa413 : /* dyaBefore */ pStyle -> usBeforeIndent = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> usBeforeIndent ) ; break ; case 0xa414 : /* dyaAfter */ pStyle -> usAfterIndent = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> usAfterIndent ) ; break ; case 0xc63e : /* anld */ iTmp = ( int ) ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; DBG_DEC_C ( iTmp < 84 , iTmp ) ; if ( iTmp >= 1 ) { tList6 . ucNFC = ucGetByte ( iFodo + iFodoOff + 3 , aucGrpprl ) ; } if ( tList6 . ucNFC != LIST_BULLETS && iTmp >= 2 ) { iBefore = ( int ) ucGetByte ( iFodo + iFodoOff + 4 , aucGrpprl ) ; } else { iBefore = 0 ; } if ( iTmp >= 12 ) { tList6 . ulStartAt = ( ULONG ) usGetWord ( iFodo + iFodoOff + 13 , aucGrpprl ) ; } if ( iTmp >= iBefore + 22 ) { tList6 . usListChar = usGetWord ( iFodo + iFodoOff + iBefore + 23 , aucGrpprl ) ; DBG_HEX ( tList6 . usListChar ) ; } break ; default : NO_DBG_HEX ( usOpCode ) ; break ; } if ( iInfoLen <= 0 ) { iInfoLen = iGet8InfoLength ( iFodo + iFodoOff , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; } iFodoOff += iInfoLen ; } if ( pStyle -> usListIndex == 2047 ) { /* Old style list */ pStyle -> usStartAt = ( USHORT ) tList6 . ulStartAt ; pStyle -> usListChar = tList6 . usListChar ; pStyle -> ucNFC = tList6 . ucNFC ; } else { /* New style list */ pList = pGetListInfo ( pStyle -> usListIndex , pStyle -> ucListLevel ) ; if ( pList != NULL ) { pStyle -> bNoRestart = pList -> bNoRestart ; fail ( pList -> ulStartAt > ( ULONG ) USHRT_MAX ) ; pStyle -> usStartAt = ( USHORT ) pList -> ulStartAt ; pStyle -> usListChar = pList -> usListChar ; pStyle -> ucNFC = pList -> ucNFC ; if ( pStyle -> sLeftIndent <= 0 ) { pStyle -> sLeftIndent = pList -> sLeftIndent ; } } } }",
    "resources/antiword/prop8.c@sGetLeftIndent": "static short sGetLeftIndent ( const UCHAR * aucGrpprl , size_t tBytes ) { int iOffset , iInfoLen ; USHORT usOpCode , usTmp ; fail ( aucGrpprl == NULL ) ; iOffset = 0 ; while ( tBytes >= ( size_t ) iOffset + 4 ) { usOpCode = usGetWord ( iOffset , aucGrpprl ) ; if ( usOpCode == 0x840f ) { /* dxaLeft */ usTmp = usGetWord ( iOffset + 2 , aucGrpprl ) ; if ( usTmp <= 0x7fff ) { NO_DBG_DEC ( usTmp ) ; return ( short ) usTmp ; } } iInfoLen = iGet8InfoLength ( iOffset , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; iOffset += iInfoLen ; } return 0 ; }",
    "resources/antiword/prop8.c@vGet8LstInfo": "void vGet8LstInfo ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { list_block_type tList ; const ULONG * aulBlockDepot ; UCHAR * aucLfoInfo , * aucLstfInfo , * aucPapx , * aucXString ; ULONG ulBeginLfoInfo , ulBeginLstfInfo , ulBeginLvlfInfo ; ULONG ulListID , ulStart ; size_t tBlockDepotLen , tBlockSize ; size_t tLfoInfoLen , tLstfInfoLen , tPapxLen , tXstLen , tOff ; size_t tLstfRecords , tStart , tIndex ; int iNums ; USHORT usIstd ; UCHAR ucTmp , ucListLevel , ucMaxLevel , ucChpxLen ; UCHAR aucLvlfInfo [ 28 ] , aucXst [ 2 ] ; fail ( pFile == NULL || pPPS == NULL || aucHeader == NULL ) ; fail ( aulBBD == NULL || aulSBD == NULL ) ; NO_DBG_DEC ( pPPS -> tTable . ulSB ) ; NO_DBG_HEX ( pPPS -> tTable . ulSize ) ; if ( pPPS -> tTable . ulSize == 0 ) { DBG_MSG ( \"No list information\" ) ; return ; } if ( pPPS -> tTable . ulSize < MIN_SIZE_FOR_BBD_USE ) { /* Use the Small Block Depot */ aulBlockDepot = aulSBD ; tBlockDepotLen = tSBDLen ; tBlockSize = SMALL_BLOCK_SIZE ; } else { /* Use the Big Block Depot */ aulBlockDepot = aulBBD ; tBlockDepotLen = tBBDLen ; tBlockSize = BIG_BLOCK_SIZE ; } /* LFO (List Format Override) */ ulBeginLfoInfo = ulGetLong ( 0x2ea , aucHeader ) ; /* fcPlfLfo */ DBG_HEX ( ulBeginLfoInfo ) ; tLfoInfoLen = ( size_t ) ulGetLong ( 0x2ee , aucHeader ) ; /* lcbPlfLfo */ DBG_DEC ( tLfoInfoLen ) ; if ( tLfoInfoLen == 0 ) { DBG_MSG ( \"No lists in this document\" ) ; return ; } aucLfoInfo = xmalloc ( tLfoInfoLen ) ; if ( ! bReadBuffer ( pFile , pPPS -> tTable . ulSB , aulBlockDepot , tBlockDepotLen , tBlockSize , aucLfoInfo , ulBeginLfoInfo , tLfoInfoLen ) ) { aucLfoInfo = xfree ( aucLfoInfo ) ; return ; } NO_DBG_PRINT_BLOCK ( aucLfoInfo , tLfoInfoLen ) ; vBuildLfoList ( aucLfoInfo , tLfoInfoLen ) ; aucLfoInfo = xfree ( aucLfoInfo ) ; /* LSTF (LiST data on File) */ ulBeginLstfInfo = ulGetLong ( 0x2e2 , aucHeader ) ; /* fcPlcfLst */ DBG_HEX ( ulBeginLstfInfo ) ; tLstfInfoLen = ( size_t ) ulGetLong ( 0x2e6 , aucHeader ) ; /* lcbPlcfLst */ DBG_DEC ( tLstfInfoLen ) ; if ( tLstfInfoLen == 0 ) { DBG_MSG ( \"No list data on file\" ) ; return ; } aucLstfInfo = xmalloc ( tLstfInfoLen ) ; if ( ! bReadBuffer ( pFile , pPPS -> tTable . ulSB , aulBlockDepot , tBlockDepotLen , tBlockSize , aucLstfInfo , ulBeginLstfInfo , tLstfInfoLen ) ) { aucLstfInfo = xfree ( aucLstfInfo ) ; return ; } NO_DBG_PRINT_BLOCK ( aucLstfInfo , tLstfInfoLen ) ; tLstfRecords = ( size_t ) usGetWord ( 0 , aucLstfInfo ) ; if ( 2 + tLstfRecords * 28 < tLstfInfoLen ) { DBG_DEC ( 2 + tLstfRecords * 28 ) ; DBG_DEC ( tLstfInfoLen ) ; aucLstfInfo = xfree ( aucLstfInfo ) ; return ; } /* LVLF (List leVeL on File) */ ulBeginLvlfInfo = ulBeginLstfInfo + tLstfInfoLen ; DBG_HEX ( ulBeginLvlfInfo ) ; aucXString = NULL ; ulStart = ulBeginLvlfInfo ; for ( tIndex = 0 , tStart = 2 ; tIndex < tLstfRecords ; tIndex ++ , tStart += 28 ) { ulListID = ulGetLong ( tStart , aucLstfInfo ) ; NO_DBG_HEX ( ulListID ) ; ucTmp = ucGetByte ( tStart + 26 , aucLstfInfo ) ; ucMaxLevel = odd ( ucTmp ) ? 1 : 9 ; for ( ucListLevel = 0 ; ucListLevel < ucMaxLevel ; ucListLevel ++ ) { fail ( aucXString != NULL ) ; usIstd = usGetWord ( tStart + 8 + 2 * ( size_t ) ucListLevel , aucLstfInfo ) ; DBG_DEC_C ( usIstd != STI_NIL , usIstd ) ; NO_DBG_HEX ( ulStart ) ; ( void ) memset ( & tList , 0 , sizeof ( tList ) ) ; /* Read the lvlf (List leVeL on File) */ if ( ! bReadBuffer ( pFile , pPPS -> tTable . ulSB , aulBlockDepot , tBlockDepotLen , tBlockSize , aucLvlfInfo , ulStart , sizeof ( aucLvlfInfo ) ) ) { aucLstfInfo = xfree ( aucLstfInfo ) ; return ; } NO_DBG_PRINT_BLOCK ( aucLvlfInfo , sizeof ( aucLvlfInfo ) ) ; if ( bAllZero ( aucLvlfInfo , sizeof ( aucLvlfInfo ) ) ) { tList . ulStartAt = 1 ; tList . ucNFC = 0x00 ; tList . bNoRestart = FALSE ; } else { tList . ulStartAt = ulGetLong ( 0 , aucLvlfInfo ) ; tList . ucNFC = ucGetByte ( 4 , aucLvlfInfo ) ; ucTmp = ucGetByte ( 5 , aucLvlfInfo ) ; tList . bNoRestart = ( ucTmp & BIT ( 3 ) ) != 0 ; DBG_MSG_C ( ( ucTmp & BIT ( 4 ) ) != 0 && ( ucTmp & BIT ( 6 ) ) != 0 , \"Found one\" ) ; } ulStart += sizeof ( aucLvlfInfo ) ; tPapxLen = ( size_t ) ucGetByte ( 25 , aucLvlfInfo ) ; if ( tPapxLen != 0 ) { aucPapx = xmalloc ( tPapxLen ) ; /* Read the Papx */ if ( ! bReadBuffer ( pFile , pPPS -> tTable . ulSB , aulBlockDepot , tBlockDepotLen , tBlockSize , aucPapx , ulStart , tPapxLen ) ) { aucPapx = xfree ( aucPapx ) ; aucLstfInfo = xfree ( aucLstfInfo ) ; return ; } NO_DBG_PRINT_BLOCK ( aucPapx , tPapxLen ) ; tList . sLeftIndent = sGetLeftIndent ( aucPapx , tPapxLen ) ; aucPapx = xfree ( aucPapx ) ; } ulStart += tPapxLen ; ucChpxLen = ucGetByte ( 24 , aucLvlfInfo ) ; ulStart += ( ULONG ) ucChpxLen ; /* Read the length of the XString */ if ( ! bReadBuffer ( pFile , pPPS -> tTable . ulSB , aulBlockDepot , tBlockDepotLen , tBlockSize , aucXst , ulStart , sizeof ( aucXst ) ) ) { aucLstfInfo = xfree ( aucLstfInfo ) ; return ; } NO_DBG_PRINT_BLOCK ( aucXst , sizeof ( aucXst ) ) ; tXstLen = ( size_t ) usGetWord ( 0 , aucXst ) ; ulStart += sizeof ( aucXst ) ; if ( tXstLen == 0 ) { tList . usListChar = DEFAULT_LISTCHAR ; vAdd2ListInfoList ( ulListID , usIstd , ucListLevel , & tList ) ; continue ; } tXstLen *= 2 ; /* Length in chars to length in bytes */ aucXString = xmalloc ( tXstLen ) ; /* Read the XString */ if ( ! bReadBuffer ( pFile , pPPS -> tTable . ulSB , aulBlockDepot , tBlockDepotLen , tBlockSize , aucXString , ulStart , tXstLen ) ) { aucXString = xfree ( aucXString ) ; aucLstfInfo = xfree ( aucLstfInfo ) ; return ; } NO_DBG_PRINT_BLOCK ( aucXString , tXstLen ) ; tOff = 0 ; for ( iNums = 6 ; iNums < 15 ; iNums ++ ) { ucTmp = ucGetByte ( iNums , aucLvlfInfo ) ; if ( ucTmp == 0 ) { break ; } tOff = ( size_t ) ucTmp ; } tOff *= 2 ; /* Offset in chars to offset in bytes */ NO_DBG_DEC ( tOff ) ; if ( tList . ucNFC == LIST_SPECIAL || tList . ucNFC == LIST_SPECIAL2 || tList . ucNFC == LIST_BULLETS ) { tList . usListChar = usGetWord ( 0 , aucXString ) ; } else if ( tOff != 0 && tOff < tXstLen ) { tList . usListChar = usGetWord ( tOff , aucXString ) ; } else { tList . usListChar = DEFAULT_LISTCHAR ; } vAdd2ListInfoList ( ulListID , usIstd , ucListLevel , & tList ) ; ulStart += tXstLen ; aucXString = xfree ( aucXString ) ; } } aucLstfInfo = xfree ( aucLstfInfo ) ; }",
    "resources/antiword/prop8.c@vGet8PapInfo": "void vGet8PapInfo ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { row_block_type tRow ; style_block_type tStyle ; ULONG * aulParfPage ; UCHAR * aucBuffer ; ULONG ulCharPos , ulCharPosFirst , ulCharPosLast ; ULONG ulBeginParfInfo ; size_t tParfInfoLen , tOffset , tLen ; int iIndex , iIndex2 , iRun , iFodo , iLen ; row_info_enum eRowInfo ; USHORT usIstd ; UCHAR aucFpage [ BIG_BLOCK_SIZE ] ; fail ( pFile == NULL || pPPS == NULL || aucHeader == NULL ) ; fail ( aulBBD == NULL || aulSBD == NULL ) ; ulBeginParfInfo = ulGetLong ( 0x102 , aucHeader ) ; /* fcPlcfbtePapx */ NO_DBG_HEX ( ulBeginParfInfo ) ; tParfInfoLen = ( size_t ) ulGetLong ( 0x106 , aucHeader ) ; /* lcbPlcfbtePapx */ NO_DBG_DEC ( tParfInfoLen ) ; if ( tParfInfoLen < 4 ) { DBG_DEC ( tParfInfoLen ) ; return ; } aucBuffer = aucFillInfoBuffer ( pFile , & pPPS -> tTable , aulBBD , tBBDLen , aulSBD , tSBDLen , ulBeginParfInfo , tParfInfoLen ) ; if ( aucBuffer == NULL ) { return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tParfInfoLen ) ; tLen = ( tParfInfoLen / 4 - 1 ) / 2 ; aulParfPage = xcalloc ( tLen , sizeof ( ULONG ) ) ; for ( iIndex = 0 , tOffset = ( tLen + 1 ) * 4 ; iIndex < ( int ) tLen ; iIndex ++ , tOffset += 4 ) { aulParfPage [ iIndex ] = ulGetLong ( tOffset , aucBuffer ) ; NO_DBG_DEC ( aulParfPage [ iIndex ] ) ; } DBG_HEX ( ulGetLong ( 0 , aucBuffer ) ) ; aucBuffer = xfree ( aucBuffer ) ; NO_DBG_PRINT_BLOCK ( aucHeader , HEADER_SIZE ) ; ( void ) memset ( & tRow , 0 , sizeof ( tRow ) ) ; ulCharPosFirst = CP_INVALID ; for ( iIndex = 0 ; iIndex < ( int ) tLen ; iIndex ++ ) { fail ( aulParfPage [ iIndex ] > ULONG_MAX / BIG_BLOCK_SIZE ) ; if ( ! bReadBuffer ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucFpage , aulParfPage [ iIndex ] * BIG_BLOCK_SIZE , BIG_BLOCK_SIZE ) ) { break ; } NO_DBG_PRINT_BLOCK ( aucFpage , BIG_BLOCK_SIZE ) ; iRun = ( int ) ucGetByte ( 0x1ff , aucFpage ) ; NO_DBG_DEC ( iRun ) ; for ( iIndex2 = 0 ; iIndex2 < iRun ; iIndex2 ++ ) { NO_DBG_HEX ( ulGetLong ( iIndex2 * 4 , aucFpage ) ) ; iFodo = 2 * ( int ) ucGetByte ( ( iRun + 1 ) * 4 + iIndex2 * 13 , aucFpage ) ; if ( iFodo <= 0 ) { continue ; } iLen = 2 * ( int ) ucGetByte ( iFodo , aucFpage ) ; if ( iLen == 0 ) { iFodo ++ ; iLen = 2 * ( int ) ucGetByte ( iFodo , aucFpage ) ; } usIstd = usGetWord ( iFodo + 1 , aucFpage ) ; vFillStyleFromStylesheet ( usIstd , & tStyle ) ; vGet8StyleInfo ( iFodo , aucFpage + 3 , iLen - 3 , & tStyle ) ; ulCharPos = ulGetLong ( iIndex2 * 4 , aucFpage ) ; NO_DBG_HEX ( ulCharPos ) ; tStyle . ulFileOffset = ulCharPos2FileOffsetX ( ulCharPos , & tStyle . eListID ) ; vAdd2StyleInfoList ( & tStyle ) ; eRowInfo = eGet8RowInfo ( iFodo , aucFpage + 3 , iLen - 3 , & tRow ) ; switch ( eRowInfo ) { case found_a_cell : if ( ulCharPosFirst != CP_INVALID ) { break ; } ulCharPosFirst = ulGetLong ( iIndex2 * 4 , aucFpage ) ; NO_DBG_HEX ( ulCharPosFirst ) ; tRow . ulCharPosStart = ulCharPosFirst ; tRow . ulFileOffsetStart = ulCharPos2FileOffset ( ulCharPosFirst ) ; NO_DBG_HEX_C ( tRow . ulFileOffsetStart == FC_INVALID , ulCharPosFirst ) ; break ; case found_end_of_row : ulCharPosLast = ulGetLong ( iIndex2 * 4 , aucFpage ) ; NO_DBG_HEX ( ulCharPosLast ) ; tRow . ulCharPosEnd = ulCharPosLast ; tRow . ulFileOffsetEnd = ulCharPos2FileOffset ( ulCharPosLast ) ; NO_DBG_HEX_C ( tRow . ulFileOffsetEnd == FC_INVALID , ulCharPosLast ) ; vAdd2RowInfoList ( & tRow ) ; ( void ) memset ( & tRow , 0 , sizeof ( tRow ) ) ; ulCharPosFirst = CP_INVALID ; break ; case found_nothing : break ; default : DBG_DEC ( eRowInfo ) ; break ; } } } aulParfPage = xfree ( aulParfPage ) ; }",
    "resources/antiword/prop8.c@vGet8FontInfo": "void vGet8FontInfo ( int iFodo , USHORT usIstd , const UCHAR * aucGrpprl , int iBytes , font_block_type * pFont ) { long lTmp ; int iFodoOff , iInfoLen ; USHORT usFtc0 , usFtc1 , usFtc2 , usTmp ; UCHAR ucTmp ; fail ( iFodo < 0 || aucGrpprl == NULL || pFont == NULL ) ; usFtc0 = USHRT_MAX ; usFtc1 = USHRT_MAX ; usFtc2 = USHRT_MAX ; iFodoOff = 0 ; while ( iBytes >= iFodoOff + 2 ) { switch ( usGetWord ( iFodo + iFodoOff , aucGrpprl ) ) { case 0x0800 : /* fRMarkDel */ ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; if ( ucTmp == 0 ) { pFont -> usFontStyle &= ~ FONT_MARKDEL ; } else { pFont -> usFontStyle |= FONT_MARKDEL ; } break ; case 0x0835 : /* fBold */ ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; switch ( ucTmp ) { case 0 : /* Unset */ pFont -> usFontStyle &= ~ FONT_BOLD ; break ; case 1 : /* Set */ pFont -> usFontStyle |= FONT_BOLD ; break ; case 128 : /* Unchanged */ break ; case 129 : /* Negation */ pFont -> usFontStyle ^= FONT_BOLD ; break ; default : DBG_DEC ( ucTmp ) ; DBG_FIXME ( ) ; break ; } break ; case 0x0836 : /* fItalic */ ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; switch ( ucTmp ) { case 0 : /* Unset */ pFont -> usFontStyle &= ~ FONT_ITALIC ; break ; case 1 : /* Set */ pFont -> usFontStyle |= FONT_ITALIC ; break ; case 128 : /* Unchanged */ break ; case 129 : /* Negation */ pFont -> usFontStyle ^= FONT_ITALIC ; break ; default : DBG_DEC ( ucTmp ) ; DBG_FIXME ( ) ; break ; } break ; case 0x0837 : /* fStrike */ ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; switch ( ucTmp ) { case 0 : /* Unset */ pFont -> usFontStyle &= ~ FONT_STRIKE ; break ; case 1 : /* Set */ pFont -> usFontStyle |= FONT_STRIKE ; break ; case 128 : /* Unchanged */ break ; case 129 : /* Negation */ pFont -> usFontStyle ^= FONT_STRIKE ; break ; default : DBG_DEC ( ucTmp ) ; DBG_FIXME ( ) ; break ; } break ; case 0x083a : /* fSmallCaps */ ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; switch ( ucTmp ) { case 0 : /* Unset */ pFont -> usFontStyle &= ~ FONT_SMALL_CAPITALS ; break ; case 1 : /* Set */ pFont -> usFontStyle |= FONT_SMALL_CAPITALS ; break ; case 128 : /* Unchanged */ break ; case 129 : /* Negation */ pFont -> usFontStyle ^= FONT_SMALL_CAPITALS ; break ; default : DBG_DEC ( ucTmp ) ; DBG_FIXME ( ) ; break ; } break ; case 0x083b : /* fCaps */ ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; switch ( ucTmp ) { case 0 : /* Unset */ pFont -> usFontStyle &= ~ FONT_CAPITALS ; break ; case 1 : /* Set */ pFont -> usFontStyle |= FONT_CAPITALS ; break ; case 128 : /* Unchanged */ break ; case 129 : /* Negation */ pFont -> usFontStyle ^= FONT_CAPITALS ; break ; default : DBG_DEC ( ucTmp ) ; DBG_FIXME ( ) ; break ; } break ; case 0x083c : /* fVanish */ ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; switch ( ucTmp ) { case 0 : /* Unset */ pFont -> usFontStyle &= ~ FONT_HIDDEN ; break ; case 1 : /* Set */ pFont -> usFontStyle |= FONT_HIDDEN ; break ; case 128 : /* Unchanged */ break ; case 129 : /* Negation */ pFont -> usFontStyle ^= FONT_HIDDEN ; break ; default : DBG_DEC ( ucTmp ) ; DBG_FIXME ( ) ; break ; } break ; case 0x2a32 : /* cDefault */ pFont -> usFontStyle &= FONT_HIDDEN ; pFont -> ucFontColor = FONT_COLOR_DEFAULT ; break ; case 0x2a33 : /* cPlain */ DBG_MSG ( \"2a33: cPlain\" ) ; vFillFontFromStylesheet ( usIstd , pFont ) ; break ; case 0x2a3e : /* cKul */ ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; if ( ucTmp == 0 || ucTmp == 5 ) { pFont -> usFontStyle &= ~ FONT_UNDERLINE ; } else { NO_DBG_MSG ( \"Underline text\" ) ; pFont -> usFontStyle |= FONT_UNDERLINE ; if ( ucTmp == 6 ) { DBG_MSG ( \"Bold text\" ) ; pFont -> usFontStyle |= FONT_BOLD ; } } break ; case 0x2a42 : /* cIco */ pFont -> ucFontColor = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; NO_DBG_DEC ( pFont -> ucFontColor ) ; break ; case 0x2a44 : /* cHpsInc */ DBG_MSG ( \"0x2a44: sprmCHpsInc\" ) ; ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; DBG_DEC ( ucTmp ) ; break ; case 0x2a48 : /* cIss */ ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; ucTmp &= 0x07 ; if ( ucTmp == 1 ) { pFont -> usFontStyle |= FONT_SUPERSCRIPT ; NO_DBG_MSG ( \"Superscript\" ) ; } else if ( ucTmp == 2 ) { pFont -> usFontStyle |= FONT_SUBSCRIPT ; NO_DBG_MSG ( \"Subscript\" ) ; } break ; case 0x4a30 : /* cIstd */ usTmp = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; NO_DBG_DEC ( usTmp ) ; break ; case 0x4a43 : /* cHps */ pFont -> usFontSize = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; NO_DBG_DEC ( pFont -> usFontSize ) ; break ; case 0x4a4d : /* cHpsMul */ DBG_MSG ( \"0x4a4d: sprmCHpsMul\" ) ; usTmp = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; DBG_DEC ( usTmp ) ; break ; case 0x4a4f : /* cFtc0 */ usFtc0 = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; break ; case 0x4a50 : /* cFtc1 */ usFtc1 = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; break ; case 0x4a51 : /* cFtc2 */ usFtc2 = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; break ; case 0xca47 : /* cMajority */ DBG_MSG ( \"0xca47: sprmCMajority\" ) ; break ; case 0xca4a : /* cHpsInc1 */ usTmp = usGetWord ( iFodo + iFodoOff + 2 , aucGrpprl ) ; lTmp = ( long ) pFont -> usFontSize + ( long ) usTmp ; if ( lTmp < 8 ) { pFont -> usFontSize = 8 ; } else if ( lTmp > 32766 ) { pFont -> usFontSize = 32766 ; } else { pFont -> usFontSize = ( USHORT ) lTmp ; } break ; case 0xca4c : /* cMajority50 */ DBG_MSG ( \"0xca4c: sprmCMajority50\" ) ; break ; case 0xea3f : /* cHps, cHpsPos */ ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; DBG_DEC ( ucTmp ) ; if ( ucTmp != 0 ) { pFont -> usFontSize = ( USHORT ) ucTmp ; } ucTmp = ucGetByte ( iFodo + iFodoOff + 3 , aucGrpprl ) ; DBG_DEC ( ucTmp ) ; break ; default : break ; } iInfoLen = iGet8InfoLength ( iFodo + iFodoOff , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; iFodoOff += iInfoLen ; } /* Combine the Ftc's to a FontNumber */ NO_DBG_DEC_C ( usFtc0 != USHRT_MAX , usFtc0 ) ; NO_DBG_DEC_C ( usFtc2 != USHRT_MAX , usFtc2 ) ; NO_DBG_DEC_C ( usFtc1 != USHRT_MAX , usFtc1 ) ; if ( usFtc0 <= 0x7fff ) { if ( usFtc0 <= ( USHORT ) UCHAR_MAX ) { pFont -> ucFontNumber = ( UCHAR ) usFtc0 ; } else { DBG_DEC ( usFtc0 ) ; DBG_FIXME ( ) ; pFont -> ucFontNumber = 0 ; } } else if ( usFtc2 <= 0x7fff ) { if ( usFtc2 <= ( USHORT ) UCHAR_MAX ) { pFont -> ucFontNumber = ( UCHAR ) usFtc2 ; } else { DBG_DEC ( usFtc2 ) ; DBG_FIXME ( ) ; pFont -> ucFontNumber = 0 ; } } else if ( usFtc1 <= 0x7fff ) { if ( usFtc1 <= ( USHORT ) UCHAR_MAX ) { pFont -> ucFontNumber = ( UCHAR ) usFtc1 ; } else { DBG_DEC ( usFtc1 ) ; DBG_FIXME ( ) ; pFont -> ucFontNumber = 0 ; } } }",
    "resources/antiword/prop8.c@bGet8PicInfo": "static BOOL bGet8PicInfo ( int iFodo , const UCHAR * aucGrpprl , int iBytes , picture_block_type * pPicture ) { ULONG ulTmp ; int iFodoOff , iInfoLen ; BOOL bFound ; UCHAR ucTmp ; fail ( iFodo <= 0 || aucGrpprl == NULL || pPicture == NULL ) ; iFodoOff = 0 ; bFound = FALSE ; while ( iBytes >= iFodoOff + 2 ) { switch ( usGetWord ( iFodo + iFodoOff , aucGrpprl ) ) { # if 0 case 0x0806 : /* fData */ ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; if ( ucTmp == 0x01 ) { /* Not a picture, but a form field */ return FALSE ; } DBG_DEC_C ( ucTmp != 0 , ucTmp ) ; break ; # endif case 0x080a : /* fOle2 */ ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; if ( ucTmp == 0x01 ) { /* Not a picture, but an OLE object */ return FALSE ; } DBG_DEC_C ( ucTmp != 0 , ucTmp ) ; break ; case 0x680e : /* fcObj */ ulTmp = ulGetLong ( iFodo + iFodoOff + 2 , aucGrpprl ) ; DBG_HEX ( ulTmp ) ; break ; case 0x6a03 : /* fcPic */ pPicture -> ulPictureOffset = ulGetLong ( iFodo + iFodoOff + 2 , aucGrpprl ) ; bFound = TRUE ; break ; default : break ; } iInfoLen = iGet8InfoLength ( iFodo + iFodoOff , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; iFodoOff += iInfoLen ; } return bFound ; }",
    "resources/antiword/prop8.c@vGet8ChrInfo": "void vGet8ChrInfo ( FILE * pFile , const pps_info_type * pPPS , const ULONG * aulBBD , size_t tBBDLen , const ULONG * aulSBD , size_t tSBDLen , const UCHAR * aucHeader ) { font_block_type tFont ; picture_block_type tPicture ; ULONG * aulCharPage ; UCHAR * aucBuffer ; ULONG ulFileOffset , ulCharPos , ulBeginCharInfo ; size_t tCharInfoLen , tOffset , tLen ; int iIndex , iIndex2 , iRun , iFodo , iLen ; USHORT usIstd ; UCHAR aucFpage [ BIG_BLOCK_SIZE ] ; fail ( pFile == NULL || pPPS == NULL || aucHeader == NULL ) ; fail ( aulBBD == NULL || aulSBD == NULL ) ; ulBeginCharInfo = ulGetLong ( 0xfa , aucHeader ) ; /* fcPlcfbteChpx */ NO_DBG_HEX ( ulBeginCharInfo ) ; tCharInfoLen = ( size_t ) ulGetLong ( 0xfe , aucHeader ) ; /* lcbPlcfbteChpx */ NO_DBG_DEC ( tCharInfoLen ) ; if ( tCharInfoLen < 4 ) { DBG_DEC ( tCharInfoLen ) ; return ; } aucBuffer = aucFillInfoBuffer ( pFile , & pPPS -> tTable , aulBBD , tBBDLen , aulSBD , tSBDLen , ulBeginCharInfo , tCharInfoLen ) ; if ( aucBuffer == NULL ) { return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tCharInfoLen ) ; tLen = ( tCharInfoLen / 4 - 1 ) / 2 ; aulCharPage = xcalloc ( tLen , sizeof ( ULONG ) ) ; for ( iIndex = 0 , tOffset = ( tLen + 1 ) * 4 ; iIndex < ( int ) tLen ; iIndex ++ , tOffset += 4 ) { aulCharPage [ iIndex ] = ulGetLong ( tOffset , aucBuffer ) ; NO_DBG_DEC ( aulCharPage [ iIndex ] ) ; } DBG_HEX ( ulGetLong ( 0 , aucBuffer ) ) ; aucBuffer = xfree ( aucBuffer ) ; NO_DBG_PRINT_BLOCK ( aucHeader , HEADER_SIZE ) ; for ( iIndex = 0 ; iIndex < ( int ) tLen ; iIndex ++ ) { fail ( aulCharPage [ iIndex ] > ULONG_MAX / BIG_BLOCK_SIZE ) ; if ( ! bReadBuffer ( pFile , pPPS -> tWordDocument . ulSB , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucFpage , aulCharPage [ iIndex ] * BIG_BLOCK_SIZE , BIG_BLOCK_SIZE ) ) { break ; } NO_DBG_PRINT_BLOCK ( aucFpage , BIG_BLOCK_SIZE ) ; iRun = ( int ) ucGetByte ( 0x1ff , aucFpage ) ; NO_DBG_DEC ( iRun ) ; for ( iIndex2 = 0 ; iIndex2 < iRun ; iIndex2 ++ ) { ulCharPos = ulGetLong ( iIndex2 * 4 , aucFpage ) ; ulFileOffset = ulCharPos2FileOffset ( ulCharPos ) ; iFodo = 2 * ( int ) ucGetByte ( ( iRun + 1 ) * 4 + iIndex2 , aucFpage ) ; iLen = ( int ) ucGetByte ( iFodo , aucFpage ) ; usIstd = usGetIstd ( ulFileOffset ) ; vFillFontFromStylesheet ( usIstd , & tFont ) ; if ( iFodo != 0 ) { vGet8FontInfo ( iFodo , usIstd , aucFpage + 1 , iLen - 1 , & tFont ) ; } tFont . ulFileOffset = ulFileOffset ; vAdd2FontInfoList ( & tFont ) ; if ( iFodo <= 0 ) { continue ; } ( void ) memset ( & tPicture , 0 , sizeof ( tPicture ) ) ; if ( bGet8PicInfo ( iFodo , aucFpage + 1 , iLen - 1 , & tPicture ) ) { tPicture . ulFileOffset = ulFileOffset ; tPicture . ulFileOffsetPicture = ulDataPos2FileOffset ( tPicture . ulPictureOffset ) ; vAdd2PictInfoList ( & tPicture ) ; } } } aulCharPage = xfree ( aulCharPage ) ; }",
    "resources/antiword/prop2.c@iGet2InfoLength": "static int iGet2InfoLength ( int iByteNbr , const UCHAR * aucGrpprl ) { int iTmp , iDel , iAdd ; switch ( ucGetByte ( iByteNbr , aucGrpprl ) ) { case 3 : case 15 : case 78 : case 152 : case 154 : case 155 : return 2 + ( int ) ucGetByte ( iByteNbr + 1 , aucGrpprl ) ; case 16 : case 17 : case 18 : case 19 : case 21 : case 22 : case 26 : case 27 : case 28 : case 30 : case 31 : case 32 : case 33 : case 34 : case 35 : case 36 : case 38 : case 39 : case 40 : case 41 : case 42 : case 43 : case 45 : case 46 : case 47 : case 48 : case 49 : case 68 : case 71 : case 72 : case 82 : case 83 : case 96 : case 97 : case 98 : case 99 : case 115 : case 116 : case 119 : case 120 : case 123 : case 124 : case 129 : case 130 : case 131 : case 132 : case 135 : case 136 : case 139 : case 140 : case 141 : case 142 : case 143 : case 144 : case 145 : case 146 : case 147 : case 148 : case 153 : case 159 : case 161 : case 162 : return 1 + 2 ; case 23 : iTmp = ( int ) ucGetByte ( iByteNbr + 1 , aucGrpprl ) ; if ( iTmp == 255 ) { iDel = ( int ) ucGetByte ( iByteNbr + 2 , aucGrpprl ) ; iAdd = ( int ) ucGetByte ( iByteNbr + 3 + iDel * 4 , aucGrpprl ) ; iTmp = 2 + iDel * 4 + iAdd * 3 ; } return 2 + iTmp ; case 70 : return 1 + 3 ; case 95 : return 1 + 13 ; case 157 : case 163 : return 1 + 5 ; case 158 : case 160 : case 164 : return 1 + 4 ; default : return 1 + 1 ; } }",
    "resources/antiword/prop2.c@vGet2DopInfo": "void vGet2DopInfo ( FILE * pFile , const UCHAR * aucHeader ) { document_block_type tDocument ; UCHAR * aucBuffer ; ULONG ulBeginDocpInfo , ulTmp ; size_t tDocpInfoLen ; USHORT usTmp ; ulBeginDocpInfo = ulGetLong ( 0x112 , aucHeader ) ; /* fcDop */ DBG_HEX ( ulBeginDocpInfo ) ; tDocpInfoLen = ( size_t ) usGetWord ( 0x116 , aucHeader ) ; /* cbDop */ DBG_DEC ( tDocpInfoLen ) ; if ( tDocpInfoLen < 28 ) { DBG_MSG ( \"No Document information\" ) ; return ; } aucBuffer = xmalloc ( tDocpInfoLen ) ; if ( ! bReadBytes ( aucBuffer , tDocpInfoLen , ulBeginDocpInfo , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } usTmp = usGetWord ( 0x00 , aucBuffer ) ; tDocument . ucHdrFtrSpecification = ( UCHAR ) ( usTmp >> 8 ) ; /* grpfIhdt */ tDocument . usDefaultTabWidth = usGetWord ( 0x0a , aucBuffer ) ; /* dxaTab */ ulTmp = ulGetLong ( 0x14 , aucBuffer ) ; /* dttmCreated */ tDocument . tCreateDate = tConvertDTTM ( ulTmp ) ; ulTmp = ulGetLong ( 0x18 , aucBuffer ) ; /* dttmRevised */ tDocument . tRevisedDate = tConvertDTTM ( ulTmp ) ; vCreateDocumentInfoList ( & tDocument ) ; aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/prop2.c@vGet2SectionInfo": "static void vGet2SectionInfo ( const UCHAR * aucGrpprl , size_t tBytes , section_block_type * pSection ) { int iFodoOff , iInfoLen ; USHORT usCcol ; UCHAR ucTmp ; fail ( aucGrpprl == NULL || pSection == NULL ) ; iFodoOff = 0 ; while ( tBytes >= ( size_t ) iFodoOff + 1 ) { switch ( ucGetByte ( iFodoOff , aucGrpprl ) ) { case 117 : /* bkc */ ucTmp = ucGetByte ( iFodoOff + 1 , aucGrpprl ) ; DBG_DEC ( ucTmp ) ; pSection -> bNewPage = ucTmp != 0 && ucTmp != 1 ; break ; case 119 : /* ccolM1 */ usCcol = 1 + usGetWord ( iFodoOff + 1 , aucGrpprl ) ; DBG_DEC ( usCcol ) ; break ; case 128 : /* grpfIhdt */ pSection -> ucHdrFtrSpecification = ucGetByte ( iFodoOff + 1 , aucGrpprl ) ; break ; default : break ; } iInfoLen = iGet2InfoLength ( iFodoOff , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; iFodoOff += iInfoLen ; } }",
    "resources/antiword/prop2.c@vGet2SepInfo": "void vGet2SepInfo ( FILE * pFile , const UCHAR * aucHeader ) { section_block_type tSection ; ULONG * aulSectPage , * aulCharPos ; UCHAR * aucBuffer , * aucFpage ; ULONG ulBeginOfText , ulTextOffset , ulBeginSectInfo ; size_t tSectInfoLen , tIndex , tOffset , tLen , tBytes ; UCHAR aucTmp [ 1 ] ; fail ( pFile == NULL || aucHeader == NULL ) ; ulBeginOfText = ulGetLong ( 0x18 , aucHeader ) ; /* fcMin */ NO_DBG_HEX ( ulBeginOfText ) ; ulBeginSectInfo = ulGetLong ( 0x7c , aucHeader ) ; /* fcPlcfsed */ DBG_HEX ( ulBeginSectInfo ) ; tSectInfoLen = ( size_t ) usGetWord ( 0x80 , aucHeader ) ; /* cbPlcfsed */ DBG_DEC ( tSectInfoLen ) ; if ( tSectInfoLen < 4 ) { DBG_DEC ( tSectInfoLen ) ; return ; } aucBuffer = xmalloc ( tSectInfoLen ) ; if ( ! bReadBytes ( aucBuffer , tSectInfoLen , ulBeginSectInfo , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tSectInfoLen ) ; /* Read the Section Descriptors */ tLen = ( tSectInfoLen - 4 ) / 10 ; /* Save the section offsets */ aulCharPos = xcalloc ( tLen , sizeof ( ULONG ) ) ; for ( tIndex = 0 , tOffset = 0 ; tIndex < tLen ; tIndex ++ , tOffset += 4 ) { ulTextOffset = ulGetLong ( tOffset , aucBuffer ) ; NO_DBG_HEX ( ulTextOffset ) ; aulCharPos [ tIndex ] = ulBeginOfText + ulTextOffset ; NO_DBG_HEX ( aulCharPos [ tIndex ] ) ; } /* Save the Sepx offsets */ aulSectPage = xcalloc ( tLen , sizeof ( ULONG ) ) ; for ( tIndex = 0 , tOffset = ( tLen + 1 ) * 4 ; tIndex < tLen ; tIndex ++ , tOffset += 6 ) { aulSectPage [ tIndex ] = ulGetLong ( tOffset + 2 , aucBuffer ) ; NO_DBG_HEX ( aulSectPage [ tIndex ] ) ; /* fcSepx */ } aucBuffer = xfree ( aucBuffer ) ; /* Read the Section Properties */ for ( tIndex = 0 ; tIndex < tLen ; tIndex ++ ) { if ( aulSectPage [ tIndex ] == FC_INVALID ) { vDefault2SectionInfoList ( aulCharPos [ tIndex ] ) ; continue ; } /* Get the number of bytes to read */ if ( ! bReadBytes ( aucTmp , 1 , aulSectPage [ tIndex ] , pFile ) ) { continue ; } tBytes = 1 + ( size_t ) ucGetByte ( 0 , aucTmp ) ; NO_DBG_DEC ( tBytes ) ; /* Read the bytes */ aucFpage = xmalloc ( tBytes ) ; if ( ! bReadBytes ( aucFpage , tBytes , aulSectPage [ tIndex ] , pFile ) ) { aucFpage = xfree ( aucFpage ) ; continue ; } NO_DBG_PRINT_BLOCK ( aucFpage , tBytes ) ; /* Process the bytes */ vGetDefaultSection ( & tSection ) ; vGet2SectionInfo ( aucFpage + 1 , tBytes - 1 , & tSection ) ; vAdd2SectionInfoList ( & tSection , aulCharPos [ tIndex ] ) ; aucFpage = xfree ( aucFpage ) ; } aulCharPos = xfree ( aulCharPos ) ; aulSectPage = xfree ( aulSectPage ) ; }",
    "resources/antiword/prop2.c@vGet2HdrFtrInfo": "void vGet2HdrFtrInfo ( FILE * pFile , const UCHAR * aucHeader ) { ULONG * aulCharPos ; UCHAR * aucBuffer ; ULONG ulHdrFtrOffset , ulBeginHdrFtrInfo ; size_t tHdrFtrInfoLen , tIndex , tOffset , tLen ; fail ( pFile == NULL || aucHeader == NULL ) ; ulBeginHdrFtrInfo = ulGetLong ( 0x9a , aucHeader ) ; /* fcPlcfhdd */ NO_DBG_HEX ( ulBeginHdrFtrInfo ) ; tHdrFtrInfoLen = ( size_t ) usGetWord ( 0x9e , aucHeader ) ; /* cbPlcfhdd */ NO_DBG_DEC ( tHdrFtrInfoLen ) ; if ( tHdrFtrInfoLen < 8 ) { DBG_DEC_C ( tHdrFtrInfoLen != 0 , tHdrFtrInfoLen ) ; return ; } aucBuffer = xmalloc ( tHdrFtrInfoLen ) ; if ( ! bReadBytes ( aucBuffer , tHdrFtrInfoLen , ulBeginHdrFtrInfo , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tHdrFtrInfoLen ) ; tLen = tHdrFtrInfoLen / 4 - 1 ; /* Save the header/footer offsets */ aulCharPos = xcalloc ( tLen , sizeof ( ULONG ) ) ; for ( tIndex = 0 , tOffset = 0 ; tIndex < tLen ; tIndex ++ , tOffset += 4 ) { ulHdrFtrOffset = ulGetLong ( tOffset , aucBuffer ) ; NO_DBG_HEX ( ulHdrFtrOffset ) ; aulCharPos [ tIndex ] = ulHdrFtrOffset2CharPos ( ulHdrFtrOffset ) ; NO_DBG_HEX ( aulCharPos [ tIndex ] ) ; } vCreat2HdrFtrInfoList ( aulCharPos , tLen ) ; aulCharPos = xfree ( aulCharPos ) ; aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/prop2.c@eGet2RowInfo": "row_info_enum eGet2RowInfo ( int iFodo , const UCHAR * aucGrpprl , int iBytes , row_block_type * pRow ) { int iFodoOff , iInfoLen ; int iIndex , iSize , iCol ; int iPosCurr , iPosPrev ; USHORT usTmp ; BOOL bFound24_0 , bFound24_1 , bFound25_0 , bFound25_1 , bFound154 ; fail ( iFodo < 0 || aucGrpprl == NULL || pRow == NULL ) ; iFodoOff = 0 ; bFound24_0 = FALSE ; bFound24_1 = FALSE ; bFound25_0 = FALSE ; bFound25_1 = FALSE ; bFound154 = FALSE ; while ( iBytes >= iFodoOff + 1 ) { iInfoLen = 0 ; switch ( ucGetByte ( iFodo + iFodoOff , aucGrpprl ) ) { case 24 : /* fIntable */ if ( odd ( ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ) ) { bFound24_1 = TRUE ; } else { bFound24_0 = TRUE ; } break ; case 25 : /* fTtp */ if ( odd ( ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ) ) { bFound25_1 = TRUE ; } else { bFound25_0 = TRUE ; } break ; case 30 : /* brcTop10 */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; usTmp &= 0x01ff ; NO_DBG_DEC ( usTmp >> 6 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_TOP ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_TOP ; } break ; case 31 : /* brcLeft10 */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; usTmp &= 0x01ff ; NO_DBG_DEC ( usTmp >> 6 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_LEFT ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_LEFT ; } break ; case 32 : /* brcBottom10 */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; usTmp &= 0x01ff ; NO_DBG_DEC ( usTmp >> 6 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_BOTTOM ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_BOTTOM ; } break ; case 33 : /* brcRight10 */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; usTmp &= 0x01ff ; NO_DBG_DEC ( usTmp >> 6 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_RIGHT ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_RIGHT ; } break ; case 38 : /* brcTop */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; usTmp &= 0x0018 ; NO_DBG_DEC ( usTmp >> 3 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_TOP ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_TOP ; } break ; case 39 : /* brcLeft */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; usTmp &= 0x0018 ; NO_DBG_DEC ( usTmp >> 3 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_LEFT ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_LEFT ; } break ; case 40 : /* brcBottom */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; usTmp &= 0x0018 ; NO_DBG_DEC ( usTmp >> 3 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_BOTTOM ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_BOTTOM ; } break ; case 41 : /* brcRight */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; usTmp &= 0x0018 ; NO_DBG_DEC ( usTmp >> 3 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_RIGHT ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_RIGHT ; } break ; case 152 : /* cDefTable10 */ case 154 : /* cDefTable */ iSize = ( int ) usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; if ( iSize < 6 || iBytes < iFodoOff + 7 ) { DBG_DEC ( iSize ) ; DBG_DEC ( iBytes ) ; DBG_DEC ( iFodoOff ) ; iInfoLen = 1 ; break ; } iCol = ( int ) ucGetByte ( iFodo + iFodoOff + 3 , aucGrpprl ) ; if ( iCol < 1 || iBytes < iFodoOff + 3 + ( iCol + 1 ) * 2 ) { DBG_DEC ( iCol ) ; DBG_DEC ( iBytes ) ; DBG_DEC ( iFodoOff ) ; DBG_DEC ( ucGetByte ( iFodo + iFodoOff , aucGrpprl ) ) ; iInfoLen = 1 ; break ; } if ( iCol >= ( int ) elementsof ( pRow -> asColumnWidth ) ) { DBG_DEC ( iCol ) ; werr ( 1 , \"The number of columns is corrupt\" ) ; } pRow -> ucNumberOfColumns = ( UCHAR ) iCol ; iPosPrev = ( int ) ( short ) usGetWord ( iFodo + iFodoOff + 4 , aucGrpprl ) ; for ( iIndex = 0 ; iIndex < iCol ; iIndex ++ ) { iPosCurr = ( int ) ( short ) usGetWord ( iFodo + iFodoOff + 6 + iIndex * 2 , aucGrpprl ) ; pRow -> asColumnWidth [ iIndex ] = ( short ) ( iPosCurr - iPosPrev ) ; iPosPrev = iPosCurr ; } bFound154 = TRUE ; break ; default : break ; } if ( iInfoLen <= 0 ) { iInfoLen = iGet2InfoLength ( iFodo + iFodoOff , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; } iFodoOff += iInfoLen ; } if ( bFound24_1 && bFound25_1 && bFound154 ) { return found_end_of_row ; } if ( bFound24_0 && bFound25_0 && ! bFound154 ) { return found_not_end_of_row ; } if ( bFound24_1 ) { return found_a_cell ; } if ( bFound24_0 ) { return found_not_a_cell ; } return found_nothing ; }",
    "resources/antiword/prop2.c@vGet2StyleInfo": "void vGet2StyleInfo ( int iFodo , const UCHAR * aucGrpprl , int iBytes , style_block_type * pStyle ) { int iFodoOff , iInfoLen ; int iTmp , iDel , iAdd ; short sTmp ; UCHAR ucTmp ; fail ( iFodo < 0 || aucGrpprl == NULL || pStyle == NULL ) ; NO_DBG_DEC ( pStyle -> usIstd ) ; iFodoOff = 0 ; while ( iBytes >= iFodoOff + 1 ) { iInfoLen = 0 ; switch ( ucGetByte ( iFodo + iFodoOff , aucGrpprl ) ) { case 2 : /* istd */ sTmp = ( short ) ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; NO_DBG_DEC ( sTmp ) ; break ; case 5 : /* jc */ pStyle -> ucAlignment = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; break ; case 12 : /* nfcSeqNumb */ pStyle -> ucNFC = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; break ; case 13 : /* nLvlAnm */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; pStyle -> ucNumLevel = ucTmp ; pStyle -> bNumPause = eGetNumType ( ucTmp ) == level_type_pause ; break ; case 15 : /* ChgTabsPapx */ case 23 : /* ChgTabs */ iTmp = ( int ) ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; if ( iTmp < 2 ) { iInfoLen = 1 ; break ; } NO_DBG_DEC ( iTmp ) ; iDel = ( int ) ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; if ( iTmp < 2 + 2 * iDel ) { iInfoLen = 1 ; break ; } NO_DBG_DEC ( iDel ) ; iAdd = ( int ) ucGetByte ( iFodo + iFodoOff + 3 + 2 * iDel , aucGrpprl ) ; if ( iTmp < 2 + 2 * iDel + 2 * iAdd ) { iInfoLen = 1 ; break ; } NO_DBG_DEC ( iAdd ) ; break ; case 16 : /* dxaRight */ pStyle -> sRightIndent = ( short ) usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> sRightIndent ) ; break ; case 17 : /* dxaLeft */ pStyle -> sLeftIndent = ( short ) usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> sLeftIndent ) ; break ; case 18 : /* Nest dxaLeft */ sTmp = ( short ) usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; pStyle -> sLeftIndent += sTmp ; if ( pStyle -> sLeftIndent < 0 ) { pStyle -> sLeftIndent = 0 ; } NO_DBG_DEC ( sTmp ) ; NO_DBG_DEC ( pStyle -> sLeftIndent ) ; break ; case 19 : /* dxaLeft1 */ pStyle -> sLeftIndent1 = ( short ) usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> sLeftIndent1 ) ; break ; case 21 : /* dyaBefore */ pStyle -> usBeforeIndent = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> usBeforeIndent ) ; break ; case 22 : /* dyaAfter */ pStyle -> usAfterIndent = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> usAfterIndent ) ; break ; default : break ; } if ( iInfoLen <= 0 ) { iInfoLen = iGet2InfoLength ( iFodo + iFodoOff , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; } iFodoOff += iInfoLen ; } }",
    "resources/antiword/prop2.c@vGet2PapInfo": "void vGet2PapInfo ( FILE * pFile , const UCHAR * aucHeader ) { row_block_type tRow ; style_block_type tStyle ; USHORT * ausParfPage ; UCHAR * aucBuffer ; ULONG ulCharPos , ulCharPosFirst , ulCharPosLast ; ULONG ulBeginParfInfo ; size_t tParfInfoLen , tParfPageNum , tOffset , tSize , tLenOld , tLen ; int iIndex , iIndex2 , iRun , iFodo , iLen ; row_info_enum eRowInfo ; USHORT usParfFirstPage , usCount , usIstd ; UCHAR ucStc ; UCHAR aucFpage [ BIG_BLOCK_SIZE ] ; fail ( pFile == NULL || aucHeader == NULL ) ; ulBeginParfInfo = ulGetLong ( 0xa6 , aucHeader ) ; /* fcPlcfbtePapx */ NO_DBG_HEX ( ulBeginParfInfo ) ; tParfInfoLen = ( size_t ) usGetWord ( 0xaa , aucHeader ) ; /* cbPlcfbtePapx */ NO_DBG_DEC ( tParfInfoLen ) ; if ( tParfInfoLen < 4 ) { DBG_DEC ( tParfInfoLen ) ; return ; } aucBuffer = xmalloc ( tParfInfoLen ) ; if ( ! bReadBytes ( aucBuffer , tParfInfoLen , ulBeginParfInfo , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tParfInfoLen ) ; tLen = ( tParfInfoLen - 4 ) / 6 ; ausParfPage = xcalloc ( tLen , sizeof ( USHORT ) ) ; for ( iIndex = 0 , tOffset = ( tLen + 1 ) * 4 ; iIndex < ( int ) tLen ; iIndex ++ , tOffset += 2 ) { ausParfPage [ iIndex ] = usGetWord ( tOffset , aucBuffer ) ; NO_DBG_DEC ( ausParfPage [ iIndex ] ) ; } DBG_HEX ( ulGetLong ( 0 , aucBuffer ) ) ; aucBuffer = xfree ( aucBuffer ) ; tParfPageNum = ( size_t ) usGetWord ( 0x144 , aucHeader ) ; /* cpnBtePap */ DBG_DEC ( tParfPageNum ) ; if ( tLen < tParfPageNum ) { /* Replace ParfPage by a longer version */ tLenOld = tLen ; usParfFirstPage = usGetWord ( 0x140 , aucHeader ) ; /* pnPapFirst */ DBG_DEC ( usParfFirstPage ) ; tLen += tParfPageNum - 1 ; tSize = tLen * sizeof ( USHORT ) ; ausParfPage = xrealloc ( ausParfPage , tSize ) ; /* Add new values */ usCount = usParfFirstPage + 1 ; for ( iIndex = ( int ) tLenOld ; iIndex < ( int ) tLen ; iIndex ++ ) { ausParfPage [ iIndex ] = usCount ; NO_DBG_DEC ( ausParfPage [ iIndex ] ) ; usCount ++ ; } } ( void ) memset ( & tRow , 0 , sizeof ( tRow ) ) ; ulCharPosFirst = CP_INVALID ; for ( iIndex = 0 ; iIndex < ( int ) tLen ; iIndex ++ ) { if ( ! bReadBytes ( aucFpage , BIG_BLOCK_SIZE , ( ULONG ) ausParfPage [ iIndex ] * BIG_BLOCK_SIZE , pFile ) ) { break ; } NO_DBG_PRINT_BLOCK ( aucFpage , BIG_BLOCK_SIZE ) ; iRun = ( int ) ucGetByte ( 0x1ff , aucFpage ) ; NO_DBG_DEC ( iRun ) ; for ( iIndex2 = 0 ; iIndex2 < iRun ; iIndex2 ++ ) { if ( ( iRun + 1 ) * 4 + iIndex2 * 1 >= BIG_BLOCK_SIZE ) { break ; } NO_DBG_HEX ( ulGetLong ( iIndex2 * 4 , aucFpage ) ) ; iFodo = 2 * ( int ) ucGetByte ( ( iRun + 1 ) * 4 + iIndex2 * 1 , aucFpage ) ; if ( iFodo <= 0 ) { continue ; } iLen = 2 * ( int ) ucGetByte ( iFodo , aucFpage ) ; ucStc = ucGetByte ( iFodo + 1 , aucFpage ) ; usIstd = usStc2istd ( ucStc ) ; vFillStyleFromStylesheet ( usIstd , & tStyle ) ; vGet2StyleInfo ( iFodo , aucFpage + 8 , iLen - 8 , & tStyle ) ; ulCharPos = ulGetLong ( iIndex2 * 4 , aucFpage ) ; NO_DBG_HEX ( ulCharPos ) ; tStyle . ulFileOffset = ulCharPos ; vAdd2StyleInfoList ( & tStyle ) ; eRowInfo = eGet2RowInfo ( iFodo , aucFpage + 8 , iLen - 8 , & tRow ) ; switch ( eRowInfo ) { case found_a_cell : if ( ulCharPosFirst != CP_INVALID ) { break ; } ulCharPosFirst = ulGetLong ( iIndex2 * 4 , aucFpage ) ; NO_DBG_HEX ( ulCharPosFirst ) ; tRow . ulCharPosStart = ulCharPosFirst ; tRow . ulFileOffsetStart = ulCharPosFirst ; break ; case found_end_of_row : ulCharPosLast = ulGetLong ( iIndex2 * 4 , aucFpage ) ; NO_DBG_HEX ( ulCharPosLast ) ; tRow . ulCharPosEnd = ulCharPosLast ; /* Add 1 for compatiblity with Word 6 and up */ tRow . ulFileOffsetEnd = ulCharPosLast + 1 ; vAdd2RowInfoList ( & tRow ) ; ( void ) memset ( & tRow , 0 , sizeof ( tRow ) ) ; ulCharPosFirst = CP_INVALID ; break ; case found_nothing : break ; default : DBG_DEC ( eRowInfo ) ; break ; } } } ausParfPage = xfree ( ausParfPage ) ; }",
    "resources/antiword/prop2.c@vGet1FontInfo": "void vGet1FontInfo ( int iFodo , const UCHAR * aucGrpprl , size_t tBytes , font_block_type * pFont ) { BOOL bIcoChange , bFtcChange , bHpsChange , bKulChange ; USHORT usTmp ; UCHAR ucTmp ; UCHAR aucChpx [ 12 ] ; fail ( iFodo < 0 || aucGrpprl == NULL || pFont == NULL ) ; if ( tBytes > sizeof ( aucChpx ) ) { NO_DBG_PRINT_BLOCK ( aucGrpprl + iFodo , tBytes ) ; return ; } /* Build the CHPX structure */ ( void ) memset ( aucChpx , 0 , sizeof ( aucChpx ) ) ; ( void ) memcpy ( aucChpx , aucGrpprl + iFodo , min ( tBytes , sizeof ( aucChpx ) ) ) ; usTmp = usGetWord ( 0 , aucChpx ) ; if ( ( usTmp & BIT ( 0 ) ) != 0 ) { pFont -> usFontStyle ^= FONT_BOLD ; } if ( ( usTmp & BIT ( 1 ) ) != 0 ) { pFont -> usFontStyle ^= FONT_ITALIC ; } if ( ( usTmp & BIT ( 2 ) ) != 0 ) { pFont -> usFontStyle ^= FONT_STRIKE ; } if ( ( usTmp & BIT ( 5 ) ) != 0 ) { pFont -> usFontStyle ^= FONT_SMALL_CAPITALS ; } if ( ( usTmp & BIT ( 6 ) ) != 0 ) { pFont -> usFontStyle ^= FONT_CAPITALS ; } if ( ( usTmp & BIT ( 7 ) ) != 0 ) { pFont -> usFontStyle ^= FONT_HIDDEN ; } ucTmp = ucGetByte ( 5 , aucChpx ) ; if ( ucTmp != 0 ) { if ( ucTmp < 128 ) { pFont -> usFontStyle |= FONT_SUPERSCRIPT ; DBG_MSG ( \"Superscript\" ) ; } else { pFont -> usFontStyle |= FONT_SUBSCRIPT ; DBG_MSG ( \"Subscript\" ) ; } } bIcoChange = ( usTmp & BIT ( 10 ) ) != 0 ; bFtcChange = ( usTmp & BIT ( 11 ) ) != 0 ; bHpsChange = ( usTmp & BIT ( 12 ) ) != 0 ; bKulChange = ( usTmp & BIT ( 13 ) ) != 0 ; if ( bFtcChange ) { usTmp = usGetWord ( 2 , aucChpx ) ; if ( usTmp <= ( USHORT ) UCHAR_MAX ) { pFont -> ucFontNumber = ( UCHAR ) usTmp ; } else { pFont -> ucFontNumber = 0 ; } } if ( bHpsChange ) { pFont -> usFontSize = ( USHORT ) ucGetByte ( 4 , aucChpx ) ; } if ( bIcoChange || bKulChange ) { usTmp = usGetWord ( 6 , aucChpx ) ; if ( bIcoChange ) { pFont -> ucFontColor = ( UCHAR ) ( ( usTmp & 0x0f00 ) >> 8 ) ; if ( pFont -> ucFontColor <= 7 ) { /* Add 1 for compatibility with Word 2 and up */ pFont -> ucFontColor ++ ; } else { DBG_DEC ( pFont -> ucFontColor ) ; pFont -> ucFontColor = 0 ; } } if ( bKulChange ) { usTmp = ( usTmp & 0x7000 ) >> 12 ; DBG_DEC_C ( usTmp > 4 , usTmp ) ; if ( usTmp == 0 ) { pFont -> usFontStyle &= ~ FONT_UNDERLINE ; } else { pFont -> usFontStyle |= FONT_UNDERLINE ; } } } }",
    "resources/antiword/prop2.c@vGet2FontInfo": "void vGet2FontInfo ( int iFodo , const UCHAR * aucGrpprl , size_t tBytes , font_block_type * pFont ) { BOOL bIcoChange , bFtcChange , bHpsChange , bKulChange ; USHORT usTmp ; UCHAR ucTmp ; UCHAR aucChpx [ 18 ] ; fail ( iFodo < 0 || aucGrpprl == NULL || pFont == NULL ) ; if ( tBytes > sizeof ( aucChpx ) ) { NO_DBG_PRINT_BLOCK ( aucGrpprl + iFodo , tBytes ) ; return ; } /* Build the CHPX structure */ ( void ) memset ( aucChpx , 0 , sizeof ( aucChpx ) ) ; ( void ) memcpy ( aucChpx , aucGrpprl + iFodo , min ( tBytes , sizeof ( aucChpx ) ) ) ; usTmp = usGetWord ( 0 , aucChpx ) ; if ( ( usTmp & BIT ( 0 ) ) != 0 ) { pFont -> usFontStyle ^= FONT_BOLD ; } if ( ( usTmp & BIT ( 1 ) ) != 0 ) { pFont -> usFontStyle ^= FONT_ITALIC ; } if ( usTmp & BIT ( 3 ) ) { pFont -> usFontStyle ^= FONT_MARKDEL ; } if ( ( usTmp & BIT ( 5 ) ) != 0 ) { pFont -> usFontStyle ^= FONT_SMALL_CAPITALS ; } if ( ( usTmp & BIT ( 6 ) ) != 0 ) { pFont -> usFontStyle ^= FONT_CAPITALS ; } if ( ( usTmp & BIT ( 7 ) ) != 0 ) { pFont -> usFontStyle ^= FONT_HIDDEN ; } if ( usTmp & BIT ( 10 ) ) { pFont -> usFontStyle ^= FONT_STRIKE ; } ucTmp = ucGetByte ( 10 , aucChpx ) ; DBG_MSG_C ( ucTmp != 0 && ucTmp < 128 , \"Superscript\" ) ; DBG_MSG_C ( ucTmp >= 128 , \"Subscript\" ) ; usTmp = usGetWord ( 2 , aucChpx ) ; if ( usTmp == 0 ) { /* No changes, nothing to do */ return ; } bIcoChange = ( usTmp & BIT ( 0 ) ) != 0 ; bFtcChange = ( usTmp & BIT ( 1 ) ) != 0 ; bHpsChange = ( usTmp & BIT ( 2 ) ) != 0 ; bKulChange = ( usTmp & BIT ( 3 ) ) != 0 ; if ( bFtcChange ) { usTmp = usGetWord ( 4 , aucChpx ) ; if ( usTmp <= ( USHORT ) UCHAR_MAX ) { pFont -> ucFontNumber = ( UCHAR ) usTmp ; } else { pFont -> ucFontNumber = 0 ; } } if ( bHpsChange ) { pFont -> usFontSize = usGetWord ( 6 , aucChpx ) ; } if ( bIcoChange || bKulChange ) { ucTmp = ucGetByte ( 9 , aucChpx ) ; if ( bIcoChange ) { pFont -> ucFontColor = ucTmp & 0x1f ; if ( pFont -> ucFontColor > 16 ) { DBG_DEC ( pFont -> ucFontColor ) ; pFont -> ucFontColor = 0 ; } } if ( bKulChange ) { ucTmp = ( ucTmp & 0xe0 ) >> 5 ; DBG_DEC_C ( ucTmp > 4 , ucTmp ) ; if ( ucTmp == 0 ) { pFont -> usFontStyle &= ~ FONT_UNDERLINE ; } else { pFont -> usFontStyle |= FONT_UNDERLINE ; } } } }",
    "resources/antiword/prop2.c@bGet1PicInfo": "static BOOL bGet1PicInfo ( int iFodo , const UCHAR * aucGrpprl , size_t tBytes , picture_block_type * pPicture ) { ULONG ulTmp ; UCHAR aucChpx [ 12 ] ; fail ( iFodo < 0 || aucGrpprl == NULL || pPicture == NULL ) ; if ( tBytes > sizeof ( aucChpx ) ) { NO_DBG_PRINT_BLOCK ( aucGrpprl + iFodo , tBytes ) ; tBytes = sizeof ( aucChpx ) ; } /* Build the CHPX structure */ ( void ) memset ( aucChpx , 0 , sizeof ( aucChpx ) ) ; ( void ) memcpy ( aucChpx , aucGrpprl + iFodo , min ( tBytes , sizeof ( aucChpx ) ) ) ; ulTmp = ulGetLong ( 8 , aucChpx ) ; if ( ulTmp != 0 && ulTmp < MAX_FILESIZE ) { pPicture -> ulPictureOffset = ulTmp ; DBG_HEX ( pPicture -> ulPictureOffset ) ; return TRUE ; } return FALSE ; }",
    "resources/antiword/prop2.c@bGet2PicInfo": "static BOOL bGet2PicInfo ( int iFodo , const UCHAR * aucGrpprl , size_t tBytes , picture_block_type * pPicture ) { ULONG ulTmp ; UCHAR aucChpx [ 18 ] ; fail ( iFodo < 0 || aucGrpprl == NULL || pPicture == NULL ) ; if ( tBytes > sizeof ( aucChpx ) ) { NO_DBG_PRINT_BLOCK ( aucGrpprl + iFodo , tBytes ) ; tBytes = sizeof ( aucChpx ) ; } /* Build the CHPX structure */ ( void ) memset ( aucChpx , 0 , sizeof ( aucChpx ) ) ; ( void ) memcpy ( aucChpx , aucGrpprl + iFodo , min ( tBytes , sizeof ( aucChpx ) ) ) ; ulTmp = ulGetLong ( 14 , aucChpx ) ; if ( ulTmp != 0 && ulTmp < MAX_FILESIZE ) { pPicture -> ulPictureOffset = ulTmp ; DBG_HEX ( pPicture -> ulPictureOffset ) ; DBG_DEC ( tBytes ) ; return TRUE ; } return FALSE ; }",
    "resources/antiword/prop2.c@vGet2ChrInfo": "void vGet2ChrInfo ( FILE * pFile , int iWordVersion , const UCHAR * aucHeader ) { font_block_type tFont ; picture_block_type tPicture ; USHORT * ausCharPage ; UCHAR * aucBuffer ; ULONG ulFileOffset , ulCharPos , ulBeginCharInfo ; size_t tCharInfoLen , tOffset , tSize , tChrLen , tCharPageNum ; size_t tLenOld , tLen ; int iIndex , iIndex2 , iRun , iFodo ; BOOL bSuccess1 , bSuccess2 ; USHORT usCharFirstPage , usCount , usIstd ; UCHAR aucFpage [ BIG_BLOCK_SIZE ] ; fail ( pFile == NULL || aucHeader == NULL ) ; fail ( iWordVersion != 1 && iWordVersion != 2 ) ; ulBeginCharInfo = ulGetLong ( 0xa0 , aucHeader ) ; /* fcPlcfbteChpx */ DBG_HEX ( ulBeginCharInfo ) ; tCharInfoLen = ( size_t ) usGetWord ( 0xa4 , aucHeader ) ; /* cbPlcfbteChpx */ DBG_DEC ( tCharInfoLen ) ; if ( tCharInfoLen < 4 ) { DBG_DEC ( tCharInfoLen ) ; return ; } aucBuffer = xmalloc ( tCharInfoLen ) ; if ( ! bReadBytes ( aucBuffer , tCharInfoLen , ulBeginCharInfo , pFile ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tCharInfoLen ) ; tLen = ( tCharInfoLen - 4 ) / 6 ; ausCharPage = xcalloc ( tLen , sizeof ( USHORT ) ) ; for ( iIndex = 0 , tOffset = ( tLen + 1 ) * 4 ; iIndex < ( int ) tLen ; iIndex ++ , tOffset += 2 ) { ausCharPage [ iIndex ] = usGetWord ( tOffset , aucBuffer ) ; NO_DBG_DEC ( ausCharPage [ iIndex ] ) ; } DBG_HEX ( ulGetLong ( 0 , aucBuffer ) ) ; aucBuffer = xfree ( aucBuffer ) ; tCharPageNum = ( size_t ) usGetWord ( 0x142 , aucHeader ) ; /* cpnBteChp */ DBG_DEC ( tCharPageNum ) ; if ( tLen < tCharPageNum ) { /* Replace CharPage by a longer version */ tLenOld = tLen ; usCharFirstPage = usGetWord ( 0x13e , aucHeader ) ; /* pnChrFirst */ NO_DBG_DEC ( usCharFirstPage ) ; tLen += tCharPageNum - 1 ; tSize = tLen * sizeof ( USHORT ) ; ausCharPage = xrealloc ( ausCharPage , tSize ) ; /* Add new values */ usCount = usCharFirstPage + 1 ; for ( iIndex = ( int ) tLenOld ; iIndex < ( int ) tLen ; iIndex ++ ) { ausCharPage [ iIndex ] = usCount ; NO_DBG_DEC ( ausCharPage [ iIndex ] ) ; usCount ++ ; } } for ( iIndex = 0 ; iIndex < ( int ) tLen ; iIndex ++ ) { if ( ! bReadBytes ( aucFpage , BIG_BLOCK_SIZE , ( ULONG ) ausCharPage [ iIndex ] * BIG_BLOCK_SIZE , pFile ) ) { break ; } NO_DBG_PRINT_BLOCK ( aucFpage , BIG_BLOCK_SIZE ) ; iRun = ( int ) ucGetByte ( 0x1ff , aucFpage ) ; NO_DBG_DEC ( iRun ) ; for ( iIndex2 = 0 ; iIndex2 < iRun ; iIndex2 ++ ) { if ( ( iRun + 1 ) * 4 + iIndex2 >= BIG_BLOCK_SIZE ) { break ; } ulCharPos = ulGetLong ( iIndex2 * 4 , aucFpage ) ; ulFileOffset = ulCharPos ; iFodo = 2 * ( int ) ucGetByte ( ( iRun + 1 ) * 4 + iIndex2 , aucFpage ) ; tChrLen = ( size_t ) ucGetByte ( iFodo , aucFpage ) ; usIstd = usGetIstd ( ulFileOffset ) ; vFillFontFromStylesheet ( usIstd , & tFont ) ; if ( iFodo != 0 ) { if ( iWordVersion == 1 ) { vGet1FontInfo ( iFodo , aucFpage + 1 , tChrLen , & tFont ) ; } else if ( iWordVersion == 2 ) { vGet2FontInfo ( iFodo , aucFpage + 1 , tChrLen , & tFont ) ; } } tFont . ulFileOffset = ulFileOffset ; vAdd2FontInfoList ( & tFont ) ; if ( iFodo <= 0 ) { continue ; } ( void ) memset ( & tPicture , 0 , sizeof ( tPicture ) ) ; bSuccess1 = iWordVersion == 1 && bGet1PicInfo ( iFodo , aucFpage + 1 , tChrLen , & tPicture ) ; bSuccess2 = iWordVersion == 2 && bGet2PicInfo ( iFodo , aucFpage + 1 , tChrLen , & tPicture ) ; if ( bSuccess1 || bSuccess2 ) { tPicture . ulFileOffset = ulFileOffset ; tPicture . ulFileOffsetPicture = tPicture . ulPictureOffset ; vAdd2PictInfoList ( & tPicture ) ; } } } ausCharPage = xfree ( ausCharPage ) ; }",
    "resources/antiword/jpeg2sprt.c@bSave2Draw": "",
    "resources/antiword/jpeg2sprt.c@bTranslateJPEG": "",
    "resources/antiword/prop6.c@iGet6InfoLength": "static int iGet6InfoLength ( int iByteNbr , const UCHAR * aucGrpprl ) { int iTmp , iDel , iAdd ; switch ( ucGetByte ( iByteNbr , aucGrpprl ) ) { case 2 : case 16 : case 17 : case 18 : case 19 : case 21 : case 22 : case 26 : case 27 : case 28 : case 30 : case 31 : case 32 : case 33 : case 34 : case 35 : case 36 : case 38 : case 39 : case 40 : case 41 : case 42 : case 43 : case 45 : case 46 : case 47 : case 48 : case 49 : case 69 : case 72 : case 80 : case 93 : case 96 : case 97 : case 99 : case 101 : case 105 : case 106 : case 107 : case 109 : case 110 : case 121 : case 122 : case 123 : case 124 : case 140 : case 141 : case 144 : case 145 : case 148 : case 149 : case 154 : case 155 : case 156 : case 157 : case 160 : case 161 : case 164 : case 165 : case 166 : case 167 : case 168 : case 169 : case 170 : case 171 : case 182 : case 183 : case 184 : case 189 : case 195 : case 197 : case 198 : return 1 + 2 ; case 3 : case 12 : case 15 : case 81 : case 103 : case 108 : case 188 : case 190 : case 191 : return 2 + ( int ) ucGetByte ( iByteNbr + 1 , aucGrpprl ) ; case 20 : case 70 : case 74 : case 192 : case 194 : case 196 : case 200 : return 1 + 4 ; case 23 : iTmp = ( int ) ucGetByte ( iByteNbr + 1 , aucGrpprl ) ; if ( iTmp == 255 ) { iDel = ( int ) ucGetByte ( iByteNbr + 2 , aucGrpprl ) ; iAdd = ( int ) ucGetByte ( iByteNbr + 3 + iDel * 4 , aucGrpprl ) ; iTmp = 2 + iDel * 4 + iAdd * 3 ; } return 2 + iTmp ; case 68 : case 193 : case 199 : return 1 + 5 ; case 73 : case 95 : case 136 : case 137 : return 1 + 3 ; case 120 : case 187 : return 1 + 12 ; default : return 1 + 1 ; } }",
    "resources/antiword/prop6.c@vGet6DopInfo": "void vGet6DopInfo ( FILE * pFile , ULONG ulStartBlock , const ULONG * aulBBD , size_t tBBDLen , const UCHAR * aucHeader ) { document_block_type tDocument ; UCHAR * aucBuffer ; ULONG ulBeginDocpInfo , ulTmp ; size_t tDocpInfoLen ; USHORT usTmp ; ulBeginDocpInfo = ulGetLong ( 0x150 , aucHeader ) ; /* fcDop */ DBG_HEX ( ulBeginDocpInfo ) ; tDocpInfoLen = ( size_t ) ulGetLong ( 0x154 , aucHeader ) ; /* lcbDop */ DBG_DEC ( tDocpInfoLen ) ; if ( tDocpInfoLen < 28 ) { DBG_MSG ( \"No Document information\" ) ; return ; } aucBuffer = xmalloc ( tDocpInfoLen ) ; if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucBuffer , ulBeginDocpInfo , tDocpInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } usTmp = usGetWord ( 0x00 , aucBuffer ) ; tDocument . ucHdrFtrSpecification = ( UCHAR ) ( usTmp >> 8 ) ; /* grpfIhdt */ tDocument . usDefaultTabWidth = usGetWord ( 0x0a , aucBuffer ) ; /* dxaTab */ ulTmp = ulGetLong ( 0x14 , aucBuffer ) ; /* dttmCreated */ tDocument . tCreateDate = tConvertDTTM ( ulTmp ) ; ulTmp = ulGetLong ( 0x18 , aucBuffer ) ; /* dttmRevised */ tDocument . tRevisedDate = tConvertDTTM ( ulTmp ) ; vCreateDocumentInfoList ( & tDocument ) ; aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/prop6.c@vGet6SectionInfo": "static void vGet6SectionInfo ( const UCHAR * aucGrpprl , size_t tBytes , section_block_type * pSection ) { UINT uiIndex ; int iFodoOff , iInfoLen , iSize , iTmp ; USHORT usCcol ; UCHAR ucTmp ; fail ( aucGrpprl == NULL || pSection == NULL ) ; iFodoOff = 0 ; while ( tBytes >= ( size_t ) iFodoOff + 1 ) { iInfoLen = 0 ; switch ( ucGetByte ( iFodoOff , aucGrpprl ) ) { case 133 : /* olstAnm */ iSize = ( int ) ucGetByte ( iFodoOff + 1 , aucGrpprl ) ; DBG_DEC_C ( iSize != 212 , iSize ) ; for ( uiIndex = 0 , iTmp = iFodoOff + 2 ; uiIndex < 9 && iTmp < iFodoOff + 2 + iSize - 15 ; uiIndex ++ , iTmp += 16 ) { pSection -> aucNFC [ uiIndex ] = ucGetByte ( iTmp , aucGrpprl ) ; NO_DBG_DEC ( pSection -> aucNFC [ uiIndex ] ) ; ucTmp = ucGetByte ( iTmp + 3 , aucGrpprl ) ; NO_DBG_HEX ( ucTmp ) ; if ( ( ucTmp & BIT ( 2 ) ) != 0 ) { pSection -> usNeedPrevLvl |= ( USHORT ) BIT ( uiIndex ) ; } if ( ( ucTmp & BIT ( 3 ) ) != 0 ) { pSection -> usHangingIndent |= ( USHORT ) BIT ( uiIndex ) ; } } DBG_HEX ( pSection -> usNeedPrevLvl ) ; DBG_HEX ( pSection -> usHangingIndent ) ; break ; case 142 : /* bkc */ ucTmp = ucGetByte ( iFodoOff + 1 , aucGrpprl ) ; DBG_DEC ( ucTmp ) ; pSection -> bNewPage = ucTmp != 0 && ucTmp != 1 ; break ; case 144 : /* ccolM1 */ usCcol = 1 + usGetWord ( iFodoOff + 1 , aucGrpprl ) ; DBG_DEC ( usCcol ) ; break ; case 153 : /* grpfIhdt */ pSection -> ucHdrFtrSpecification = ucGetByte ( iFodoOff + 1 , aucGrpprl ) ; break ; default : break ; } if ( iInfoLen <= 0 ) { iInfoLen = iGet6InfoLength ( iFodoOff , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; } iFodoOff += iInfoLen ; } }",
    "resources/antiword/prop6.c@vGet6SepInfo": "void vGet6SepInfo ( FILE * pFile , ULONG ulStartBlock , const ULONG * aulBBD , size_t tBBDLen , const UCHAR * aucHeader ) { section_block_type tSection ; ULONG * aulSectPage , * aulCharPos ; UCHAR * aucBuffer , * aucFpage ; ULONG ulBeginOfText , ulTextOffset , ulBeginSectInfo ; size_t tSectInfoLen , tIndex , tOffset , tLen , tBytes ; UCHAR aucTmp [ 2 ] ; fail ( pFile == NULL || aucHeader == NULL ) ; fail ( ulStartBlock > MAX_BLOCKNUMBER && ulStartBlock != END_OF_CHAIN ) ; fail ( aulBBD == NULL ) ; ulBeginOfText = ulGetLong ( 0x18 , aucHeader ) ; /* fcMin */ NO_DBG_HEX ( ulBeginOfText ) ; ulBeginSectInfo = ulGetLong ( 0x88 , aucHeader ) ; /* fcPlcfsed */ DBG_HEX ( ulBeginSectInfo ) ; tSectInfoLen = ( size_t ) ulGetLong ( 0x8c , aucHeader ) ; /* lcbPlcfsed */ DBG_DEC ( tSectInfoLen ) ; if ( tSectInfoLen < 4 ) { DBG_DEC ( tSectInfoLen ) ; return ; } aucBuffer = xmalloc ( tSectInfoLen ) ; if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucBuffer , ulBeginSectInfo , tSectInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tSectInfoLen ) ; /* Read the Section Descriptors */ tLen = ( tSectInfoLen - 4 ) / 16 ; /* Save the section offsets */ aulCharPos = xcalloc ( tLen , sizeof ( ULONG ) ) ; for ( tIndex = 0 , tOffset = 0 ; tIndex < tLen ; tIndex ++ , tOffset += 4 ) { ulTextOffset = ulGetLong ( tOffset , aucBuffer ) ; NO_DBG_HEX ( ulTextOffset ) ; aulCharPos [ tIndex ] = ulBeginOfText + ulTextOffset ; NO_DBG_HEX ( aulCharPos [ tIndex ] ) ; } /* Save the Sepx offsets */ aulSectPage = xcalloc ( tLen , sizeof ( ULONG ) ) ; for ( tIndex = 0 , tOffset = ( tLen + 1 ) * 4 ; tIndex < tLen ; tIndex ++ , tOffset += 12 ) { aulSectPage [ tIndex ] = ulGetLong ( tOffset + 2 , aucBuffer ) ; NO_DBG_HEX ( aulSectPage [ tIndex ] ) ; /* fcSepx */ } aucBuffer = xfree ( aucBuffer ) ; /* Read the Section Properties */ for ( tIndex = 0 ; tIndex < tLen ; tIndex ++ ) { if ( aulSectPage [ tIndex ] == FC_INVALID ) { vDefault2SectionInfoList ( aulCharPos [ tIndex ] ) ; continue ; } /* Get the number of bytes to read */ if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucTmp , aulSectPage [ tIndex ] , 2 ) ) { continue ; } tBytes = 2 + ( size_t ) usGetWord ( 0 , aucTmp ) ; NO_DBG_DEC ( tBytes ) ; /* Read the bytes */ aucFpage = xmalloc ( tBytes ) ; if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucFpage , aulSectPage [ tIndex ] , tBytes ) ) { aucFpage = xfree ( aucFpage ) ; continue ; } NO_DBG_PRINT_BLOCK ( aucFpage , tBytes ) ; /* Process the bytes */ vGetDefaultSection ( & tSection ) ; vGet6SectionInfo ( aucFpage + 2 , tBytes - 2 , & tSection ) ; vAdd2SectionInfoList ( & tSection , aulCharPos [ tIndex ] ) ; aucFpage = xfree ( aucFpage ) ; } aulCharPos = xfree ( aulCharPos ) ; aulSectPage = xfree ( aulSectPage ) ; }",
    "resources/antiword/prop6.c@vGet6HdrFtrInfo": "void vGet6HdrFtrInfo ( FILE * pFile , ULONG ulStartBlock , const ULONG * aulBBD , size_t tBBDLen , const UCHAR * aucHeader ) { ULONG * aulCharPos ; UCHAR * aucBuffer ; ULONG ulHdrFtrOffset , ulBeginHdrFtrInfo ; size_t tHdrFtrInfoLen , tIndex , tOffset , tLen ; fail ( pFile == NULL || aucHeader == NULL ) ; fail ( ulStartBlock > MAX_BLOCKNUMBER && ulStartBlock != END_OF_CHAIN ) ; fail ( aulBBD == NULL ) ; ulBeginHdrFtrInfo = ulGetLong ( 0xb0 , aucHeader ) ; /* fcPlcfhdd */ NO_DBG_HEX ( ulBeginHdrFtrInfo ) ; tHdrFtrInfoLen = ( size_t ) ulGetLong ( 0xb4 , aucHeader ) ; /* lcbPlcfhdd */ NO_DBG_DEC ( tHdrFtrInfoLen ) ; if ( tHdrFtrInfoLen < 8 ) { DBG_DEC_C ( tHdrFtrInfoLen != 0 , tHdrFtrInfoLen ) ; return ; } aucBuffer = xmalloc ( tHdrFtrInfoLen ) ; if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucBuffer , ulBeginHdrFtrInfo , tHdrFtrInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tHdrFtrInfoLen ) ; tLen = tHdrFtrInfoLen / 4 - 1 ; /* Save the header/footer offsets */ aulCharPos = xcalloc ( tLen , sizeof ( ULONG ) ) ; for ( tIndex = 0 , tOffset = 0 ; tIndex < tLen ; tIndex ++ , tOffset += 4 ) { ulHdrFtrOffset = ulGetLong ( tOffset , aucBuffer ) ; NO_DBG_HEX ( ulHdrFtrOffset ) ; aulCharPos [ tIndex ] = ulHdrFtrOffset2CharPos ( ulHdrFtrOffset ) ; NO_DBG_HEX ( aulCharPos [ tIndex ] ) ; } vCreat6HdrFtrInfoList ( aulCharPos , tLen ) ; aulCharPos = xfree ( aulCharPos ) ; aucBuffer = xfree ( aucBuffer ) ; }",
    "resources/antiword/prop6.c@eGet6RowInfo": "row_info_enum eGet6RowInfo ( int iFodo , const UCHAR * aucGrpprl , int iBytes , row_block_type * pRow ) { int iFodoOff , iInfoLen ; int iIndex , iSize , iCol ; int iPosCurr , iPosPrev ; USHORT usTmp ; BOOL bFound24_0 , bFound24_1 , bFound25_0 , bFound25_1 , bFound190 ; fail ( iFodo < 0 || aucGrpprl == NULL || pRow == NULL ) ; iFodoOff = 0 ; bFound24_0 = FALSE ; bFound24_1 = FALSE ; bFound25_0 = FALSE ; bFound25_1 = FALSE ; bFound190 = FALSE ; while ( iBytes >= iFodoOff + 1 ) { iInfoLen = 0 ; switch ( ucGetByte ( iFodo + iFodoOff , aucGrpprl ) ) { case 24 : /* fInTable */ if ( odd ( ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ) ) { bFound24_1 = TRUE ; } else { bFound24_0 = TRUE ; } break ; case 25 : /* fTtp */ if ( odd ( ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ) ) { bFound25_1 = TRUE ; } else { bFound25_0 = TRUE ; } break ; case 38 : /* brcTop */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; usTmp &= 0x0018 ; NO_DBG_DEC ( usTmp >> 3 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_TOP ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_TOP ; } break ; case 39 : /* brcLeft */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; usTmp &= 0x0018 ; NO_DBG_DEC ( usTmp >> 3 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_LEFT ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_LEFT ; } break ; case 40 : /* brcBottom */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; usTmp &= 0x0018 ; NO_DBG_DEC ( usTmp >> 3 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_BOTTOM ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_BOTTOM ; } break ; case 41 : /* brcRight */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; usTmp &= 0x0018 ; NO_DBG_DEC ( usTmp >> 3 ) ; if ( usTmp == 0 ) { pRow -> ucBorderInfo &= ~ TABLE_BORDER_RIGHT ; } else { pRow -> ucBorderInfo |= TABLE_BORDER_RIGHT ; } break ; case 188 : /* cDefTable10 */ DBG_MSG ( \"188: sprmTDefTable10\" ) ; iSize = ( int ) usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; DBG_DEC ( iSize ) ; break ; case 190 : /* cDefTable */ iSize = ( int ) usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; if ( iSize < 6 || iBytes < iFodoOff + 7 ) { DBG_DEC ( iSize ) ; DBG_DEC ( iFodoOff ) ; iInfoLen = 1 ; break ; } iCol = ( int ) ucGetByte ( iFodo + iFodoOff + 3 , aucGrpprl ) ; if ( iCol < 1 || iBytes < iFodoOff + 3 + ( iCol + 1 ) * 2 ) { DBG_DEC ( iCol ) ; DBG_DEC ( iFodoOff ) ; iInfoLen = 1 ; break ; } if ( iCol >= ( int ) elementsof ( pRow -> asColumnWidth ) ) { DBG_DEC ( iCol ) ; werr ( 1 , \"The number of columns is corrupt\" ) ; } pRow -> ucNumberOfColumns = ( UCHAR ) iCol ; iPosPrev = ( int ) ( short ) usGetWord ( iFodo + iFodoOff + 4 , aucGrpprl ) ; for ( iIndex = 0 ; iIndex < iCol ; iIndex ++ ) { iPosCurr = ( int ) ( short ) usGetWord ( iFodo + iFodoOff + 6 + iIndex * 2 , aucGrpprl ) ; pRow -> asColumnWidth [ iIndex ] = ( short ) ( iPosCurr - iPosPrev ) ; iPosPrev = iPosCurr ; } bFound190 = TRUE ; break ; default : break ; } if ( iInfoLen <= 0 ) { iInfoLen = iGet6InfoLength ( iFodo + iFodoOff , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; } iFodoOff += iInfoLen ; } if ( bFound25_1 && bFound190 ) { return found_end_of_row ; } if ( bFound25_0 && ! bFound190 ) { return found_not_end_of_row ; } if ( bFound24_1 ) { return found_a_cell ; } if ( bFound24_0 ) { return found_not_a_cell ; } return found_nothing ; }",
    "resources/antiword/prop6.c@vGet6StyleInfo": "void vGet6StyleInfo ( int iFodo , const UCHAR * aucGrpprl , int iBytes , style_block_type * pStyle ) { int iFodoOff , iInfoLen ; int iTmp , iDel , iAdd , iBefore ; short sTmp ; UCHAR ucTmp ; fail ( iFodo < 0 || aucGrpprl == NULL || pStyle == NULL ) ; NO_DBG_DEC ( pStyle -> usIstd ) ; iFodoOff = 0 ; while ( iBytes >= iFodoOff + 1 ) { iInfoLen = 0 ; switch ( ucGetByte ( iFodo + iFodoOff , aucGrpprl ) ) { case 2 : /* istd */ sTmp = ( short ) ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; NO_DBG_DEC ( sTmp ) ; break ; case 5 : /* jc */ pStyle -> ucAlignment = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; break ; case 12 : /* anld */ iTmp = ( int ) ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; DBG_DEC_C ( iTmp < 52 , iTmp ) ; if ( iTmp >= 1 ) { pStyle -> ucNFC = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; } if ( pStyle -> ucNFC != LIST_BULLETS && iTmp >= 2 ) { iBefore = ( int ) ucGetByte ( iFodo + iFodoOff + 3 , aucGrpprl ) ; } else { iBefore = 0 ; } if ( iTmp >= 12 ) { pStyle -> usStartAt = usGetWord ( iFodo + iFodoOff + 12 , aucGrpprl ) ; } if ( iTmp >= iBefore + 21 ) { pStyle -> usListChar = ( USHORT ) ucGetByte ( iFodo + iFodoOff + iBefore + 22 , aucGrpprl ) ; NO_DBG_HEX ( pStyle -> usListChar ) ; } break ; case 13 : /* nLvlAnm */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; pStyle -> ucNumLevel = ucTmp ; pStyle -> bNumPause = eGetNumType ( ucTmp ) == level_type_pause ; break ; case 15 : /* ChgTabsPapx */ case 23 : /* ChgTabs */ iTmp = ( int ) ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; if ( iTmp < 2 ) { iInfoLen = 1 ; break ; } NO_DBG_DEC ( iTmp ) ; iDel = ( int ) ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; if ( iTmp < 2 + 2 * iDel ) { iInfoLen = 1 ; break ; } NO_DBG_DEC ( iDel ) ; iAdd = ( int ) ucGetByte ( iFodo + iFodoOff + 3 + 2 * iDel , aucGrpprl ) ; if ( iTmp < 2 + 2 * iDel + 2 * iAdd ) { iInfoLen = 1 ; break ; } NO_DBG_DEC ( iAdd ) ; break ; case 16 : /* dxaRight */ pStyle -> sRightIndent = ( short ) usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> sRightIndent ) ; break ; case 17 : /* dxaLeft */ pStyle -> sLeftIndent = ( short ) usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> sLeftIndent ) ; break ; case 18 : /* Nest dxaLeft */ sTmp = ( short ) usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; pStyle -> sLeftIndent += sTmp ; if ( pStyle -> sLeftIndent < 0 ) { pStyle -> sLeftIndent = 0 ; } NO_DBG_DEC ( sTmp ) ; NO_DBG_DEC ( pStyle -> sLeftIndent ) ; break ; case 19 : /* dxaLeft1 */ pStyle -> sLeftIndent1 = ( short ) usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> sLeftIndent1 ) ; break ; case 21 : /* dyaBefore */ pStyle -> usBeforeIndent = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> usBeforeIndent ) ; break ; case 22 : /* dyaAfter */ pStyle -> usAfterIndent = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; NO_DBG_DEC ( pStyle -> usAfterIndent ) ; break ; default : break ; } if ( iInfoLen <= 0 ) { iInfoLen = iGet6InfoLength ( iFodo + iFodoOff , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; } iFodoOff += iInfoLen ; } }",
    "resources/antiword/prop6.c@vGet6PapInfo": "void vGet6PapInfo ( FILE * pFile , ULONG ulStartBlock , const ULONG * aulBBD , size_t tBBDLen , const UCHAR * aucHeader ) { row_block_type tRow ; style_block_type tStyle ; USHORT * ausParfPage ; UCHAR * aucBuffer ; ULONG ulCharPos , ulCharPosFirst , ulCharPosLast ; ULONG ulBeginParfInfo ; size_t tParfInfoLen , tParfPageNum , tOffset , tSize , tLenOld , tLen ; size_t tIndex , tIndex2 , tRun ; int iFodo , iLen ; row_info_enum eRowInfo ; USHORT usParfFirstPage , usCount , usIstd ; UCHAR aucFpage [ BIG_BLOCK_SIZE ] ; fail ( pFile == NULL || aucHeader == NULL ) ; fail ( ulStartBlock > MAX_BLOCKNUMBER && ulStartBlock != END_OF_CHAIN ) ; fail ( aulBBD == NULL ) ; ulBeginParfInfo = ulGetLong ( 0xc0 , aucHeader ) ; /* fcPlcfbtePapx */ NO_DBG_HEX ( ulBeginParfInfo ) ; tParfInfoLen = ( size_t ) ulGetLong ( 0xc4 , aucHeader ) ; /* lcbPlcfbtePapx */ NO_DBG_DEC ( tParfInfoLen ) ; if ( tParfInfoLen < 4 ) { DBG_DEC ( tParfInfoLen ) ; return ; } aucBuffer = xmalloc ( tParfInfoLen ) ; if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucBuffer , ulBeginParfInfo , tParfInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } NO_DBG_PRINT_BLOCK ( aucBuffer , tParfInfoLen ) ; tLen = ( tParfInfoLen - 4 ) / 6 ; ausParfPage = xcalloc ( tLen , sizeof ( USHORT ) ) ; for ( tIndex = 0 , tOffset = ( tLen + 1 ) * 4 ; tIndex < tLen ; tIndex ++ , tOffset += 2 ) { ausParfPage [ tIndex ] = usGetWord ( tOffset , aucBuffer ) ; NO_DBG_DEC ( ausParfPage [ tIndex ] ) ; } DBG_HEX ( ulGetLong ( 0 , aucBuffer ) ) ; aucBuffer = xfree ( aucBuffer ) ; tParfPageNum = ( size_t ) usGetWord ( 0x190 , aucHeader ) ; /* cpnBtePap */ DBG_DEC ( tParfPageNum ) ; if ( tLen < tParfPageNum ) { /* Replace ParfPage by a longer version */ tLenOld = tLen ; usParfFirstPage = usGetWord ( 0x18c , aucHeader ) ; /* pnPapFirst */ DBG_DEC ( usParfFirstPage ) ; tLen += tParfPageNum - 1 ; tSize = tLen * sizeof ( USHORT ) ; ausParfPage = xrealloc ( ausParfPage , tSize ) ; /* Add new values */ usCount = usParfFirstPage + 1 ; for ( tIndex = tLenOld ; tIndex < tLen ; tIndex ++ ) { ausParfPage [ tIndex ] = usCount ; NO_DBG_DEC ( ausParfPage [ tIndex ] ) ; usCount ++ ; } } ( void ) memset ( & tRow , 0 , sizeof ( tRow ) ) ; ulCharPosFirst = CP_INVALID ; for ( tIndex = 0 ; tIndex < tLen ; tIndex ++ ) { if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucFpage , ( ULONG ) ausParfPage [ tIndex ] * BIG_BLOCK_SIZE , BIG_BLOCK_SIZE ) ) { break ; } tRun = ( size_t ) ucGetByte ( 0x1ff , aucFpage ) ; NO_DBG_DEC ( tRun ) ; for ( tIndex2 = 0 ; tIndex2 < tRun ; tIndex2 ++ ) { NO_DBG_HEX ( ulGetLong ( tIndex2 * 4 , aucFpage ) ) ; iFodo = 2 * ( int ) ucGetByte ( ( tRun + 1 ) * 4 + tIndex2 * 7 , aucFpage ) ; if ( iFodo <= 0 ) { continue ; } iLen = 2 * ( int ) ucGetByte ( iFodo , aucFpage ) ; usIstd = ( USHORT ) ucGetByte ( iFodo + 1 , aucFpage ) ; vFillStyleFromStylesheet ( usIstd , & tStyle ) ; vGet6StyleInfo ( iFodo , aucFpage + 3 , iLen - 3 , & tStyle ) ; ulCharPos = ulGetLong ( tIndex2 * 4 , aucFpage ) ; NO_DBG_HEX ( ulCharPos ) ; tStyle . ulFileOffset = ulCharPos2FileOffsetX ( ulCharPos , & tStyle . eListID ) ; vAdd2StyleInfoList ( & tStyle ) ; eRowInfo = eGet6RowInfo ( iFodo , aucFpage + 3 , iLen - 3 , & tRow ) ; switch ( eRowInfo ) { case found_a_cell : if ( ulCharPosFirst != CP_INVALID ) { break ; } ulCharPosFirst = ulGetLong ( tIndex2 * 4 , aucFpage ) ; NO_DBG_HEX ( ulCharPosFirst ) ; tRow . ulCharPosStart = ulCharPosFirst ; tRow . ulFileOffsetStart = ulCharPos2FileOffset ( ulCharPosFirst ) ; DBG_HEX_C ( tRow . ulFileOffsetStart == FC_INVALID , ulCharPosFirst ) ; break ; case found_end_of_row : ulCharPosLast = ulGetLong ( tIndex2 * 4 , aucFpage ) ; NO_DBG_HEX ( ulCharPosLast ) ; tRow . ulCharPosEnd = ulCharPosLast ; tRow . ulFileOffsetEnd = ulCharPos2FileOffset ( ulCharPosLast ) ; DBG_HEX_C ( tRow . ulFileOffsetEnd == FC_INVALID , ulCharPosLast ) ; vAdd2RowInfoList ( & tRow ) ; ( void ) memset ( & tRow , 0 , sizeof ( tRow ) ) ; ulCharPosFirst = CP_INVALID ; break ; case found_nothing : break ; default : DBG_DEC ( eRowInfo ) ; break ; } } } ausParfPage = xfree ( ausParfPage ) ; }",
    "resources/antiword/prop6.c@vGet6FontInfo": "void vGet6FontInfo ( int iFodo , USHORT usIstd , const UCHAR * aucGrpprl , int iBytes , font_block_type * pFont ) { long lTmp ; int iFodoOff , iInfoLen ; USHORT usTmp ; UCHAR ucTmp ; TRACE_MSG ( \"vGet6FontInfo\" ) ; fail ( iFodo < 0 || aucGrpprl == NULL || pFont == NULL ) ; iFodoOff = 0 ; while ( iBytes >= iFodoOff + 1 ) { switch ( ucGetByte ( iFodo + iFodoOff , aucGrpprl ) ) { case 65 : /* fRMarkDel */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; if ( ucTmp == 0 ) { pFont -> usFontStyle &= ~ FONT_MARKDEL ; } else { pFont -> usFontStyle |= FONT_MARKDEL ; } break ; case 80 : /* cIstd */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; NO_DBG_DEC ( usTmp ) ; break ; case 82 : /* cDefault */ pFont -> usFontStyle &= FONT_HIDDEN ; pFont -> ucFontColor = FONT_COLOR_DEFAULT ; break ; case 83 : /* cPlain */ DBG_MSG ( \"83: cPlain\" ) ; vFillFontFromStylesheet ( usIstd , pFont ) ; break ; case 85 : /* fBold */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; switch ( ucTmp ) { case 0 : /* Unset */ pFont -> usFontStyle &= ~ FONT_BOLD ; break ; case 1 : /* Set */ pFont -> usFontStyle |= FONT_BOLD ; break ; case 128 : /* Unchanged */ break ; case 129 : /* Negation */ pFont -> usFontStyle ^= FONT_BOLD ; break ; default : DBG_DEC ( ucTmp ) ; DBG_FIXME ( ) ; break ; } break ; case 86 : /* fItalic */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; switch ( ucTmp ) { case 0 : /* Unset */ pFont -> usFontStyle &= ~ FONT_ITALIC ; break ; case 1 : /* Set */ pFont -> usFontStyle |= FONT_ITALIC ; break ; case 128 : /* Unchanged */ break ; case 129 : /* Negation */ pFont -> usFontStyle ^= FONT_ITALIC ; break ; default : DBG_DEC ( ucTmp ) ; DBG_FIXME ( ) ; break ; } break ; case 87 : /* fStrike */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; switch ( ucTmp ) { case 0 : /* Unset */ pFont -> usFontStyle &= ~ FONT_STRIKE ; break ; case 1 : /* Set */ pFont -> usFontStyle |= FONT_STRIKE ; break ; case 128 : /* Unchanged */ break ; case 129 : /* Negation */ pFont -> usFontStyle ^= FONT_STRIKE ; break ; default : DBG_DEC ( ucTmp ) ; DBG_FIXME ( ) ; break ; } break ; case 90 : /* fSmallCaps */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; switch ( ucTmp ) { case 0 : /* Unset */ pFont -> usFontStyle &= ~ FONT_SMALL_CAPITALS ; break ; case 1 : /* Set */ pFont -> usFontStyle |= FONT_SMALL_CAPITALS ; break ; case 128 : /* Unchanged */ break ; case 129 : /* Negation */ pFont -> usFontStyle ^= FONT_SMALL_CAPITALS ; break ; default : DBG_DEC ( ucTmp ) ; DBG_FIXME ( ) ; break ; } break ; case 91 : /* fCaps */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; switch ( ucTmp ) { case 0 : /* Unset */ pFont -> usFontStyle &= ~ FONT_CAPITALS ; break ; case 1 : /* Set */ pFont -> usFontStyle |= FONT_CAPITALS ; break ; case 128 : /* Unchanged */ break ; case 129 : /* Negation */ pFont -> usFontStyle ^= FONT_CAPITALS ; break ; default : DBG_DEC ( ucTmp ) ; DBG_FIXME ( ) ; break ; } break ; case 92 : /* fVanish */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; switch ( ucTmp ) { case 0 : /* Unset */ pFont -> usFontStyle &= ~ FONT_HIDDEN ; break ; case 1 : /* Set */ pFont -> usFontStyle |= FONT_HIDDEN ; break ; case 128 : /* Unchanged */ break ; case 129 : /* Negation */ pFont -> usFontStyle ^= FONT_HIDDEN ; break ; default : DBG_DEC ( ucTmp ) ; DBG_FIXME ( ) ; break ; } break ; case 93 : /* cFtc */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; if ( usTmp <= ( USHORT ) UCHAR_MAX ) { pFont -> ucFontNumber = ( UCHAR ) usTmp ; } else { DBG_DEC ( usTmp ) ; DBG_FIXME ( ) ; pFont -> ucFontNumber = 0 ; } break ; case 94 : /* cKul */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; if ( ucTmp == 0 || ucTmp == 5 ) { pFont -> usFontStyle &= ~ FONT_UNDERLINE ; } else { NO_DBG_MSG ( \"Underline text\" ) ; pFont -> usFontStyle |= FONT_UNDERLINE ; if ( ucTmp == 6 ) { DBG_MSG ( \"Bold text\" ) ; pFont -> usFontStyle |= FONT_BOLD ; } } break ; case 95 : /* cHps, cHpsPos */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; DBG_DEC ( ucTmp ) ; if ( ucTmp != 0 ) { pFont -> usFontSize = ( USHORT ) ucTmp ; } ucTmp = ucGetByte ( iFodo + iFodoOff + 2 , aucGrpprl ) ; DBG_DEC ( ucTmp ) ; break ; case 98 : /* cIco */ pFont -> ucFontColor = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; break ; case 99 : /* cHps */ pFont -> usFontSize = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; break ; case 100 : /* cHpsInc */ DBG_MSG ( \"100: sprmCHpsInc\" ) ; ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; DBG_DEC ( ucTmp ) ; break ; case 103 : /* cMajority */ DBG_MSG ( \"103: sprmCMajority\" ) ; break ; case 104 : /* cIss */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; ucTmp &= 0x07 ; if ( ucTmp == 1 ) { pFont -> usFontStyle |= FONT_SUPERSCRIPT ; NO_DBG_MSG ( \"Superscript\" ) ; } else if ( ucTmp == 2 ) { pFont -> usFontStyle |= FONT_SUBSCRIPT ; NO_DBG_MSG ( \"Subscript\" ) ; } break ; case 106 : /* cHpsInc1 */ usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; lTmp = ( long ) pFont -> usFontSize + ( long ) usTmp ; if ( lTmp < 8 ) { pFont -> usFontSize = 8 ; } else if ( lTmp > 32766 ) { pFont -> usFontSize = 32766 ; } else { pFont -> usFontSize = ( USHORT ) lTmp ; } break ; case 108 : /* cMajority50 */ DBG_MSG ( \"108: sprmCMajority50\" ) ; break ; case 109 : /* cHpsMul */ DBG_MSG ( \"109: sprmCHpsMul\" ) ; usTmp = usGetWord ( iFodo + iFodoOff + 1 , aucGrpprl ) ; DBG_DEC ( usTmp ) ; break ; default : break ; } iInfoLen = iGet6InfoLength ( iFodo + iFodoOff , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; iFodoOff += iInfoLen ; } }",
    "resources/antiword/prop6.c@bGet6PicInfo": "static BOOL bGet6PicInfo ( int iFodo , const UCHAR * aucGrpprl , int iBytes , picture_block_type * pPicture ) { int iFodoOff , iInfoLen ; BOOL bFound ; UCHAR ucTmp ; TRACE_MSG ( \"vGet6PicInfo\" ) ; fail ( iFodo < 0 || aucGrpprl == NULL || pPicture == NULL ) ; iFodoOff = 0 ; bFound = FALSE ; while ( iBytes >= iFodoOff + 1 ) { switch ( ucGetByte ( iFodo + iFodoOff , aucGrpprl ) ) { case 68 : /* fcPic */ pPicture -> ulPictureOffset = ulGetLong ( iFodo + iFodoOff + 2 , aucGrpprl ) ; bFound = TRUE ; break ; # if 0 case 71 : /* fData */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; if ( ucTmp == 0x01 ) { /* Not a picture, but a form field */ return FALSE ; } DBG_DEC_C ( ucTmp != 0 , ucTmp ) ; break ; # endif case 75 : /* fOle2 */ ucTmp = ucGetByte ( iFodo + iFodoOff + 1 , aucGrpprl ) ; if ( ucTmp == 0x01 ) { /* Not a picture, but an OLE object */ return FALSE ; } DBG_DEC_C ( ucTmp != 0 , ucTmp ) ; break ; default : break ; } iInfoLen = iGet6InfoLength ( iFodo + iFodoOff , aucGrpprl ) ; fail ( iInfoLen <= 0 ) ; iFodoOff += iInfoLen ; } return bFound ; }",
    "resources/antiword/prop6.c@vGet6ChrInfo": "void vGet6ChrInfo ( FILE * pFile , ULONG ulStartBlock , const ULONG * aulBBD , size_t tBBDLen , const UCHAR * aucHeader ) { font_block_type tFont ; picture_block_type tPicture ; USHORT * ausCharPage ; UCHAR * aucBuffer ; ULONG ulFileOffset , ulCharPos , ulBeginCharInfo ; size_t tCharInfoLen , tOffset , tSize , tLenOld , tLen , tCharPageNum ; size_t tIndex , tIndex2 , tRun ; int iFodo , iLen ; USHORT usCharFirstPage , usCount , usIstd ; UCHAR aucFpage [ BIG_BLOCK_SIZE ] ; fail ( pFile == NULL || aucHeader == NULL ) ; fail ( ulStartBlock > MAX_BLOCKNUMBER && ulStartBlock != END_OF_CHAIN ) ; fail ( aulBBD == NULL ) ; ulBeginCharInfo = ulGetLong ( 0xb8 , aucHeader ) ; /* fcPlcfbteChpx */ NO_DBG_HEX ( lBeginCharInfo ) ; tCharInfoLen = ( size_t ) ulGetLong ( 0xbc , aucHeader ) ; /* lcbPlcfbteChpx */ NO_DBG_DEC ( tCharInfoLen ) ; if ( tCharInfoLen < 4 ) { DBG_DEC ( tCharInfoLen ) ; return ; } aucBuffer = xmalloc ( tCharInfoLen ) ; if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucBuffer , ulBeginCharInfo , tCharInfoLen ) ) { aucBuffer = xfree ( aucBuffer ) ; return ; } tLen = ( tCharInfoLen - 4 ) / 6 ; ausCharPage = xcalloc ( tLen , sizeof ( USHORT ) ) ; for ( tIndex = 0 , tOffset = ( tLen + 1 ) * 4 ; tIndex < tLen ; tIndex ++ , tOffset += 2 ) { ausCharPage [ tIndex ] = usGetWord ( tOffset , aucBuffer ) ; NO_DBG_DEC ( ausCharPage [ tIndex ] ) ; } DBG_HEX ( ulGetLong ( 0 , aucBuffer ) ) ; aucBuffer = xfree ( aucBuffer ) ; tCharPageNum = ( size_t ) usGetWord ( 0x18e , aucHeader ) ; /* cpnBteChp */ DBG_DEC ( tCharPageNum ) ; if ( tLen < tCharPageNum ) { /* Replace CharPage by a longer version */ tLenOld = tLen ; usCharFirstPage = usGetWord ( 0x18a , aucHeader ) ; /* pnChrFirst */ DBG_DEC ( usCharFirstPage ) ; tLen += tCharPageNum - 1 ; tSize = tLen * sizeof ( USHORT ) ; ausCharPage = xrealloc ( ausCharPage , tSize ) ; /* Add new values */ usCount = usCharFirstPage + 1 ; for ( tIndex = tLenOld ; tIndex < tLen ; tIndex ++ ) { ausCharPage [ tIndex ] = usCount ; NO_DBG_DEC ( ausCharPage [ tIndex ] ) ; usCount ++ ; } } for ( tIndex = 0 ; tIndex < tLen ; tIndex ++ ) { if ( ! bReadBuffer ( pFile , ulStartBlock , aulBBD , tBBDLen , BIG_BLOCK_SIZE , aucFpage , ( ULONG ) ausCharPage [ tIndex ] * BIG_BLOCK_SIZE , BIG_BLOCK_SIZE ) ) { break ; } tRun = ( size_t ) ucGetByte ( 0x1ff , aucFpage ) ; NO_DBG_DEC ( tRun ) ; for ( tIndex2 = 0 ; tIndex2 < tRun ; tIndex2 ++ ) { ulCharPos = ulGetLong ( tIndex2 * 4 , aucFpage ) ; ulFileOffset = ulCharPos2FileOffset ( ulCharPos ) ; iFodo = 2 * ( int ) ucGetByte ( ( tRun + 1 ) * 4 + tIndex2 , aucFpage ) ; iLen = ( int ) ucGetByte ( iFodo , aucFpage ) ; usIstd = usGetIstd ( ulFileOffset ) ; vFillFontFromStylesheet ( usIstd , & tFont ) ; if ( iFodo != 0 ) { vGet6FontInfo ( iFodo , usIstd , aucFpage + 1 , iLen - 1 , & tFont ) ; } tFont . ulFileOffset = ulFileOffset ; vAdd2FontInfoList ( & tFont ) ; if ( iFodo <= 0 ) { continue ; } ( void ) memset ( & tPicture , 0 , sizeof ( tPicture ) ) ; if ( bGet6PicInfo ( iFodo , aucFpage + 1 , iLen - 1 , & tPicture ) ) { tPicture . ulFileOffset = ulFileOffset ; tPicture . ulFileOffsetPicture = ulDataPos2FileOffset ( tPicture . ulPictureOffset ) ; vAdd2PictInfoList ( & tPicture ) ; } } } ausCharPage = xfree ( ausCharPage ) ; }",
    "resources/antiword/icons.c@vUpdateIcon": "void vUpdateIcon ( window_handle tWindow , icon_block * pIcon ) { window_redrawblock tRedraw ; BOOL bMore ; tRedraw . window = tWindow ; tRedraw . rect = pIcon -> workarearect ; Error_CheckFatal ( Wimp_UpdateWindow ( & tRedraw , & bMore ) ) ; while ( bMore ) { Error_CheckFatal ( Wimp_PlotIcon ( pIcon ) ) ; Error_CheckFatal ( Wimp_GetRectangle ( & tRedraw , & bMore ) ) ; } }",
    "resources/antiword/icons.c@vUpdateRadioButton": "void vUpdateRadioButton ( window_handle tWindow , icon_handle tIconNumber , BOOL bSelected ) { icon_block tIcon ; Error_CheckFatal ( Wimp_GetIconState ( tWindow , tIconNumber , & tIcon ) ) ; DBG_DEC ( tIconNumber ) ; DBG_HEX ( tIcon . flags . data . selected ) ; if ( bSelected == ( tIcon . flags . data . selected == 1 ) ) { /* No update needed */ return ; } Error_CheckFatal ( Wimp_SetIconState ( tWindow , tIconNumber , bSelected ? 0x00200000 : 0 , 0x00200000 ) ) ; vUpdateIcon ( tWindow , & tIcon ) ; }",
    "resources/antiword/icons.c@vUpdateWriteable": "void vUpdateWriteable ( window_handle tWindow , icon_handle tIconNumber , const char * szString ) { icon_block tIcon ; caret_block tCaret ; int iLen ; fail ( szString == NULL ) ; NO_DBG_DEC ( tIconNumber ) ; NO_DBG_MSG ( szString ) ; Error_CheckFatal ( Wimp_GetIconState ( tWindow , tIconNumber , & tIcon ) ) ; NO_DBG_HEX ( tIcon . flags ) ; if ( ! tIcon . flags . data . text || ! tIcon . flags . data . indirected ) { werr ( 1 , \"Icon %d must be indirected text\" , ( int ) tIconNumber ) ; return ; } strncpy ( tIcon . data . indirecttext . buffer , szString , tIcon . data . indirecttext . bufflen - 1 ) ; /* Ensure the caret is behind the last character of the text */ Error_CheckFatal ( Wimp_GetCaretPosition ( & tCaret ) ) ; if ( tCaret . window == tWindow && tCaret . icon == tIconNumber ) { iLen = strlen ( tIcon . data . indirecttext . buffer ) ; if ( tCaret . index != iLen ) { tCaret . index = iLen ; Error_CheckFatal ( Wimp_SetCaretPosition ( & tCaret ) ) ; } } Error_CheckFatal ( Wimp_SetIconState ( tWindow , tIconNumber , 0 , 0 ) ) ; vUpdateIcon ( tWindow , & tIcon ) ; }",
    "resources/antiword/icons.c@vUpdateWriteableNumber": "void vUpdateWriteableNumber ( window_handle tWindow , icon_handle tIconNumber , int iNumber ) { char szTmp [ 1 + 3 * sizeof ( int ) + 1 ] ; ( void ) sprintf ( szTmp , \"%d\" , iNumber ) ; vUpdateWriteable ( tWindow , tIconNumber , szTmp ) ; }",
    "resources/antiword/misc.c@szGetHomeDirectory": "const char * szGetHomeDirectory ( void ) { const char * szHome ; # if defined ( __vms ) szHome = decc$translate_vms ( getenv ( \"HOME\" ) ) ; # elif defined ( __Plan9__ ) szHome = getenv ( \"home\" ) ; # else szHome = getenv ( \"HOME\" ) ; # endif /* __vms */ if ( szHome == NULL || szHome [ 0 ] == '\\0' ) { # if defined ( N_PLAT_NLM ) szHome = \"SYS:\" ; # elif defined ( __dos ) szHome = \"C:\" ; # else werr ( 0 , \"I can't find the name of your HOME directory\" ) ; szHome = \"\" ; # endif /* __dos */ } return szHome ; }",
    "resources/antiword/misc.c@szGetAntiwordDirectory": "const char * szGetAntiwordDirectory ( void ) { # if defined ( __vms ) return decc$translate_vms ( getenv ( \"ANTIWORDHOME\" ) ) ; # else return getenv ( \"ANTIWORDHOME\" ) ; # endif /* __vms */ }",
    "resources/antiword/misc.c@lGetFilesize": "long lGetFilesize ( const char * szFilename ) { # if defined ( __riscos ) os_error * e ; int iType , iSize ; e = SWI ( 2 , 5 , SWI_OS_File | XOS_Bit , 17 , szFilename , & iType , NULL , NULL , NULL , & iSize ) ; if ( e != NULL ) { werr ( 0 , \"Get Filesize error %d: %s\" , e -> errnum , e -> errmess ) ; return - 1 ; } if ( iType != 1 ) { /* It's not a proper file or the file does not exist */ return - 1 ; } return ( long ) iSize ; # else struct stat tBuffer ; errno = 0 ; if ( stat ( szFilename , & tBuffer ) != 0 ) { werr ( 0 , \"Get Filesize error %d\" , errno ) ; return - 1 ; } if ( ! S_ISREG ( tBuffer . st_mode ) ) { /* It's not a regular file */ return - 1 ; } return ( long ) tBuffer . st_size ; # endif /* __riscos */ }",
    "resources/antiword/misc.c@bReadBytes": "",
    "resources/antiword/misc.c@bReadBuffer": "",
    "resources/antiword/misc.c@ulColor2Color": "ULONG ulColor2Color ( UCHAR ucFontColor ) { static const ULONG aulColorTable [ ] = { /*  0 */ 0x00000000UL , /* Automatic */ /*  1 */ 0x00000000UL , /* Black */ /*  2 */ 0xff000000UL , /* Blue */ /*  3 */ 0xffff0000UL , /* Turquoise */ /*  4 */ 0x00ff0000UL , /* Bright Green */ /*  5 */ 0xff00ff00UL , /* Pink */ /*  6 */ 0x0000ff00UL , /* Red */ /*  7 */ 0x00ffff00UL , /* Yellow */ /*  8 */ 0xffffff00UL , /* White */ /*  9 */ 0x80000000UL , /* Dark Blue */ /* 10 */ 0x80800000UL , /* Teal */ /* 11 */ 0x00800000UL , /* Green */ /* 12 */ 0x80008000UL , /* Violet */ /* 13 */ 0x00008000UL , /* Dark Red */ /* 14 */ 0x00808000UL , /* Dark Yellow */ /* 15 */ 0x80808000UL , /* Gray 50% */ /* 16 */ 0xc0c0c000UL , /* Gray 25% */ } ; if ( ( size_t ) ucFontColor >= elementsof ( aulColorTable ) ) { return aulColorTable [ 0 ] ; } return aulColorTable [ ( int ) ucFontColor ] ; }",
    "resources/antiword/misc.c@iFindSplit": "static int iFindSplit ( const char * szString , size_t tStringLen ) { size_t tSplit ; if ( tStringLen == 0 ) { return - 1 ; } tSplit = tStringLen - 1 ; while ( tSplit >= 1 ) { if ( szString [ tSplit ] == ' ' || ( szString [ tSplit ] == '-' && szString [ tSplit - 1 ] != ' ' ) ) { return ( int ) tSplit ; } tSplit -- ; } return - 1 ; }",
    "resources/antiword/misc.c@pSplitList": "output_type * pSplitList ( output_type * pAnchor ) { output_type * pCurr , * pLeftOver ; int iIndex ; fail ( pAnchor == NULL ) ; for ( pCurr = pAnchor ; pCurr -> pNext != NULL ; pCurr = pCurr -> pNext ) ; /* EMPTY */ iIndex = - 1 ; for ( ; pCurr != NULL ; pCurr = pCurr -> pPrev ) { iIndex = iFindSplit ( pCurr -> szStorage , pCurr -> tNextFree ) ; if ( iIndex >= 0 ) { break ; } } if ( pCurr == NULL || iIndex < 0 ) { /* No split, no leftover */ return NULL ; } /* Split over the iIndex-th character */ NO_DBG_MSG ( \"pLeftOver\" ) ; pLeftOver = xmalloc ( sizeof ( * pLeftOver ) ) ; fail ( pCurr -> tNextFree < ( size_t ) iIndex ) ; pLeftOver -> tStorageSize = pCurr -> tNextFree - ( size_t ) iIndex ; pLeftOver -> szStorage = xmalloc ( pLeftOver -> tStorageSize ) ; pLeftOver -> tNextFree = pCurr -> tNextFree - ( size_t ) iIndex - 1 ; ( void ) strncpy ( pLeftOver -> szStorage , pCurr -> szStorage + iIndex + 1 , pLeftOver -> tNextFree ) ; pLeftOver -> szStorage [ pLeftOver -> tNextFree ] = '\\0' ; NO_DBG_MSG ( pLeftOver -> szStorage ) ; pLeftOver -> ucFontColor = pCurr -> ucFontColor ; pLeftOver -> usFontStyle = pCurr -> usFontStyle ; pLeftOver -> tFontRef = pCurr -> tFontRef ; pLeftOver -> usFontSize = pCurr -> usFontSize ; pLeftOver -> lStringWidth = lComputeStringWidth ( pLeftOver -> szStorage , pLeftOver -> tNextFree , pLeftOver -> tFontRef , pLeftOver -> usFontSize ) ; pLeftOver -> pPrev = NULL ; pLeftOver -> pNext = pCurr -> pNext ; if ( pLeftOver -> pNext != NULL ) { pLeftOver -> pNext -> pPrev = pLeftOver ; } fail ( ! bCheckDoubleLinkedList ( pLeftOver ) ) ; NO_DBG_MSG ( \"pAnchor\" ) ; NO_DBG_HEX ( pCurr -> szStorage [ iIndex ] ) ; while ( iIndex >= 0 && isspace ( ( int ) ( UCHAR ) pCurr -> szStorage [ iIndex ] ) ) { iIndex -- ; } pCurr -> tNextFree = ( size_t ) iIndex + 1 ; pCurr -> szStorage [ pCurr -> tNextFree ] = '\\0' ; NO_DBG_MSG ( pCurr -> szStorage ) ; pCurr -> lStringWidth = lComputeStringWidth ( pCurr -> szStorage , pCurr -> tNextFree , pCurr -> tFontRef , pCurr -> usFontSize ) ; pCurr -> pNext = NULL ; fail ( ! bCheckDoubleLinkedList ( pAnchor ) ) ; return pLeftOver ; }",
    "resources/antiword/misc.c@tNumber2Roman": "size_t tNumber2Roman ( UINT uiNumber , BOOL bUpperCase , char * szOutput ) { char * outp , * p , * q ; UINT uiNextVal , uiValue ; fail ( szOutput == NULL ) ; uiNumber %= 4000 ; /* Very high numbers can't be represented */ if ( uiNumber == 0 ) { szOutput [ 0 ] = '\\0' ; return 0 ; } outp = szOutput ; p = bUpperCase ? \"M\\2D\\5C\\2L\\5X\\2V\\5I\" : \"m\\2d\\5c\\2l\\5x\\2v\\5i\" ; uiValue = 1000 ; for ( ; ; ) { while ( uiNumber >= uiValue ) { * outp ++ = * p ; uiNumber -= uiValue ; } if ( uiNumber == 0 ) { * outp = '\\0' ; fail ( outp < szOutput ) ; return ( size_t ) ( outp - szOutput ) ; } q = p + 1 ; uiNextVal = uiValue / ( UINT ) ( UCHAR ) * q ; if ( ( int ) * q == 2 ) { /* magic */ uiNextVal /= ( UINT ) ( UCHAR ) * ( q += 2 ) ; } if ( uiNumber + uiNextVal >= uiValue ) { * outp ++ = * ++ q ; uiNumber += uiNextVal ; } else { p ++ ; uiValue /= ( UINT ) ( UCHAR ) ( * p ++ ) ; } } }",
    "resources/antiword/misc.c@tNumber2Alpha": "size_t tNumber2Alpha ( UINT uiNumber , BOOL bUpperCase , char * szOutput ) { char * outp ; UINT uiTmp ; fail ( szOutput == NULL ) ; if ( uiNumber == 0 ) { szOutput [ 0 ] = '\\0' ; return 0 ; } outp = szOutput ; uiTmp = ( UINT ) ( bUpperCase ? 'A' : 'a' ) ; if ( uiNumber <= 26 ) { uiNumber -= 1 ; * outp ++ = ( char ) ( uiTmp + uiNumber ) ; } else if ( uiNumber <= 26U + 26U * 26U ) { uiNumber -= 26 + 1 ; * outp ++ = ( char ) ( uiTmp + uiNumber / 26 ) ; * outp ++ = ( char ) ( uiTmp + uiNumber % 26 ) ; } else if ( uiNumber <= 26U + 26U * 26U + 26U * 26U * 26U ) { uiNumber -= 26 + 26 * 26 + 1 ; * outp ++ = ( char ) ( uiTmp + uiNumber / ( 26 * 26 ) ) ; * outp ++ = ( char ) ( uiTmp + uiNumber / 26 % 26 ) ; * outp ++ = ( char ) ( uiTmp + uiNumber % 26 ) ; } * outp = '\\0' ; fail ( outp < szOutput ) ; return ( size_t ) ( outp - szOutput ) ; }",
    "resources/antiword/misc.c@unincpy": "char * unincpy ( char * s1 , const UCHAR * s2 , size_t n ) { char * pcDest ; ULONG ulChar ; size_t tLen ; USHORT usUni ; for ( pcDest = s1 , tLen = 0 ; tLen < n ; pcDest ++ , tLen ++ ) { usUni = usGetWord ( tLen * 2 , s2 ) ; if ( usUni == 0 ) { break ; } ulChar = ulTranslateCharacters ( usUni , 0 , 8 , conversion_unknown , encoding_neutral , FALSE ) ; if ( ulChar == IGNORE_CHARACTER ) { ulChar = ( ULONG ) '?' ; } * pcDest = ( char ) ulChar ; } for ( ; tLen < n ; tLen ++ ) { * pcDest ++ = '\\0' ; } return s1 ; }",
    "resources/antiword/misc.c@unilen": "size_t unilen ( const UCHAR * s ) { size_t tLen ; USHORT usUni ; tLen = 0 ; for ( ; ; ) { usUni = usGetWord ( tLen , s ) ; if ( usUni == 0 ) { return tLen ; } tLen += 2 ; } }",
    "resources/antiword/misc.c@szBasename": "const char * szBasename ( const char * szFilename ) { const char * szTmp ; fail ( szFilename == NULL ) ; if ( szFilename == NULL || szFilename [ 0 ] == '\\0' ) { return \"null\" ; } szTmp = strrchr ( szFilename , FILE_SEPARATOR [ 0 ] ) ; if ( szTmp == NULL ) { return szFilename ; } return ++ szTmp ; }",
    "resources/antiword/misc.c@lComputeLeading": "long lComputeLeading ( USHORT usFontSize ) { long lLeading ; lLeading = ( long ) usFontSize * 500L ; if ( usFontSize < 18 ) { /* Small text: 112% */ lLeading *= 112 ; } else if ( usFontSize < 28 ) { /* Normal text: 124% */ lLeading *= 124 ; } else if ( usFontSize < 48 ) { /* Small headlines: 104% */ lLeading *= 104 ; } else { /* Large headlines: 100% */ lLeading *= 100 ; } lLeading = lMilliPoints2DrawUnits ( lLeading ) ; lLeading += 50 ; lLeading /= 100 ; return lLeading ; }",
    "resources/antiword/misc.c@tUcs2Utf8": "size_t tUcs2Utf8 ( ULONG ulChar , char * szResult , size_t tMaxResultLen ) { if ( szResult == NULL || tMaxResultLen == 0 ) { return 0 ; } if ( ulChar < 0x80 && tMaxResultLen >= 2 ) { szResult [ 0 ] = ( char ) ulChar ; szResult [ 1 ] = '\\0' ; return 1 ; } if ( ulChar < 0x800 && tMaxResultLen >= 3 ) { szResult [ 0 ] = ( char ) ( 0xc0 | ulChar >> 6 ) ; szResult [ 1 ] = ( char ) ( 0x80 | ( ulChar & 0x3f ) ) ; szResult [ 2 ] = '\\0' ; return 2 ; } if ( ulChar < 0x10000 && tMaxResultLen >= 4 ) { szResult [ 0 ] = ( char ) ( 0xe0 | ulChar >> 12 ) ; szResult [ 1 ] = ( char ) ( 0x80 | ( ulChar >> 6 & 0x3f ) ) ; szResult [ 2 ] = ( char ) ( 0x80 | ( ulChar & 0x3f ) ) ; szResult [ 3 ] = '\\0' ; return 3 ; } if ( ulChar < 0x200000 && tMaxResultLen >= 5 ) { szResult [ 0 ] = ( char ) ( 0xf0 | ulChar >> 18 ) ; szResult [ 1 ] = ( char ) ( 0x80 | ( ulChar >> 12 & 0x3f ) ) ; szResult [ 2 ] = ( char ) ( 0x80 | ( ulChar >> 6 & 0x3f ) ) ; szResult [ 3 ] = ( char ) ( 0x80 | ( ulChar & 0x3f ) ) ; szResult [ 4 ] = '\\0' ; return 4 ; } szResult [ 0 ] = '\\0' ; return 0 ; }",
    "resources/antiword/misc.c@vGetBulletValue": "void vGetBulletValue ( conversion_type eConversionType , encoding_type eEncoding , char * szResult , size_t tMaxResultLen ) { fail ( szResult == NULL ) ; fail ( tMaxResultLen < 2 ) ; if ( eEncoding == encoding_utf_8 ) { ( void ) tUcs2Utf8 ( UNICODE_BULLET , szResult , tMaxResultLen ) ; } else { szResult [ 0 ] = ( char ) ucGetBulletCharacter ( eConversionType , eEncoding ) ; szResult [ 1 ] = '\\0' ; } }",
    "resources/antiword/misc.c@bAllZero": "",
    "resources/antiword/misc.c@bGetCodesetFromLocale": "static BOOL bGetCodesetFromLocale ( char * szCodeset , size_t tMaxCodesetLength , BOOL * pbEuro ) { # if ! defined ( __dos ) const char * szLocale ; const char * pcTmp ; size_t tIndex ; char szModifier [ 6 ] ; # endif /* __dos */ if ( pbEuro != NULL ) { * pbEuro = FALSE ; /* Until proven otherwise */ } if ( szCodeset == NULL || tMaxCodesetLength == 0 ) { return FALSE ; } # if defined ( __dos ) if ( tMaxCodesetLength < 2 + sizeof ( int ) * 3 + 1 ) { DBG_DEC ( tMaxCodesetLength ) ; DBG_DEC ( 2 + sizeof ( int ) * 3 + 1 ) ; return FALSE ; } /* Get the active codepage from DOS */ sprintf ( szCodeset , \"cp%d\" , iGetCodepage ( ) ) ; DBG_MSG ( szCodeset ) ; # else /* Get the locale from the environment */ szLocale = getenv ( \"LC_ALL\" ) ; if ( szLocale == NULL || szLocale [ 0 ] == '\\0' ) { szLocale = getenv ( \"LC_CTYPE\" ) ; if ( szLocale == NULL || szLocale [ 0 ] == '\\0' ) { szLocale = getenv ( \"LANG\" ) ; } } if ( szLocale == NULL || szLocale [ 0 ] == '\\0' ) { /* No locale, so no codeset name and no modifier */ return FALSE ; } DBG_MSG ( szLocale ) ; pcTmp = strchr ( szLocale , '.' ) ; if ( pcTmp == NULL ) { /* No codeset name */ szCodeset [ 0 ] = '\\0' ; } else { /* Copy the codeset name */ pcTmp ++ ; for ( tIndex = 0 ; tIndex < tMaxCodesetLength ; tIndex ++ ) { if ( * pcTmp == '@' || * pcTmp == '+' || * pcTmp == ',' || * pcTmp == '_' || * pcTmp == '\\0' ) { szCodeset [ tIndex ] = '\\0' ; break ; } szCodeset [ tIndex ] = * pcTmp ; pcTmp ++ ; } szCodeset [ tMaxCodesetLength - 1 ] = '\\0' ; } if ( pbEuro == NULL ) { /* No need to get the modifier */ return TRUE ; } pcTmp = strchr ( szLocale , '@' ) ; if ( pcTmp != NULL ) { /* Copy the modifier */ pcTmp ++ ; for ( tIndex = 0 ; tIndex < sizeof ( szModifier ) ; tIndex ++ ) { if ( * pcTmp == '+' || * pcTmp == ',' || * pcTmp == '_' || * pcTmp == '\\0' ) { szModifier [ tIndex ] = '\\0' ; break ; } szModifier [ tIndex ] = * pcTmp ; pcTmp ++ ; } szModifier [ sizeof ( szModifier ) - 1 ] = '\\0' ; * pbEuro = STRCEQ ( szModifier , \"Euro\" ) ; } # endif /* __dos */ return TRUE ; }",
    "resources/antiword/misc.c@bGetNormalizedCodeset": "",
    "resources/antiword/misc.c@szGetDefaultMappingFile": "const char * szGetDefaultMappingFile ( void ) { static const struct { const char * szCodeset ; const char * szMappingFile ; } atMappingFile [ ] = { { \"iso88591\" , MAPPING_FILE_8859_1 } , { \"iso88592\" , MAPPING_FILE_8859_2 } , { \"iso88593\" , \"8859-3.txt\" } , { \"iso88594\" , \"8859-4.txt\" } , { \"iso88595\" , \"8859-5.txt\" } , { \"iso88596\" , MAPPING_FILE_8859_5 } , { \"iso88597\" , \"8859-7.txt\" } , { \"iso88598\" , \"8859-8.txt\" } , { \"iso88599\" , \"8859-9.txt\" } , { \"iso885910\" , \"8859-10.txt\" } , { \"iso885913\" , \"8859-13.txt\" } , { \"iso885914\" , \"8859-14.txt\" } , { \"iso885915\" , MAPPING_FILE_8859_15 } , { \"iso885916\" , \"8859-16.txt\" } , { \"koi8r\" , MAPPING_FILE_KOI8_R } , { \"koi8u\" , MAPPING_FILE_KOI8_U } , { \"utf8\" , MAPPING_FILE_UTF_8 } , { \"cp437\" , MAPPING_FILE_CP437 } , { \"cp850\" , \"cp850.txt\" } , { \"cp852\" , MAPPING_FILE_CP852 } , { \"cp862\" , \"cp862.txt\" } , { \"cp864\" , \"cp864.txt\" } , { \"cp866\" , MAPPING_FILE_CP866 } , { \"cp1250\" , MAPPING_FILE_CP1250 } , { \"cp1251\" , MAPPING_FILE_CP1251 } , { \"cp1252\" , \"cp1252.txt\" } , } ; size_t tIndex ; BOOL bEuro ; char szCodeset [ 20 ] ; szCodeset [ 0 ] = '\\0' ; bEuro = FALSE ; /* Get the normalized codeset name */ if ( ! bGetNormalizedCodeset ( szCodeset , sizeof ( szCodeset ) , & bEuro ) ) { return MAPPING_FILE_8859_1 ; } if ( szCodeset [ 0 ] == '\\0' ) { if ( bEuro ) { /* Default mapping file (with Euro sign) */ return MAPPING_FILE_8859_15 ; } else { /* Default mapping file (without Euro sign) */ return MAPPING_FILE_8859_1 ; } } /* Find the name in the table */ for ( tIndex = 0 ; tIndex < elementsof ( atMappingFile ) ; tIndex ++ ) { if ( STREQ ( atMappingFile [ tIndex ] . szCodeset , szCodeset ) ) { return atMappingFile [ tIndex ] . szMappingFile ; } } /* Default default mapping file */ # if defined ( __dos ) return MAPPING_FILE_CP437 ; # else return MAPPING_FILE_8859_1 ; # endif /* __dos */ }",
    "resources/antiword/misc.c@tConvertDTTM": "time_t tConvertDTTM ( ULONG ulDTTM ) { struct tm tTime ; time_t tResult ; if ( ulDTTM == 0 ) { return ( time_t ) - 1 ; } memset ( & tTime , 0 , sizeof ( tTime ) ) ; tTime . tm_min = ( int ) ( ulDTTM & 0x0000003f ) ; tTime . tm_hour = ( int ) ( ( ulDTTM & 0x000007c0 ) >> 6 ) ; tTime . tm_mday = ( int ) ( ( ulDTTM & 0x0000f800 ) >> 11 ) ; tTime . tm_mon = ( int ) ( ( ulDTTM & 0x000f0000 ) >> 16 ) ; tTime . tm_year = ( int ) ( ( ulDTTM & 0x1ff00000 ) >> 20 ) ; tTime . tm_isdst = - 1 ; tTime . tm_mon -- ; /* From 01-12 to 00-11 */ tResult = mktime ( & tTime ) ; NO_DBG_MSG ( ctime ( & tResult ) ) ; return tResult ; }",
    "resources/antiword/listlist.c@vDestroyListInfoList": "void vDestroyListInfoList ( void ) { list_desc_type * pCurr , * pNext ; list_value_type * pValueCurr , * pValueNext ; DBG_MSG ( \"vDestroyListInfoList\" ) ; /* Free the LFO list */ usLfoLen = 0 ; aulLfoList = xfree ( aulLfoList ) ; /* Free the List Information List */ pCurr = pAnchor ; while ( pCurr != NULL ) { pNext = pCurr -> pNext ; pCurr = xfree ( pCurr ) ; pCurr = pNext ; } pAnchor = NULL ; /* Reset all control variables */ pBlockLast = NULL ; /* Free the values list */ pValueCurr = pValues ; while ( pValueCurr != NULL ) { pValueNext = pValueCurr -> pNext ; pValueCurr = xfree ( pValueCurr ) ; pValueCurr = pValueNext ; } pValues = NULL ; /* Reset the values for the old lists */ iOldListSeqNumber = 0 ; usOldListValue = 0 ; }",
    "resources/antiword/listlist.c@vBuildLfoList": "void vBuildLfoList ( const UCHAR * aucBuffer , size_t tBufLen ) { size_t tRecords ; int iIndex ; fail ( aucBuffer == NULL ) ; if ( tBufLen < 4 ) { return ; } tRecords = ( size_t ) ulGetLong ( 0 , aucBuffer ) ; NO_DBG_DEC ( tRecords ) ; if ( 4 + 16 * tRecords > tBufLen || tRecords >= 0x7fff ) { /* Just a sanity check */ DBG_DEC ( tRecords ) ; DBG_DEC ( 4 + 16 * tRecords ) ; DBG_DEC ( tBufLen ) ; return ; } aulLfoList = xcalloc ( tRecords , sizeof ( ULONG ) ) ; for ( iIndex = 0 ; iIndex < ( int ) tRecords ; iIndex ++ ) { aulLfoList [ iIndex ] = ulGetLong ( 4 + 16 * iIndex , aucBuffer ) ; NO_DBG_HEX ( aulLfoList [ iIndex ] ) ; } usLfoLen = ( USHORT ) tRecords ; }",
    "resources/antiword/listlist.c@vAdd2ListInfoList": "void vAdd2ListInfoList ( ULONG ulListID , USHORT usIstd , UCHAR ucListLevel , const list_block_type * pListBlock ) { list_desc_type * pListMember ; fail ( pListBlock == NULL ) ; NO_DBG_HEX ( ulListID ) ; NO_DBG_DEC ( usIstd ) ; NO_DBG_DEC ( ucListLevel ) ; NO_DBG_DEC ( pListBlock -> ulStartAt ) ; NO_DBG_DEC ( pListBlock -> bNoRestart ) ; NO_DBG_DEC ( pListBlock -> sLeftIndent ) ; NO_DBG_HEX ( pListBlock -> ucNFC ) ; NO_DBG_HEX ( pListBlock -> usListChar ) ; /* Create list member */ pListMember = xmalloc ( sizeof ( list_desc_type ) ) ; /* Fill the list member */ pListMember -> tInfo = * pListBlock ; pListMember -> ulListID = ulListID ; pListMember -> usIstd = usIstd ; pListMember -> ucListLevel = ucListLevel ; pListMember -> pNext = NULL ; /* Correct the values where needed */ if ( pListMember -> tInfo . ulStartAt > 0xffff ) { DBG_DEC ( pListMember -> tInfo . ulStartAt ) ; pListMember -> tInfo . ulStartAt = 1 ; } /* Add the new member to the list */ if ( pAnchor == NULL ) { pAnchor = pListMember ; } else { fail ( pBlockLast == NULL ) ; pBlockLast -> pNext = pListMember ; } pBlockLast = pListMember ; }",
    "resources/antiword/listlist.c@pGetListInfo": "const list_block_type * pGetListInfo ( USHORT usListIndex , UCHAR ucListLevel ) { list_desc_type * pCurr ; list_block_type * pNearMatch ; ULONG ulListID ; if ( usListIndex == 0 ) { return NULL ; } if ( usListIndex - 1 >= usLfoLen || ucListLevel > 8 ) { DBG_DEC ( usListIndex ) ; DBG_DEC ( ucListLevel ) ; return NULL ; } fail ( aulLfoList == NULL ) ; ulListID = aulLfoList [ usListIndex - 1 ] ; NO_DBG_HEX ( ulListID ) ; pNearMatch = NULL ; for ( pCurr = pAnchor ; pCurr != NULL ; pCurr = pCurr -> pNext ) { if ( pCurr -> ulListID != ulListID ) { /* No match */ continue ; } if ( pCurr -> ucListLevel == ucListLevel ) { /* Exact match */ return & pCurr -> tInfo ; } if ( pCurr -> ucListLevel == 0 ) { /* Near match */ pNearMatch = & pCurr -> tInfo ; } } /* No exact match, use a near match if any */ return pNearMatch ; }",
    "resources/antiword/listlist.c@pGetListInfoByIstd": "const list_block_type * pGetListInfoByIstd ( USHORT usIstd ) { list_desc_type * pCurr ; if ( usIstd == ISTD_INVALID || usIstd == STI_NIL || usIstd == STI_USER ) { return NULL ; } for ( pCurr = pAnchor ; pCurr != NULL ; pCurr = pCurr -> pNext ) { if ( pCurr -> usIstd == usIstd ) { return & pCurr -> tInfo ; } } return NULL ; }",
    "resources/antiword/listlist.c@vRestartListValues": "static void vRestartListValues ( USHORT usListIndex , UCHAR ucListLevel ) { list_value_type * pPrev , * pCurr , * pNext ; int iCounter ; iCounter = 0 ; pPrev = NULL ; pCurr = pValues ; while ( pCurr != NULL ) { if ( pCurr -> usListIndex != usListIndex || pCurr -> ucListLevel <= ucListLevel ) { pPrev = pCurr ; pCurr = pCurr -> pNext ; continue ; } /* Reset the level by deleting the record */ pNext = pCurr -> pNext ; if ( pPrev == NULL ) { pValues = pNext ; } else { pPrev -> pNext = pNext ; } DBG_DEC ( pCurr -> usListIndex ) ; DBG_DEC ( pCurr -> ucListLevel ) ; pCurr = xfree ( pCurr ) ; pCurr = pNext ; iCounter ++ ; } DBG_DEC_C ( iCounter > 0 , iCounter ) ; }",
    "resources/antiword/listlist.c@usGetListValue": "USHORT usGetListValue ( int iListSeqNumber , int iWordVersion , const style_block_type * pStyle ) { list_value_type * pCurr ; USHORT usValue ; fail ( iListSeqNumber < 0 ) ; fail ( iListSeqNumber < iOldListSeqNumber ) ; fail ( iWordVersion < 0 ) ; fail ( pStyle == NULL ) ; if ( iListSeqNumber <= 0 ) { return 0 ; } if ( iWordVersion < 8 ) { /* Old style list */ if ( iListSeqNumber == iOldListSeqNumber || ( iListSeqNumber == iOldListSeqNumber + 1 && eGetNumType ( pStyle -> ucNumLevel ) == level_type_sequence ) ) { if ( ! pStyle -> bNumPause ) { usOldListValue ++ ; } } else { usOldListValue = pStyle -> usStartAt ; } iOldListSeqNumber = iListSeqNumber ; return usOldListValue ; } /* New style list */ if ( pStyle -> usListIndex == 0 || pStyle -> usListIndex - 1 >= usLfoLen || pStyle -> ucListLevel > 8 ) { /* Out of range; no need to search */ return 0 ; } for ( pCurr = pValues ; pCurr != NULL ; pCurr = pCurr -> pNext ) { if ( pCurr -> usListIndex == pStyle -> usListIndex && pCurr -> ucListLevel == pStyle -> ucListLevel ) { /* Record found; increment and return the value */ pCurr -> usValue ++ ; usValue = pCurr -> usValue ; if ( ! pStyle -> bNoRestart ) { vRestartListValues ( pStyle -> usListIndex , pStyle -> ucListLevel ) ; } return usValue ; } } /* Record not found; create it and add it to the front of the list */ pCurr = xmalloc ( sizeof ( list_value_type ) ) ; pCurr -> usValue = pStyle -> usStartAt ; pCurr -> usListIndex = pStyle -> usListIndex ; pCurr -> ucListLevel = pStyle -> ucListLevel ; pCurr -> pNext = pValues ; pValues = pCurr ; usValue = pCurr -> usValue ; if ( ! pStyle -> bNoRestart ) { vRestartListValues ( pStyle -> usListIndex , pStyle -> ucListLevel ) ; } return usValue ; }",
    "resources/antiword/output.c@vPrologue1": "static void vPrologue1 ( diagram_type * pDiag , const char * szTask , const char * szFilename ) { options_type tOptions ; fail ( pDiag == NULL ) ; fail ( szTask == NULL || szTask [ 0 ] == '\\0' ) ; vGetOptions ( & tOptions ) ; eConversionType = tOptions . eConversionType ; eEncoding = tOptions . eEncoding ; switch ( eConversionType ) { case conversion_text : vPrologueTXT ( pDiag , & tOptions ) ; break ; case conversion_fmt_text : vPrologueFMT ( pDiag , & tOptions ) ; break ; case conversion_ps : vProloguePS ( pDiag , szTask , szFilename , & tOptions ) ; break ; case conversion_xml : vPrologueXML ( pDiag , & tOptions ) ; break ; case conversion_pdf : vProloguePDF ( pDiag , szTask , & tOptions ) ; break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@vEpilogue": "static void vEpilogue ( diagram_type * pDiag ) { switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : vEpilogueTXT ( pDiag -> pOutFile ) ; break ; case conversion_ps : vEpiloguePS ( pDiag ) ; break ; case conversion_xml : vEpilogueXML ( pDiag ) ; break ; case conversion_pdf : vEpiloguePDF ( pDiag ) ; break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@vImagePrologue": "void vImagePrologue ( diagram_type * pDiag , const imagedata_type * pImg ) { switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : break ; case conversion_ps : vImageProloguePS ( pDiag , pImg ) ; break ; case conversion_xml : break ; case conversion_pdf : vImageProloguePDF ( pDiag , pImg ) ; break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@vImageEpilogue": "void vImageEpilogue ( diagram_type * pDiag ) { switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : break ; case conversion_ps : vImageEpiloguePS ( pDiag ) ; break ; case conversion_xml : break ; case conversion_pdf : vImageEpiloguePDF ( pDiag ) ; break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@bAddDummyImage": "",
    "resources/antiword/output.c@pCreateDiagram": "diagram_type * pCreateDiagram ( const char * szTask , const char * szFilename ) { diagram_type * pDiag ; fail ( szTask == NULL || szTask [ 0 ] == '\\0' ) ; DBG_MSG ( \"pCreateDiagram\" ) ; /* Get the necessary memory */ pDiag = xmalloc ( sizeof ( diagram_type ) ) ; /* Initialization */ pDiag -> pOutFile = stdout ; vPrologue1 ( pDiag , szTask , szFilename ) ; /* Return success */ return pDiag ; }",
    "resources/antiword/output.c@vDestroyDiagram": "void vDestroyDiagram ( diagram_type * pDiag ) { DBG_MSG ( \"vDestroyDiagram\" ) ; fail ( pDiag == NULL ) ; if ( pDiag == NULL ) { return ; } vEpilogue ( pDiag ) ; pDiag = xfree ( pDiag ) ; }",
    "resources/antiword/output.c@vPrologue2": "void vPrologue2 ( diagram_type * pDiag , int iWordVersion ) { switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : break ; case conversion_ps : vAddFontsPS ( pDiag ) ; break ; case conversion_xml : vCreateBookIntro ( pDiag , iWordVersion ) ; break ; case conversion_pdf : vCreateInfoDictionary ( pDiag , iWordVersion ) ; vAddFontsPDF ( pDiag ) ; break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@vMove2NextLine": "void vMove2NextLine ( diagram_type * pDiag , drawfile_fontref tFontRef , USHORT usFontSize ) { fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : vMove2NextLineTXT ( pDiag ) ; break ; case conversion_ps : vMove2NextLinePS ( pDiag , usFontSize ) ; break ; case conversion_xml : vMove2NextLineXML ( pDiag ) ; break ; case conversion_pdf : vMove2NextLinePDF ( pDiag , usFontSize ) ; break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@vSubstring2Diagram": "void vSubstring2Diagram ( diagram_type * pDiag , char * szString , size_t tStringLength , long lStringWidth , UCHAR ucFontColor , USHORT usFontstyle , drawfile_fontref tFontRef , USHORT usFontSize , USHORT usMaxFontSize ) { switch ( eConversionType ) { case conversion_text : vSubstringTXT ( pDiag , szString , tStringLength , lStringWidth ) ; break ; case conversion_fmt_text : vSubstringFMT ( pDiag , szString , tStringLength , lStringWidth , usFontstyle ) ; break ; case conversion_ps : vSubstringPS ( pDiag , szString , tStringLength , lStringWidth , ucFontColor , usFontstyle , tFontRef , usFontSize , usMaxFontSize ) ; break ; case conversion_xml : vSubstringXML ( pDiag , szString , tStringLength , lStringWidth , usFontstyle ) ; break ; case conversion_pdf : vSubstringPDF ( pDiag , szString , tStringLength , lStringWidth , ucFontColor , usFontstyle , tFontRef , usFontSize , usMaxFontSize ) ; break ; default : DBG_DEC ( eConversionType ) ; break ; } pDiag -> lXleft += lStringWidth ; }",
    "resources/antiword/output.c@vStartOfParagraph1": "void vStartOfParagraph1 ( diagram_type * pDiag , long lBeforeIndentation ) { fail ( pDiag == NULL ) ; switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : vStartOfParagraphTXT ( pDiag , lBeforeIndentation ) ; break ; case conversion_ps : vStartOfParagraphPS ( pDiag , lBeforeIndentation ) ; break ; case conversion_xml : break ; case conversion_pdf : vStartOfParagraphPDF ( pDiag , lBeforeIndentation ) ; break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@vStartOfParagraph2": "void vStartOfParagraph2 ( diagram_type * pDiag ) { fail ( pDiag == NULL ) ; switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : break ; case conversion_ps : break ; case conversion_xml : vStartOfParagraphXML ( pDiag , 1 ) ; break ; case conversion_pdf : break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@vEndOfParagraph": "void vEndOfParagraph ( diagram_type * pDiag , drawfile_fontref tFontRef , USHORT usFontSize , long lAfterIndentation ) { fail ( pDiag == NULL ) ; fail ( pDiag -> pOutFile == NULL ) ; fail ( usFontSize < MIN_FONT_SIZE || usFontSize > MAX_FONT_SIZE ) ; fail ( lAfterIndentation < 0 ) ; switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : vEndOfParagraphTXT ( pDiag , lAfterIndentation ) ; break ; case conversion_ps : vEndOfParagraphPS ( pDiag , usFontSize , lAfterIndentation ) ; break ; case conversion_xml : vEndOfParagraphXML ( pDiag , 1 ) ; break ; case conversion_pdf : vEndOfParagraphPDF ( pDiag , usFontSize , lAfterIndentation ) ; break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@vEndOfPage": "void vEndOfPage ( diagram_type * pDiag , long lAfterIndentation , BOOL bNewSection ) { switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : vEndOfPageTXT ( pDiag , lAfterIndentation ) ; break ; case conversion_ps : vEndOfPagePS ( pDiag , bNewSection ) ; break ; case conversion_xml : vEndOfPageXML ( pDiag ) ; break ; case conversion_pdf : vEndOfPagePDF ( pDiag , bNewSection ) ; break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@vSetHeaders": "void vSetHeaders ( diagram_type * pDiag , USHORT usIstd ) { switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : break ; case conversion_ps : break ; case conversion_xml : vSetHeadersXML ( pDiag , usIstd ) ; break ; case conversion_pdf : break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@vStartOfList": "void vStartOfList ( diagram_type * pDiag , UCHAR ucNFC , BOOL bIsEndOfTable ) { switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : break ; case conversion_ps : break ; case conversion_xml : vStartOfListXML ( pDiag , ucNFC , bIsEndOfTable ) ; break ; case conversion_pdf : break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@vEndOfList": "void vEndOfList ( diagram_type * pDiag ) { switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : break ; case conversion_ps : break ; case conversion_xml : vEndOfListXML ( pDiag ) ; break ; case conversion_pdf : break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@vStartOfListItem": "void vStartOfListItem ( diagram_type * pDiag , BOOL bNoMarks ) { switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : break ; case conversion_ps : break ; case conversion_xml : vStartOfListItemXML ( pDiag , bNoMarks ) ; break ; case conversion_pdf : break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@vEndOfTable": "void vEndOfTable ( diagram_type * pDiag ) { switch ( eConversionType ) { case conversion_text : case conversion_fmt_text : break ; case conversion_ps : break ; case conversion_xml : vEndOfTableXML ( pDiag ) ; break ; case conversion_pdf : break ; default : DBG_DEC ( eConversionType ) ; break ; } }",
    "resources/antiword/output.c@bAddTableRow": "",
    "resources/antiword/options.c@bCorrectPapersize": "static BOOL bCorrectPapersize ( const char * szName , conversion_type eConversionType ) { const papersize_type * pPaperSize ; for ( pPaperSize = atPaperSizes ; pPaperSize -> szName [ 0 ] != '\\0' ; pPaperSize ++ ) { if ( ! STRCEQ ( pPaperSize -> szName , szName ) ) { continue ; } DBG_DEC ( pPaperSize -> usWidth ) ; DBG_DEC ( pPaperSize -> usHeight ) ; tOptionsCurr . eConversionType = eConversionType ; tOptionsCurr . iPageHeight = ( int ) pPaperSize -> usHeight ; tOptionsCurr . iPageWidth = ( int ) pPaperSize -> usWidth ; return TRUE ; } return FALSE ; }",
    "resources/antiword/options.c@szCreateSuffix": "static const char * szCreateSuffix ( const char * szLeafname ) { const char * pcDot ; pcDot = strrchr ( szLeafname , '.' ) ; if ( pcDot != NULL && STRCEQ ( pcDot , \".txt\" ) ) { /* There is already a .txt suffix, no need for another one */ return \"\" ; } return \".txt\" ; }",
    "resources/antiword/options.c@eMappingFile2Encoding": "static encoding_type eMappingFile2Encoding ( const char * szLeafname ) { char szMappingFile [ LEAFNAME_SIZE + 4 ] ; fail ( szLeafname == NULL ) ; if ( strlen ( szLeafname ) + 4 >= sizeof ( szMappingFile ) ) { DBG_MSG ( szLeafname ) ; return encoding_latin_1 ; } sprintf ( szMappingFile , \"%s%s\" , szLeafname , szCreateSuffix ( szLeafname ) ) ; DBG_MSG ( szMappingFile ) ; if ( STRCEQ ( szMappingFile , MAPPING_FILE_UTF_8 ) ) { return encoding_utf_8 ; } if ( STRCEQ ( szMappingFile , MAPPING_FILE_CP852 ) || STRCEQ ( szMappingFile , MAPPING_FILE_CP1250 ) || STRCEQ ( szMappingFile , MAPPING_FILE_8859_2 ) ) { return encoding_latin_2 ; } if ( STRCEQ ( szMappingFile , MAPPING_FILE_KOI8_R ) || STRCEQ ( szMappingFile , MAPPING_FILE_KOI8_U ) || STRCEQ ( szMappingFile , MAPPING_FILE_CP866 ) || STRCEQ ( szMappingFile , MAPPING_FILE_CP1251 ) || STRCEQ ( szMappingFile , MAPPING_FILE_8859_5 ) ) { return encoding_cyrillic ; } return encoding_latin_1 ; }",
    "resources/antiword/options.c@pOpenCharacterMappingFile": "static FILE * pOpenCharacterMappingFile ( const char * szLeafname ) { # if ! defined ( __riscos ) FILE * pFile ; const char * szHome , * szAntiword , * szSuffix ; size_t tFilenameLen ; char szMappingFile [ PATH_MAX + 1 ] ; # endif /* !__riscos */ if ( szLeafname == NULL || szLeafname [ 0 ] == '\\0' ) { return NULL ; } DBG_MSG ( szLeafname ) ; # if defined ( __riscos ) return fopen ( szLeafname , \"r\" ) ; # else /* Set the suffix */ szSuffix = szCreateSuffix ( szLeafname ) ; /* Set length */ tFilenameLen = strlen ( szLeafname ) + strlen ( szSuffix ) ; /* Try the environment version of the mapping file */ szAntiword = szGetAntiwordDirectory ( ) ; if ( szAntiword != NULL && szAntiword [ 0 ] != '\\0' ) { if ( strlen ( szAntiword ) + tFilenameLen < sizeof ( szMappingFile ) - sizeof ( FILE_SEPARATOR ) ) { sprintf ( szMappingFile , \"%s\" FILE_SEPARATOR \"%s%s\" , szAntiword , szLeafname , szSuffix ) ; DBG_MSG ( szMappingFile ) ; pFile = fopen ( szMappingFile , \"r\" ) ; if ( pFile != NULL ) { return pFile ; } } else { werr ( 0 , \"Environment mappingfilename ignored\" ) ; } } /* Try the local version of the mapping file */ szHome = szGetHomeDirectory ( ) ; if ( strlen ( szHome ) + tFilenameLen < sizeof ( szMappingFile ) - sizeof ( ANTIWORD_DIR ) - 2 * sizeof ( FILE_SEPARATOR ) ) { sprintf ( szMappingFile , \"%s\" FILE_SEPARATOR ANTIWORD_DIR FILE_SEPARATOR \"%s%s\" , szHome , szLeafname , szSuffix ) ; DBG_MSG ( szMappingFile ) ; pFile = fopen ( szMappingFile , \"r\" ) ; if ( pFile != NULL ) { return pFile ; } } else { werr ( 0 , \"Local mappingfilename too long, ignored\" ) ; } /* Try the global version of the mapping file */ if ( tFilenameLen < sizeof ( szMappingFile ) - sizeof ( GLOBAL_ANTIWORD_DIR ) - sizeof ( FILE_SEPARATOR ) ) { sprintf ( szMappingFile , GLOBAL_ANTIWORD_DIR FILE_SEPARATOR \"%s%s\" , szLeafname , szSuffix ) ; DBG_MSG ( szMappingFile ) ; pFile = fopen ( szMappingFile , \"r\" ) ; if ( pFile != NULL ) { return pFile ; } } else { werr ( 0 , \"Global mappingfilename too long, ignored\" ) ; } werr ( 0 , \"I can't open your mapping file (%s%s)\\n\" \"It is not in '%s\" FILE_SEPARATOR ANTIWORD_DIR \"' nor in '\" GLOBAL_ANTIWORD_DIR \"'.\" , szLeafname , szSuffix , szHome ) ; return NULL ; # endif /* __riscos */ }",
    "resources/antiword/options.c@vCloseCharacterMappingFile": "static void vCloseCharacterMappingFile ( FILE * pFile ) { ( void ) fclose ( pFile ) ; }",
    "resources/antiword/options.c@iReadOptions": "int iReadOptions ( int argc , char * * argv ) { # if defined ( __riscos ) FILE * pFile ; const char * szAlphabet ; int iAlphabet ; char szLine [ 81 ] ; # else extern char * optarg ; extern int optind ; char * pcChar , * szTmp ; int iChar ; char szLeafname [ LEAFNAME_SIZE ] ; # endif /* __riscos */ FILE * pCharacterMappingFile ; int iTmp ; BOOL bSuccess ; DBG_MSG ( \"iReadOptions\" ) ; /* Defaults */ tOptionsCurr = tOptionsDefault ; # if defined ( __riscos ) /* Choices file */ pFile = fopen ( \"<AntiWord$ChoicesFile>\" , \"r\" ) ; DBG_MSG_C ( pFile == NULL , \"Choices file not found\" ) ; DBG_HEX_C ( pFile != NULL , pFile ) ; if ( pFile != NULL ) { while ( fgets ( szLine , ( int ) sizeof ( szLine ) , pFile ) != NULL ) { DBG_MSG ( szLine ) ; if ( szLine [ 0 ] == '#' || szLine [ 0 ] == '\\r' || szLine [ 0 ] == '\\n' ) { continue ; } if ( sscanf ( szLine , PARAGRAPH_BREAK , & iTmp ) == 1 && ( iTmp == 0 || ( iTmp >= MIN_SCREEN_WIDTH && iTmp <= MAX_SCREEN_WIDTH ) ) ) { tOptionsCurr . iParagraphBreak = iTmp ; DBG_DEC ( tOptionsCurr . iParagraphBreak ) ; } else if ( sscanf ( szLine , AUTOFILETYPE , & iTmp ) == 1 ) { tOptionsCurr . bAutofiletypeAllowed = iTmp != 0 ; DBG_DEC ( tOptionsCurr . bAutofiletypeAllowed ) ; } else if ( sscanf ( szLine , USE_OUTLINEFONTS , & iTmp ) == 1 ) { tOptionsCurr . eConversionType = iTmp == 0 ? conversion_text : conversion_draw ; DBG_DEC ( tOptionsCurr . eConversionType ) ; } else if ( sscanf ( szLine , SHOW_IMAGES , & iTmp ) == 1 ) { tOptionsCurr . eImageLevel = iTmp != 0 ? level_default : level_no_images ; } else if ( sscanf ( szLine , HIDE_HIDDEN_TEXT , & iTmp ) == 1 ) { tOptionsCurr . bHideHiddenText = iTmp != 0 ; DBG_DEC ( tOptionsCurr . bHideHiddenText ) ; } else if ( sscanf ( szLine , SCALE_FACTOR_START , & iTmp ) == 1 ) { if ( iTmp >= MIN_SCALE_FACTOR && iTmp <= MAX_SCALE_FACTOR ) { tOptionsCurr . iScaleFactor = iTmp ; DBG_DEC ( tOptionsCurr . iScaleFactor ) ; } } } ( void ) fclose ( pFile ) ; } iAlphabet = iReadCurrentAlphabetNumber ( ) ; switch ( iAlphabet ) { case 101 : /* ISO-8859-1 aka Latin1 */ szAlphabet = \"<AntiWord$Latin1>\" ; break ; case 112 : /* ISO-8859-15 aka Latin9 */ szAlphabet = \"<AntiWord$Latin9>\" ; break ; default : werr ( 0 , \"Alphabet '%d' is not supported\" , iAlphabet ) ; return - 1 ; } pCharacterMappingFile = pOpenCharacterMappingFile ( szAlphabet ) ; if ( pCharacterMappingFile != NULL ) { bSuccess = bReadCharacterMappingTable ( pCharacterMappingFile ) ; vCloseCharacterMappingFile ( pCharacterMappingFile ) ; } else { bSuccess = FALSE ; } return bSuccess ? 1 : - 1 ; # else /* Environment */ szTmp = getenv ( \"COLUMNS\" ) ; if ( szTmp != NULL ) { DBG_MSG ( szTmp ) ; iTmp = ( int ) strtol ( szTmp , & pcChar , 10 ) ; if ( * pcChar == '\\0' ) { iTmp -= 4 ; /* This is for the edge */ if ( iTmp < MIN_SCREEN_WIDTH ) { iTmp = MIN_SCREEN_WIDTH ; } else if ( iTmp > MAX_SCREEN_WIDTH ) { iTmp = MAX_SCREEN_WIDTH ; } tOptionsCurr . iParagraphBreak = iTmp ; DBG_DEC ( tOptionsCurr . iParagraphBreak ) ; } } strncpy ( szLeafname , szGetDefaultMappingFile ( ) , sizeof ( szLeafname ) - 1 ) ; szLeafname [ sizeof ( szLeafname ) - 1 ] = '\\0' ; /* Command line */ while ( ( iChar = getopt ( argc , argv , \"La:fhi:m:p:rstw:x:\" ) ) != - 1 ) { switch ( iChar ) { case 'L' : tOptionsCurr . bUseLandscape = TRUE ; break ; case 'a' : if ( ! bCorrectPapersize ( optarg , conversion_pdf ) ) { werr ( 0 , \"-a without a valid papersize\" ) ; return - 1 ; } break ; case 'f' : tOptionsCurr . eConversionType = conversion_fmt_text ; break ; case 'h' : return 0 ; case 'i' : iTmp = ( int ) strtol ( optarg , & pcChar , 10 ) ; if ( * pcChar != '\\0' ) { break ; } switch ( iTmp ) { case 0 : tOptionsCurr . eImageLevel = level_gs_special ; break ; case 1 : tOptionsCurr . eImageLevel = level_no_images ; break ; case 2 : tOptionsCurr . eImageLevel = level_ps_2 ; break ; case 3 : tOptionsCurr . eImageLevel = level_ps_3 ; break ; default : tOptionsCurr . eImageLevel = level_default ; break ; } DBG_DEC ( tOptionsCurr . eImageLevel ) ; break ; case 'm' : if ( tOptionsCurr . eConversionType == conversion_xml ) { werr ( 0 , \"XML doesn't need a mapping file\" ) ; break ; } strncpy ( szLeafname , optarg , sizeof ( szLeafname ) - 1 ) ; szLeafname [ sizeof ( szLeafname ) - 1 ] = '\\0' ; DBG_MSG ( szLeafname ) ; break ; case 'p' : if ( ! bCorrectPapersize ( optarg , conversion_ps ) ) { werr ( 0 , \"-p without a valid papersize\" ) ; return - 1 ; } break ; case 'r' : tOptionsCurr . bRemoveRemovedText = FALSE ; break ; case 's' : tOptionsCurr . bHideHiddenText = FALSE ; break ; case 't' : tOptionsCurr . eConversionType = conversion_text ; break ; case 'w' : iTmp = ( int ) strtol ( optarg , & pcChar , 10 ) ; if ( * pcChar == '\\0' ) { if ( iTmp != 0 && iTmp < MIN_SCREEN_WIDTH ) { iTmp = MIN_SCREEN_WIDTH ; } else if ( iTmp > MAX_SCREEN_WIDTH ) { iTmp = MAX_SCREEN_WIDTH ; } tOptionsCurr . iParagraphBreak = iTmp ; DBG_DEC ( tOptionsCurr . iParagraphBreak ) ; } break ; case 'x' : if ( STREQ ( optarg , \"db\" ) ) { tOptionsCurr . iParagraphBreak = 0 ; tOptionsCurr . eConversionType = conversion_xml ; strcpy ( szLeafname , MAPPING_FILE_UTF_8 ) ; } else { werr ( 0 , \"-x %s is not supported\" , optarg ) ; return - 1 ; } break ; default : return - 1 ; } } tOptionsCurr . eEncoding = eMappingFile2Encoding ( szLeafname ) ; DBG_DEC ( tOptionsCurr . eEncoding ) ; if ( tOptionsCurr . eConversionType == conversion_ps && tOptionsCurr . eEncoding == encoding_utf_8 ) { werr ( 0 , \"The combination PostScript and UTF-8 is not supported\" ) ; return - 1 ; } if ( tOptionsCurr . eConversionType == conversion_pdf && tOptionsCurr . eEncoding == encoding_utf_8 ) { werr ( 0 , \"The combination PDF and UTF-8 is not supported\" ) ; return - 1 ; } if ( tOptionsCurr . eConversionType == conversion_pdf && tOptionsCurr . eEncoding == encoding_cyrillic ) { werr ( 0 , \"The combination PDF and Cyrillic is not supported\" ) ; return - 1 ; } if ( tOptionsCurr . eConversionType == conversion_ps || tOptionsCurr . eConversionType == conversion_pdf ) { /* PostScript or PDF mode */ if ( tOptionsCurr . bUseLandscape ) { /* Swap the page height and width */ iTmp = tOptionsCurr . iPageHeight ; tOptionsCurr . iPageHeight = tOptionsCurr . iPageWidth ; tOptionsCurr . iPageWidth = iTmp ; } /* The paragraph break depends on the width of the paper */ tOptionsCurr . iParagraphBreak = iMilliPoints2Char ( ( long ) tOptionsCurr . iPageWidth * 1000 - lDrawUnits2MilliPoints ( PS_LEFT_MARGIN + PS_RIGHT_MARGIN ) ) ; DBG_DEC ( tOptionsCurr . iParagraphBreak ) ; } pCharacterMappingFile = pOpenCharacterMappingFile ( szLeafname ) ; if ( pCharacterMappingFile != NULL ) { bSuccess = bReadCharacterMappingTable ( pCharacterMappingFile ) ; vCloseCharacterMappingFile ( pCharacterMappingFile ) ; } else { bSuccess = FALSE ; } return bSuccess ? optind : - 1 ; # endif /* __riscos */ }",
    "resources/antiword/options.c@vGetOptions": "void vGetOptions ( options_type * pOptions ) { fail ( pOptions == NULL ) ; * pOptions = tOptionsCurr ; }",
    "resources/antiword/word2text.c@vUpdateCounters": "static void vUpdateCounters ( void ) { # if defined ( __riscos ) ulCharCounter ++ ; iCurrPct = ( int ) ( ( ulCharCounter * 100 ) / ulDocumentLength ) ; if ( iCurrPct != iPrevPct ) { Hourglass_Percentage ( iCurrPct ) ; iPrevPct = iCurrPct ; } # endif /* __riscos */ }",
    "resources/antiword/word2text.c@bOutputContainsText": "",
    "resources/antiword/word2text.c@lTotalStringWidth": "static long lTotalStringWidth ( const output_type * pAnchor ) { const output_type * pCurr ; long lTotal ; lTotal = 0 ; for ( pCurr = pAnchor ; pCurr != NULL ; pCurr = pCurr -> pNext ) { DBG_DEC_C ( pCurr -> lStringWidth < 0 , pCurr -> lStringWidth ) ; fail ( pCurr -> lStringWidth < 0 ) ; lTotal += pCurr -> lStringWidth ; } return lTotal ; }",
    "resources/antiword/word2text.c@vStoreByte": "static void vStoreByte ( UCHAR ucChar , output_type * pOutput ) { fail ( pOutput == NULL ) ; if ( ucChar == 0 ) { pOutput -> szStorage [ pOutput -> tNextFree ] = '\\0' ; return ; } while ( pOutput -> tNextFree + 2 > pOutput -> tStorageSize ) { pOutput -> tStorageSize += EXTENTION_SIZE ; pOutput -> szStorage = xrealloc ( pOutput -> szStorage , pOutput -> tStorageSize ) ; } pOutput -> szStorage [ pOutput -> tNextFree ] = ( char ) ucChar ; pOutput -> szStorage [ pOutput -> tNextFree + 1 ] = '\\0' ; pOutput -> tNextFree ++ ; }",
    "resources/antiword/word2text.c@vStoreChar": "static void vStoreChar ( ULONG ulChar , BOOL bChangeAllowed , output_type * pOutput ) { char szResult [ 4 ] ; size_t tIndex , tLen ; fail ( pOutput == NULL ) ; if ( tOptions . eEncoding == encoding_utf_8 && bChangeAllowed ) { DBG_HEX_C ( ulChar > 0xffff , ulChar ) ; fail ( ulChar > 0xffff ) ; tLen = tUcs2Utf8 ( ulChar , szResult , sizeof ( szResult ) ) ; for ( tIndex = 0 ; tIndex < tLen ; tIndex ++ ) { vStoreByte ( ( UCHAR ) szResult [ tIndex ] , pOutput ) ; } } else { DBG_HEX_C ( ulChar > 0xff , ulChar ) ; fail ( ulChar > 0xff ) ; vStoreByte ( ( UCHAR ) ulChar , pOutput ) ; tLen = 1 ; } pOutput -> lStringWidth += lComputeStringWidth ( pOutput -> szStorage + pOutput -> tNextFree - tLen , tLen , pOutput -> tFontRef , pOutput -> usFontSize ) ; }",
    "resources/antiword/word2text.c@vStoreCharacter": "static void vStoreCharacter ( ULONG ulChar , output_type * pOutput ) { vStoreChar ( ulChar , TRUE , pOutput ) ; }",
    "resources/antiword/word2text.c@vStoreString": "static void vStoreString ( const char * szString , size_t tStringLength , output_type * pOutput ) { size_t tIndex ; fail ( szString == NULL || pOutput == NULL ) ; for ( tIndex = 0 ; tIndex < tStringLength ; tIndex ++ ) { vStoreCharacter ( ( ULONG ) ( UCHAR ) szString [ tIndex ] , pOutput ) ; } }",
    "resources/antiword/word2text.c@vStoreNumberAsDecimal": "static void vStoreNumberAsDecimal ( UINT uiNumber , output_type * pOutput ) { size_t tLen ; char szString [ 3 * sizeof ( UINT ) + 1 ] ; fail ( uiNumber == 0 ) ; fail ( pOutput == NULL ) ; tLen = ( size_t ) sprintf ( szString , \"%u\" , uiNumber ) ; vStoreString ( szString , tLen , pOutput ) ; }",
    "resources/antiword/word2text.c@vStoreNumberAsRoman": "static void vStoreNumberAsRoman ( UINT uiNumber , output_type * pOutput ) { size_t tLen ; char szString [ 15 ] ; fail ( uiNumber == 0 ) ; fail ( pOutput == NULL ) ; tLen = tNumber2Roman ( uiNumber , FALSE , szString ) ; vStoreString ( szString , tLen , pOutput ) ; }",
    "resources/antiword/word2text.c@vStoreStyle": "static void vStoreStyle ( diagram_type * pDiag , output_type * pOutput , const style_block_type * pStyle ) { size_t tLen ; char szString [ 120 ] ; fail ( pDiag == NULL ) ; fail ( pOutput == NULL ) ; fail ( pStyle == NULL ) ; if ( tOptions . eConversionType == conversion_xml ) { vSetHeaders ( pDiag , pStyle -> usIstd ) ; } else { tLen = tStyle2Window ( szString , sizeof ( szString ) , pStyle , pSection ) ; vStoreString ( szString , tLen , pOutput ) ; } }",
    "resources/antiword/word2text.c@vPutIndentation": "static void vPutIndentation ( diagram_type * pDiag , output_type * pOutput , BOOL bNoMarks , BOOL bFirstLine , UINT uiListNumber , UCHAR ucNFC , const char * szListChar , long lLeftIndentation , long lLeftIndentation1 ) { long lWidth ; size_t tIndex , tNextFree ; char szLine [ 30 ] ; fail ( pDiag == NULL ) ; fail ( pOutput == NULL ) ; fail ( szListChar == NULL ) ; fail ( lLeftIndentation < 0 ) ; if ( tOptions . eConversionType == conversion_xml ) { /* XML does its own indentation at rendering time */ return ; } if ( bNoMarks ) { if ( bFirstLine ) { lLeftIndentation += lLeftIndentation1 ; } if ( lLeftIndentation < 0 ) { lLeftIndentation = 0 ; } vSetLeftIndentation ( pDiag , lLeftIndentation ) ; return ; } if ( lLeftIndentation <= 0 ) { DBG_HEX_C ( ucNFC != 0x00 , ucNFC ) ; vSetLeftIndentation ( pDiag , 0 ) ; return ; } # if defined ( DEBUG ) if ( tOptions . eEncoding == encoding_utf_8 ) { fail ( strlen ( szListChar ) > 3 ) ; } else { DBG_HEX_C ( iscntrl ( ( int ) szListChar [ 0 ] ) , szListChar [ 0 ] ) ; fail ( iscntrl ( ( int ) szListChar [ 0 ] ) ) ; fail ( szListChar [ 1 ] != '\\0' ) ; } # endif /* DEBUG */ switch ( ucNFC ) { case LIST_ARABIC_NUM : case LIST_NUMBER_TXT : tNextFree = ( size_t ) sprintf ( szLine , \"%u\" , uiListNumber ) ; break ; case LIST_UPPER_ROMAN : case LIST_LOWER_ROMAN : tNextFree = tNumber2Roman ( uiListNumber , ucNFC == LIST_UPPER_ROMAN , szLine ) ; break ; case LIST_UPPER_ALPHA : case LIST_LOWER_ALPHA : tNextFree = tNumber2Alpha ( uiListNumber , ucNFC == LIST_UPPER_ALPHA , szLine ) ; break ; case LIST_ORDINAL_NUM : case LIST_ORDINAL_TXT : if ( uiListNumber % 10 == 1 && uiListNumber != 11 ) { tNextFree = ( size_t ) sprintf ( szLine , \"%ust\" , uiListNumber ) ; } else if ( uiListNumber % 10 == 2 && uiListNumber != 12 ) { tNextFree = ( size_t ) sprintf ( szLine , \"%und\" , uiListNumber ) ; } else if ( uiListNumber % 10 == 3 && uiListNumber != 13 ) { tNextFree = ( size_t ) sprintf ( szLine , \"%urd\" , uiListNumber ) ; } else { tNextFree = ( size_t ) sprintf ( szLine , \"%uth\" , uiListNumber ) ; } break ; case LIST_OUTLINE_NUM : tNextFree = ( size_t ) sprintf ( szLine , \"%02u\" , uiListNumber ) ; break ; case LIST_SPECIAL : case LIST_SPECIAL2 : case LIST_BULLETS : tNextFree = 0 ; break ; default : DBG_HEX ( ucNFC ) ; DBG_FIXME ( ) ; tNextFree = ( size_t ) sprintf ( szLine , \"%u\" , uiListNumber ) ; break ; } tNextFree += ( size_t ) sprintf ( szLine + tNextFree , \"%.3s\" , szListChar ) ; szLine [ tNextFree ++ ] = ' ' ; szLine [ tNextFree ] = '\\0' ; lWidth = lComputeStringWidth ( szLine , tNextFree , pOutput -> tFontRef , pOutput -> usFontSize ) ; lLeftIndentation -= lWidth ; if ( lLeftIndentation < 0 ) { lLeftIndentation = 0 ; } vSetLeftIndentation ( pDiag , lLeftIndentation ) ; for ( tIndex = 0 ; tIndex < tNextFree ; tIndex ++ ) { vStoreChar ( ( ULONG ) ( UCHAR ) szLine [ tIndex ] , FALSE , pOutput ) ; } }",
    "resources/antiword/word2text.c@vPutSeparatorLine": "static void vPutSeparatorLine ( output_type * pOutput ) { long lCharWidth ; int iCounter , iChars ; char szOne [ 2 ] ; fail ( pOutput == NULL ) ; szOne [ 0 ] = OUR_EM_DASH ; szOne [ 1 ] = '\\0' ; lCharWidth = lComputeStringWidth ( szOne , 1 , pOutput -> tFontRef , pOutput -> usFontSize ) ; NO_DBG_DEC ( lCharWidth ) ; iChars = ( int ) ( ( 144000 + lCharWidth / 2 ) / lCharWidth ) ; NO_DBG_DEC ( iChars ) ; for ( iCounter = 0 ; iCounter < iChars ; iCounter ++ ) { vStoreCharacter ( ( ULONG ) ( UCHAR ) OUR_EM_DASH , pOutput ) ; } }",
    "resources/antiword/word2text.c@pStartNextOutput": "static output_type * pStartNextOutput ( output_type * pCurrent ) { output_type * pNew ; TRACE_MSG ( \"pStartNextOutput\" ) ; if ( pCurrent -> tNextFree == 0 ) { /* The current record is empty, re-use */ fail ( pCurrent -> szStorage [ 0 ] != '\\0' ) ; fail ( pCurrent -> lStringWidth != 0 ) ; return pCurrent ; } /* The current record is in use, make a new one */ pNew = xmalloc ( sizeof ( * pNew ) ) ; pCurrent -> pNext = pNew ; pNew -> tStorageSize = INITIAL_SIZE ; pNew -> szStorage = xmalloc ( pNew -> tStorageSize ) ; pNew -> szStorage [ 0 ] = '\\0' ; pNew -> tNextFree = 0 ; pNew -> lStringWidth = 0 ; pNew -> ucFontColor = FONT_COLOR_DEFAULT ; pNew -> usFontStyle = FONT_REGULAR ; pNew -> tFontRef = ( drawfile_fontref ) 0 ; pNew -> usFontSize = DEFAULT_FONT_SIZE ; pNew -> pPrev = pCurrent ; pNew -> pNext = NULL ; return pNew ; }",
    "resources/antiword/word2text.c@pStartNewOutput": "static output_type * pStartNewOutput ( output_type * pAnchor , output_type * pLeftOver ) { output_type * pCurr , * pNext ; USHORT usFontStyle , usFontSize ; drawfile_fontref tFontRef ; UCHAR ucFontColor ; TRACE_MSG ( \"pStartNewOutput\" ) ; ucFontColor = FONT_COLOR_DEFAULT ; usFontStyle = FONT_REGULAR ; tFontRef = ( drawfile_fontref ) 0 ; usFontSize = DEFAULT_FONT_SIZE ; /* Free the old output space */ pCurr = pAnchor ; while ( pCurr != NULL ) { TRACE_MSG ( \"Free the old output space\" ) ; pNext = pCurr -> pNext ; pCurr -> szStorage = xfree ( pCurr -> szStorage ) ; if ( pCurr -> pNext == NULL ) { ucFontColor = pCurr -> ucFontColor ; usFontStyle = pCurr -> usFontStyle ; tFontRef = pCurr -> tFontRef ; usFontSize = pCurr -> usFontSize ; } pCurr = xfree ( pCurr ) ; pCurr = pNext ; } if ( pLeftOver == NULL ) { /* Create new output space */ TRACE_MSG ( \"Create new output space\" ) ; pLeftOver = xmalloc ( sizeof ( * pLeftOver ) ) ; pLeftOver -> tStorageSize = INITIAL_SIZE ; NO_DBG_DEC ( pLeftOver -> tStorageSize ) ; TRACE_MSG ( \"before 2nd xmalloc\" ) ; pLeftOver -> szStorage = xmalloc ( pLeftOver -> tStorageSize ) ; TRACE_MSG ( \"after 2nd xmalloc\" ) ; pLeftOver -> szStorage [ 0 ] = '\\0' ; pLeftOver -> tNextFree = 0 ; pLeftOver -> lStringWidth = 0 ; pLeftOver -> ucFontColor = ucFontColor ; pLeftOver -> usFontStyle = usFontStyle ; pLeftOver -> tFontRef = tFontRef ; pLeftOver -> usFontSize = usFontSize ; pLeftOver -> pPrev = NULL ; pLeftOver -> pNext = NULL ; } fail ( ! bCheckDoubleLinkedList ( pLeftOver ) ) ; return pLeftOver ; }",
    "resources/antiword/word2text.c@ulGetChar": "static ULONG ulGetChar ( FILE * pFile , list_id_enum eListID ) { const font_block_type * pCurr ; ULONG ulChar , ulFileOffset , ulCharPos ; row_info_enum eRowInfo ; USHORT usChar , usPropMod ; BOOL bSkip ; fail ( pFile == NULL ) ; pCurr = pFontInfo ; bSkip = FALSE ; for ( ; ; ) { usChar = usNextChar ( pFile , eListID , & ulFileOffset , & ulCharPos , & usPropMod ) ; if ( usChar == ( USHORT ) EOF ) { return ( ULONG ) EOF ; } vUpdateCounters ( ) ; eRowInfo = ePropMod2RowInfo ( usPropMod , iWordVersion ) ; if ( ! bStartRow ) { # if 0 bStartRow = eRowInfo == found_a_cell || ( pRowInfo != NULL && ulFileOffset == pRowInfo -> ulFileOffsetStart && eRowInfo != found_not_a_cell ) ; # else bStartRow = pRowInfo != NULL && ulFileOffset == pRowInfo -> ulFileOffsetStart ; # endif NO_DBG_HEX_C ( bStartRow , pRowInfo -> ulFileOffsetStart ) ; } if ( ! bEndRowNorm ) { # if 0 bEndRow = eRowInfo == found_end_of_row || ( pRowInfo != NULL && ulFileOffset == pRowInfo -> ulFileOffsetEnd && eRowInfo != found_not_end_of_row ) ; # else bEndRowNorm = pRowInfo != NULL && ulFileOffset == pRowInfo -> ulFileOffsetEnd ; # endif NO_DBG_HEX_C ( bEndRowNorm , pRowInfo -> ulFileOffsetEnd ) ; } if ( ! bEndRowFast ) { bEndRowFast = eRowInfo == found_end_of_row ; NO_DBG_HEX_C ( bEndRowFast , pRowInfo -> ulFileOffsetEnd ) ; } if ( ! bStartStyle ) { bStartStyle = pStyleInfo != NULL && ulFileOffset == pStyleInfo -> ulFileOffset ; NO_DBG_HEX_C ( bStartStyle , ulFileOffset ) ; } if ( pCurr != NULL && ulFileOffset == pCurr -> ulFileOffset ) { bStartFont = TRUE ; NO_DBG_HEX ( ulFileOffset ) ; pFontInfo = pCurr ; pCurr = pGetNextFontInfoListItem ( pCurr ) ; } /* Skip embedded characters */ if ( usChar == START_EMBEDDED ) { bSkip = TRUE ; continue ; } if ( usChar == END_IGNORE || usChar == END_EMBEDDED ) { bSkip = FALSE ; continue ; } if ( bSkip ) { continue ; } ulChar = ulTranslateCharacters ( usChar , ulFileOffset , iWordVersion , tOptions . eConversionType , tOptions . eEncoding , bOldMacFile ) ; if ( ulChar == IGNORE_CHARACTER ) { continue ; } if ( ulChar == PICTURE ) { ulFileOffsetImage = ulGetPictInfoListItem ( ulFileOffset ) ; } else { ulFileOffsetImage = FC_INVALID ; } if ( ulChar == PAR_END ) { /* End of paragraph seen, prepare for the next */ vFillStyleFromStylesheet ( usIstdNext , & tStyleNext ) ; vCorrectStyleValues ( & tStyleNext ) ; bStartStyleNext = TRUE ; vFillFontFromStylesheet ( usIstdNext , & tFontNext ) ; vCorrectFontValues ( & tFontNext ) ; bStartFontNext = TRUE ; } if ( ulChar == PAGE_BREAK ) { /* Might be the start of a new section */ pSectionNext = pGetSectionInfo ( pSection , ulCharPos ) ; } return ulChar ; } }",
    "resources/antiword/word2text.c@lGetWidthMax": "static long lGetWidthMax ( int iParagraphBreak ) { fail ( iParagraphBreak < 0 ) ; if ( iParagraphBreak == 0 ) { return LONG_MAX ; } if ( iParagraphBreak < MIN_SCREEN_WIDTH ) { return lChar2MilliPoints ( MIN_SCREEN_WIDTH ) ; } if ( iParagraphBreak > MAX_SCREEN_WIDTH ) { return lChar2MilliPoints ( MAX_SCREEN_WIDTH ) ; } return lChar2MilliPoints ( iParagraphBreak ) ; }",
    "resources/antiword/word2text.c@bWordDecryptor": "",
    "resources/antiword/word2text.c@lLastStringWidth": "static long lLastStringWidth ( const output_type * pAnchor ) { const output_type * pCurr , * pStart ; pStart = NULL ; for ( pCurr = pAnchor ; pCurr != NULL ; pCurr = pCurr -> pNext ) { if ( pCurr -> tNextFree == 1 && ( pCurr -> szStorage [ 0 ] == PAR_END || pCurr -> szStorage [ 0 ] == HARD_RETURN ) ) { /* Found a separator. Start after the separator */ pStart = pCurr -> pNext ; } } if ( pStart == NULL ) { /* No separators. Use the whole output string */ pStart = pAnchor ; } return lTotalStringWidth ( pStart ) ; }",
    "resources/antiword/word2text.c@pHdrFtrDecryptor": "output_type * pHdrFtrDecryptor ( FILE * pFile , ULONG ulCharPosStart , ULONG ulCharPosNext ) { output_type * pAnchor , * pOutput , * pLeftOver ; ULONG ulChar , ulFileOffset , ulCharPos ; long lWidthCurr , lWidthMax ; long lRightIndentation ; USHORT usChar ; UCHAR ucAlignment ; BOOL bSkip ; fail ( iWordVersion < 0 ) ; fail ( tOptions . eConversionType == conversion_unknown ) ; fail ( tOptions . eEncoding == 0 ) ; if ( ulCharPosStart == ulCharPosNext ) { /* There are no bytes to decrypt */ return NULL ; } lRightIndentation = 0 ; ucAlignment = ALIGNMENT_LEFT ; bSkip = FALSE ; lWidthMax = lGetWidthMax ( tOptions . iParagraphBreak ) ; pAnchor = pStartNewOutput ( NULL , NULL ) ; pOutput = pAnchor ; pOutput -> tFontRef = tOpenFont ( 0 , FONT_REGULAR , DEFAULT_FONT_SIZE ) ; usChar = usToHdrFtrPosition ( pFile , ulCharPosStart ) ; ulCharPos = ulCharPosStart ; ulFileOffset = ulCharPos2FileOffset ( ulCharPos ) ; while ( usChar != ( USHORT ) EOF && ulCharPos != ulCharPosNext ) { /* Skip embedded characters */ if ( usChar == START_EMBEDDED ) { bSkip = TRUE ; } else if ( usChar == END_IGNORE || usChar == END_EMBEDDED ) { bSkip = FALSE ; } /* Translate character */ if ( bSkip || usChar == END_IGNORE || usChar == END_EMBEDDED ) { ulChar = IGNORE_CHARACTER ; } else { ulChar = ulTranslateCharacters ( usChar , ulFileOffset , iWordVersion , tOptions . eConversionType , tOptions . eEncoding , bOldMacFile ) ; } /* Process character */ if ( ulChar != IGNORE_CHARACTER ) { switch ( ulChar ) { case PICTURE : vStoreString ( \"[pic]\" , 5 , pOutput ) ; break ; case PAR_END : case HARD_RETURN : case PAGE_BREAK : case COLUMN_FEED : /* To the next substring */ pOutput = pStartNextOutput ( pOutput ) ; vCloseFont ( ) ; pOutput -> tFontRef = tOpenFont ( 0 , FONT_REGULAR , DEFAULT_FONT_SIZE ) ; /* A substring with just one character */ if ( ulChar == HARD_RETURN ) { vStoreCharacter ( HARD_RETURN , pOutput ) ; } else { vStoreCharacter ( PAR_END , pOutput ) ; } /* To the next substring */ pOutput = pStartNextOutput ( pOutput ) ; vCloseFont ( ) ; pOutput -> tFontRef = tOpenFont ( 0 , FONT_REGULAR , DEFAULT_FONT_SIZE ) ; fail ( ! bCheckDoubleLinkedList ( pAnchor ) ) ; break ; case TABLE_SEPARATOR : vStoreCharacter ( ( ULONG ) ' ' , pOutput ) ; vStoreCharacter ( ( ULONG ) TABLE_SEPARATOR_CHAR , pOutput ) ; break ; case TAB : vStoreCharacter ( ( ULONG ) FILLER_CHAR , pOutput ) ; break ; default : vStoreCharacter ( ulChar , pOutput ) ; break ; } } lWidthCurr = lLastStringWidth ( pAnchor ) ; if ( lWidthCurr >= lWidthMax + lRightIndentation ) { pLeftOver = pSplitList ( pAnchor ) ; for ( pOutput = pAnchor ; pOutput -> pNext != NULL ; pOutput = pOutput -> pNext ) ; /* EMPTY */ fail ( pOutput == NULL ) ; /* To the next substring */ pOutput = pStartNextOutput ( pOutput ) ; /* A substring with just one HARD_RETURN */ vStoreCharacter ( HARD_RETURN , pOutput ) ; /* Put the leftover piece(s) at the end */ pOutput -> pNext = pLeftOver ; if ( pLeftOver != NULL ) { pLeftOver -> pPrev = pOutput ; } fail ( ! bCheckDoubleLinkedList ( pAnchor ) ) ; for ( pOutput = pAnchor ; pOutput -> pNext != NULL ; pOutput = pOutput -> pNext ) ; /* EMPTY */ fail ( pOutput == NULL ) ; } usChar = usNextChar ( pFile , hdrftr_list , & ulFileOffset , & ulCharPos , NULL ) ; } vCloseFont ( ) ; if ( bOutputContainsText ( pAnchor ) ) { return pAnchor ; } pAnchor = pStartNewOutput ( pAnchor , NULL ) ; pAnchor -> szStorage = xfree ( pAnchor -> szStorage ) ; pAnchor = xfree ( pAnchor ) ; return NULL ; }",
    "resources/antiword/word2text.c@szFootnoteDecryptor": "char * szFootnoteDecryptor ( FILE * pFile , ULONG ulCharPosStart , ULONG ulCharPosNext ) { char * szText ; ULONG ulChar , ulFileOffset , ulCharPos ; USHORT usChar ; size_t tLen , tIndex , tNextFree , tStorageSize ; char szResult [ 6 ] ; BOOL bSkip ; fail ( iWordVersion < 0 ) ; fail ( tOptions . eConversionType == conversion_unknown ) ; fail ( tOptions . eEncoding == 0 ) ; if ( ulCharPosStart == ulCharPosNext ) { /* There are no bytes to decrypt */ return NULL ; } if ( tOptions . eConversionType != conversion_xml ) { /* Only implemented for XML output */ return NULL ; } bSkip = FALSE ; /* Initialise the text buffer */ tStorageSize = INITIAL_SIZE ; szText = xmalloc ( tStorageSize ) ; tNextFree = 0 ; szText [ tNextFree ] = '\\0' ; /* Goto the start */ usChar = usToFootnotePosition ( pFile , ulCharPosStart ) ; ulCharPos = ulCharPosStart ; ulFileOffset = ulCharPos2FileOffset ( ulCharPos ) ; /* Skip the unwanted starting characters */ while ( usChar != ( USHORT ) EOF && ulCharPos != ulCharPosNext && ( usChar == FOOTNOTE_OR_ENDNOTE || usChar == PAR_END || usChar == TAB || usChar == ( USHORT ) ' ' ) ) { usChar = usNextChar ( pFile , footnote_list , & ulFileOffset , & ulCharPos , NULL ) ; } /* Process the footnote text */ while ( usChar != ( USHORT ) EOF && ulCharPos != ulCharPosNext ) { /* Skip embedded characters */ if ( usChar == START_EMBEDDED ) { bSkip = TRUE ; } else if ( usChar == END_IGNORE || usChar == END_EMBEDDED ) { bSkip = FALSE ; } /* Translate character */ if ( bSkip || usChar == END_IGNORE || usChar == END_EMBEDDED || usChar == FOOTNOTE_OR_ENDNOTE ) { ulChar = IGNORE_CHARACTER ; } else { ulChar = ulTranslateCharacters ( usChar , ulFileOffset , iWordVersion , tOptions . eConversionType , tOptions . eEncoding , bOldMacFile ) ; } /* Process character */ if ( ulChar == PICTURE ) { tLen = 5 ; strcpy ( szResult , \"[pic]\" ) ; } else if ( ulChar == IGNORE_CHARACTER ) { tLen = 0 ; szResult [ 0 ] = '\\0' ; } else { switch ( ulChar ) { case PAR_END : case HARD_RETURN : case PAGE_BREAK : case COLUMN_FEED : ulChar = ( ULONG ) PAR_END ; break ; case TAB : ulChar = ( ULONG ) ' ' ; break ; default : break ; } tLen = tUcs2Utf8 ( ulChar , szResult , sizeof ( szResult ) ) ; } /* Add the results to the text */ if ( tNextFree + tLen + 1 > tStorageSize ) { tStorageSize += EXTENTION_SIZE ; szText = xrealloc ( szText , tStorageSize ) ; } for ( tIndex = 0 ; tIndex < tLen ; tIndex ++ ) { szText [ tNextFree ++ ] = szResult [ tIndex ] ; } szText [ tNextFree ] = '\\0' ; /* Next character */ usChar = usNextChar ( pFile , footnote_list , & ulFileOffset , & ulCharPos , NULL ) ; } /* Remove redundant spaces */ while ( tNextFree != 0 && szText [ tNextFree - 1 ] == ' ' ) { szText [ tNextFree - 1 ] = '\\0' ; tNextFree -- ; } if ( tNextFree == 0 ) { /* No text */ szText = xfree ( szText ) ; return NULL ; } return szText ; }",
    "resources/antiword/startup.c@bIsMatch": "static BOOL bIsMatch ( const char * szStr1 , const char * szStr2 ) { const char * pcTmp1 , * pcTmp2 ; for ( pcTmp1 = szStr1 , pcTmp2 = szStr2 ; * pcTmp1 != '\\0' ; pcTmp1 ++ , pcTmp2 ++ ) { if ( toupper ( * pcTmp1 ) != toupper ( * pcTmp2 ) ) { return FALSE ; } } return * pcTmp2 == '\\0' ; }",
    "resources/antiword/startup.c@tGetTaskHandle": "static task_handle tGetTaskHandle ( const char * szTaskname ) { const char * pcTmp ; int iReg0 , iIndex ; int aiBuffer [ 4 ] ; char szTmp [ 21 ] ; iReg0 = 0 ; do { /* Get info on the next task */ Error_CheckFatal ( SWI ( 3 , 1 , TaskManager_EnumerateTasks | XOS_Bit , iReg0 , aiBuffer , sizeof ( aiBuffer ) , & iReg0 ) ) ; /* Copy the (control character terminated) task name */ for ( iIndex = 0 , pcTmp = ( const char * ) aiBuffer [ 1 ] ; iIndex < elementsof ( szTmp ) ; iIndex ++ , pcTmp ++ ) { if ( iscntrl ( * pcTmp ) ) { szTmp [ iIndex ] = '\\0' ; break ; } szTmp [ iIndex ] = * pcTmp ; } szTmp [ elementsof ( szTmp ) - 1 ] = '\\0' ; if ( bIsMatch ( szTmp , szTaskname ) ) { /* Task found */ return ( task_handle ) aiBuffer [ 0 ] ; } } while ( iReg0 >= 0 ) ; /* Task not found */ return 0 ; }",
    "resources/antiword/startup.c@main": "int main ( int argc , char * * argv ) { message_block tMsg ; task_handle tTaskHandle ; size_t tArgLen ; int aiMessages [ ] = { 0 } ; char szCommand [ 512 ] ; Event_Initialise3 ( \"StartUp\" , 310 , aiMessages ) ; if ( argc > 1 ) { tArgLen = strlen ( argv [ 1 ] ) ; } else { tArgLen = 0 ; } if ( tArgLen >= sizeof ( tMsg . data . dataload . filename ) ) { werr ( 1 , \"Input filename too long\" ) ; return EXIT_FAILURE ; } tTaskHandle = tGetTaskHandle ( \"antiword\" ) ; if ( tTaskHandle == 0 ) { /* Antiword is not active */ strcpy ( szCommand , \"chain:<Antiword$Dir>.!Antiword\" ) ; if ( argc > 1 ) { strcat ( szCommand , \" \" ) ; strcat ( szCommand , argv [ 1 ] ) ; } # if defined ( DEBUG ) strcat ( szCommand , \" \" ) ; strcat ( szCommand , \"2><Antiword$Dir>.Debug\" ) ; # endif /* DEBUG */ system ( szCommand ) ; /* If we reach here something has gone wrong */ return EXIT_FAILURE ; } /* Antiword is active */ if ( argc > 1 ) { /*\n\t\t * Send the argument to Antiword by imitating a\n\t\t * drag-and-drop to Antiword's iconbar icon\n\t\t */ memset ( & tMsg , 0 , sizeof ( tMsg ) ) ; tMsg . header . size = ROUND4 ( offsetof ( message_block , data ) + offsetof ( message_dataload , filename ) + 1 + tArgLen ) ; tMsg . header . yourref = 0 ; tMsg . header . action = message_DATALOAD ; tMsg . data . dataload . window = window_ICONBAR ; tMsg . data . dataload . icon = - 1 ; tMsg . data . dataload . size = 0 ; tMsg . data . dataload . filetype = FILETYPE_MSWORD ; strcpy ( tMsg . data . dataload . filename , argv [ 1 ] ) ; Error_CheckFatal ( Wimp_SendMessage ( event_SEND , & tMsg , tTaskHandle , 0 ) ) ; return EXIT_SUCCESS ; } else { /* Give an error message and return */ werr ( 1 , \"Antiword is already running\" ) ; return EXIT_FAILURE ; } }"
}