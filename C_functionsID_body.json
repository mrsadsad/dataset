{
    "resources/C/misc/run_length_encoding.c@run_length_encode": "char * run_length_encode ( char * str ) { int str_length = strlen ( str ) ; int encoded_index = 0 ; //allocate space for worst-case scenario char * encoded = malloc ( 2 * strlen ( str ) ) ; //temp space for int to str conversion char int_str [ 20 ] ; for ( int i = 0 ; i < str_length ; ++ i ) { int count = 0 ; char current = str [ i ] ; //count occurences while ( current == str [ i + count ] ) count ++ ; i += count - 1 ; //convert occurrence amount to string and write to encoded string sprintf ( int_str , \"%d\" , count ) ; int int_str_length = strlen ( int_str ) ; strncpy ( & encoded [ encoded_index ] , int_str , strlen ( int_str ) ) ; //write current char to encoded string encoded_index += strlen ( int_str ) ; encoded [ encoded_index ] = current ; ++ encoded_index ; } //null terminate string and move encoded string to compacted memory space  encoded [ encoded_index ] = '\\0' ; char * compacted_string = malloc ( strlen ( encoded ) + 1 ) ; strcpy ( compacted_string , encoded ) ; free ( encoded ) ; return compacted_string ; }",
    "resources/C/misc/run_length_encoding.c@test": "static void test ( ) { char * test ; test = run_length_encode ( \"aaaaaaabbbaaccccdefaadr\" ) ; assert ( ! strcmp ( test , \"7a3b2a4c1d1e1f2a1d1r\" ) ) ; free ( test ) ; test = run_length_encode ( \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\" ) ; assert ( ! strcmp ( test , \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1bq\" ) ) ; free ( test ) ; test = run_length_encode ( \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\" ) ; assert ( ! strcmp ( test , \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\" ) ) ; free ( test ) ; }",
    "resources/C/misc/run_length_encoding.c@main": "int main ( ) { test ( ) ; // run self-test implementations printf ( \"All tests have passed!\\n\" ) ; return 0 ; }",
    "resources/C/misc/poly_add.c@free_poly": "void free_poly ( struct term * poly ) { while ( poly ) { struct term * next = poly -> next ; free ( poly ) ; poly = next ; } }",
    "resources/C/misc/poly_add.c@create_polynomial": "void create_polynomial ( struct term * * poly , int coef , int pow ) { // Creating the polynomial using temporary linked lists struct term * * temp1 = poly ; while ( * temp1 ) { temp1 = & ( * temp1 ) -> next ; } // Now temp1 reaches to the end of the list * temp1 = ( struct term * ) malloc ( sizeof ( struct term ) ) ; // Create the term and linked as the tail ( * temp1 ) -> coef = coef ; ( * temp1 ) -> pow = pow ; ( * temp1 ) -> next = NULL ; }",
    "resources/C/misc/poly_add.c@poly_add": "void poly_add ( struct term * * pol , struct term * poly1 , struct term * poly2 ) { // Creating a temporary linked list to store the resultant polynomial struct term * temp = ( struct term * ) malloc ( sizeof ( struct term ) ) ; temp -> next = NULL ; * pol = temp ; //*pol always points to the 1st node of the resultant polynomial // Comparing the powers of the nodes of both the polynomials // until one gets exhausted while ( poly1 && poly2 ) { /* If the power of the first polynomial is greater than the power of the\n       second one place the power and coefficient of that node of the first\n       polynomial in temp and increase the pointer poly1\n       */ if ( poly1 -> pow > poly2 -> pow ) { temp -> coef = poly1 -> coef ; temp -> pow = poly1 -> pow ; poly1 = poly1 -> next ; } /* If the power of the second polynomial is greater than the power of\n          the first one place the power and coefficient of that node of the\n          second polynomial in temp and increase the pointer poly2\n        */ else if ( poly1 -> pow < poly2 -> pow ) { temp -> coef = poly2 -> coef ; temp -> pow = poly2 -> pow ; poly2 = poly2 -> next ; } /* If both of them have same power then sum the coefficients\n          place both the summed coefficient and the power in temp\n          increase both the pointers poly1 and poly2\n        */ else { temp -> coef = poly1 -> coef + poly2 -> coef ; temp -> pow = poly1 -> pow ; poly1 = poly1 -> next ; poly2 = poly2 -> next ; } /* If none of the polynomials are exhausted\n         dynamically create a node in temp\n         */ if ( poly1 && poly2 ) { temp -> next = ( struct term * ) malloc ( sizeof ( struct term ) ) ; // Dynamic node creation temp = temp -> next ; // Increase the pointer temp temp -> next = NULL ; } } /* If one of the polynomials is exhausted\n    place the rest of the other polynomial as it is in temp\n    by creating nodes dynamically\n    */ while ( poly1 || poly2 ) { temp -> next = ( struct term * ) malloc ( sizeof ( struct term ) ) ; // Dynamic node creation temp = temp -> next ; // Increasing the pointer temp -> next = NULL ; /* If poly1 is not exhausted\n        place rest of that polynomial in temp\n        */ if ( poly1 ) { temp -> coef = poly1 -> coef ; temp -> pow = poly1 -> pow ; poly1 = poly1 -> next ; } /* If poly2 is not exhausted\n       place rest of that polynomial in temp\n       */ else if ( poly2 ) { temp -> coef = poly2 -> coef ; temp -> pow = poly2 -> pow ; poly2 = poly2 -> next ; } } }",
    "resources/C/misc/poly_add.c@display_polynomial": "void display_polynomial ( struct term * poly ) { while ( poly != NULL ) { printf ( \"%d x^%d\" , poly -> coef , poly -> pow ) ; poly = poly -> next ; if ( poly != NULL ) { printf ( \" + \" ) ; } } }",
    "resources/C/misc/poly_add.c@test1": "static void test1 ( struct term * poly1 , struct term * poly2 , struct term * poly3 ) { printf ( \"\\n----Test 1----\\n\" ) ; printf ( \"\\nFirst Polynomial:\\n\" ) ; // Defining the 1st polynomial create_polynomial ( & poly1 , 5 , 2 ) ; create_polynomial ( & poly1 , 3 , 1 ) ; create_polynomial ( & poly1 , 2 , 0 ) ; display_polynomial ( poly1 ) ; printf ( \"\\nSecond Polynomial:\\n\" ) ; // Defining the 2nd polynomial create_polynomial ( & poly2 , 7 , 3 ) ; create_polynomial ( & poly2 , 9 , 1 ) ; create_polynomial ( & poly2 , 10 , 0 ) ; display_polynomial ( poly2 ) ; poly_add ( & poly3 , poly1 , poly2 ) ; // Adding the two polynomials printf ( \"\\nResultant polynomial:\\n\" ) ; display_polynomial ( poly3 ) ; printf ( \"\\n\" ) ; // Frees memory space free_poly ( poly1 ) ; free_poly ( poly2 ) ; free_poly ( poly3 ) ; }",
    "resources/C/misc/poly_add.c@test2": "static void test2 ( struct term * poly1 , struct term * poly2 , struct term * poly3 ) { printf ( \"\\n----Test 2----\\n\" ) ; printf ( \"\\nFirst Polynomial:\\n\" ) ; // Defining the 1st polynomial create_polynomial ( & poly1 , 3 , 5 ) ; create_polynomial ( & poly1 , 1 , 4 ) ; create_polynomial ( & poly1 , 2 , 3 ) ; create_polynomial ( & poly1 , - 2 , 1 ) ; create_polynomial ( & poly1 , 5 , 0 ) ; display_polynomial ( poly1 ) ; printf ( \"\\nSecond Polynomial:\\n\" ) ; // Defining the 2nd polynomial create_polynomial ( & poly2 , 2 , 5 ) ; create_polynomial ( & poly2 , 3 , 3 ) ; create_polynomial ( & poly2 , 7 , 1 ) ; create_polynomial ( & poly2 , 2 , 0 ) ; display_polynomial ( poly2 ) ; poly_add ( & poly3 , poly1 , poly2 ) ; // Adding the two polynomials printf ( \"\\nResultant polynomial:\\n\" ) ; display_polynomial ( poly3 ) ; printf ( \"\\n\" ) ; // Frees memory space free_poly ( poly1 ) ; free_poly ( poly2 ) ; free_poly ( poly3 ) ; }",
    "resources/C/misc/poly_add.c@test3": "static void test3 ( struct term * poly1 , struct term * poly2 , struct term * poly3 ) { printf ( \"\\n----Test 3----\\n\" ) ; printf ( \"\\nFirst Polynomial:\\n\" ) ; // Defining the 1st polynomial create_polynomial ( & poly1 , - 12 , 0 ) ; create_polynomial ( & poly1 , 8 , 1 ) ; create_polynomial ( & poly1 , 4 , 3 ) ; display_polynomial ( poly1 ) ; printf ( \"\\nSecond Polynomial:\\n\" ) ; // Defining the 2nd polynomial create_polynomial ( & poly2 , 5 , 0 ) ; create_polynomial ( & poly2 , - 13 , 1 ) ; create_polynomial ( & poly2 , 3 , 3 ) ; display_polynomial ( poly2 ) ; poly_add ( & poly3 , poly1 , poly2 ) ; // Adding the two polynomials printf ( \"\\nResultant polynomial:\\n\" ) ; display_polynomial ( poly3 ) ; printf ( \"\\n\" ) ; // Frees memory space free_poly ( poly1 ) ; free_poly ( poly2 ) ; free_poly ( poly3 ) ; }",
    "resources/C/misc/poly_add.c@main": "int main ( void ) { struct term * poly1 = NULL , * poly2 = NULL , * poly3 = NULL ; test1 ( poly1 , poly2 , poly3 ) ; test2 ( poly1 , poly2 , poly3 ) ; test3 ( poly1 , poly2 , poly3 ) ; return 0 ; }",
    "resources/C/misc/rselect.c@swap": "void swap ( int * a , int * b ) { int t ; t = * a ; * a = * b ; * b = t ; }",
    "resources/C/misc/rselect.c@part": "int part ( int a [ ] , int l , int r , int n , int pivot , int pindex ) { int p1 = l , p2 = r ; while ( p2 > p1 ) { if ( a [ p1 ] > pivot && a [ p2 ] < pivot ) { swap ( & a [ p1 ] , & a [ p2 ] ) ; } else { if ( a [ p1 ] <= pivot ) { p1 ++ ; } if ( a [ p2 ] >= pivot ) { p2 -- ; } } } swap ( & a [ pindex ] , & a [ p2 ] ) ; return p2 ; }",
    "resources/C/misc/rselect.c@rselect": "int rselect ( int a [ ] , int l , int r , int n , int o ) { int pivot , pindex , pactual ; if ( r > l ) { pindex = rand ( ) % ( r - l + 1 ) ; pivot = a [ pindex ] ; pactual = part ( a , l , r , n , pivot , pindex ) ; if ( pactual == o ) { return a [ pactual ] ; } if ( o < pactual ) { rselect ( a , l , pactual - 1 , n , o ) ; } if ( o > pactual ) { rselect ( a , pactual + 1 , r , n , o - pactual ) ; } } if ( r == l ) { return a [ l ] ; } return - 1 ; }",
    "resources/C/misc/rselect.c@main": "int main ( ) { srand ( time ( NULL ) ) ; int n , o , i , * a ; scanf ( \"%d %d\" , & n , & o ) ; a = ( int * ) malloc ( n * sizeof ( int ) ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , a + i ) ; } printf ( \"\\n\\n%d\" , rselect ( a , 0 , n - 1 , n , o ) ) ; return 0 ; }",
    "resources/C/misc/demonetization.c@ways": "int ways ( int n , int * a , int k ) { if ( n < 0 || k < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( k == 0 ) return 0 ; return ways ( n , a , k - 1 ) + ways ( n - a [ k - 1 ] , a , k ) ; }",
    "resources/C/misc/demonetization.c@main": "int main ( ) { int m ; int t ; int n ; printf ( \"Number of coins? \" ) ; scanf ( \"%d\" , & m ) ; int * coin = ( int * ) malloc ( m * sizeof ( int ) ) , i ; for ( i = 0 ; i < m ; i ++ ) { printf ( \"coin? \" ) ; scanf ( \"%d\" , & coin [ i ] ) ; } printf ( \"---- your requests --- \\n\" ) ; while ( 1 ) { printf ( \"amount? exit(0) \" ) ; scanf ( \"%d\" , & n ) ; if ( ! n ) { break ; } printf ( \"%d\\n\" , ways ( n , coin , m ) ) ; } free ( coin ) ; return 0 ; }",
    "resources/C/misc/shunting_yard.c@getPrecedence": "int getPrecedence ( char operator ) { switch ( operator ) { case '+' : case '-' : { return 1 ; } case '*' : case '/' : { return 2 ; } case '^' : { return 3 ; } default : { fprintf ( stderr , \"Error: Invalid operator\\n\" ) ; return - 1 ; } } }",
    "resources/C/misc/shunting_yard.c@getAssociativity": "int getAssociativity ( char operator ) { switch ( operator ) { case '^' : { return 0 ; } case '+' : case '-' : case '*' : case '/' : { return 1 ; } default : { fprintf ( stderr , \"Error: Invalid operator\\n\" ) ; return - 1 ; } } }",
    "resources/C/misc/shunting_yard.c@shuntingYard": "int shuntingYard ( const char * input , char * output ) { const unsigned int inputLength = strlen ( input ) ; char * operatorStack = ( char * ) malloc ( sizeof ( char ) * inputLength ) ; // This pointer points at where we should insert the next element, // Hence stackPointer - 1 is used when accessing elements unsigned int stackPointer = 0 ; // We will parse the input with strtok(), // Since strtok() is destructive, we make a copy of the input to preserve the original string char * str = malloc ( sizeof ( char ) * inputLength + 1 ) ; strcpy ( str , input ) ; char * token = strtok ( str , \" \" ) ; // We will push to output with strcat() and strncat(), // This initializes output to be a string with a length of zero output [ 0 ] = '\\0' ; while ( token != NULL ) { // If it's a number, push it to the output directly if ( isdigit ( token [ 0 ] ) ) { strcat ( output , token ) ; strcat ( output , \" \" ) ; token = strtok ( NULL , \" \" ) ; continue ; } switch ( token [ 0 ] ) { // If it's a left parenthesis, push it to the operator stack for later matching case '(' : { operatorStack [ stackPointer ++ ] = token [ 0 ] ; break ; } // If it's a right parenthesis, search for a left parenthesis to match it case ')' : { // Guard statement against accessing an empty stack if ( stackPointer < 1 ) { fprintf ( stderr , \"Error: Mismatched parentheses\\n\" ) ; free ( operatorStack ) ; free ( str ) ; return 1 ; } while ( operatorStack [ stackPointer - 1 ] != '(' ) { // strncat() with a count of 1 is used to append characters to output const unsigned int i = ( stackPointer -- ) - 1 ; strncat ( output , & operatorStack [ i ] , 1 ) ; strcat ( output , \" \" ) ; // If the operator stack is exhausted before a match can be found, // There must be a mismatch if ( stackPointer == 0 ) { fprintf ( stderr , \"Error: Mismatched parentheses\\n\" ) ; free ( operatorStack ) ; free ( str ) ; return 1 ; } } // Discards the parentheses now the matching is complete, // Simply remove the left parenthesis from the stack is enough, // Since the right parenthesis didn't enter the stack in the first place stackPointer -- ; break ; } // If it's an operator(o1), we compare it to whatever is at the top of the operator stack(o2) default : { // Places the operator into the stack directly if it's empty if ( stackPointer < 1 ) { operatorStack [ stackPointer ++ ] = token [ 0 ] ; break ; } // We need to check if there's actually a valid operator at the top of the stack if ( ( stackPointer - 1 > 0 ) && operatorStack [ stackPointer - 1 ] != '(' ) { const int precedence1 = getPrecedence ( token [ 0 ] ) ; const int precedence2 = getPrecedence ( operatorStack [ stackPointer - 1 ] ) ; const int associativity = getAssociativity ( token [ 0 ] ) ; // We pop operators from the stack, if... while ( // ... their precedences are equal, and o1 is left associative, ... ( ( associativity && precedence1 == precedence2 ) || // ... or o2 simply have a higher precedence, ... precedence2 > precedence1 ) && // ... and there are still operators available to be popped. ( ( stackPointer - 1 > 0 ) && operatorStack [ stackPointer - 1 ] != '(' ) ) { strncat ( output , & operatorStack [ ( stackPointer -- ) - 1 ] , 1 ) ; strcat ( output , \" \" ) ; } } // We'll save o1 for later operatorStack [ stackPointer ++ ] = token [ 0 ] ; break ; } } token = strtok ( NULL , \" \" ) ; } free ( str ) ; // Now all input has been exhausted, // Pop everything from the operator stack, then push them to the output while ( stackPointer > 0 ) { // If there are still leftover left parentheses in the stack, // There must be a mismatch if ( operatorStack [ stackPointer - 1 ] == '(' ) { fprintf ( stderr , \"Error: Mismatched parentheses\\n\" ) ; free ( operatorStack ) ; return 1 ; } const unsigned int i = ( stackPointer -- ) - 1 ; strncat ( output , & operatorStack [ i ] , 1 ) ; if ( i != 0 ) { strcat ( output , \" \" ) ; } } free ( operatorStack ) ; return 0 ; }",
    "resources/C/misc/shunting_yard.c@test": "static void test ( ) { char * in = malloc ( sizeof ( char ) * 50 ) ; char * out = malloc ( sizeof ( char ) * 50 ) ; int i ; strcpy ( in , \"3 + 4 * ( 2 - 1 )\" ) ; printf ( \"Infix: %s\\n\" , in ) ; i = shuntingYard ( in , out ) ; printf ( \"RPN: %s\\n\" , out ) ; printf ( \"Return code: %d\\n\\n\" , i ) ; assert ( strcmp ( out , \"3 4 2 1 - * +\" ) == 0 ) ; assert ( i == 0 ) ; strcpy ( in , \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\" ) ; printf ( \"Infix: %s\\n\" , in ) ; i = shuntingYard ( in , out ) ; printf ( \"RPN: %s\\n\" , out ) ; printf ( \"Return code: %d\\n\\n\" , i ) ; assert ( strcmp ( out , \"3 4 2 * 1 5 - 2 3 ^ ^ / +\" ) == 0 ) ; assert ( i == 0 ) ; printf ( \"Testing successfully completed!\\n\" ) ; free ( in ) ; free ( out ) ; }",
    "resources/C/misc/shunting_yard.c@main": "int main ( ) { test ( ) ; // Run self-test implementations return 0 ; }",
    "resources/C/misc/tower_of_hanoi.c@hanoi": "void hanoi ( int noOfDisks , char where , char to , char extra ) { if ( noOfDisks != 0 ) { hanoi ( noOfDisks - 1 , where , extra , to ) ; printf ( \"Move disk : %d from %c to %c\\n\" , noOfDisks , where , to ) ; hanoi ( noOfDisks - 1 , extra , to , where ) ; } }",
    "resources/C/misc/tower_of_hanoi.c@main": "int main ( void ) { int noOfDisks ; // Asks the number of disks in the tower printf ( \"Number of disks: \\n\" ) ; scanf ( \"%d\" , & noOfDisks ) ; hanoi ( noOfDisks , 'A' , 'B' , 'C' ) ; return 0 ; }",
    "resources/C/misc/longest_subsequence.c@longestSub": "void longestSub ( int * ARRAY , int ARRAY_LENGTH , int * * RESULT , int * RESULT_LENGTH ) { // RESULT and RESULT_LENGTH will be modified by their pointers if ( ARRAY_LENGTH <= 1 ) { * RESULT = ARRAY ; * RESULT_LENGTH = ARRAY_LENGTH ; } else { int PIVOT = ARRAY [ 0 ] ; int * LONGEST_SUB = NULL ; int i , j , LONGEST_SUB_LENGTH = 0 ; int TEMPORARY_ARRAY_LENGTH = 0 , * TEMPORARY_ARRAY = NULL ; for ( i = 1 ; i < ARRAY_LENGTH ; i ++ ) { if ( ARRAY [ i ] < PIVOT ) { TEMPORARY_ARRAY_LENGTH = 0 ; TEMPORARY_ARRAY = NULL ; for ( j = i + 1 ; j < ARRAY_LENGTH ; j ++ ) { if ( ARRAY [ j ] >= ARRAY [ i ] ) { TEMPORARY_ARRAY_LENGTH ++ ; TEMPORARY_ARRAY = ( int * ) realloc ( TEMPORARY_ARRAY , TEMPORARY_ARRAY_LENGTH * sizeof ( int ) ) ; TEMPORARY_ARRAY [ TEMPORARY_ARRAY_LENGTH - 1 ] = ARRAY [ j ] ; } } longestSub ( TEMPORARY_ARRAY , TEMPORARY_ARRAY_LENGTH , & TEMPORARY_ARRAY , & TEMPORARY_ARRAY_LENGTH ) ; if ( LONGEST_SUB_LENGTH < TEMPORARY_ARRAY_LENGTH + 1 ) { LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1 ; LONGEST_SUB = ( int * ) realloc ( LONGEST_SUB , LONGEST_SUB_LENGTH * sizeof ( int ) ) ; LONGEST_SUB [ 0 ] = ARRAY [ i ] ; for ( i = 1 ; i < LONGEST_SUB_LENGTH ; i ++ ) LONGEST_SUB [ i ] = TEMPORARY_ARRAY [ i - 1 ] ; } } } TEMPORARY_ARRAY = NULL ; TEMPORARY_ARRAY_LENGTH = 0 ; for ( i = 1 ; i < ARRAY_LENGTH ; i ++ ) { if ( ARRAY [ i ] >= PIVOT ) { TEMPORARY_ARRAY_LENGTH ++ ; TEMPORARY_ARRAY = ( int * ) realloc ( TEMPORARY_ARRAY , TEMPORARY_ARRAY_LENGTH * sizeof ( int ) ) ; TEMPORARY_ARRAY [ TEMPORARY_ARRAY_LENGTH - 1 ] = ARRAY [ i ] ; } } longestSub ( TEMPORARY_ARRAY , TEMPORARY_ARRAY_LENGTH , & TEMPORARY_ARRAY , & TEMPORARY_ARRAY_LENGTH ) ; if ( TEMPORARY_ARRAY_LENGTH + 1 > LONGEST_SUB_LENGTH ) { LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1 ; LONGEST_SUB = ( int * ) realloc ( LONGEST_SUB , LONGEST_SUB_LENGTH * sizeof ( int ) ) ; LONGEST_SUB [ 0 ] = PIVOT ; for ( i = 1 ; i < LONGEST_SUB_LENGTH ; i ++ ) LONGEST_SUB [ i ] = TEMPORARY_ARRAY [ i - 1 ] ; } * RESULT = LONGEST_SUB ; * RESULT_LENGTH = LONGEST_SUB_LENGTH ; } }",
    "resources/C/misc/longest_subsequence.c@main": "int main ( ) { int EXAMPLE_LENGTH = 8 ; int EXAMPLE [ ] = { 18 , 2 , 15 , 4 , 30 , 0 , 11 , 12 } ; int * RESULT = NULL ; int RESULT_LENGTH , i ; longestSub ( EXAMPLE , EXAMPLE_LENGTH , & RESULT , & RESULT_LENGTH ) ; printf ( \"Longest Sub Sequence length: %d and it's:\\n\" , RESULT_LENGTH ) ; for ( i = 0 ; i < RESULT_LENGTH ; i ++ ) printf ( \"%d \" , RESULT [ i ] ) ; printf ( \"\\n\" ) ; return 0 ; }",
    "resources/C/misc/pid.c@pid_step": "float pid_step ( struct pid * controller , float dt , float error ) { // Calculate p term float p = error * controller -> kP ; // Calculate i term controller -> integral += error * dt * controller -> kI ; // Calculate d term, taking care to not divide by zero float d = dt == 0 ? 0 : ( ( error - controller -> lastError ) / dt ) * controller -> kD ; controller -> lastError = error ; return p + controller -> integral + d ; }",
    "resources/C/misc/pid.c@main": "int main ( ) { printf ( \"PID Controller Example\\n\" ) ; struct pid controller = { . lastError = 0 , . integral = 0 } ; // Take the controller gains from the user printf ( \"Please enter controller gains in format kP, kI, KD. For example, \" \"\\\"1.2 2.1 3.2\\\"\\n> \" ) ; scanf ( \"%f %f %f\" , & controller . kP , & controller . kI , & controller . kD ) ; printf ( \"Using kP: %f, kI: %f, kD: %f\\n\" , controller . kP , controller . kI , controller . kD ) ; // How often the pid_step algorithm expects to be called. In a real life // scenario this would be provided by calling time(NULL) - last_time, or by // calling the function reliably at X Hz (using a timer or RTOS etc) For // demonstration of this algorithm though, it is defined below as 1 second, // allowing easy testing of integral and derivative terms. float time_step = 1 ; float error_value ; while ( 1 ) { printf ( \"Enter error value\\n>\" ) ; scanf ( \"%f\" , & error_value ) ; float output = pid_step ( & controller , time_step , error_value ) ; printf ( \"Output: %f\\n\" , output ) ; } }",
    "resources/C/misc/union_find.c@find": "int find ( int * p , int x ) { if ( x >= MAX_SIZE ) { fprintf ( stderr , \"Out-of bounds value\\n\" ) ; exit ( EXIT_FAILURE ) ; } if ( p [ x ] == x ) { return x ; } else { p [ x ] = find ( p , p [ x ] ) ; return p [ x ] ; } }",
    "resources/C/misc/union_find.c@join": "void join ( int * p , int x , int y ) { p [ find ( p , x ) ] = find ( p , y ) ; }",
    "resources/C/misc/union_find.c@main": "int main ( ) { int union_set [ MAX_SIZE ] ; // Have all array indexes that you need to use reference themselves for ( int i = 0 ; i < 10 ; i ++ ) { union_set [ i ] = i ; } // p = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} join ( union_set , 3 , 5 ) ; printf ( \"The array is now: \" ) ; for ( int i = 0 ; i < 10 ; i ++ ) { printf ( \"%d \" , union_set [ i ] ) ; } printf ( \"\\n\" ) ; // Now 3 and 5 are groupped together, that is find(3) = find(5) // p = {0, 1, 2, 5, 4, 5, 6, 7, 8, 9} join ( union_set , 3 , 8 ) ; printf ( \"The array is now: \" ) ; for ( int i = 0 ; i < 10 ; i ++ ) { printf ( \"%d \" , union_set [ i ] ) ; } printf ( \"\\n\" ) ; // Now 3, 5 and are groupped together, find(3) = find(5) = find(8) // p = {0, 1, 2, 5, 4, 8, 6, 7, 8, 9} join ( union_set , 0 , 5 ) ; if ( find ( union_set , 0 ) == find ( union_set , 3 ) ) { printf ( \"0 and 3 are groupped together\\n\" ) ; } printf ( \"The array is now: \" ) ; for ( int i = 0 ; i < 10 ; i ++ ) { printf ( \"%d \" , union_set [ i ] ) ; } printf ( \"\\n\" ) ; return 0 ; }",
    "resources/C/misc/sudoku_solver.c@OKrow": "",
    "resources/C/misc/sudoku_solver.c@OKcol": "",
    "resources/C/misc/sudoku_solver.c@OKbox": "",
    "resources/C/misc/sudoku_solver.c@OK": "",
    "resources/C/misc/sudoku_solver.c@print": "void print ( const struct sudoku * a ) { int i , j ; for ( i = 0 ; i < a -> N ; i ++ ) for ( j = 0 ; j < a -> N ; j ++ ) printf ( \"%\" SCNu8 \"%c\" , a -> a [ i * a -> N + j ] , ( j == a -> N - 1 ? '\\n' : ' ' ) ) ; }",
    "resources/C/misc/sudoku_solver.c@get_next_unknown": "",
    "resources/C/misc/sudoku_solver.c@solve": "",
    "resources/C/misc/sudoku_solver.c@test": "void test ( ) { printf ( \"Test begin...\\n\" ) ; uint8_t test_array [ ] = { 3 , 0 , 6 , 5 , 0 , 8 , 4 , 0 , 0 , 5 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 8 , 7 , 0 , 0 , 0 , 0 , 3 , 1 , 0 , 0 , 3 , 0 , 1 , 0 , 0 , 8 , 0 , 9 , 0 , 0 , 8 , 6 , 3 , 0 , 0 , 5 , 0 , 5 , 0 , 0 , 9 , 0 , 6 , 0 , 0 , 1 , 3 , 0 , 0 , 0 , 0 , 2 , 5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 4 , 0 , 0 , 5 , 2 , 0 , 6 , 3 , 0 , 0 } ; struct sudoku a = { . N = 9 , . N2 = 3 , . a = test_array } ; assert ( solve ( & a ) ) ; // ensure that solution is obtained uint8_t expected [ ] = { 3 , 1 , 6 , 5 , 7 , 8 , 4 , 9 , 2 , 5 , 2 , 9 , 1 , 3 , 4 , 7 , 6 , 8 , 4 , 8 , 7 , 6 , 2 , 9 , 5 , 3 , 1 , 2 , 6 , 3 , 4 , 1 , 5 , 9 , 8 , 7 , 9 , 7 , 4 , 8 , 6 , 3 , 1 , 2 , 5 , 8 , 5 , 1 , 7 , 9 , 2 , 6 , 4 , 3 , 1 , 3 , 8 , 9 , 4 , 7 , 2 , 5 , 6 , 6 , 9 , 2 , 3 , 5 , 1 , 8 , 7 , 4 , 7 , 4 , 5 , 2 , 8 , 6 , 3 , 1 , 9 } ; for ( int i = 0 ; i < a . N ; i ++ ) for ( int j = 0 ; j < a . N ; j ++ ) assert ( a . a [ i * a . N + j ] == expected [ i * a . N + j ] ) ; printf ( \"Test passed\\n\" ) ; }",
    "resources/C/misc/sudoku_solver.c@main": "int main ( ) { test ( ) ; struct sudoku a ; // store the matrix as a 1D array scanf ( \"%\" SCNu8 , & ( a . N ) ) ; a . a = ( uint8_t * ) malloc ( a . N * a . N * sizeof ( uint8_t ) ) ; a . N2 = ( uint8_t ) sqrt ( a . N ) ; for ( int i = 0 ; i < a . N ; i ++ ) for ( int j = 0 ; j < a . N ; j ++ ) scanf ( \"%\" SCNu8 , & ( a . a [ i * a . N + j ] ) ) ; printf ( \"Entered a %udx%ud matrix with block size: %\" SCNu8 \"\\n\" , a . N , a . N , a . N2 ) ; // print(&a); printf ( \"\\n\\n\" ) ; if ( solve ( & a ) ) printf ( \"Valid solution found!\\n\" ) ; else printf ( \"Invalid\\n\" ) ; print ( & a ) ; free ( a . a ) ; return 0 ; }",
    "resources/C/misc/mirror.c@main": "int main ( int argc , char * argv [ ] ) { char chaine [ 20 ] ; saisie ( chaine ) ; printf ( \"miroir est %s\" , miroir ( chaine ) ) ; }",
    "resources/C/misc/mirror.c@saisie": "void saisie ( char * cpointeur ) { printf ( \"saisir une chaine\\n\" ) ; scanf ( \"%s\" , cpointeur ) ; }",
    "resources/C/misc/mirror.c@miroir": "char * miroir ( char * s ) { int i ; char aux ; int k ; k = compte ( s ) - 1 ; i = 0 ; while ( i <= k ) { aux = s [ i ] ; s [ i ] = s [ k ] ; s [ k ] = aux ; k -- ; i ++ ; } return s ; }",
    "resources/C/misc/mirror.c@compte": "int compte ( char * s ) { char * p ; int k ; p = s ; k = 0 ; while ( * p != '\\0' ) { p ++ ; k ++ ; } return k ; }",
    "resources/C/misc/quartile.c@main": "int main ( ) { int a [ 10 ] , n , i , j , temp ; float q1 , q3 , iqr ; printf ( \"Enter no. for Random Numbers :\" ) ; scanf ( \"%d\" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = rand ( ) % 100 ; } printf ( \"Random Numbers Generated are :\\n\" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"\\n%d\" , a [ i ] ) ; } printf ( \"\\n\" ) ; printf ( \"\\nSorted Data:\" ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( a [ i ] < a [ j ] ) { temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; } } } for ( i = 0 ; i < n ; i ++ ) { printf ( \"\\n%d\" , a [ i ] ) ; } q1 = a [ n / 4 ] ; printf ( \"\\nFirst Quartile : %f\" , q1 ) ; q3 = a [ ( 3 * n ) / 4 ] ; printf ( \"\\nThird Quartile : %f\" , q3 ) ; iqr = q3 - q1 ; printf ( \"\\nInterQuartile Range is : %f\" , iqr ) ; return 0 ; }",
    "resources/C/misc/postfix_evaluation.c@push": "void push ( int8_t opd ) { if ( st . top == 19 ) { // overflow condition printf ( \"Stack overflow...\" ) ; exit ( 1 ) ; } st . top ++ ; st . stack [ st . top ] = opd ; }",
    "resources/C/misc/postfix_evaluation.c@pop": "int8_t pop ( ) { int8_t item ; ///< to store the popped value to be returned if ( st . top == - 1 ) { // underflow condition printf ( \"Stack underflow...\" ) ; exit ( 1 ) ; } item = st . stack [ st . top ] ; st . top -- ; return item ; }",
    "resources/C/misc/postfix_evaluation.c@evaluate": "int8_t evaluate ( char post [ ] ) { int8_t it1 ; int8_t it2 ; int8_t temp ; int8_t number ; int i ; for ( i = 0 ; i < strlen ( post ) ; i ++ ) { if ( post [ i ] == ' ' ) { continue ; // ignore delimiter } else if ( isdigit ( post [ i ] ) ) { number = 0 ; do { number = number * 10 + ( post [ i ] - '0' ) ; i ++ ; } while ( i < strlen ( post ) && isdigit ( post [ i ] ) ) ; push ( number ) ; } else { it2 = pop ( ) ; it1 = pop ( ) ; switch ( post [ i ] ) { case '+' : temp = it1 + it2 ; break ; case '-' : temp = it1 - it2 ; break ; case '*' : temp = it1 * it2 ; break ; case '/' : temp = it1 / it2 ; break ; case '%' : temp = it1 % it2 ; break ; default : printf ( \"Invalid operator\" ) ; exit ( 1 ) ; } push ( temp ) ; } } return pop ( ) ; }",
    "resources/C/misc/postfix_evaluation.c@test": "static void test ( ) { /* check sample test case\n\t   input: \"2 10 + 9 6 - /\"\n\t   expected output: 4\n\t */ char temp1 [ 50 ] = \"2 10 + 9 6 - /\" ; assert ( evaluate ( temp1 ) == 4 ) ; /// this ensures that the algorithm works as expected /* input: \"4 2 + 3 5 1 - * +\"\n\t   expected output: 18\n\t */ char temp2 [ 50 ] = \"4 2 + 3 5 1 - * +\" ; assert ( evaluate ( temp2 ) == 18 ) ; /// this ensures that the algorithm works as expected printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/misc/postfix_evaluation.c@main": "int main ( ) { st . top = - 1 ; /// initialize test ( ) ; /// run self-test implementations return 0 ; }",
    "resources/C/misc/hamming_distance.c@hamming_distance": "int hamming_distance ( char * str1 , char * str2 ) { int i = 0 , distance = 0 ; while ( str1 [ i ] != '\\0' ) { if ( str1 [ i ] != str2 [ i ] ) { distance ++ ; } i ++ ; } return distance ; }",
    "resources/C/misc/hamming_distance.c@test": "static void test ( ) { char str1 [ ] = \"karolin\" ; char str2 [ ] = \"kathrin\" ; assert ( hamming_distance ( str1 , str2 ) == 3 ) ; char str3 [ ] = \"00000\" ; char str4 [ ] = \"11111\" ; assert ( hamming_distance ( str3 , str4 ) == 5 ) ; printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/misc/hamming_distance.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@isLiteral": "int isLiteral ( const char ch ) { return ! ( ch == '(' || ch == ')' || ch == '*' || ch == '\\n' || ch == '|' ) ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@preProcessing": "char * preProcessing ( const char * input ) { const size_t len = strlen ( input ) ; if ( len == 0 ) { char * str = malloc ( 1 ) ; str [ 0 ] = '\\0' ; return str ; } char * str = malloc ( len * 2 ) ; size_t op = 0 ; for ( size_t i = 0 ; i < len - 1 ; ++ i ) { char c = input [ i ] ; str [ op ++ ] = c ; // one character lookahead char c1 = input [ i + 1 ] ; if ( ( isLiteral ( c ) && isLiteral ( c1 ) ) || ( isLiteral ( c ) && c1 == '(' ) || ( c == ')' && c1 == '(' ) || ( c == ')' && isLiteral ( c1 ) ) || ( c == '*' && isLiteral ( c1 ) ) || ( c == '*' && c1 == '(' ) ) { // '\\n' is used to represent concatenation // in this implementation str [ op ++ ] = '\\n' ; } } str [ op ++ ] = input [ len - 1 ] ; str [ op ] = '\\0' ; return str ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@indexOf": "size_t indexOf ( const char * str , char key ) { int depth = 0 ; for ( size_t i = 0 ; i < strlen ( str ) ; ++ i ) { const char c = str [ i ] ; if ( depth == 0 && c == key ) { return i ; } if ( c == '(' ) depth ++ ; if ( c == ')' ) depth -- ; } // Due to the way this function is intended to be used, // it's safe to assume the character will not appear as // the string's first character // thus `0` is used as the `not found` value return 0 ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@subString": "char * subString ( const char * str , size_t begin , size_t end ) { char * res = malloc ( end - begin + 2 ) ; strncpy ( res , str + begin , end - begin + 1 ) ; res [ end - begin + 1 ] = '\\0' ; return res ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@buildAST": "struct ASTNode * buildAST ( const char * input ) { struct ASTNode * node = createNode ( '\\0' ) ; node -> left = NULL ; node -> right = NULL ; const size_t len = strlen ( input ) ; size_t index ; // Empty input if ( len == 0 ) return node ; // Character literals if ( len == 1 ) { node -> content = input [ 0 ] ; return node ; } // Discard parentheses if ( input [ 0 ] == '(' && input [ len - 1 ] == ')' ) { char * temp = subString ( input , 1 , len - 2 ) ; destroyNode ( node ) ; node = buildAST ( temp ) ; free ( temp ) ; return node ; } // Union index = indexOf ( input , '|' ) ; if ( index ) { node -> content = '|' ; char * temp1 = subString ( input , 0 , index - 1 ) ; char * temp2 = subString ( input , index + 1 , len - 1 ) ; node -> left = buildAST ( temp1 ) ; node -> right = buildAST ( temp2 ) ; free ( temp2 ) ; free ( temp1 ) ; return node ; } // Concatenation index = indexOf ( input , '\\n' ) ; if ( index ) { node -> content = '\\n' ; char * temp1 = subString ( input , 0 , index - 1 ) ; char * temp2 = subString ( input , index + 1 , len - 1 ) ; node -> left = buildAST ( temp1 ) ; node -> right = buildAST ( temp2 ) ; free ( temp2 ) ; free ( temp1 ) ; return node ; } // Kleene star // Testing with indexOf() is unnecessary here, // Since all other possibilities have been exhausted node -> content = '*' ; char * temp = subString ( input , 0 , len - 2 ) ; node -> left = buildAST ( temp ) ; node -> right = NULL ; free ( temp ) ; return node ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@redirect": "void redirect ( struct NFA * nfa , struct NFAState * src , struct NFAState * dest ) { for ( int i = 0 ; i < nfa -> subCount ; ++ i ) { redirect ( nfa -> subs [ i ] , src , dest ) ; } for ( int i = 0 ; i < nfa -> ruleCount ; ++ i ) { struct transRule * rule = nfa -> rulePool [ i ] ; if ( rule -> target == src ) { rule -> target = dest ; } } }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@compileFromAST": "struct NFA * compileFromAST ( struct ASTNode * root ) { struct NFA * nfa = createNFA ( ) ; // Empty input if ( root -> content == '\\0' ) { addRule ( nfa , createRule ( nfa -> statePool [ 1 ] , '\\0' ) , 0 ) ; return nfa ; } // Character literals if ( isLiteral ( root -> content ) ) { addRule ( nfa , createRule ( nfa -> statePool [ 1 ] , root -> content ) , 0 ) ; return nfa ; } switch ( root -> content ) { case '\\n' : { struct NFA * ln = compileFromAST ( root -> left ) ; struct NFA * rn = compileFromAST ( root -> right ) ; // Redirects all rules targeting ln's accepting state to // target rn's starting state redirect ( ln , ln -> statePool [ 1 ] , rn -> statePool [ 0 ] ) ; // Manually creates and initializes a special // \"wrapper\" NFA destroyNFA ( nfa ) ; struct NFA * wrapper = malloc ( sizeof ( struct NFA ) ) ; wrapper -> stateCount = 2 ; wrapper -> statePool = malloc ( sizeof ( struct NFAState * ) * 2 ) ; wrapper -> subCount = 0 ; wrapper -> subs = malloc ( sizeof ( struct NFA * ) * 2 ) ; wrapper -> ruleCount = 0 ; wrapper -> rulePool = malloc ( sizeof ( struct transRule * ) * 3 ) ; wrapper -> CSCount = 0 ; wrapper -> currentStates = malloc ( sizeof ( struct NFAState * ) * 2 ) ; wrapper -> wrapperFlag = 1 ; wrapper -> subs [ wrapper -> subCount ++ ] = ln ; wrapper -> subs [ wrapper -> subCount ++ ] = rn ; // Maps the wrapper NFA's starting and ending states // to its sub NFAs wrapper -> statePool [ 0 ] = ln -> statePool [ 0 ] ; wrapper -> statePool [ 1 ] = rn -> statePool [ 1 ] ; return wrapper ; } case '|' : { struct NFA * ln = compileFromAST ( root -> left ) ; struct NFA * rn = compileFromAST ( root -> right ) ; nfa -> subs [ nfa -> subCount ++ ] = ln ; nfa -> subs [ nfa -> subCount ++ ] = rn ; // Adds empty character transition rules addRule ( nfa , createRule ( ln -> statePool [ 0 ] , '\\0' ) , 0 ) ; addRule ( ln , createRule ( nfa -> statePool [ 1 ] , '\\0' ) , 1 ) ; addRule ( nfa , createRule ( rn -> statePool [ 0 ] , '\\0' ) , 0 ) ; addRule ( rn , createRule ( nfa -> statePool [ 1 ] , '\\0' ) , 1 ) ; return nfa ; } case '*' : { struct NFA * ln = compileFromAST ( root -> left ) ; nfa -> subs [ nfa -> subCount ++ ] = ln ; addRule ( ln , createRule ( ln -> statePool [ 0 ] , '\\0' ) , 1 ) ; addRule ( nfa , createRule ( ln -> statePool [ 0 ] , '\\0' ) , 0 ) ; addRule ( ln , createRule ( nfa -> statePool [ 1 ] , '\\0' ) , 1 ) ; addRule ( nfa , createRule ( nfa -> statePool [ 1 ] , '\\0' ) , 0 ) ; return nfa ; } } // Fallback, shouldn't happen in normal operation destroyNFA ( nfa ) ; return NULL ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@addState": "void addState ( struct NFA * nfa , struct NFAState * state ) { nfa -> statePool [ nfa -> stateCount ++ ] = state ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@addRule": "void addRule ( struct NFA * nfa , struct transRule * rule , int loc ) { nfa -> rulePool [ nfa -> ruleCount ++ ] = rule ; struct NFAState * state = nfa -> statePool [ loc ] ; state -> rules [ state -> ruleCount ++ ] = rule ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@postProcessing": "void postProcessing ( struct NFA * nfa ) { // Since the sub NFA's states and rules are managed // through their own pools, recursion is necessary for ( int i = 0 ; i < nfa -> subCount ; ++ i ) { postProcessing ( nfa -> subs [ i ] ) ; } // If a state does not have any empty character accepting rule, // we add a rule that circles back to itself // So this state will be preserved when // empty characters are inputted for ( int i = 0 ; i < nfa -> stateCount ; ++ i ) { struct NFAState * pState = nfa -> statePool [ i ] ; int f = 0 ; for ( int j = 0 ; j < pState -> ruleCount ; ++ j ) { if ( pState -> rules [ j ] -> cond == '\\0' ) { f = 1 ; break ; } } if ( ! f ) { addRule ( nfa , createRule ( pState , '\\0' ) , i ) ; } } }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@contains": "int contains ( struct NFAState * * states , int len , struct NFAState * state ) { int f = 0 ; for ( int i = 0 ; i < len ; ++ i ) { if ( states [ i ] == state ) { f = 1 ; break ; } } return f ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@findEmpty": "void findEmpty ( struct NFAState * target , struct NFAState * * states , int * sc ) { for ( int i = 0 ; i < target -> ruleCount ; ++ i ) { const struct transRule * pRule = target -> rules [ i ] ; if ( pRule -> cond == '\\0' && ! contains ( states , * sc , pRule -> target ) ) { states [ ( * sc ) ++ ] = pRule -> target ; // the use of `states` and `sc` is necessary // to sync data across recursion levels findEmpty ( pRule -> target , states , sc ) ; } } }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@transit": "void transit ( struct NFA * nfa , char input ) { struct NFAState * * newStates = malloc ( sizeof ( struct NFAState * ) * 10 ) ; int NSCount = 0 ; if ( input == '\\0' ) { // In case of empty character input, it's possible for // a state to transit to another state that's more than // one rule away, we need to take that into account for ( int i = nfa -> CSCount - 1 ; i > - 1 ; -- i ) { struct NFAState * pState = nfa -> currentStates [ i ] ; nfa -> CSCount -- ; struct NFAState * * states = malloc ( sizeof ( struct NFAState * ) * 10 ) ; int sc = 0 ; findEmpty ( pState , states , & sc ) ; for ( int j = 0 ; j < sc ; ++ j ) { if ( ! contains ( newStates , NSCount , states [ j ] ) ) { newStates [ NSCount ++ ] = states [ j ] ; } } free ( states ) ; } } else { // Iterates through all current states for ( int i = nfa -> CSCount - 1 ; i > - 1 ; -- i ) { struct NFAState * pState = nfa -> currentStates [ i ] ; // Gradually empties the current states pool, so // it can be refilled nfa -> CSCount -- ; // Iterates through rules of this state for ( int j = 0 ; j < pState -> ruleCount ; ++ j ) { const struct transRule * pRule = pState -> rules [ j ] ; if ( pRule -> cond == input ) { if ( ! contains ( newStates , NSCount , pRule -> target ) ) { newStates [ NSCount ++ ] = pRule -> target ; } } } } } nfa -> CSCount = NSCount ; for ( int i = 0 ; i < NSCount ; ++ i ) { nfa -> currentStates [ i ] = newStates [ i ] ; } free ( newStates ) ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@isAccepting": "int isAccepting ( const struct NFA * nfa ) { for ( int i = 0 ; i < nfa -> CSCount ; ++ i ) { if ( nfa -> currentStates [ i ] == nfa -> statePool [ 1 ] ) { return 1 ; } } return 0 ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@testHelper": "void testHelper ( const char * regex , const char * string , const int expected ) { char * temp = preProcessing ( regex ) ; struct ASTNode * node = buildAST ( temp ) ; struct NFA * nfa = compileFromAST ( node ) ; postProcessing ( nfa ) ; // reallocates the outermost NFA's current states pool // because it will actually be used to store all the states nfa -> currentStates = realloc ( nfa -> currentStates , sizeof ( struct NFAState * ) * 100 ) ; // Starts the NFA by adding its starting state to the pool nfa -> currentStates [ nfa -> CSCount ++ ] = nfa -> statePool [ 0 ] ; // feeds empty characters into the NFA before and after // every normal character for ( size_t i = 0 ; i < strlen ( string ) ; ++ i ) { transit ( nfa , '\\0' ) ; transit ( nfa , string [ i ] ) ; } transit ( nfa , '\\0' ) ; assert ( isAccepting ( nfa ) == expected ) ; destroyNFA ( nfa ) ; destroyNode ( node ) ; free ( temp ) ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@test": "static void test ( void ) { testHelper ( \"(c|a*b)\" , \"c\" , 1 ) ; testHelper ( \"(c|a*b)\" , \"aab\" , 1 ) ; testHelper ( \"(c|a*b)\" , \"ca\" , 0 ) ; testHelper ( \"(c|a*b)*\" , \"caaab\" , 1 ) ; testHelper ( \"(c|a*b)*\" , \"caba\" , 0 ) ; testHelper ( \"\" , \"\" , 1 ) ; testHelper ( \"\" , \"1\" , 0 ) ; testHelper ( \"(0|(1(01*(00)*0)*1)*)*\" , \"11\" , 1 ) ; testHelper ( \"(0|(1(01*(00)*0)*1)*)*\" , \"110\" , 1 ) ; testHelper ( \"(0|(1(01*(00)*0)*1)*)*\" , \"1100\" , 1 ) ; testHelper ( \"(0|(1(01*(00)*0)*1)*)*\" , \"10000\" , 0 ) ; testHelper ( \"(0|(1(01*(00)*0)*1)*)*\" , \"00000\" , 1 ) ; printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@main": "int main ( void ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@createNode": "struct ASTNode * createNode ( const char content ) { struct ASTNode * node = malloc ( sizeof ( struct ASTNode ) ) ; node -> content = content ; node -> left = NULL ; node -> right = NULL ; return node ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@destroyNode": "void destroyNode ( struct ASTNode * node ) { if ( node -> left != NULL ) { destroyNode ( node -> left ) ; } if ( node -> right != NULL ) { destroyNode ( node -> right ) ; } free ( node ) ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@createRule": "struct transRule * createRule ( struct NFAState * state , char c ) { struct transRule * rule = malloc ( sizeof ( struct transRule ) ) ; rule -> target = state ; rule -> cond = c ; return rule ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@destroyRule": "void destroyRule ( struct transRule * rule ) { free ( rule ) ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@createState": "struct NFAState * createState ( void ) { struct NFAState * state = malloc ( sizeof ( struct NFAState ) ) ; state -> ruleCount = 0 ; state -> rules = malloc ( sizeof ( struct transRule * ) * 3 ) ; return state ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@destroyState": "void destroyState ( struct NFAState * state ) { free ( state -> rules ) ; free ( state ) ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@createNFA": "struct NFA * createNFA ( void ) { struct NFA * nfa = malloc ( sizeof ( struct NFA ) ) ; nfa -> stateCount = 0 ; nfa -> statePool = malloc ( sizeof ( struct NFAState * ) * 5 ) ; nfa -> ruleCount = 0 ; nfa -> rulePool = malloc ( sizeof ( struct transRule * ) * 10 ) ; nfa -> CSCount = 0 ; nfa -> currentStates = malloc ( sizeof ( struct NFAState * ) * 5 ) ; nfa -> subCount = 0 ; nfa -> subs = malloc ( sizeof ( struct NFA * ) * 5 ) ; nfa -> wrapperFlag = 0 ; addState ( nfa , createState ( ) ) ; addState ( nfa , createState ( ) ) ; return nfa ; }",
    "resources/C/misc/mcnaughton_yamada_thompson.c@destroyNFA": "void destroyNFA ( struct NFA * nfa ) { for ( int i = 0 ; i < nfa -> subCount ; ++ i ) { destroyNFA ( nfa -> subs [ i ] ) ; } // In case of a wrapper NFA, do not free its states // because it doesn't really have any states of its own if ( ! nfa -> wrapperFlag ) { for ( int i = 0 ; i < nfa -> stateCount ; ++ i ) { destroyState ( nfa -> statePool [ i ] ) ; } } for ( int i = 0 ; i < nfa -> ruleCount ; ++ i ) { destroyRule ( nfa -> rulePool [ i ] ) ; } free ( nfa -> statePool ) ; free ( nfa -> currentStates ) ; free ( nfa -> rulePool ) ; free ( nfa -> subs ) ; free ( nfa ) ; }",
    "resources/C/misc/lexicographic_permutations.c@swap": "void swap ( char * left , char * right ) { char temp = * left ; * left = * right ; * right = temp ; }",
    "resources/C/misc/lexicographic_permutations.c@compare": "int compare ( const void * a , const void * b ) { return ( * ( char * ) a - * ( char * ) b ) ; }",
    "resources/C/misc/lexicographic_permutations.c@PrintSortedPermutations": "void PrintSortedPermutations ( char * str ) { int strSize = strlen ( str ) ; qsort ( str , strSize , sizeof ( char ) , compare ) ; int largerPermFound = 1 ; do { // 1. Print permutation printf ( \"%s\\n\" , str ) ; // 2. Find rightmost char that is smaller than char to its right int i ; for ( i = strSize - 2 ; i >= 0 && str [ i ] >= str [ i + 1 ] ; -- i ) { } // if we couldn't find one, we're finished, else we can swap if ( i >= 0 ) { // 3. find character at index j such that str[j] = min(str[k]) && // str[k] > str[i] for all k > i int j = i + 1 , k ; for ( k = j ; k < strSize && str [ k ] ; k ++ ) { if ( str [ k ] > str [ i ] && str [ k ] < str [ j ] ) j = k ; } // 3. Swap chars at i and j swap ( & str [ i ] , & str [ j ] ) ; // 4. Sort string to the right of i qsort ( str + i + 1 , strSize - i - 1 , sizeof ( char ) , compare ) ; } else largerPermFound = 0 ; } while ( largerPermFound ) ; }",
    "resources/C/misc/lexicographic_permutations.c@main": "int main ( ) { int n ; // size of string scanf ( \"%d\\n\" , & n ) ; if ( n <= 0 || n >= 1000 ) { perror ( \"Input number out of range: >0 and <1000\\n\" ) ; return - 1 ; } char * str = ( char * ) malloc ( n * sizeof ( char ) ) ; scanf ( \"%s\" , str ) ; PrintSortedPermutations ( str ) ; free ( str ) ; return 0 ; }",
    "resources/C/client_server/tcp_half_duplex_server.c@error": "void error ( ) { perror ( \"Socket Creation Failed\" ) ; exit ( EXIT_FAILURE ) ; }",
    "resources/C/client_server/tcp_half_duplex_server.c@main": "int main ( ) { /** Variable Declarations */ uint32_t sockfd , conn ; ///< socket descriptors - Like file handles but for sockets char server_msg [ 10000 ] , client_msg [ 10000 ] ; ///< character arrays to read and store string data /// for communication struct sockaddr_in server_addr , client_addr ; ///< asic structures for all syscalls and functions that /// deal with internet addresses. Structures for handling /// internet addresses /**\n     * The TCP socket is created using the socket function\n     *\n     * AF_INET (Family) - it is an address family that is used to designate the\n     * type of addresses that your socket can communicate with\n     *\n     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides\n     * for the bidirectional, reliable, sequenced, and unduplicated flow of data\n     * without record boundaries. Aside from the bidirectionality of data flow,\n     * a pair of connected stream sockets provides an interface nearly identical\n     * to pipes\n     *\n     * 0 (Protocol) - Specifies a particular protocol to be used with the\n     * socket. Specifying a protocol of 0 causes socket() to use an unspecified\n     * default protocol appropriate for the requested socket type\n     */ if ( ( sockfd = socket ( AF_INET , SOCK_STREAM , 0 ) ) < 0 ) { error ( ) ; ///< Error if the socket descriptor has a value lower than 0 - /// socket wasnt created } /**\n     * Server Address Information\n     *\n     * The bzero() function erases the data in the n bytes of the memory\n     * starting at the location pointed to, by writing zeros (bytes\n     * containing '\\0') to that area\n     *\n     * We bind the server_addr to the internet address and port number thus\n     * giving our socket an identity with an address and port where it can\n     * listen for connections\n     *\n     * htons - The htons() function translates a short integer from host byte\n     * order to network byte order\n     *\n     * htonl - The htonl() function translates a long integer from host byte\n     * order to network byte order\n     *\n     * These functions are necessary so that the binding of address and port\n     * takes place with data in the correct format\n     */ bzero ( & server_addr , sizeof ( server_addr ) ) ; server_addr . sin_family = AF_INET ; /// Domain/Family to be used server_addr . sin_port = htons ( PORT ) ; /// Port to be used server_addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; printf ( \"Server is running...\\n\" ) ; /**\n     * This binds the socket descriptor to the server thus enabling the server\n     * to listen for connections and communicate with other clients\n     */ if ( bind ( sockfd , ( struct sockaddr * ) & server_addr , sizeof ( server_addr ) ) < 0 ) { error ( ) ; /// If binding is unsuccessful } /**\n     * This is to listen for clients or connections made to the server\n     *\n     * The limit is currently at 5 but can be increased to listen for\n     * more connections\n     *\n     * It listens to connections through the socket descriptor\n     */ listen ( sockfd , 5 ) ; printf ( \"Server is listening...\\n\" ) ; /**\n     * When a connection is found, a socket is created and connection is\n     * accepted and established through the socket descriptor\n     */ conn = accept ( sockfd , ( struct sockaddr * ) NULL , NULL ) ; printf ( \"Server is connected...\\n\" ) ; /**\n     * Communication between client and server\n     *\n     * The bzero() function erases the data in the n bytes of the memory\n     * starting at the location pointed to, by writing zeros (bytes\n     * containing '\\0') to that area. The variables are emptied and then\n     * ready for use\n     *\n     * First the SERVER is prompted to type a message which is read from\n     * stdin and then sent over the connection that was established - the socket\n     * - to be received by the client (send())\n     *\n     * The SERVER then waits for the client to reply. It then receives the reply\n     * in the string variable and displays it (recv())\n     *\n     * The server and client can communicate till one of them exits the\n     * connection\n     *\n     * Since the exchange of information between the server and client take\n     * place one at a time this represents HALF DUPLEX COMMUNICATION\n     */ while ( 1 ) { bzero ( & server_msg , sizeof ( server_msg ) ) ; bzero ( & client_msg , sizeof ( client_msg ) ) ; /// Send message printf ( \"\\nEnter message here: \" ) ; fgets ( server_msg , 10000 , stdin ) ; send ( conn , server_msg , strlen ( server_msg ) + 1 , 0 ) ; /// Receive Message recv ( conn , client_msg , sizeof ( client_msg ) , 0 ) ; printf ( \"\\nClient Message: %s\\n\" , client_msg ) ; } /// Close socket close ( sockfd ) ; printf ( \"Server is offline...\\n\" ) ; return 0 ; }",
    "resources/C/client_server/remote_command_exec_udp_server.c@error": "void error ( ) { perror ( \"Socket Creation Failed\" ) ; exit ( EXIT_FAILURE ) ; }",
    "resources/C/client_server/remote_command_exec_udp_server.c@main": "int main ( ) { /** Variable Declarations */ uint32_t sockfd ; ///< socket descriptors - Like file handles but for sockets char recv_msg [ 1024 ] , success_message [ ] = \"Command Executed Successfully!\\n\" ; ///< character arrays to read /// and store string data /// for communication & Success /// message struct sockaddr_in server_addr , client_addr ; ///< basic structures for all syscalls and functions that /// deal with internet addresses. Structures for handling /// internet addresses socklen_t clientLength = sizeof ( client_addr ) ; /// size of address /**\n     * The UDP socket is created using the socket function.\n     *\n     * AF_INET (Family) - it is an address family that is used to designate the\n     * type of addresses that your socket can communicate with\n     *\n     * SOCK_DGRAM (Type) - Indicates UDP Connection - UDP does not require the\n     * source and destination to establish a three-way handshake before\n     * transmission takes place. Additionally, there is no need for an\n     * end-to-end connection\n     *\n     * 0 (Protocol) - Specifies a particular protocol to be used with the\n     * socket. Specifying a protocol of 0 causes socket() to use an unspecified\n     * default protocol appropriate for the requested socket type.\n     */ if ( ( sockfd = socket ( AF_INET , SOCK_DGRAM , 0 ) ) < 0 ) { error ( ) ; } /**\n     * Server Address Information\n     *\n     * The bzero() function erases the data in the n bytes of the memory\n     * starting at the location pointed to, by writing zeros (bytes\n     * containing '\\0') to that area.\n     *\n     * We bind the server_addr to the internet address and port number thus\n     * giving our socket an identity with an address and port where it can\n     * listen for connections\n     *\n     * htons - The htons() function translates a short integer from host byte\n     * order to network byte order\n     *\n     * htonl - The htonl() function translates a long integer from host byte\n     * order to network byte order\n     *\n     * These functions are necessary so that the binding of address and port\n     * takes place with data in the correct format\n     */ bzero ( & server_addr , sizeof ( server_addr ) ) ; server_addr . sin_family = AF_INET ; server_addr . sin_port = htons ( PORT ) ; server_addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; /**\n     * This binds the socket descriptor to the server thus enabling the server\n     * to listen for connections and communicate with other clients\n     */ if ( bind ( sockfd , ( struct sockaddr * ) & server_addr , sizeof ( server_addr ) ) < 0 ) { error ( ) ; /// If binding is unsuccessful } printf ( \"Server is Connected Successfully...\\n\" ) ; /**\n     * Communication between client and server\n     *\n     * The bzero() function erases the data in the n bytes of the memory\n     * starting at the location pointed to, by writing zeros (bytes\n     * containing '\\0') to that area. The variables are emptied and then\n     * ready for use\n     *\n     * The server receives data from the client which is a command. It then\n     * executes the command.\n     *\n     * The client then receives a response from the server when the\n     * command has been executed\n     *\n     * The server and client can communicate indefinitely till one of them\n     * exits the connection\n     *\n     * The client sends the server a command which it executes thus showing\n     * remote command execution using UDP\n     */ while ( 1 ) { bzero ( recv_msg , sizeof ( recv_msg ) ) ; recvfrom ( sockfd , recv_msg , sizeof ( recv_msg ) , 0 , ( struct sockaddr * ) & client_addr , & clientLength ) ; printf ( \"Command Output: \\n\" ) ; system ( recv_msg ) ; printf ( \"Command Executed\\n\" ) ; sendto ( sockfd , success_message , sizeof ( success_message ) , 0 , ( struct sockaddr * ) & client_addr , clientLength ) ; } /// Close socket close ( sockfd ) ; printf ( \"Server is offline...\\n\" ) ; return 0 ; }",
    "resources/C/client_server/udp_server.c@main": "int main ( ) { # ifdef _WIN32 // when using winsock2.h, startup required WSADATA wsData ; if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsData ) != 0 ) { perror ( \"WSA Startup error: \\n\" ) ; return 0 ; } atexit ( cleanup ) ; // register at-exit function # endif int sockfd ; char buffer [ MAXLINE ] ; char * hello = \"Hello from server\" ; struct sockaddr_in servaddr , cliaddr ; // Creating socket file descriptor if ( ( sockfd = socket ( AF_INET , SOCK_DGRAM , 0 ) ) < 0 ) { perror ( \"socket creation failed\" ) ; exit ( EXIT_FAILURE ) ; } memset ( & servaddr , 0 , sizeof ( servaddr ) ) ; memset ( & cliaddr , 0 , sizeof ( cliaddr ) ) ; // Filling server information servaddr . sin_family = AF_INET ; // IPv4 servaddr . sin_addr . s_addr = INADDR_ANY ; servaddr . sin_port = htons ( PORT ) ; // Bind the socket with the server address if ( bind ( sockfd , ( const struct sockaddr * ) & servaddr , sizeof ( servaddr ) ) < 0 ) { perror ( \"bind failed\" ) ; exit ( EXIT_FAILURE ) ; } unsigned int len ; int n ; n = recvfrom ( sockfd , ( char * ) buffer , MAXLINE , MSG_WAITALL , ( struct sockaddr * ) & cliaddr , & len ) ; buffer [ n ] = '\\0' ; printf ( \"Client : %s\\n\" , buffer ) ; sendto ( sockfd , ( const char * ) hello , strlen ( hello ) , 0 , ( const struct sockaddr * ) & cliaddr , len ) ; printf ( \"Hello message sent.\\n\" ) ; close ( sockfd ) ; return 0 ; }",
    "resources/C/client_server/tcp_full_duplex_server.c@error": "void error ( ) { perror ( \"Socket Creation Failed\" ) ; exit ( EXIT_FAILURE ) ; }",
    "resources/C/client_server/tcp_full_duplex_server.c@main": "int main ( ) { /** Variable Declarations */ uint32_t sockfd , conn ; ///< socket descriptors - Like file handles but for sockets char recvbuff [ 1024 ] , sendbuff [ 1024 ] ; ///< character arrays to read and store string data /// for communication struct sockaddr_in server_addr , client_addr ; ///< basic structures for all syscalls and functions that /// deal with internet addresses. Structures for handling /// internet addresses socklen_t ClientLen ; /// size of address /**\n     * The TCP socket is created using the socket function\n     *\n     * AF_INET (Family) - it is an address family that is used to designate the\n     * type of addresses that your socket can communicate with\n     *\n     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides\n     * for the bidirectional, reliable, sequenced, and unduplicated flow of data\n     * without record boundaries. Aside from the bidirectionality of data flow,\n     * a pair of connected stream sockets provides an interface nearly identical\n     * to pipes\n     *\n     * 0 (Protocol) - Specifies a particular protocol to be used with the\n     * socket. Specifying a protocol of 0 causes socket() to use an unspecified\n     * default protocol appropriate for the requested socket type\n     */ if ( ( sockfd = socket ( AF_INET , SOCK_STREAM , 0 ) ) < 0 ) { error ( ) ; ///< Error if the socket descriptor has a value lower than 0 - /// socket wasnt created } /**\n     * Server Address Information\n     *\n     * The bzero() function erases the data in the n bytes of the memory\n     * starting at the location pointed to, by writing zeros (bytes\n     * containing '\\0') to that area\n     *\n     * We bind the server_addr to the internet address and port number thus\n     * giving our socket an identity with an address and port where it can\n     * listen for connections\n     *\n     * htons - The htons() function translates a short integer from host byte\n     * order to network byte order\n     *\n     * htonl - The htonl() function translates a long integer from host byte\n     * order to network byte order\n     *\n     * These functions are necessary so that the binding of address and port\n     * takes place with data in the correct format\n     */ bzero ( & server_addr , sizeof ( server_addr ) ) ; server_addr . sin_family = AF_INET ; server_addr . sin_port = htons ( PORT ) ; server_addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; printf ( \"Server is running...\\n\" ) ; /**\n     * This binds the socket descriptor to the server thus enabling the server\n     * to listen for connections and communicate with other clients\n     */ if ( bind ( sockfd , ( struct sockaddr * ) & server_addr , sizeof ( server_addr ) ) < 0 ) { error ( ) ; /// If binding is unsuccessful } /**\n     * This is to listen for clients or connections made to the server\n     *\n     * The limit is currently at 5 but can be increased to listen for\n     * more connections\n     *\n     * It listens to connections through the socket descriptor\n     */ listen ( sockfd , 5 ) ; printf ( \"Server is listening...\\n\" ) ; /**\n     * When a connection is found, a socket is created and connection is\n     * accepted and established through the socket descriptor\n     */ conn = accept ( sockfd , ( struct sockaddr * ) NULL , NULL ) ; printf ( \"Server is connected...\\n\" ) ; /**\n     * Communication between client and server\n     *\n     * The bzero() function erases the data in the n bytes of the memory\n     * starting at the location pointed to, by writing zeros (bytes\n     * containing '\\0') to that area. The variables are emptied and then\n     * ready for use\n     *\n     * The fork function call is used to create a child and parent process\n     * which run and execute code simultaneously\n     *\n     * The child process is used to receive data and after doing so\n     * sleeps for 5 seconds to wait for the parent to send data\n     *\n     * The parent process is used to send data and after doing so\n     * sleeps for 5 seconds to wait for the child to receive data\n     *\n     * The server and client can communicate indefinitely till one of them\n     * exits the connection\n     *\n     * Since the exchange of information between the server and client takes\n     * place simultaneously this represents FULL DUPLEX COMMUNICATION\n     */ pid_t pid ; # ifdef _WIN32 # ifdef FORK_WINDOWS pid = fork ( ) ; # endif # else pid = fork ( ) ; # endif if ( pid == 0 ) /// Value of 0 is for child process { while ( 1 ) { bzero ( & recvbuff , sizeof ( recvbuff ) ) ; recv ( conn , recvbuff , sizeof ( recvbuff ) , 0 ) ; printf ( \"\\nCLIENT : %s\\n\" , recvbuff ) ; sleep ( 5 ) ; // break; } } else /// Parent process { while ( 1 ) { bzero ( & sendbuff , sizeof ( sendbuff ) ) ; printf ( \"\\nType message here: \" ) ; fgets ( sendbuff , 1024 , stdin ) ; send ( conn , sendbuff , strlen ( sendbuff ) + 1 , 0 ) ; printf ( \"\\nMessage Sent!\\n\" ) ; sleep ( 5 ) ; // break; } } /// Close socket close ( sockfd ) ; printf ( \"Server is offline...\\n\" ) ; return 0 ; }",
    "resources/C/client_server/server.c@func": "void func ( int sockfd ) { char buff [ MAX ] ; int n ; // infinite loop for chat for ( ; ; ) { bzero ( buff , MAX ) ; // read the message from client and copy it in buffer read ( sockfd , buff , sizeof ( buff ) ) ; // print buffer which contains the client contents printf ( \"From client: %s\\t To client : \" , buff ) ; bzero ( buff , MAX ) ; n = 0 ; // copy server message in the buffer while ( ( buff [ n ++ ] = getchar ( ) ) != '\\n' ) { ; } // and send that buffer to client write ( sockfd , buff , sizeof ( buff ) ) ; // if msg contains \"Exit\" then server exit and chat ended. if ( strncmp ( \"exit\" , buff , 4 ) == 0 ) { printf ( \"Server Exit...\\n\" ) ; break ; } } }",
    "resources/C/client_server/server.c@main": "int main ( ) { # ifdef _WIN32 // when using winsock2.h, startup required WSADATA wsData ; if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsData ) != 0 ) { perror ( \"WSA Startup error: \\n\" ) ; return 0 ; } atexit ( cleanup ) ; // register at-exit function # endif int sockfd , connfd ; unsigned int len ; struct sockaddr_in servaddr , cli ; // socket create and verification sockfd = socket ( AF_INET , SOCK_STREAM , 0 ) ; if ( sockfd == - 1 ) { perror ( \"socket creation failed...\\n\" ) ; exit ( 0 ) ; } else { printf ( \"Socket successfully created..\\n\" ) ; } bzero ( & servaddr , sizeof ( servaddr ) ) ; // assign IP, PORT servaddr . sin_family = AF_INET ; servaddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; servaddr . sin_port = htons ( PORT ) ; // Binding newly created socket to given IP and verification if ( ( bind ( sockfd , ( SA * ) & servaddr , sizeof ( servaddr ) ) ) != 0 ) { perror ( \"socket bind failed...\\n\" ) ; exit ( 0 ) ; } else { printf ( \"Socket successfully binded..\\n\" ) ; } // Now server is ready to listen and verification if ( ( listen ( sockfd , 5 ) ) != 0 ) { perror ( \"Listen failed...\\n\" ) ; exit ( 0 ) ; } else { printf ( \"Server listening..\\n\" ) ; } len = sizeof ( cli ) ; // Accept the data packet from client and verification connfd = accept ( sockfd , ( SA * ) & cli , & len ) ; if ( connfd < 0 ) { perror ( \"server acccept failed...\\n\" ) ; exit ( 0 ) ; } else { printf ( \"server acccept the client...\\n\" ) ; } // Function for chatting between client and server func ( connfd ) ; // After chatting close the socket close ( sockfd ) ; return 0 ; }",
    "resources/C/client_server/client.c@func": "void func ( int sockfd ) { char buff [ MAX ] ; int n ; for ( ; ; ) { bzero ( buff , sizeof ( buff ) ) ; printf ( \"Enter the string : \" ) ; n = 0 ; while ( ( buff [ n ++ ] = getchar ( ) ) != '\\n' ) { ; } write ( sockfd , buff , sizeof ( buff ) ) ; bzero ( buff , sizeof ( buff ) ) ; read ( sockfd , buff , sizeof ( buff ) ) ; printf ( \"From Server : %s\" , buff ) ; if ( ( strncmp ( buff , \"exit\" , 4 ) ) == 0 ) { printf ( \"Client Exit...\\n\" ) ; break ; } } }",
    "resources/C/client_server/client.c@main": "int main ( ) { # ifdef _WIN32 // when using winsock2.h, startup required WSADATA wsData ; if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsData ) != 0 ) { perror ( \"WSA Startup error: \\n\" ) ; return 0 ; } atexit ( cleanup ) ; // register at-exit function # endif int sockfd , connfd ; struct sockaddr_in servaddr , cli ; // socket create and verification sockfd = socket ( AF_INET , SOCK_STREAM , 0 ) ; if ( sockfd == - 1 ) { printf ( \"socket creation failed...\\n\" ) ; exit ( 0 ) ; } else { printf ( \"Socket successfully created..\\n\" ) ; } bzero ( & servaddr , sizeof ( servaddr ) ) ; // assign IP, PORT servaddr . sin_family = AF_INET ; servaddr . sin_addr . s_addr = inet_addr ( \"127.0.0.1\" ) ; servaddr . sin_port = htons ( PORT ) ; // connect the client socket to server socket if ( connect ( sockfd , ( SA * ) & servaddr , sizeof ( servaddr ) ) != 0 ) { printf ( \"connection with the server failed...\\n\" ) ; exit ( 0 ) ; } else { printf ( \"connected to the server..\\n\" ) ; } // function for chat func ( sockfd ) ; // close the socket close ( sockfd ) ; return 0 ; }",
    "resources/C/client_server/tcp_full_duplex_client.c@error": "void error ( ) { perror ( \"Socket Creation Failed\" ) ; exit ( EXIT_FAILURE ) ; }",
    "resources/C/client_server/tcp_full_duplex_client.c@main": "int main ( ) { /** Variable Declarations */ uint32_t sockfd ; ///< socket descriptors - Like file handles but for sockets char sendbuff [ 1024 ] , recvbuff [ 1024 ] ; ///< character arrays to read and store string data /// for communication struct sockaddr_in server_addr ; ///< basic structures for all syscalls and functions that /// deal with internet addresses. Structures for handling /// internet addresses /**\n     * The TCP socket is created using the socket function.\n     *\n     * AF_INET (Family) - it is an address family that is used to designate the\n     * type of addresses that your socket can communicate with\n     *\n     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides\n     * for the bidirectional, reliable, sequenced, and unduplicated flow of data\n     * without record boundaries. Aside from the bidirectionality of data flow,\n     * a pair of connected stream sockets provides an interface nearly identical\n     * to pipes.\n     *\n     * 0 (Protocol) - Specifies a particular protocol to be used with the\n     * socket. Specifying a protocol of 0 causes socket() to use an unspecified\n     * default protocol appropriate for the requested socket type.\n     */ if ( ( sockfd = socket ( AF_INET , SOCK_STREAM , 0 ) ) < 0 ) { error ( ) ; } /**\n     * Server Address Information\n     *\n     * The bzero() function erases the data in the n bytes of the memory\n     * starting at the location pointed to, by writing zeros (bytes\n     * containing '\\0') to that area.\n     *\n     * We bind the server_addr to the internet address and port number thus\n     * giving our socket an identity with an address and port where it can\n     * listen for connections\n     *\n     * htons - The htons() function translates a short integer from host byte\n     * order to network byte order\n     *\n     * htonl - The htonl() function translates a long integer from host byte\n     * order to network byte order\n     *\n     * These functions are necessary so that the binding of address and port\n     * takes place with data in the correct format\n     */ bzero ( & server_addr , sizeof ( server_addr ) ) ; server_addr . sin_family = AF_INET ; server_addr . sin_port = htons ( PORT ) ; server_addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; printf ( \"Client is running...\\n\" ) ; /**\n     * Connects the client to the server address using the socket descriptor\n     * This enables the two to communicate and exchange data\n     */ connect ( sockfd , ( struct sockaddr * ) & server_addr , sizeof ( server_addr ) ) ; printf ( \"Client is connected...\\n\" ) ; /**\n     * Communication between client and server\n     *\n     * The bzero() function erases the data in the n bytes of the memory\n     * starting at the location pointed to, by writing zeros (bytes\n     * containing '\\0') to that area. The variables are emptied and then\n     * ready for use\n     *\n     * The fork function call is used to create a child and parent process\n     * which run and execute code simultaneously\n     *\n     * The child process is used to send data and after doing so\n     * sleeps for 5 seconds to wait for the parent to receive data\n     *\n     * The parent process is used to receive data and after doing so\n     * sleeps for 5 seconds to wait for the child to send data\n     *\n     * The server and client can communicate indefinitely till one of them\n     * exits the connection\n     *\n     * Since the exchange of information between the server and client takes\n     * place simultaneously this represents FULL DUPLEX COMMUNICATION\n     */ pid_t pid ; pid = fork ( ) ; if ( pid == 0 ) /// Value of 0 is for child process { while ( 1 ) { bzero ( & sendbuff , sizeof ( sendbuff ) ) ; printf ( \"\\nType message here: \" ) ; fgets ( sendbuff , 1024 , stdin ) ; send ( sockfd , sendbuff , strlen ( sendbuff ) + 1 , 0 ) ; printf ( \"\\nMessage sent!\\n\" ) ; sleep ( 5 ) ; // break; } } else /// Parent Process { while ( 1 ) { bzero ( & recvbuff , sizeof ( recvbuff ) ) ; recv ( sockfd , recvbuff , sizeof ( recvbuff ) , 0 ) ; printf ( \"\\nSERVER: %s\\n\" , recvbuff ) ; sleep ( 5 ) ; // break; } } /// Close Socket close ( sockfd ) ; printf ( \"Client is offline...\\n\" ) ; return 0 ; }",
    "resources/C/client_server/udp_client.c@main": "int main ( ) { # ifdef _WIN32 // when using winsock2.h, startup required WSADATA wsData ; if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsData ) != 0 ) { perror ( \"WSA Startup error: \\n\" ) ; return 0 ; } atexit ( cleanup ) ; // register at-exit function # endif int sockfd ; char buffer [ MAXLINE ] ; char * hello = \"Hello from client\" ; struct sockaddr_in servaddr ; // Creating socket file descriptor if ( ( sockfd = socket ( AF_INET , SOCK_DGRAM , 0 ) ) < 0 ) { perror ( \"socket creation failed\" ) ; exit ( EXIT_FAILURE ) ; } memset ( & servaddr , 0 , sizeof ( servaddr ) ) ; // Filling server information servaddr . sin_family = AF_INET ; servaddr . sin_port = htons ( PORT ) ; servaddr . sin_addr . s_addr = INADDR_ANY ; int n ; unsigned int len ; sendto ( sockfd , ( const char * ) hello , strlen ( hello ) , 0 , ( const struct sockaddr * ) & servaddr , sizeof ( servaddr ) ) ; printf ( \"Hello message sent.\\n\" ) ; n = recvfrom ( sockfd , ( char * ) buffer , MAXLINE , MSG_WAITALL , ( struct sockaddr * ) & servaddr , & len ) ; buffer [ n ] = '\\0' ; printf ( \"Server : %s\\n\" , buffer ) ; close ( sockfd ) ; return 0 ; }",
    "resources/C/client_server/remote_command_exec_udp_client.c@error": "void error ( ) { perror ( \"Socket Creation Failed\" ) ; exit ( EXIT_FAILURE ) ; }",
    "resources/C/client_server/remote_command_exec_udp_client.c@main": "int main ( ) { /** Variable Declarations */ uint32_t sockfd ; ///< socket descriptors - Like file handles but for sockets char send_msg [ 1024 ] , recv_msg [ 1024 ] ; ///< character arrays to read and store string data /// for communication struct sockaddr_in server_addr ; ///< basic structures for all syscalls and functions that /// deal with internet addresses. Structures for handling /// internet addresses socklen_t serverLength = sizeof ( server_addr ) ; ///< length of socket /**\n     * The UDP socket is created using the socket function.\n     *\n     * AF_INET (Family) - it is an address family that is used to designate the\n     * type of addresses that your socket can communicate with\n     *\n     * SOCK_DGRAM (Type) - Indicates UDP Connection - UDP does not require the\n     * source and destination to establish a three-way handshake before\n     * transmission takes place. Additionally, there is no need for an\n     * end-to-end connection\n     *\n     * 0 (Protocol) - Specifies a particular protocol to be used with the\n     * socket. Specifying a protocol of 0 causes socket() to use an unspecified\n     * default protocol appropriate for the requested socket type.\n     */ if ( ( sockfd = socket ( AF_INET , SOCK_DGRAM , 0 ) ) < 0 ) { error ( ) ; } /**\n     * Server Address Information\n     *\n     * The bzero() function erases the data in the n bytes of the memory\n     * starting at the location pointed to, by writing zeros (bytes\n     * containing '\\0') to that area.\n     *\n     * We bind the server_addr to the internet address and port number thus\n     * giving our socket an identity with an address and port where it can\n     * listen for connections\n     *\n     * htons - The htons() function translates a short integer from host byte\n     * order to network byte order\n     *\n     * htonl - The htonl() function translates a long integer from host byte\n     * order to network byte order\n     *\n     * These functions are necessary so that the binding of address and port\n     * takes place with data in the correct format\n     */ bzero ( & server_addr , sizeof ( server_addr ) ) ; server_addr . sin_family = AF_INET ; server_addr . sin_port = htons ( PORT ) ; server_addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; printf ( \"Client is running...\\n\" ) ; /**\n     * Connects the client to the server address using the socket descriptor\n     * This enables the two to communicate and exchange data\n     */ connect ( sockfd , ( struct sockaddr * ) & server_addr , sizeof ( server_addr ) ) ; printf ( \"Client is Connected Successfully...\\n\" ) ; /**\n     * Communication between client and server\n     *\n     * The client sends data to the server after taking the input\n     * from the user\n     *\n     * The client then receives a response from the server when the\n     * command has been executed\n     *\n     * The server and client can communicate indefinitely till one of them\n     * exits the connection\n     *\n     * The client sends the server a command which it executes thus showing\n     * remote command execution using UDP\n     */ while ( 1 ) { printf ( \"\\nEnter Command To Be Executed Remotely: \\n\" ) ; fgets ( send_msg , sizeof ( send_msg ) , stdin ) ; sendto ( sockfd , send_msg , sizeof ( send_msg ) , 0 , ( struct sockaddr * ) & server_addr , serverLength ) ; recvfrom ( sockfd , recv_msg , sizeof ( recv_msg ) , 0 , ( struct sockaddr * ) & server_addr , & serverLength ) ; printf ( \"Server Reply: %s\\n\" , recv_msg ) ; } /// Close Socket close ( sockfd ) ; printf ( \"Client is offline...\\n\" ) ; return 0 ; }",
    "resources/C/client_server/tcp_half_duplex_client.c@error": "void error ( ) { perror ( \"Socket Creation Failed\" ) ; exit ( EXIT_FAILURE ) ; }",
    "resources/C/client_server/tcp_half_duplex_client.c@main": "int main ( ) { /** Variable Declarations */ uint32_t sockfd ; ///< socket descriptors - Like file handles but for sockets struct sockaddr_in server_addr ; ///< basic structures for all syscalls and functions that /// deal with internet addresses. Structures for handling /// internet addresses char serverResponse [ 10000 ] , clientResponse [ 10000 ] ; ///< Character arrays to read and store string /// data for communication /**\n     * The TCP socket is created using the socket function.\n     *\n     * AF_INET (Family) - it is an address family that is used to designate the\n     * type of addresses that your socket can communicate with\n     *\n     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides\n     * for the bidirectional, reliable, sequenced, and unduplicated flow of data\n     * without record boundaries. Aside from the bidirectionality of data flow,\n     * a pair of connected stream sockets provides an interface nearly identical\n     * to pipes.\n     *\n     * 0 (Protocol) - Specifies a particular protocol to be used with the\n     * socket. Specifying a protocol of 0 causes socket() to use an unspecified\n     * default protocol appropriate for the requested socket type.\n     */ if ( ( sockfd = socket ( AF_INET , SOCK_STREAM , 0 ) ) < 0 ) { error ( ) ; } /**\n     * Server Address Information\n     *\n     * The bzero() function erases the data in the n bytes of the memory\n     * starting at the location pointed to, by writing zeros (bytes\n     * containing '\\0') to that area.\n     *\n     * We bind the server_addr to the internet address and port number thus\n     * giving our socket an identity with an address and port where it can\n     * listen for connections\n     *\n     * htons - The htons() function translates a short integer from host byte\n     * order to network byte order\n     *\n     * htonl - The htonl() function translates a long integer from host byte\n     * order to network byte order\n     *\n     * These functions are necessary so that the binding of address and port\n     * takes place with data in the correct format\n     */ bzero ( & server_addr , sizeof ( server_addr ) ) ; server_addr . sin_family = AF_INET ; server_addr . sin_port = htons ( PORT ) ; server_addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; printf ( \"Client is running...\\n\" ) ; /**\n     * Connects the client to the server address using the socket descriptor\n     * This enables the two to communicate and exchange data\n     */ connect ( sockfd , ( struct sockaddr * ) & server_addr , sizeof ( server_addr ) ) ; printf ( \"Client is connected...\\n\" ) ; /**\n     * Communication between client and server\n     *\n     * The bzero() function erases the data in the n bytes of the memory\n     * starting at the location pointed to, by writing zeros (bytes\n     * containing '\\0') to that area. The variables are emptied and then\n     * ready for use\n     *\n     * First the CLIENT receives the servers message and displays it (recv())\n     *\n     * The CLIENT is then prompted to type in a message and send it to the\n     * server. (send())\n     *\n     * The server and client can communicate till one of them exits the\n     * connection\n     *\n     * Since the exchange of information between the server and client take\n     * place one at a time this represents HALF DUPLEX COMMUNICATION\n     */ while ( 1 ) { bzero ( & serverResponse , sizeof ( serverResponse ) ) ; bzero ( & clientResponse , sizeof ( clientResponse ) ) ; /// Receive Message recv ( sockfd , serverResponse , sizeof ( serverResponse ) , 0 ) ; printf ( \"\\nServer message: %s \\n\" , serverResponse ) ; /// Send Message printf ( \"\\nEnter message here: \" ) ; fgets ( clientResponse , 10000 , stdin ) ; send ( sockfd , clientResponse , strlen ( clientResponse ) + 1 , 0 ) ; } /// Close Socket close ( sockfd ) ; printf ( \"Client is offline...\\n\" ) ; return 0 ; }",
    "resources/C/data_structures/stack.c@main": "int main ( int argc , char const * argv [ ] ) { int x , y , z ; create ( ) ; push ( 4 ) ; x = pop ( ) ; // 4. Count: 0. Empty: 1. printf ( \"%d.\\t\\tCount: %d.\\tEmpty: %d.\\n\" , x , size ( ) , isEmpty ( ) ) ; push ( 1 ) ; push ( 2 ) ; push ( 3 ) ; x = pop ( ) ; y = pop ( ) ; // 3, 2. Count: 1. Empty: 0; printf ( \"%d, %d.\\t\\tCount: %d.\\tEmpty: %d.\\n\" , x , y , size ( ) , isEmpty ( ) ) ; pop ( ) ; // Empty the stack. push ( 5 ) ; push ( 6 ) ; x = peek ( ) ; push ( 7 ) ; y = pop ( ) ; push ( 8 ) ; z = pop ( ) ; // 1, 6, 7, 8. Count: 2. Empty: 0. printf ( \"%d, %d, %d.\\tCount: %d.\\tEmpty: %d.\\n\" , x , y , z , size ( ) , isEmpty ( ) ) ; return 0 ; }",
    "resources/C/data_structures/stack.c@create": "void create ( ) { head = NULL ; }",
    "resources/C/data_structures/stack.c@push": "void push ( int x ) { if ( head == NULL ) { head = ( struct node * ) malloc ( 1 * sizeof ( struct node ) ) ; head -> next = NULL ; head -> pre = NULL ; head -> data = x ; } else { tmp = ( struct node * ) malloc ( 1 * sizeof ( struct node ) ) ; tmp -> data = x ; tmp -> next = NULL ; tmp -> pre = head ; head -> next = tmp ; head = tmp ; } ++ count ; }",
    "resources/C/data_structures/stack.c@pop": "int pop ( ) { int returnData ; if ( head == NULL ) { printf ( \"ERROR: Pop from empty stack.\\n\" ) ; exit ( 1 ) ; } else { returnData = head -> data ; if ( head -> pre == NULL ) { free ( head ) ; head = NULL ; } else { head = head -> pre ; free ( head -> next ) ; } } -- count ; return returnData ; }",
    "resources/C/data_structures/stack.c@peek": "int peek ( ) { if ( head != NULL ) return head -> data ; else { printf ( \"ERROR: Peeking from empty stack.\" ) ; exit ( 1 ) ; } }",
    "resources/C/data_structures/stack.c@size": "int size ( ) { return count ; }",
    "resources/C/data_structures/stack.c@isEmpty": "int isEmpty ( ) { if ( count == 0 ) return 1 ; return 0 ; }",
    "resources/C/data_structures/array/carray_tests.c@CArrayTests": "int CArrayTests ( ) { printf ( \"\\n\" ) ; printf ( \" +-------------------------------------+\\n\" ) ; printf ( \" |                                     |\\n\" ) ; printf ( \" |               C Array               |\\n\" ) ; printf ( \" |                                     |\\n\" ) ; printf ( \" +-------------------------------------+\\n\" ) ; printf ( \"\\n\" ) ; CArray * array = getCArray ( 10 ) ; int i ; for ( i = 0 ; i < array -> size ; i ++ ) { insertValueCArray ( array , i , i + 1 ) ; } printf ( \"Entered array is:\\n\" ) ; displayCArray ( array ) ; printf ( \"\\nCode: %d\\n\" , pushValueCArray ( array , 11 ) ) ; // 5 for ( i = 0 ; i < array -> size ; i ++ ) { removeValueCArray ( array , i ) ; } displayCArray ( array ) ; printf ( \"\\nCode: %d\" , removeValueCArray ( array , - 1 ) ) ; // 1 printf ( \"\\nCode: %d\\n\" , insertValueCArray ( array , - 1 , 1 ) ) ; // 1 // Erase for ( i = 0 ; i < array -> size ; i ++ ) { insertValueCArray ( array , i , i + 1 ) ; } eraseCArray ( array ) ; displayCArray ( array ) ; // Should give all 0s // Switching CArray * arr = getCArray ( 13 ) ; for ( i = 0 ; i < arr -> size ; i ++ ) { insertValueCArray ( arr , i , i + 1 ) ; } displayCArray ( arr ) ; for ( i = 0 ; i < arr -> size / 2 ; i ++ ) { switchValuesCArray ( arr , i , arr -> size - i - 1 ) ; } displayCArray ( arr ) ; // Or simply... reverseCArray ( arr ) ; displayCArray ( arr ) ; // Sorting srand ( time ( NULL ) ) ; CArray * barray = getCArray ( 20 ) ; for ( i = 0 ; i < barray -> size ; i ++ ) { insertValueCArray ( barray , i , rand ( ) ) ; } CArray * carray = getCopyCArray ( barray ) ; CArray * darray = getCopyCArray ( barray ) ; printf ( \"\\nNot sorted Array:\" ) ; displayCArray ( barray ) ; printf ( \"\\nBubble Sort:\" ) ; clock_t begin1 = clock ( ) ; // Timing bubble sort bubbleSortCArray ( barray ) ; clock_t end1 = clock ( ) ; double time_spent1 = ( double ) ( end1 - begin1 ) / CLOCKS_PER_SEC ; displayCArray ( barray ) ; printf ( \"\\nSelection Sort:\" ) ; clock_t begin2 = clock ( ) ; // Timing selection sort selectionSortCArray ( carray ) ; clock_t end2 = clock ( ) ; double time_spent2 = ( double ) ( end2 - begin2 ) / CLOCKS_PER_SEC ; displayCArray ( carray ) ; printf ( \"\\nInsertion Sort:\" ) ; clock_t begin3 = clock ( ) ; // Timing insertion sort insertionSortCArray ( darray ) ; clock_t end3 = clock ( ) ; double time_spent3 = ( double ) ( end3 - begin3 ) / CLOCKS_PER_SEC ; displayCArray ( carray ) ; // Descending order reverseCArray ( barray ) ; // displayCArray(barray); //\tprintf(\"\\nBlender:\"); //\tblenderCArray(barray); //\tdisplayCArray(barray); printf ( \"\\nTotal time spent for bubble sort: %lf seconds\" , time_spent1 ) ; printf ( \"\\nTotal time spent for selection sort: %lf seconds\" , time_spent2 ) ; printf ( \"\\nTotal time spent for insertion sort: %lf seconds\" , time_spent3 ) ; // Searching CArray * aarray = getCArray ( 1000 ) ; for ( i = 0 ; i < aarray -> size ; i ++ ) { insertValueCArray ( aarray , i , rand ( ) % 100 ) ; } int j = 24 ; printf ( \"\\nOccurrences of the number %d in the array: %d\" , j , valueOcurranceCArray ( aarray , j ) ) ; printf ( \"\\nAnd its positions:\\n\" ) ; CArray * positions = valuePositionsCArray ( aarray , j ) ; displayCArray ( positions ) ; // This should all give value of j printf ( \"\\nAll %d s\" , j ) ; for ( i = 0 ; i < positions -> size ; i ++ ) { printf ( \"\\nPosition %d has a value of %d\" , positions -> array [ i ] , aarray -> array [ positions -> array [ i ] ] ) ; } printf ( \"\\nThe list has a minimum value of %d and a maximum value of %d\" , findMinCArray ( aarray ) , findMaxCArray ( aarray ) ) ; insertionSortCArray ( aarray ) ; // displayCArray(aarray); free ( arr ) ; free ( array ) ; free ( aarray ) ; free ( barray ) ; free ( carray ) ; free ( darray ) ; printf ( \"\\n\" ) ; return 0 ; }",
    "resources/C/data_structures/array/carray.c@getCArray": "CArray * getCArray ( int size ) { CArray * array = ( CArray * ) malloc ( sizeof ( CArray ) ) ; array -> array = ( int * ) malloc ( sizeof ( int ) * size ) ; array -> size = size ; int i ; for ( i = 0 ; i < size ; i ++ ) { array -> array [ i ] = 0 ; } return array ; }",
    "resources/C/data_structures/array/carray.c@insertValueCArray": "int insertValueCArray ( CArray * array , int position , int value ) { if ( position >= 0 && position < array -> size ) { if ( array -> array [ position ] == 0 ) { array -> array [ position ] = value ; return SUCCESS ; } else return POSITION_INIT ; } return INVALID_POSITION ; }",
    "resources/C/data_structures/array/carray.c@removeValueCArray": "int removeValueCArray ( CArray * array , int position ) { if ( position >= 0 && position < array -> size ) { if ( array -> array [ position ] != 0 ) { array -> array [ position ] = 0 ; } else return POSITION_EMPTY ; } return INVALID_POSITION ; }",
    "resources/C/data_structures/array/carray.c@pushValueCArray": "int pushValueCArray ( CArray * array , int value ) { int i ; int ok = 0 ; for ( i = 0 ; i < array -> size ; i ++ ) { if ( array -> array [ i ] == 0 ) { array -> array [ i ] = value ; ok = 1 ; break ; } } if ( ok == 1 ) return SUCCESS ; else return ARRAY_FULL ; }",
    "resources/C/data_structures/array/carray.c@updateValueCArray": "int updateValueCArray ( CArray * array , int position , int value ) { if ( position >= 0 && position < array -> size ) { if ( array -> array [ position ] != 0 ) { array -> array [ position ] = value ; return SUCCESS ; } else return POSITION_NOT_INIT ; } return INVALID_POSITION ; }",
    "resources/C/data_structures/array/carray.c@eraseCArray": "int eraseCArray ( CArray * array ) { int i ; for ( i = 0 ; i < array -> size ; i ++ ) { array -> array [ i ] = 0 ; } return 0 ; }",
    "resources/C/data_structures/array/carray.c@switchValuesCArray": "int switchValuesCArray ( CArray * array , int position1 , int position2 ) { if ( position1 >= 0 && position1 < array -> size && position2 >= 0 && position2 < array -> size ) { int temp = array -> array [ position1 ] ; array -> array [ position1 ] = array -> array [ position2 ] ; array -> array [ position2 ] = temp ; return SUCCESS ; } return INVALID_POSITION ; }",
    "resources/C/data_structures/array/carray.c@reverseCArray": "int reverseCArray ( CArray * array ) { int i ; for ( i = 0 ; i < array -> size / 2 ; i ++ ) { swap ( array , i , array -> size - i - 1 ) ; } return SUCCESS ; }",
    "resources/C/data_structures/array/carray.c@displayCArray": "int displayCArray ( CArray * array ) { int i ; printf ( \"\\nC ARRAY\\n\" ) ; for ( i = 0 ; i < array -> size ; i ++ ) { printf ( \"%d \" , array -> array [ i ] ) ; } printf ( \"\\n\" ) ; return 0 ; }",
    "resources/C/data_structures/array/carray.c@blenderCArray": "int blenderCArray ( CArray * array ) { srand ( time ( NULL ) * array -> size ) ; int i ; int total = array -> size * 100 ; for ( i = 0 ; i < total ; i ++ ) { swap ( array , rand ( ) % array -> size , rand ( ) % array -> size ) ; } return 0 ; }",
    "resources/C/data_structures/array/carray.c@getCopyCArray": "CArray * getCopyCArray ( CArray * arr ) { CArray * array = ( CArray * ) malloc ( sizeof ( CArray ) ) ; array -> array = ( int * ) malloc ( sizeof ( int ) * arr -> size ) ; array -> size = arr -> size ; int i ; for ( i = 0 ; i < arr -> size ; i ++ ) { array -> array [ i ] = arr -> array [ i ] ; } return array ; }",
    "resources/C/data_structures/array/carray.c@swap": "void swap ( CArray * array , int position1 , int position2 ) { int temp = array -> array [ position1 ] ; array -> array [ position1 ] = array -> array [ position2 ] ; array -> array [ position2 ] = temp ; }",
    "resources/C/data_structures/array/carray.c@bubbleSortCArray": "int bubbleSortCArray ( CArray * array ) { int i , j ; for ( i = 0 ; i < array -> size - 1 ; i ++ ) { for ( j = 0 ; j < array -> size - i - 1 ; j ++ ) { if ( array -> array [ j ] > array -> array [ j + 1 ] ) { swap ( array , j , j + 1 ) ; } } } return 0 ; }",
    "resources/C/data_structures/array/carray.c@selectionSortCArray": "int selectionSortCArray ( CArray * array ) { int i , j , min ; for ( i = 0 ; i < array -> size - 1 ; i ++ ) { min = i ; for ( j = i + 1 ; j < array -> size ; j ++ ) if ( array -> array [ j ] < array -> array [ min ] ) min = j ; swap ( array , min , i ) ; } return 0 ; }",
    "resources/C/data_structures/array/carray.c@insertionSortCArray": "int insertionSortCArray ( CArray * array ) { int i , j , num ; for ( i = 1 ; i < array -> size ; i ++ ) { num = array -> array [ i ] ; j = i - 1 ; while ( j >= 0 && array -> array [ j ] > num ) { array -> array [ j + 1 ] = array -> array [ j ] ; j -- ; } array -> array [ j + 1 ] = num ; } return 0 ; }",
    "resources/C/data_structures/array/carray.c@valueOcurranceCArray": "int valueOcurranceCArray ( CArray * array , int value ) { int i , total = 0 ; for ( i = 0 ; i < array -> size ; i ++ ) { if ( array -> array [ i ] == value ) total ++ ; } return total ; }",
    "resources/C/data_structures/array/carray.c@valuePositionsCArray": "CArray * valuePositionsCArray ( CArray * array , int value ) { int i , j = 0 ; int total = valueOcurranceCArray ( array , value ) ; CArray * resultArray = getCArray ( total ) ; for ( i = 0 ; i < array -> size ; i ++ ) { if ( array -> array [ i ] == value ) { // Hopefully this won't overflow resultArray -> array [ j ] = i ; j ++ ; } } return resultArray ; }",
    "resources/C/data_structures/array/carray.c@findMinCArray": "int findMinCArray ( CArray * array ) { int i ; int min = array -> array [ 0 ] ; for ( i = 1 ; i < array -> size ; i ++ ) { if ( array -> array [ i ] < min ) { min = array -> array [ i ] ; } } return min ; }",
    "resources/C/data_structures/array/carray.c@findMaxCArray": "int findMaxCArray ( CArray * array ) { int i ; int max = array -> array [ 0 ] ; for ( i = 1 ; i < array -> size ; i ++ ) { if ( array -> array [ i ] > max ) { max = array -> array [ i ] ; } } return max ; }",
    "resources/C/data_structures/vector.c@init": "void init ( Vector * vec , int val ) { vec -> contents = ( int * ) malloc ( sizeof ( int ) ) ; vec -> contents [ 0 ] = val ; vec -> current = 0 ; vec -> len = 1 ; }",
    "resources/C/data_structures/vector.c@delete": "void delete ( Vector * vec ) { free ( vec -> contents ) ; }",
    "resources/C/data_structures/vector.c@clear": "void clear ( Vector * vec ) { delete ( vec ) ; init ( vec , 0 ) ; }",
    "resources/C/data_structures/vector.c@len": "int len ( Vector * vec ) { return vec -> len ; }",
    "resources/C/data_structures/vector.c@push": "void push ( Vector * vec , int val ) { vec -> contents = realloc ( vec -> contents , ( sizeof ( int ) * ( vec -> len + 1 ) ) ) ; vec -> contents [ vec -> len ] = val ; vec -> len ++ ; }",
    "resources/C/data_structures/vector.c@get": "int get ( Vector * vec , int index ) { if ( index < vec -> len ) { return vec -> contents [ index ] ; } return - 1 ; }",
    "resources/C/data_structures/vector.c@set": "void set ( Vector * vec , int index , int val ) { if ( index < vec -> len ) { vec -> contents [ index ] = val ; } }",
    "resources/C/data_structures/vector.c@next": "int next ( Vector * vec ) { if ( vec -> current == vec -> len ) { vec -> current = 0 ; } int current_val = vec -> contents [ vec -> current ] ; vec -> current ++ ; return current_val ; }",
    "resources/C/data_structures/vector.c@begin": "void * begin ( Vector * vec ) { return ( void * ) vec -> contents ; }",
    "resources/C/data_structures/vector.c@print": "void print ( Vector * vec ) { int size = vec -> len ; printf ( \"[ \" ) ; for ( int count = 0 ; count < size ; count ++ ) { printf ( \"%d \" , vec -> contents [ count ] ) ; } printf ( \"]\\n\" ) ; }",
    "resources/C/data_structures/vector.c@test": "static void test ( ) { Vector vec ; init ( & vec , 10 ) ; assert ( get ( & vec , 0 ) == 10 ) ; push ( & vec , 20 ) ; assert ( get ( & vec , 1 ) == 20 ) ; set ( & vec , 0 , 11 ) ; assert ( get ( & vec , 0 ) == 11 ) ; assert ( next ( & vec ) == 11 ) ; set ( & vec , 1 , 22 ) ; assert ( get ( & vec , 1 ) == 22 ) ; assert ( len ( & vec ) == 2 ) ; }",
    "resources/C/data_structures/vector.c@main": "int main ( ) { test ( ) ; Vector vec ; init ( & vec , 10 ) ; push ( & vec , 20 ) ; print ( & vec ) ; set ( & vec , 0 , 11 ) ; set ( & vec , 1 , 22 ) ; print ( & vec ) ; printf ( \"Length: %d\\n\" , len ( & vec ) ) ; return 0 ; }",
    "resources/C/data_structures/hash_set/hash_set.c@init_hash_set": "extern hash_set_t * init_hash_set ( ) { hash_set_t * set = ( hash_set_t * ) malloc ( sizeof ( hash_set_t ) ) ; set -> keys = calloc ( DEFAULT_HASH_SET_CAPACITY , sizeof ( void * * ) ) ; set -> values = calloc ( DEFAULT_HASH_SET_CAPACITY , sizeof ( void * * ) ) ; set -> length = 0 ; set -> capacity = DEFAULT_HASH_SET_CAPACITY ; return set ; }",
    "resources/C/data_structures/hash_set/hash_set.c@add": "unsigned add ( hash_set_t * set , void * value ) { return put ( set , hash ( value ) , value ) ; }",
    "resources/C/data_structures/hash_set/hash_set.c@put": "unsigned put ( hash_set_t * set , long long hash , void * value ) { if ( contains_hash ( set , hash ) ) { if ( set -> keys [ retrieve_index_from_hash ( hash , set -> capacity ) ] == value ) { return 0 ; } // collision resize ( set ) ; return put ( set , hash , value ) ; } set -> keys [ retrieve_index_from_hash ( hash , set -> capacity ) ] = value ; set -> values [ set -> length ++ ] = value ; return 1 ; }",
    "resources/C/data_structures/hash_set/hash_set.c@contains": "int contains ( hash_set_t * set , void * value ) { return set -> keys [ retrieve_index_from_hash ( hash ( value ) , set -> capacity ) ] == value ? 1 : 0 ; }",
    "resources/C/data_structures/hash_set/hash_set.c@contains_hash": "int contains_hash ( hash_set_t * set , long long hash ) { return set -> keys [ retrieve_index_from_hash ( hash , set -> capacity ) ] ? 1 : 0 ; }",
    "resources/C/data_structures/hash_set/hash_set.c@delete": "void delete ( hash_set_t * set , void * value ) { set -> keys [ retrieve_index_from_hash ( hash ( value ) , set -> capacity ) ] = NULL ; }",
    "resources/C/data_structures/hash_set/hash_set.c@hash": "long long hash ( void * value ) { char * str = value ; int a = 1 ; int b = 0 ; const int MODADLER = 65521 ; for ( int i = 0 ; str [ i ] != '\\0' ; i ++ ) { a = ( a + str [ i ] ) % MODADLER ; b = ( b + a ) % MODADLER ; } return ( b << 16 ) | a ; }",
    "resources/C/data_structures/hash_set/hash_set.c@retrieve_index_from_hash": "unsigned retrieve_index_from_hash ( const long long hash , const unsigned capacity ) { return ( capacity - 1 ) & ( hash ^ ( hash >> 12 ) ) ; }",
    "resources/C/data_structures/hash_set/hash_set.c@resize": "void resize ( hash_set_t * set ) { void * * keys_resized = calloc ( ( set -> capacity <<= 1 ) , sizeof ( void * * ) ) ; for ( int i = 0 ; i < set -> length ; i ++ ) { keys_resized [ retrieve_index_from_hash ( hash ( set -> values [ i ] ) , set -> capacity ) ] = set -> values [ i ] ; } free ( set -> keys ) ; set -> keys = keys_resized ; void * * new_values = ( void * * ) realloc ( set -> values , set -> capacity * sizeof ( void * * ) ) ; set -> values = new_values ; }",
    "resources/C/data_structures/hash_set/main.c@main": "int main ( ) { hash_set_t * set = init_hash_set ( ) ; int v1 = 10 , v2 = 20 , v3 = 30 , v4 = 40 , v5 = 50 , v6 = 60 , v7 = 70 ; printf ( \"Value %d was add ? %d\\n\" , v1 , add ( set , & v1 ) ) ; printf ( \"Value %d was add ? %d\\n\" , v1 , add ( set , & v1 ) ) ; printf ( \"contains %d ? %d\\n\" , v1 , contains ( set , & v1 ) ) ; printf ( \"Value %d was add ? %d\\n\" , v2 , add ( set , & v2 ) ) ; printf ( \"Value %d was add ? %d\\n\" , v2 , add ( set , & v2 ) ) ; printf ( \"contains %d ? %d\\n\" , v2 , contains ( set , & v2 ) ) ; printf ( \"Value %d was add ? %d\\n\" , v3 , add ( set , & v3 ) ) ; printf ( \"Value %d is add ? %d\\n\" , v3 , add ( set , & v3 ) ) ; printf ( \"contains %d ? %d\\n\" , v3 , contains ( set , & v3 ) ) ; printf ( \"Value %d was add ? %d\\n\" , v4 , add ( set , & v4 ) ) ; printf ( \"Value %d was add ? %d\\n\" , v4 , add ( set , & v4 ) ) ; printf ( \"contains %d ? %d\\n\" , v4 , contains ( set , & v4 ) ) ; printf ( \"Value %d was add ? %d\\n\" , v5 , add ( set , & v5 ) ) ; printf ( \"Value %d was add ? %d\\n\" , v5 , add ( set , & v5 ) ) ; printf ( \"contains %d ? %d\\n\" , v5 , contains ( set , & v5 ) ) ; printf ( \"Value %d is add ? %d\\n\" , v6 , add ( set , & v6 ) ) ; printf ( \"Value %d is add ? %d\\n\" , v6 , add ( set , & v6 ) ) ; printf ( \"contains %d ? %d\\n\" , v6 , contains ( set , & v6 ) ) ; printf ( \"contains %d ? %d\\n\" , v7 , contains ( set , & v7 ) ) ; delete ( set , & v6 ) ; printf ( \"contains %d ? %d\\n\" , v6 , contains ( set , & v6 ) ) ; return 0 ; }",
    "resources/C/data_structures/linked_list/circular_linked_list.c@create": "void create ( ) { int i , n ; struct node * pnode , * p ; printf ( \"Enter the number of nodes required:\\n\" ) ; scanf ( \"%d\" , & n ) ; printf ( \"Enter the data value of each node:\\n\" ) ; for ( i = 1 ; i <= n ; i ++ ) { pnode = ( struct node * ) malloc ( sizeof ( struct node ) ) ; if ( pnode == NULL ) { printf ( \"Memory overflow. Unable to create.\\n\" ) ; return ; } scanf ( \"%d\" , & pnode -> data ) ; if ( first == NULL ) first = last = pnode ; else { last -> next = pnode ; last = pnode ; /* last keeps track of last node */ } last -> next = first ; } }",
    "resources/C/data_structures/linked_list/circular_linked_list.c@deletenode": "void deletenode ( int k ) { struct node * p , * follow ; /* searching the required node */ p = first ; follow = NULL ; while ( follow != last ) { if ( p -> data == k ) break ; follow = p ; p = p -> next ; } if ( follow == last ) printf ( \"Required node not found.\\n\" ) ; else { if ( p == first && p == last ) /* deleting the one and the only node */ first = last = NULL ; else if ( p == first ) /* deleting the first node */ { first = first -> next ; last -> next = first ; } else if ( p == last ) /* deleting the last node */ { last = follow ; last -> next = first ; } else /* deleting any other node */ follow -> next = p -> next ; free ( p ) ; } }",
    "resources/C/data_structures/linked_list/circular_linked_list.c@traverse": "void traverse ( ) { struct node * p , * follow ; if ( first == NULL ) printf ( \"Circularly Linked List Empty\" ) ; else { printf ( \"Circularly Linked List is as shown: \\n\" ) ; p = first ; follow = NULL ; while ( follow != last ) { printf ( \"%d \" , p -> data ) ; follow = p ; p = p -> next ; } printf ( \"\\n\" ) ; } }",
    "resources/C/data_structures/linked_list/circular_linked_list.c@main": "void main ( ) { int x , k , ch ; clrscr ( ) ; do { printf ( \"\\n Menu: \\n\" ) ; printf ( \"1:Create Linked List \\n\" ) ; printf ( \"2:Delete Node \\n\" ) ; printf ( \"3:Traverse \\n\" ) ; printf ( \"4:Exit \\n\" ) ; printf ( \"\\nEnter your choice: \" ) ; scanf ( \"%d\" , & ch ) ; switch ( ch ) { case 1 : create ( ) ; break ; case 2 : printf ( \"Enter the data value of the node to be deleted: \" ) ; scanf ( \"%d\" , & k ) ; deletenode ( k ) ; break ; case 3 : traverse ( ) ; break ; case 4 : break ; } } while ( ch != 4 ) ; getch ( ) ; }",
    "resources/C/data_structures/linked_list/ascending_priority_queue.c@createqueue": "void createqueue ( ) { front = rear = NULL ; }",
    "resources/C/data_structures/linked_list/ascending_priority_queue.c@empty": "int empty ( ) { if ( front == NULL ) return 1 ; else return 0 ; }",
    "resources/C/data_structures/linked_list/ascending_priority_queue.c@insert": "void insert ( int x ) { struct node * pnode ; pnode = ( struct node * ) malloc ( sizeof ( struct node ) ) ; if ( pnode == NULL ) { printf ( \"Memory overflow. Unable to insert.\\n\" ) ; exit ( 1 ) ; } pnode -> data = x ; pnode -> next = NULL ; /* New node is always last node */ if ( empty ( ) ) front = rear = pnode ; else { rear -> next = pnode ; rear = pnode ; } }",
    "resources/C/data_structures/linked_list/ascending_priority_queue.c@removes": "int removes ( ) { int min ; struct node * follow , * follow1 , * p , * p1 ; if ( empty ( ) ) { printf ( \"\\nQueue Underflow. Unable to remove.\" ) ; exit ( 1 ) ; } /* finding the node with minimum value in the APQ.*/ p = p1 = front ; follow = follow1 = NULL ; min = front -> data ; while ( p != NULL ) { if ( p -> data < min ) { min = p -> data ; follow1 = follow ; p1 = p ; } follow = p ; p = p -> next ; } /* Deleting the node with min value */ if ( p1 == front ) /* deleting first node.*/ { front = front -> next ; if ( front == NULL ) /* Deleting the only one node */ rear = NULL ; } else if ( p1 == rear ) /* Deleting last node */ { rear = follow1 ; rear -> next = NULL ; } else /* deleting any other node.*/ follow1 -> next = p1 -> next ; free ( p1 ) ; return min ; /* DONT FORGET LAST 2 STATEMENTS.*/ }",
    "resources/C/data_structures/linked_list/ascending_priority_queue.c@show": "void show ( ) { struct node * p ; if ( empty ( ) ) printf ( \"Queue empty. No data to display \\n\" ) ; else { printf ( \"Queue from front to rear is as shown: \\n\" ) ; p = front ; while ( p != NULL ) { printf ( \"%d \" , p -> data ) ; p = p -> next ; } printf ( \"\\n\" ) ; } }",
    "resources/C/data_structures/linked_list/ascending_priority_queue.c@destroyqueue": "void destroyqueue ( ) { front = rear = NULL ; }",
    "resources/C/data_structures/linked_list/ascending_priority_queue.c@main": "int main ( ) { int x , ch ; createqueue ( ) ; do { printf ( \"\\n\\n  Menu: \\n\" ) ; printf ( \"1:Insert \\n\" ) ; printf ( \"2:Remove \\n\" ) ; printf ( \"3:exit \\n\" ) ; printf ( \"Enter your choice: \" ) ; scanf ( \"%d\" , & ch ) ; switch ( ch ) { case 1 : printf ( \"Enter element to be inserted: \" ) ; scanf ( \"%d\" , & x ) ; insert ( x ) ; show ( ) ; break ; case 2 : x = removes ( ) ; printf ( \"Element removed is: %d\\n\" , x ) ; show ( ) ; break ; case 3 : break ; } } while ( ch != 3 ) ; destroyqueue ( ) ; return 0 ; }",
    "resources/C/data_structures/linked_list/queue_linked_list.c@createqueue": "void createqueue ( ) { q . front = q . rear = NULL ; }",
    "resources/C/data_structures/linked_list/queue_linked_list.c@empty": "int empty ( ) { if ( q . front == NULL ) return 1 ; else return 0 ; }",
    "resources/C/data_structures/linked_list/queue_linked_list.c@insert": "void insert ( int x ) { struct node * pnode ; pnode = ( struct node * ) malloc ( sizeof ( struct node ) ) ; if ( pnode == NULL ) { printf ( \"Memory overflow. Unable to insert.\\n\" ) ; exit ( 1 ) ; } pnode -> data = x ; pnode -> next = NULL ; /* New node is always last node */ if ( empty ( ) ) q . front = q . rear = pnode ; else { ( q . rear ) -> next = pnode ; q . rear = pnode ; } }",
    "resources/C/data_structures/linked_list/queue_linked_list.c@removes": "int removes ( ) { int x ; struct node * p ; if ( empty ( ) ) { printf ( \"Queue Underflow. Unable to remove.\\n\" ) ; exit ( 1 ) ; } p = q . front ; x = ( q . front ) -> data ; q . front = ( q . front ) -> next ; if ( q . front == NULL ) /* Queue contained only one node */ q . rear = NULL ; free ( p ) ; return x ; }",
    "resources/C/data_structures/linked_list/queue_linked_list.c@show": "void show ( ) { struct node * p ; if ( empty ( ) ) printf ( \"Queue empty. No data to display \\n\" ) ; else { printf ( \"Queue from front to rear is as shown: \\n\" ) ; p = q . front ; while ( p != NULL ) { printf ( \"%d \" , p -> data ) ; p = p -> next ; } printf ( \"\\n\" ) ; } }",
    "resources/C/data_structures/linked_list/queue_linked_list.c@destroyqueue": "void destroyqueue ( ) { q . front = q . rear = NULL ; }",
    "resources/C/data_structures/linked_list/queue_linked_list.c@main": "int main ( ) { int x , ch ; createqueue ( ) ; do { printf ( \"\\n\\n  Menu: \\n\" ) ; printf ( \"1:Insert \\n\" ) ; printf ( \"2:Remove \\n\" ) ; printf ( \"3:exit \\n\" ) ; printf ( \"Enter your choice: \" ) ; scanf ( \"%d\" , & ch ) ; switch ( ch ) { case 1 : printf ( \"Enter element to be inserted: \" ) ; scanf ( \"%d\" , & x ) ; insert ( x ) ; show ( ) ; break ; case 2 : x = removes ( ) ; printf ( \"Element removed is: %d\\n\" , x ) ; show ( ) ; break ; case 3 : break ; } } while ( ch != 3 ) ; destroyqueue ( ) ; return 0 ; }",
    "resources/C/data_structures/linked_list/doubly_linked_list.c@main": "int main ( ) { // examples for better understanding example ( ) ; // code here return 0 ; }",
    "resources/C/data_structures/linked_list/doubly_linked_list.c@create": "List * create ( double value ) { List * new_list = ( List * ) malloc ( sizeof ( List ) ) ; new_list -> value = value ; new_list -> next = NULL ; new_list -> prev = NULL ; return new_list ; }",
    "resources/C/data_structures/linked_list/doubly_linked_list.c@insert": "List * insert ( List * list , double value , int pos ) { // list NULL case if ( list == NULL ) { list = create ( value ) ; return list ; } // position existing case if ( pos > 0 ) { List * cpy = list , * tmp = cpy ; int flag = 1 , index = 1 , size = 0 ; while ( tmp != NULL ) { size ++ ; tmp = tmp -> next ; } // first position case if ( pos == 1 ) { List * new_node = create ( value ) ; new_node -> next = cpy ; cpy -> prev = new_node ; list = new_node ; return list ; } // position existing in list range case if ( size + 2 > pos ) { while ( cpy -> next != NULL && index < pos ) { flag ++ ; index ++ ; cpy = cpy -> next ; } List * new_node = ( List * ) malloc ( sizeof ( List ) ) ; new_node -> value = value ; // position into list with no poiting for NULL if ( flag == pos ) { cpy -> prev -> next = new_node ; new_node -> next = cpy ; new_node -> prev = cpy -> prev ; cpy -> prev = new_node ; } // last position case if ( flag < pos ) { new_node -> next = cpy -> next ; new_node -> prev = cpy ; cpy -> next = new_node ; } } return list ; } }",
    "resources/C/data_structures/linked_list/doubly_linked_list.c@delete": "List * delete ( List * list , int pos ) { // list NULL case if ( list == NULL ) return list ; // position existing case if ( pos > 0 ) { List * cpy = list , * tmp = cpy ; int flag = 1 , index = 1 , size = 0 ; while ( tmp != NULL ) { size ++ ; tmp = tmp -> next ; } // first position case if ( pos == 1 ) { if ( size == 1 ) return NULL ; cpy = cpy -> next ; cpy -> prev = NULL ; return cpy ; } // position existing in list range case if ( size + 2 > pos ) { while ( cpy -> next != NULL && index < pos ) { flag ++ ; index ++ ; cpy = cpy -> next ; } if ( flag == pos ) { // position into list with no poiting for NULL if ( cpy -> next != NULL ) { cpy -> prev -> next = cpy -> next ; cpy -> next -> prev = cpy -> prev ; } // last position case else cpy -> prev -> next = NULL ; } } return list ; } }",
    "resources/C/data_structures/linked_list/doubly_linked_list.c@search": "int search ( List * list , double value ) { if ( list == NULL ) return 0 ; if ( list -> value == value ) return 1 ; search ( list -> next , value ) ; }",
    "resources/C/data_structures/linked_list/doubly_linked_list.c@print": "void print ( List * list ) { if ( list != NULL ) { printf ( \"%f\\t\" , list -> value ) ; print ( list -> next ) ; } }",
    "resources/C/data_structures/linked_list/doubly_linked_list.c@example": "void example ( ) { List * my_list = NULL ; double node_value = 0 ; int searching ; my_list = create ( node_value ) ; my_list = insert ( my_list , 3 , 1 ) ; my_list = insert ( my_list , 5 , 3 ) ; my_list = insert ( my_list , 10 , 3 ) ; my_list = insert ( my_list , 20 , 3 ) ; print ( my_list ) ; searching = search ( my_list , 20 ) ; printf ( \"\\n%d\\n\" , searching ) ; my_list = delete ( my_list , 1 ) ; my_list = delete ( my_list , 1 ) ; my_list = delete ( my_list , 1 ) ; my_list = delete ( my_list , 1 ) ; print ( my_list ) ; searching = search ( my_list , 20 ) ; printf ( \"\\n%d\\n\" , searching ) ; }",
    "resources/C/data_structures/linked_list/stack_using_linked_lists.c@main": "int main ( ) { int x = 0 , item ; printf ( \"\\t****stack using linked list****\\n\" ) ; while ( x != 4 ) { printf ( \"\\n1. Push\\n2. Pop\\n3. Display\\n4. Exit\\n\" ) ; printf ( \"Enter your choice: \" ) ; scanf ( \"%d\" , & x ) ; switch ( x ) { case 1 : push ( top ) ; break ; case 2 : pop ( top ) ; break ; case 3 : display ( top ) ; break ; case 4 : return 0 ; } } }",
    "resources/C/data_structures/linked_list/stack_using_linked_lists.c@push": "void push ( struct node * p ) { int item ; struct node * temp ; temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \"\\nEnter element to be inserted: \" ) ; scanf ( \"%d\" , & item ) ; temp -> info = item ; temp -> link = top ; top = temp ; printf ( \"Inserted successfully.\\n\" ) ; }",
    "resources/C/data_structures/linked_list/stack_using_linked_lists.c@pop": "void pop ( struct node * p ) { int item ; struct node * temp ; if ( top == NULL ) printf ( \"\\nStack is empty.\\n\" ) ; else { item = top -> info ; temp = top ; top = top -> link ; free ( temp ) ; printf ( \"\\nElement popped is %d.\\n\" , item ) ; } }",
    "resources/C/data_structures/linked_list/stack_using_linked_lists.c@display": "void display ( struct node * p ) { if ( top == NULL ) printf ( \"\\nStack is empty.\\n\" ) ; else { printf ( \"\\nElements in the stack are:\\n\" ) ; while ( p != NULL ) { printf ( \"\\t%d\\n\" , p -> info ) ; p = p -> link ; } // printf(\"%d\\n\",p->info); } }",
    "resources/C/data_structures/linked_list/merge_linked_lists.c@merge": "void merge ( ) { struct node * temp1 = head1 ; struct node * temp2 = head2 ; struct node * holder1 = NULL ; struct node * holder2 = NULL ; // Temporary pointer variables to store the address of next node of the two // input linked list while ( temp1 != NULL && temp2 != NULL ) { holder1 = temp1 -> next ; // Storing the address of next node of first linked list temp1 -> next = temp2 ; // Making the first node of first linked list point to first node of // second linked list if ( holder1 != NULL ) { // Making the first node of second linked list point to second node // of first linked list holder2 = temp2 -> next ; temp2 -> next = holder1 ; } temp1 = holder1 ; temp2 = holder2 ; // Updating the address location of two pointer variables temp1 and // temp2 } }",
    "resources/C/data_structures/linked_list/merge_linked_lists.c@printlist": "void printlist ( struct node * temp ) { printf ( \"%d\" , temp -> data ) ; temp = temp -> next ; while ( temp != NULL ) { printf ( \"->%d\" , temp -> data ) ; temp = temp -> next ; } printf ( \"\\n\" ) ; }",
    "resources/C/data_structures/linked_list/merge_linked_lists.c@main": "int main ( ) { // Linked List 1: 1->3->5->7   :   Linked List 2: 2->4->6 //  making lists struct node * one = ( struct node * ) malloc ( sizeof ( struct node ) ) ; struct node * two = ( struct node * ) malloc ( sizeof ( struct node ) ) ; struct node * three = ( struct node * ) malloc ( sizeof ( struct node ) ) ; struct node * four = ( struct node * ) malloc ( sizeof ( struct node ) ) ; struct node * five = ( struct node * ) malloc ( sizeof ( struct node ) ) ; struct node * six = ( struct node * ) malloc ( sizeof ( struct node ) ) ; struct node * seven = ( struct node * ) malloc ( sizeof ( struct node ) ) ; // Seven nodes are created head1 = one ; head2 = two ; // head1 points to first node of first linked list // head2 points to first node of second linked list one -> data = 1 ; one -> next = three ; two -> data = 2 ; two -> next = four ; three -> data = 3 ; three -> next = five ; four -> data = 4 ; four -> next = six ; five -> data = 5 ; five -> next = seven ; six -> data = 6 ; six -> next = NULL ; // Last node of second input linked list seven -> data = 7 ; seven -> next = NULL ; // Last node of first input linked list printf ( \"Linked List 1: \" ) ; printlist ( head1 ) ; printf ( \"\\nLinked List 2: \" ) ; printlist ( head2 ) ; // Merging the two linked list into single linked list merge ( ) ; printf ( \"\\nMerged Linked List: \" ) ; printlist ( head1 ) ; // list one has been modified return 0 ; }",
    "resources/C/data_structures/linked_list/circular_doubly_linked_list.c@create_node": "ListNode * create_node ( uint64_t data ) { ListNode * new_list = ( ListNode * ) malloc ( sizeof ( ListNode ) ) ; new_list -> value = data ; new_list -> next = new_list ; new_list -> prev = new_list ; return new_list ; }",
    "resources/C/data_structures/linked_list/circular_doubly_linked_list.c@insert_at_head": "ListNode * insert_at_head ( ListNode * head , uint64_t data ) { if ( head == NULL ) { head = create_node ( data ) ; return head ; } else { ListNode * temp ; ListNode * new_node = create_node ( data ) ; temp = head -> prev ; new_node -> next = head ; head -> prev = new_node ; new_node -> prev = temp ; temp -> next = new_node ; head = new_node ; return head ; } }",
    "resources/C/data_structures/linked_list/circular_doubly_linked_list.c@insert_at_tail": "ListNode * insert_at_tail ( ListNode * head , uint64_t data ) { if ( head == NULL ) { head = create_node ( data ) ; return head ; } else { ListNode * temp1 , * temp2 ; ListNode * new_node = create_node ( data ) ; temp1 = head ; temp2 = head -> prev ; new_node -> prev = temp2 ; new_node -> next = temp1 ; temp1 -> prev = new_node ; temp2 -> next = new_node ; return head ; } }",
    "resources/C/data_structures/linked_list/circular_doubly_linked_list.c@delete_from_head": "ListNode * delete_from_head ( ListNode * head ) { if ( head == NULL ) { printf ( \"The list is empty\\n\" ) ; return head ; } ListNode * temp1 , * temp2 ; temp1 = head ; temp2 = temp1 -> prev ; if ( temp1 == temp2 ) { free ( temp2 ) ; head = NULL ; return head ; } temp2 -> next = temp1 -> next ; ( temp1 -> next ) -> prev = temp2 ; head = temp1 -> next ; free ( temp1 ) ; return head ; }",
    "resources/C/data_structures/linked_list/circular_doubly_linked_list.c@delete_from_tail": "ListNode * delete_from_tail ( ListNode * head ) { if ( head == NULL ) { printf ( \"The list is empty\\n\" ) ; return head ; } ListNode * temp1 , * temp2 ; temp1 = head ; temp2 = temp1 -> prev ; if ( temp1 == temp2 ) { free ( temp2 ) ; head = NULL ; return head ; } ( temp2 -> prev ) -> next = temp1 ; temp1 -> prev = temp2 -> prev ; free ( temp2 ) ; return head ; }",
    "resources/C/data_structures/linked_list/circular_doubly_linked_list.c@getsize": "int getsize ( ListNode * head ) { if ( ! head ) { return 0 ; } int size = 1 ; ListNode * temp = head -> next ; while ( temp != head ) { temp = temp -> next ; size ++ ; } return size ; }",
    "resources/C/data_structures/linked_list/circular_doubly_linked_list.c@display_list": "void display_list ( ListNode * head ) { printf ( \"\\nContents of your linked list: \" ) ; ListNode * temp ; temp = head ; if ( head != NULL ) { while ( temp -> next != head ) { printf ( \"%\" PRIu64 \" <-> \" , temp -> value ) ; temp = temp -> next ; } if ( temp -> next == head ) { printf ( \"%\" PRIu64 , temp -> value ) ; } } else { printf ( \"The list is empty\" ) ; } printf ( \"\\n\" ) ; }",
    "resources/C/data_structures/linked_list/circular_doubly_linked_list.c@get": "uint64_t get ( ListNode * list , const int index ) { if ( list == NULL || index < 0 ) { exit ( EXIT_FAILURE ) ; } ListNode * temp = list ; for ( int i = 0 ; i < index ; ++ i ) { temp = temp -> next ; } return temp -> value ; }",
    "resources/C/data_structures/linked_list/circular_doubly_linked_list.c@test": "static void test ( ) { ListNode * testList = NULL ; unsigned int array [ ] = { 2 , 3 , 4 , 5 , 6 } ; assert ( getsize ( testList ) == 0 ) ; printf ( \"Testing inserting elements:\\n\" ) ; for ( int i = 0 ; i < 5 ; ++ i ) { display_list ( testList ) ; testList = insert_at_head ( testList , array [ i ] ) ; assert ( testList -> value == array [ i ] ) ; assert ( getsize ( testList ) == i + 1 ) ; } printf ( \"\\nTesting removing elements:\\n\" ) ; for ( int i = 4 ; i > - 1 ; -- i ) { display_list ( testList ) ; assert ( testList -> value == array [ i ] ) ; testList = delete_from_head ( testList ) ; assert ( getsize ( testList ) == i ) ; } printf ( \"\\nTesting inserting at tail:\\n\" ) ; for ( int i = 0 ; i < 5 ; ++ i ) { display_list ( testList ) ; testList = insert_at_tail ( testList , array [ i ] ) ; assert ( get ( testList , i ) == array [ i ] ) ; assert ( getsize ( testList ) == i + 1 ) ; } printf ( \"\\nTesting removing from tail:\\n\" ) ; for ( int i = 4 ; i > - 1 ; -- i ) { display_list ( testList ) ; testList = delete_from_tail ( testList ) ; assert ( getsize ( testList ) == i ) ; // If list is not empty, assert that accessing the just removed element // will wrap around to the list head if ( testList != NULL ) { assert ( get ( testList , i ) == testList -> value ) ; } else { // If the list is empty, assert that the elements were removed after // the correct number of iterations assert ( i == 0 ) ; } } }",
    "resources/C/data_structures/linked_list/circular_doubly_linked_list.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/data_structures/linked_list/middle_element_in_list.c@printMiddle": "void printMiddle ( struct Node * head ) { struct Node * slow_ptr = head ; struct Node * fast_ptr = head ; if ( head != NULL ) { while ( fast_ptr != NULL && fast_ptr -> next != NULL ) { fast_ptr = fast_ptr -> next -> next ; slow_ptr = slow_ptr -> next ; } printf ( \"The middle element is [%d]\\n\\n\" , slow_ptr -> data ) ; } }",
    "resources/C/data_structures/linked_list/middle_element_in_list.c@push": "void push ( struct Node * * head_ref , int new_data ) { /* allocate node */ struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; /* put in the data */ new_node -> data = new_data ; /* link the old list off the new node */ new_node -> next = ( * head_ref ) ; /* move the head to point to the new node */ ( * head_ref ) = new_node ; }",
    "resources/C/data_structures/linked_list/middle_element_in_list.c@printList": "void printList ( struct Node * ptr ) { while ( ptr != NULL ) { printf ( \"%d->\" , ptr -> data ) ; ptr = ptr -> next ; } printf ( \"NULL\\n\" ) ; }",
    "resources/C/data_structures/linked_list/middle_element_in_list.c@main": "int main ( ) { /* Start with the empty list */ struct Node * head = NULL ; int i ; for ( i = 5 ; i > 0 ; i -- ) { push ( & head , i ) ; printList ( head ) ; printMiddle ( head ) ; } return 0 ; }",
    "resources/C/data_structures/linked_list/singly_link_list_deletion.c@createnode": "struct node * createnode ( ) // function to create node { struct node * t ; t = ( struct node * ) malloc ( sizeof ( struct node ) ) ; return ( t ) ; }",
    "resources/C/data_structures/linked_list/singly_link_list_deletion.c@insert": "int insert ( int pos , int d ) { struct node * new ; new = createnode ( ) ; new -> info = d ; if ( pos == 1 ) { new -> link = NULL ; if ( start == NULL ) { start = new ; } else { new -> link = start ; start = new ; } } else { struct node * pre = start ; for ( int i = 2 ; i < pos ; i ++ ) { if ( pre == NULL ) { break ; } pre = pre -> link ; } if ( pre == NULL ) { printf ( \"Position not found!\" ) ; return 0 ; } new -> link = pre -> link ; pre -> link = new ; } return 0 ; }",
    "resources/C/data_structures/linked_list/singly_link_list_deletion.c@deletion": "int deletion ( int pos ) // function to delete from any position { struct node * t ; if ( start == NULL ) { printf ( \"\\nlist is empty\" ) ; } else { if ( pos == 1 ) { struct node * p ; p = start ; start = start -> link ; free ( p ) ; } else { struct node * prev = start ; for ( int i = 2 ; i < pos ; i ++ ) { if ( prev == NULL ) { printf ( \"Position not found!\" ) ; return 0 ; } prev = prev -> link ; } struct node * n = prev -> link ; // n points to required node to be deleted prev -> link = n -> link ; free ( n ) ; } } return 0 ; }",
    "resources/C/data_structures/linked_list/singly_link_list_deletion.c@viewlist": "void viewlist ( ) // function to display values { struct node * p ; if ( start == NULL ) { printf ( \"\\nlist is empty\" ) ; } else { p = start ; while ( p != NULL ) { printf ( \"%d \" , p -> info ) ; p = p -> link ; } } }",
    "resources/C/data_structures/linked_list/singly_link_list_deletion.c@test": "static void test ( ) { insert ( 1 , 39 ) ; assert ( start -> info == 39 ) ; insert ( 2 , 10 ) ; insert ( 3 , 11 ) ; deletion ( 1 ) ; assert ( start -> info != 39 ) ; printf ( \"Self-tests successfully passed!\\n\" ) ; }",
    "resources/C/data_structures/linked_list/singly_link_list_deletion.c@main": "int main ( ) { int n = 0 , pos = 0 , p = 0 , num = 0 , c = 0 ; printf ( \"\\n1.self test mode\" ) ; printf ( \"\\n2.interactive mode\" ) ; printf ( \"\\nenter your choice:\" ) ; scanf ( \"%d\" , & c ) ; if ( c == 1 ) { test ( ) ; } else if ( c == 2 ) { while ( 1 ) { printf ( \"\\n1.add value at the given location\" ) ; printf ( \"\\n2.delete value at the given location\" ) ; printf ( \"\\n3.view list\" ) ; printf ( \"\\nenter your choice :\" ) ; scanf ( \"%d\" , & n ) ; switch ( n ) { case 1 : printf ( \"enter the position where the element is to be added :\" ) ; scanf ( \"%d\" , & p ) ; printf ( \"enter the element is to be added :\" ) ; scanf ( \"%d\" , & num ) ; insert ( p , num ) ; break ; case 2 : printf ( \"enter the position where the element is to be deleted :\" ) ; scanf ( \"%d\" , & pos ) ; deletion ( pos ) ; break ; case 3 : viewlist ( ) ; break ; default : printf ( \"\\ninvalid choice\" ) ; } } } else { printf ( \"Invalid choice\" ) ; } return 0 ; }",
    "resources/C/data_structures/dynamic_array/main.c@main": "int main ( ) { dynamic_array_t * da = init_dynamic_array ( ) ; for ( int i = 1 ; i <= 50 ; i ++ ) { add ( da , & i ) ; } delete ( da , 10 ) ; int value = 1000 ; put ( da , & value , 0 ) ; value = 5000 ; int another_value = 7000 ; add ( da , & another_value ) ; for ( int i = 0 ; i < da -> size ; i ++ ) { printf ( \"value %d\\n\" , * ( int * ) get ( da , i ) ) ; } int value_for_invalid_index = 10000 ; put ( da , & value_for_invalid_index , 150 ) ; return 0 ; }",
    "resources/C/data_structures/dynamic_array/dynamic_array.c@init_dynamic_array": "dynamic_array_t * init_dynamic_array ( ) { dynamic_array_t * da = malloc ( sizeof ( dynamic_array_t ) ) ; da -> items = calloc ( DEFAULT_CAPACITY , sizeof ( void * ) ) ; da -> capacity = DEFAULT_CAPACITY ; return da ; }",
    "resources/C/data_structures/dynamic_array/dynamic_array.c@add": "void * add ( dynamic_array_t * da , const void * value ) { if ( da -> size >= da -> capacity ) { void * * newItems = realloc ( da -> items , ( da -> capacity <<= 1 ) * sizeof ( void * * ) ) ; da -> items = newItems ; } void * copy_value = retrive_copy_of_value ( value ) ; da -> items [ da -> size ++ ] = copy_value ; return copy_value ; }",
    "resources/C/data_structures/dynamic_array/dynamic_array.c@put": "void * put ( dynamic_array_t * da , const void * value , const unsigned index ) { if ( ! contains ( da -> size , index ) ) return INDEX_OUT_OF_BOUNDS ; free ( da -> items [ index ] ) ; void * copy_value = retrive_copy_of_value ( value ) ; da -> items [ index ] = copy_value ; return copy_value ; }",
    "resources/C/data_structures/dynamic_array/dynamic_array.c@get": "void * get ( dynamic_array_t * da , const unsigned index ) { if ( ! contains ( da -> size , index ) ) return INDEX_OUT_OF_BOUNDS ; return da -> items [ index ] ; }",
    "resources/C/data_structures/dynamic_array/dynamic_array.c@delete": "void delete ( dynamic_array_t * da , const unsigned index ) { if ( ! contains ( da -> size , index ) ) return ; for ( unsigned i = index ; i < da -> size ; i ++ ) { da -> items [ i ] = da -> items [ i + 1 ] ; } da -> size -- ; free ( da -> items [ da -> size ] ) ; }",
    "resources/C/data_structures/dynamic_array/dynamic_array.c@contains": "unsigned contains ( const unsigned size , const unsigned index ) { if ( size >= 0 && index < size ) return 1 ; printf ( \"index [%d] out of bounds!\\n\" , index ) ; return 0 ; }",
    "resources/C/data_structures/dynamic_array/dynamic_array.c@retrive_copy_of_value": "void * retrive_copy_of_value ( const void * value ) { void * value_copy = malloc ( sizeof ( void * ) ) ; memcpy ( value_copy , value , sizeof ( void * ) ) ; return value_copy ; }",
    "resources/C/data_structures/trie/trie.c@trie_new": "int trie_new ( struct trie * * trie ) { * trie = calloc ( 1 , sizeof ( struct trie ) ) ; if ( NULL == * trie ) { // memory allocation failed return - 1 ; } return 0 ; }",
    "resources/C/data_structures/trie/trie.c@trie_insert": "int trie_insert ( struct trie * trie , char * word , unsigned word_len ) { int ret = 0 ; // this is the end of this word; add an end-of-word marker here and we're // done. if ( 0 == word_len ) { trie -> end_of_word = true ; return 0 ; } // if you have some more complex mapping, you could introduce one here. In // this easy example, we just subtract 'a' (97) from it, meaning that 'a' is 0, // 'b' is 1, and so on. const unsigned int index = word [ 0 ] - 'a' ; // this index is outside the alphabet size; indexing this would mean an // out-of-bound memory access (bad!). If you introduce a separate map // function for indexing, then you could move the out-of-bounds index in // there. if ( ALPHABET_SIZE <= index ) { return - 1 ; } // The index does not exist yet, allocate it. if ( NULL == trie -> children [ index ] ) { ret = trie_new ( & trie -> children [ index ] ) ; if ( - 1 == ret ) { // creating new trie node failed return - 1 ; } } // recurse into the child node return trie_insert ( /* trie = */ trie -> children [ index ] , /* word = */ word + 1 , /* word_len = */ word_len - 1 ) ; }",
    "resources/C/data_structures/trie/trie.c@trie_search": "int trie_search ( struct trie * trie , char * word , unsigned word_len , struct trie * * result ) { // we found a match if ( 0 == word_len ) { * result = trie ; return 0 ; } // same here as in trie_insert, if you have a separate index mapping, add // it here. In this example, we just subtract 'a'. const unsigned int index = word [ 0 ] - 'a' ; // This word contains letters outside the alphabet length; it's invalid. // Remember to do this to prevent buffer overflows. if ( ALPHABET_SIZE <= index ) { return - 1 ; } // No match if ( NULL == trie -> children [ index ] ) { return - 1 ; } // traverse the trie return trie_search ( /* trie = */ trie -> children [ index ] , /* word = */ word + 1 , /* word_len = */ word_len - 1 , /* result = */ result ) ; }",
    "resources/C/data_structures/trie/trie.c@trie_print": "void trie_print ( struct trie * trie , char prefix [ ] , unsigned prefix_len ) { // An end-of-word marker means that this is a complete word, print it. if ( true == trie -> end_of_word ) { printf ( \"%.*s\\n\" , prefix_len , prefix ) ; } // However, there can be longer words with the same prefix; traverse into // those as well. for ( int i = 0 ; i < ALPHABET_SIZE ; i ++ ) { // No words on this character if ( NULL == trie -> children [ i ] ) { continue ; } // If you have a separate index mapping, then you'd need the inverse of // the map here. Since we subtracted 'a' for the index, we can just add // 'a' to get the inverse map function. prefix [ prefix_len ] = i + 'a' ; // traverse the print into the child trie_print ( trie -> children [ i ] , prefix , prefix_len + 1 ) ; } }",
    "resources/C/data_structures/trie/trie.c@main": "int main ( ) { int ret = 0 ; struct trie * root = NULL ; struct trie * trie = NULL ; char word [ 100 ] = { 0 } ; // Create a root trie ret = trie_new ( & root ) ; if ( - 1 == ret ) { fprintf ( stderr , \"Could not create trie\\n\" ) ; exit ( 1 ) ; } // open the dictionary file FILE * fp = fopen ( \"dictionary.txt\" , \"r\" ) ; if ( NULL == fp ) { fprintf ( stderr , \"Error while opening dictionary file\" ) ; exit ( 1 ) ; } // insert all the words from the dictionary while ( 1 == fscanf ( fp , \"%100s\\n\" , word ) ) { ret = trie_insert ( root , word , strnlen ( word , 100 ) ) ; if ( - 1 == ret ) { fprintf ( stderr , \"Could not insert word into trie\\n\" ) ; exit ( 1 ) ; } } while ( 1 ) { printf ( \"Enter keyword: \" ) ; if ( 1 != scanf ( \"%100s\" , word ) ) { break ; } printf ( \"\\n==========================================================\\n\" ) ; printf ( \"\\n********************* Possible Words ********************\\n\" ) ; ret = trie_search ( root , word , strnlen ( word , 100 ) , & trie ) ; if ( - 1 == ret ) { printf ( \"No results\\n\" ) ; continue ; } trie_print ( trie , word , strnlen ( word , 100 ) ) ; printf ( \"\\n==========================================================\\n\" ) ; } }",
    "resources/C/data_structures/binary_trees/threaded_binary_trees.c@create_node": "node * create_node ( int data ) { node * ptr = ( node * ) malloc ( sizeof ( node ) ) ; ptr -> rlink = ptr -> llink = NULL ; ptr -> data = data ; return ptr ; }",
    "resources/C/data_structures/binary_trees/threaded_binary_trees.c@insert_bt": "void insert_bt ( node * * root , int data ) { node * new_node = create_node ( data ) ; node * temp ; // to be deleted node * prev ; // keeps track of the parent of the element deleted if ( * root == NULL ) { * root = new_node ; } else { temp = * root ; prev = NULL ; while ( temp != NULL ) { if ( new_node -> data > temp -> data ) { prev = temp ; temp = temp -> rlink ; } else if ( new_node -> data < temp -> data ) { prev = temp ; temp = temp -> llink ; } else { return ; } } if ( new_node -> data > prev -> data ) { prev -> rlink = new_node ; } else { prev -> llink = new_node ; } } }",
    "resources/C/data_structures/binary_trees/threaded_binary_trees.c@search": "void search ( node * root , int ele ) { node * temp = root ; while ( temp != NULL ) { if ( temp -> data == ele ) { break ; } else if ( ele > temp -> data ) { temp = temp -> rlink ; } else { temp = temp -> llink ; } } if ( temp == NULL ) { printf ( \"%s\\n\" , \"Element not found.\" ) ; } else printf ( \"%s\\n\" , \"Element found.\" ) ; }",
    "resources/C/data_structures/binary_trees/threaded_binary_trees.c@inorder_display": "void inorder_display ( node * curr ) { if ( curr != NULL ) { inorder_display ( curr -> llink ) ; printf ( \"%d\\t\" , curr -> data ) ; inorder_display ( curr -> rlink ) ; } }",
    "resources/C/data_structures/binary_trees/threaded_binary_trees.c@postorder_display": "void postorder_display ( node * curr ) { if ( curr != NULL ) { postorder_display ( curr -> llink ) ; postorder_display ( curr -> rlink ) ; printf ( \"%d\\t\" , curr -> data ) ; } }",
    "resources/C/data_structures/binary_trees/threaded_binary_trees.c@preorder_display": "void preorder_display ( node * curr ) { if ( curr != NULL ) { printf ( \"%d\\t\" , curr -> data ) ; preorder_display ( curr -> llink ) ; preorder_display ( curr -> rlink ) ; } }",
    "resources/C/data_structures/binary_trees/threaded_binary_trees.c@delete_bt": "void delete_bt ( node * * root , int ele ) { node * temp ; node * prev ; if ( * root == NULL ) return ; else { temp = * root ; prev = NULL ; // search while ( temp != NULL ) { if ( temp -> data == ele ) { break ; } else if ( ele > temp -> data ) { prev = temp ; temp = temp -> rlink ; } else { prev = temp ; temp = temp -> llink ; } } } if ( temp == NULL ) return ; else { node * replacement ; // deleted node's replacement node * t ; if ( temp -> llink == NULL && temp -> rlink == NULL ) { replacement = NULL ; } else if ( temp -> llink == NULL && temp -> rlink != NULL ) { replacement = temp -> rlink ; } else if ( temp -> llink != NULL && temp -> rlink == NULL ) { replacement = temp -> llink ; } else { replacement = temp -> rlink ; // replaced with inorder successor t = replacement ; while ( t -> llink != NULL ) { t = t -> llink ; } t -> llink = temp -> llink ; // leftmost node of the replacement is linked to // the left child of the deleted node } if ( temp == * root ) { free ( * root ) ; * root = replacement ; } else if ( prev -> llink == temp ) { free ( prev -> llink ) ; prev -> llink = replacement ; } else if ( prev -> rlink == temp ) { free ( prev -> rlink ) ; prev -> rlink = replacement ; } } }",
    "resources/C/data_structures/binary_trees/threaded_binary_trees.c@main": "int main ( ) { printf ( \"BINARY THREADED TREE: \\n\" ) ; node * root = NULL ; int choice , n ; do { printf ( \"%s\\n\" , \"1. Insert into BT\" ) ; printf ( \"%s\\n\" , \"2. Print BT - inorder\" ) ; printf ( \"%s\\n\" , \"3. Print BT - preorder\" ) ; printf ( \"%s\\n\" , \"4. print BT - postorder\" ) ; printf ( \"%s\\n\" , \"5. delete from BT\" ) ; printf ( \"%s\\n\" , \"6. search in BT\" ) ; printf ( \"%s\\n\" , \"Type 0 to exit\" ) ; scanf ( \"%d\" , & choice ) ; switch ( choice ) { case 1 : printf ( \"%s\\n\" , \"Enter a no:\" ) ; scanf ( \"%d\" , & n ) ; insert_bt ( & root , n ) ; break ; case 2 : inorder_display ( root ) ; printf ( \"\\n\" ) ; break ; case 3 : preorder_display ( root ) ; printf ( \"\\n\" ) ; break ; case 4 : postorder_display ( root ) ; printf ( \"\\n\" ) ; break ; case 5 : printf ( \"%s\\n\" , \"Enter a no:\" ) ; scanf ( \"%d\" , & n ) ; delete_bt ( & root , n ) ; break ; case 6 : printf ( \"%s\\n\" , \"Enter a no:\" ) ; scanf ( \"%d\" , & n ) ; search ( root , n ) ; break ; } } while ( choice != 0 ) ; return 0 ; }",
    "resources/C/data_structures/binary_trees/segment_tree.c@segment_tree_build": "void segment_tree_build ( segment_tree * tree ) { size_t elem_size = tree -> elem_size ; int index = ( tree -> length - 2 ) ; size_t b , l , r ; char * ptr = ( char * ) tree -> root ; for ( ; index >= 0 ; index -- ) { b = index * elem_size ; l = ( 2 * index + 1 ) * elem_size ; r = ( 2 * index + 2 ) * elem_size ; tree -> combine ( ptr + l , ptr + r , ptr + b ) ; } }",
    "resources/C/data_structures/binary_trees/segment_tree.c@segment_tree_update": "void segment_tree_update ( segment_tree * tree , size_t index , void * val ) { size_t elem_size = tree -> elem_size ; index = index + tree -> length - 1 ; char * base = ( char * ) tree -> root ; char * t = base + index * elem_size ; memcpy ( t , val , elem_size ) ; while ( index > 0 ) { index = ( ( index - 1 ) >> 1 ) ; tree -> combine ( base + ( 2 * index + 1 ) * elem_size , base + ( 2 * index + 2 ) * elem_size , base + index * elem_size ) ; } }",
    "resources/C/data_structures/binary_trees/segment_tree.c@segment_tree_query": "void segment_tree_query ( segment_tree * tree , long long l , long long r , void * res ) { size_t elem_size = tree -> elem_size ; memcpy ( res , tree -> identity , elem_size ) ; elem_size = tree -> elem_size ; char * root = ( char * ) tree -> root ; l += tree -> length - 1 ; r += tree -> length - 1 ; while ( l <= r ) { if ( ! ( l & 1 ) ) { tree -> combine ( res , root + l * elem_size , res ) ; } if ( r & 1 ) { tree -> combine ( res , root + r * elem_size , res ) ; } r = ( r >> 1 ) - 1 ; l = ( l >> 1 ) ; } }",
    "resources/C/data_structures/binary_trees/segment_tree.c@segment_tree_init": "segment_tree * segment_tree_init ( void * arr , size_t elem_size , size_t len , void * identity , combine_function func ) { segment_tree * tree = malloc ( sizeof ( segment_tree ) ) ; tree -> elem_size = elem_size ; tree -> length = len ; tree -> combine = func ; tree -> root = malloc ( sizeof ( char ) * elem_size * ( 2 * len - 1 ) ) ; tree -> identity = malloc ( sizeof ( char ) * elem_size ) ; char * ptr = ( char * ) tree -> root ; memset ( ptr , 0 , ( len - 1 ) * elem_size ) ; // Initializing memory ptr = ptr + ( len - 1 ) * elem_size ; memcpy ( ptr , arr , elem_size * len ) ; // copy the leaf nodes i.e. array data memcpy ( tree -> identity , identity , elem_size ) ; // copy identity element return tree ; }",
    "resources/C/data_structures/binary_trees/segment_tree.c@segment_tree_dispose": "void segment_tree_dispose ( segment_tree * tree ) { free ( tree -> root ) ; free ( tree -> identity ) ; }",
    "resources/C/data_structures/binary_trees/segment_tree.c@segment_tree_print_int": "void segment_tree_print_int ( segment_tree * tree ) { char * base = ( char * ) tree -> root ; size_t i = 0 ; for ( ; i < 2 * tree -> length - 1 ; i ++ ) { printf ( \"%d \" , * ( int * ) ( base + i * tree -> elem_size ) ) ; } printf ( \"\\n\" ) ; }",
    "resources/C/data_structures/binary_trees/segment_tree.c@minimum": "void minimum ( const void * a , const void * b , void * c ) { * ( int * ) c = * ( int * ) a < * ( int * ) b ? * ( int * ) a : * ( int * ) b ; }",
    "resources/C/data_structures/binary_trees/segment_tree.c@test": "static void test ( ) { int32_t arr [ 10 ] = { 1 , 0 , 3 , 5 , 7 , 2 , 11 , 6 , - 2 , 8 } ; int32_t identity = __INT32_MAX__ ; segment_tree * tree = segment_tree_init ( arr , sizeof ( * arr ) , 10 , & identity , minimum ) ; segment_tree_build ( tree ) ; int32_t result ; segment_tree_query ( tree , 3 , 6 , & result ) ; assert ( result == 2 ) ; segment_tree_query ( tree , 8 , 9 , & result ) ; assert ( result == - 2 ) ; result = 12 ; segment_tree_update ( tree , 5 , & result ) ; segment_tree_update ( tree , 8 , & result ) ; segment_tree_query ( tree , 0 , 3 , & result ) ; assert ( result == 0 ) ; segment_tree_query ( tree , 8 , 9 , & result ) ; assert ( result == 8 ) ; segment_tree_dispose ( tree ) ; }",
    "resources/C/data_structures/binary_trees/segment_tree.c@main": "int main ( ) { test ( ) ; return 0 ; }",
    "resources/C/data_structures/binary_trees/words_alphabetical.c@endProgramAbruptly": "void endProgramAbruptly ( char * errorMessage ) { fprintf ( stderr , \"%s\\n\" , errorMessage ) ; exit ( EXIT_FAILURE ) ; }",
    "resources/C/data_structures/binary_trees/words_alphabetical.c@freeTreeMemory": "void freeTreeMemory ( struct Node * node ) { if ( node != NULL ) { freeTreeMemory ( node -> left ) ; freeTreeMemory ( node -> right ) ; free ( node -> word ) ; // freeing node->word because memory was allocated // using malloc free ( node ) ; // freeing node because memory was allocated using malloc } }",
    "resources/C/data_structures/binary_trees/words_alphabetical.c@getPointerToWord": "char * getPointerToWord ( char * word ) { char * string = ( char * ) malloc ( ( strlen ( word ) + 1 ) * sizeof ( char ) ) ; ///< pointer to string // + 1 is for the '\\0' character if ( string != NULL ) { strcpy ( string , word ) ; return string ; } endProgramAbruptly ( \"\\nA problem occurred while reserving memory for the word\\n\" ) ; return NULL ; }",
    "resources/C/data_structures/binary_trees/words_alphabetical.c@closeFile": "void closeFile ( FILE * file ) { if ( fclose ( file ) ) { endProgramAbruptly ( \"\\nA Problem Occurred while closing a file\\n\" ) ; } }",
    "resources/C/data_structures/binary_trees/words_alphabetical.c@allocateMemoryForNode": "struct Node * allocateMemoryForNode ( ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; ///< pointer to the node if ( node != NULL ) { return node ; } endProgramAbruptly ( \"\\nA problem occurred while reserving memory for the structure\\n\" ) ; return NULL ; }",
    "resources/C/data_structures/binary_trees/words_alphabetical.c@writeContentOfTreeToFile": "void writeContentOfTreeToFile ( struct Node * node , FILE * file ) { static uint64_t i = 1 ; ///< for word numbering in the write file if ( node != NULL ) // checks if the node is valid { writeContentOfTreeToFile ( node -> left , file ) ; // calls `writeContentOfTreeToFile` for left sub tree fprintf ( file , \"%-5lu \\t %-9lu \\t %s \\n\" , i ++ , node -> frequency , node -> word ) ; // prints the word number, word frequency and word // in tabular format to the file writeContentOfTreeToFile ( node -> right , file ) ; // calls `writeContentOfTreeToFile` for right sub tree } }",
    "resources/C/data_structures/binary_trees/words_alphabetical.c@addWordToTree": "struct Node * addWordToTree ( char * word , struct Node * currentNode ) { if ( currentNode == NULL ) // checks if `currentNode` is `NULL` { struct Node * currentNode = allocateMemoryForNode ( ) ; // allocates memory for new node currentNode -> word = getPointerToWord ( word ) ; // stores `word` in memory currentNode -> frequency = 1 ; // initializes the word frequency to 1 currentNode -> left = NULL ; // sets left node to `NULL` currentNode -> right = NULL ; // sets right node to `NULL` return currentNode ; // returns pointer to newly created node } int64_t compared = strcmp ( word , currentNode -> word ) ; ///< holds compare state if ( compared > 0 ) { currentNode -> right = addWordToTree ( word , currentNode -> right ) ; // adds `word` to right sub tree if `word` is // alphabetically greater than `currentNode->word` } else if ( compared < 0 ) { currentNode -> left = addWordToTree ( word , currentNode -> left ) ; // adds `word` to left sub tree if `word` is // alphabetically less than `currentNode->word` } else { currentNode -> frequency ++ ; // increments `currentNode` frequency if `word` is the same as `currentNode->word` } return currentNode ; // returns pointer to current node }",
    "resources/C/data_structures/binary_trees/words_alphabetical.c@readWordsInFileToTree": "struct Node * readWordsInFileToTree ( FILE * file , struct Node * root ) { // longest english word = 45 chars // +1 for '\\0' = 46 chars char * inputString = ( char * ) malloc ( 46 * sizeof ( char ) ) ; ///< pointer to the input string char inputChar ; ///< temp storage of characters bool isPrevCharAlpha = false ; ///< bool to mark the end of a word uint8_t pos = 0 ; ///< position in inputString to place the inputChar while ( ( inputChar = fgetc ( file ) ) != EOF ) { if ( pos > 0 ) isPrevCharAlpha = isalpha ( inputString [ pos - 1 ] ) ; // checks if character is letter if ( isalpha ( inputChar ) ) { inputString [ pos ++ ] = tolower ( inputChar ) ; continue ; } // checks if character is ' or - and if it is preceded by a letter eg // yours-not, persons' (valid) if ( ( inputChar == '\\'' || inputChar == '-' ) && isPrevCharAlpha ) { inputString [ pos ++ ] = inputChar ; continue ; } // makes sure that there is something valid in inputString if ( pos == 0 ) continue ; // if last character is not letter and is not ' then replace by \\0 if ( ! isPrevCharAlpha && inputString [ pos - 1 ] != '\\'' ) pos -- ; inputString [ pos ] = '\\0' ; pos = 0 ; isPrevCharAlpha = false ; root = addWordToTree ( inputString , root ) ; } // this is to catch the case for the EOF being immediately after the last // letter or ' if ( pos > 0 ) { if ( ! isPrevCharAlpha && inputString [ pos - 1 ] != '\\'' ) pos -- ; inputString [ pos ] = '\\0' ; root = addWordToTree ( inputString , root ) ; } free ( inputString ) ; return root ; }",
    "resources/C/data_structures/binary_trees/words_alphabetical.c@test": "static void test ( ) { struct Node * root = NULL ; ///< pointer to the root node FILE * file = NULL ; ///< pointer to the file file = fopen ( \"file.txt\" , \"w\" ) ; // creates test file in write mode fprintf ( file , \"hey_this, is a. test input \\n to a_file\" ) ; // writes test data to // test file closeFile ( file ) ; // closes test file file = fopen ( \"file.txt\" , \"r\" ) ; // reopens test file in read mode root = readWordsInFileToTree ( file , root ) ; // reads words from test file to tree // Tests to check if words were added to correct position in tree and also // if their frequencies were added correctly assert ( strcmp ( root -> word , \"hey\" ) == 0 ) ; assert ( root -> frequency == 1 ) ; assert ( strcmp ( root -> left -> word , \"a\" ) == 0 ) ; assert ( root -> left -> frequency == 2 ) ; assert ( strcmp ( root -> right -> word , \"this\" ) == 0 ) ; assert ( strcmp ( root -> left -> right -> word , \"file\" ) == 0 ) ; assert ( strcmp ( root -> right -> left -> word , \"is\" ) == 0 ) ; closeFile ( file ) ; // closes test file remove ( \"file.txt\" ) ; // deletes test file from storage file = fopen ( \"wordcount.txt\" , \"a\" ) ; // creates write file fprintf ( file , \"%-5s \\t %9s \\t %s \\n\" , \"S/N\" , \"FREQUENCY\" , \"WORD\" ) ; // prints the heading to `wordcount.txt` writeContentOfTreeToFile ( root , file ) ; // writes content of tree to file (`wordcount.txt`) // Here is how the output to `wordcount.txt` should look like char * correctString = \"S/N   \t FREQUENCY \t WORD \\n\" \"1     \t 2         \t a \\n\" \"2     \t 1         \t file \\n\" \"3     \t 1         \t hey \\n\" \"4     \t 1         \t input \\n\" \"5     \t 1         \t is \\n\" \"6     \t 1         \t n \\n\" \"7     \t 1         \t test \\n\" \"8     \t 1         \t this \\n\" \"9     \t 1         \t to \\n\" ; int16_t inputChar ; // holds the current character in `wordcount.txt` uint64_t i = 0 ; // holds the current index in `correctString` // Checks if the content in `wordcount.txt` is as expected (the same as in // `correctString`) while ( ( inputChar = fgetc ( file ) ) != EOF ) { assert ( inputChar == correctString [ i ++ ] ) ; } closeFile ( file ) ; // closes `wordcount.txt` remove ( \"wordcount.txt\" ) ; // deletes `wordcount.txt` freeTreeMemory ( root ) ; // frees memory taken up by the tree }",
    "resources/C/data_structures/binary_trees/words_alphabetical.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/data_structures/binary_trees/create_node.c@newNode": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> leftNode = NULL ; node -> data = data ; node -> rightNode = NULL ; return node ; }",
    "resources/C/data_structures/binary_trees/create_node.c@main": "int main ( void ) { /* new node can be created here as :-\n\n       struct node *nameOfNode = newNode(data);\n\n       and tree can be formed by creating further nodes at\n       nameOfNode->leftNode and so on.\n    */ return 0 ; }",
    "resources/C/data_structures/binary_trees/red_black_tree.c@newNode": "Node * newNode ( int val , Node * par ) { Node * create = ( Node * ) ( malloc ( sizeof ( Node ) ) ) ; create -> val = val ; create -> par = par ; create -> left = NULL ; create -> right = NULL ; create -> color = 1 ; }",
    "resources/C/data_structures/binary_trees/red_black_tree.c@isLeaf": "int isLeaf ( Node * n ) { if ( n -> left == NULL && n -> right == NULL ) { return 1 ; } return 0 ; }",
    "resources/C/data_structures/binary_trees/red_black_tree.c@leftRotate": "Node * leftRotate ( Node * node ) { Node * parent = node -> par ; Node * grandParent = parent -> par ; parent -> right = node -> left ; if ( node -> left != NULL ) { node -> left -> par = parent ; } node -> par = grandParent ; parent -> par = node ; node -> left = parent ; if ( grandParent != NULL ) { if ( grandParent -> right == parent ) { grandParent -> right = node ; } else { grandParent -> left = node ; } } return node ; }",
    "resources/C/data_structures/binary_trees/red_black_tree.c@rightRotate": "Node * rightRotate ( Node * node ) { Node * parent = node -> par ; Node * grandParent = parent -> par ; parent -> left = node -> right ; if ( node -> right != NULL ) { node -> right -> par = parent ; } node -> par = grandParent ; parent -> par = node ; node -> right = parent ; if ( grandParent != NULL ) { if ( grandParent -> right == parent ) { grandParent -> right = node ; } else { grandParent -> left = node ; } } return node ; }",
    "resources/C/data_structures/binary_trees/red_black_tree.c@checkNode": "void checkNode ( Node * node ) { // If the node is the root if ( node == NULL || node -> par == NULL ) { return ; } Node * child = node ; // If it is a black node or its parent is a black node if ( node -> color == 0 || ( node -> par ) -> color == 0 ) { // Dont Do Anything return ; } // Both parent and child are red // Check For Uncle Node * parent = node -> par ; Node * grandParent = parent -> par ; // If grandParent is NULL, then parent is the root. // Just make the root black. if ( grandParent == NULL ) { parent -> color = 0 ; return ; } // If both the children of the grandParent are red if ( grandParent -> right != NULL && ( grandParent -> right ) -> color == 1 && grandParent -> left != NULL && ( grandParent -> left ) -> color == 1 ) { // Make the grandParent red and both of its children black ( grandParent -> right ) -> color = 0 ; ( grandParent -> left ) -> color = 0 ; grandParent -> color = 1 ; return ; } else { // The only option left is rotation. Node * greatGrandParent = grandParent -> par ; // Right Case if ( grandParent -> right == parent ) { // Right Right Case if ( parent -> right == node ) { grandParent -> right = parent -> left ; if ( parent -> left != NULL ) { ( parent -> left ) -> par = grandParent ; } parent -> left = grandParent ; grandParent -> par = parent ; // Attach to existing Tree; parent -> par = greatGrandParent ; if ( greatGrandParent != NULL ) { if ( greatGrandParent -> left != NULL && greatGrandParent -> left == grandParent ) { greatGrandParent -> left = parent ; } else { greatGrandParent -> right = parent ; } } // Change the colors parent -> color = 0 ; grandParent -> color = 1 ; } else { // Right Left Case // First step -> Parent Child Rotation parent -> left = child -> right ; if ( child -> right != NULL ) { ( child -> right ) -> par = parent ; } child -> right = parent ; parent -> par = child ; // Second step -> Child and GrandParent Rotation grandParent -> right = child -> left ; if ( child -> left != NULL ) { ( child -> left ) -> par = grandParent ; } child -> left = grandParent ; grandParent -> par = child ; // Attach to the existing tree child -> par = greatGrandParent ; if ( greatGrandParent != NULL ) { if ( greatGrandParent -> left != NULL && greatGrandParent -> left == grandParent ) { greatGrandParent -> left = child ; } else { greatGrandParent -> right = child ; } } // Change The Colors child -> color = 0 ; grandParent -> color = 1 ; } } else { // Left Case // Left Left Case if ( parent -> left == node ) { grandParent -> left = parent -> right ; if ( parent -> right != NULL ) { ( parent -> right ) -> par = grandParent ; } parent -> right = grandParent ; grandParent -> par = parent ; // Attach to existing Tree; parent -> par = greatGrandParent ; if ( greatGrandParent != NULL ) { if ( greatGrandParent -> left != NULL && greatGrandParent -> left == grandParent ) { greatGrandParent -> left = parent ; } else { greatGrandParent -> right = parent ; } } // Change the colors parent -> color = 0 ; grandParent -> color = 1 ; } else { // Left Right Case // First step -> Parent Child Rotation parent -> right = child -> left ; if ( child -> left != NULL ) { ( child -> left ) -> par = parent ; } child -> left = parent ; parent -> par = child ; // Second step -> Child and GrandParent Rotation grandParent -> left = child -> right ; if ( child -> right != NULL ) { ( child -> right ) -> par = grandParent ; } child -> right = grandParent ; grandParent -> par = child ; // Attach to the existing tree child -> par = greatGrandParent ; if ( greatGrandParent != NULL ) { if ( greatGrandParent -> left != NULL && greatGrandParent -> left == grandParent ) { greatGrandParent -> left = child ; } else { greatGrandParent -> right = child ; } } // Change The Colors child -> color = 0 ; grandParent -> color = 1 ; } } } }",
    "resources/C/data_structures/binary_trees/red_black_tree.c@insertNode": "void insertNode ( int val , Node * * root ) { Node * buffRoot = * root ; while ( buffRoot ) { if ( buffRoot -> val > val ) { // Go left if ( buffRoot -> left != NULL ) { buffRoot = buffRoot -> left ; } else { // Insert The Node Node * toInsert = newNode ( val , buffRoot ) ; buffRoot -> left = toInsert ; buffRoot = toInsert ; // Check For Double Red Problems break ; } } else { // Go right if ( buffRoot -> right != NULL ) { buffRoot = buffRoot -> right ; } else { // Insert The Node Node * toInsert = newNode ( val , buffRoot ) ; buffRoot -> right = toInsert ; buffRoot = toInsert ; // Check For Double Red Problems break ; } } } while ( buffRoot != * root ) { checkNode ( buffRoot ) ; if ( buffRoot -> par == NULL ) { * root = buffRoot ; break ; } buffRoot = buffRoot -> par ; if ( buffRoot == * root ) { buffRoot -> color = 0 ; } } }",
    "resources/C/data_structures/binary_trees/red_black_tree.c@checkForCase2": "void checkForCase2 ( Node * toDelete , int delete , int fromDirection , Node * * root ) { if ( toDelete == ( * root ) ) { ( * root ) -> color = 0 ; return ; } if ( ! delete && toDelete -> color == 1 ) { if ( ! fromDirection ) { if ( toDelete -> right != NULL ) { toDelete -> right -> color = 1 ; } } else { if ( toDelete -> left != NULL ) { toDelete -> left -> color = 1 ; } } toDelete -> color = 0 ; return ; } // Get the sibling for further inspection Node * sibling ; Node * parent = toDelete -> par ; int locateChild = 0 ; // 0 if toDeleted is left of its parent else 1 if ( parent -> right == toDelete ) { sibling = parent -> left ; locateChild = 1 ; } else { sibling = parent -> right ; } // Case 2.1. i.e. if the any children of the sibling is red if ( ( sibling -> right != NULL && sibling -> right -> color == 1 ) || ( sibling -> left != NULL && sibling -> left -> color == 1 ) ) { if ( sibling -> right != NULL && sibling -> right -> color == 1 ) { // Sibling is left and child is right. i.e. LEFT RIGHT ROTATION if ( locateChild == 1 ) { int parColor = parent -> color ; // Step 1: Left rotate sibling sibling = leftRotate ( sibling -> right ) ; // Step 2: Right rotate updated sibling parent = rightRotate ( sibling ) ; // Check if the root is rotated if ( parent -> par == NULL ) { * root = parent ; } // Step 3: Update the colors parent -> color = parColor ; parent -> left -> color = 0 ; parent -> right -> color = 0 ; // Delete the node (present at parent->right->right) if ( delete ) { if ( toDelete -> left != NULL ) { toDelete -> left -> par = parent -> right ; } parent -> right -> right = toDelete -> left ; free ( toDelete ) ; } } else { // Sibling is right and child is also right. i.e. LEFT LEFT // ROTATION int parColor = parent -> color ; // Left Rotate the sibling parent = leftRotate ( sibling ) ; // Check if the root is rotated if ( parent -> par == NULL ) { * root = parent ; } // Update Colors parent -> color = parColor ; parent -> left -> color = 0 ; parent -> right -> color = 0 ; // Delete the node (present at parent->left->left) if ( delete ) { if ( toDelete -> right != NULL ) { toDelete -> right -> par = parent -> left ; } parent -> left -> left = toDelete -> left ; free ( toDelete ) ; } } } else { // Sibling is right and child is left. i.e. RIGHT LEFT ROTATION if ( locateChild == 0 ) { int parColor = parent -> color ; // Step 1: Right rotate sibling sibling = rightRotate ( sibling -> left ) ; // printf(\"%d - reached\\n\", sibling->val); // return; // Step 2: Left rotate updated sibling parent = leftRotate ( sibling ) ; // Check if the root is rotated if ( parent -> par == NULL ) { * root = parent ; } // Step 3: Update the colors parent -> color = parColor ; parent -> left -> color = 0 ; parent -> right -> color = 0 ; // Delete the node (present at parent->left->left) if ( delete ) { if ( toDelete -> right != NULL ) { toDelete -> right -> par = parent -> left ; } parent -> left -> left = toDelete -> right ; free ( toDelete ) ; } } else { // Sibling is left and child is also left. i.e. RIGHT RIGHT // ROTATION int parColor = parent -> color ; // Right Rotate the sibling parent = rightRotate ( sibling ) ; // Check if the root is rotated if ( parent -> par == NULL ) { * root = parent ; } // Update Colors parent -> color = parColor ; parent -> left -> color = 0 ; parent -> right -> color = 0 ; // Delete the node (present at parent->right->right) if ( delete ) { if ( toDelete -> left != NULL ) { toDelete -> left -> par = parent -> right ; } parent -> right -> right = toDelete -> left ; free ( toDelete ) ; } } } } else if ( sibling -> color == 0 ) { // Make the sibling red and recur for its parent // Recolor the sibling sibling -> color = 1 ; // Delete if necessary if ( delete ) { if ( locateChild ) { toDelete -> par -> right = toDelete -> left ; if ( toDelete -> left != NULL ) { toDelete -> left -> par = toDelete -> par ; } } else { toDelete -> par -> left = toDelete -> right ; if ( toDelete -> right != NULL ) { toDelete -> right -> par = toDelete -> par ; } } } checkForCase2 ( parent , 0 , locateChild , root ) ; } else { // Bring the sibling on top and apply 2.1 or 2.2 accordingly if ( locateChild ) { // Right Rotate toDelete -> par -> right = toDelete -> left ; if ( toDelete -> left != NULL ) { toDelete -> left -> par = toDelete -> par ; } parent = rightRotate ( sibling ) ; // Check if the root is rotated if ( parent -> par == NULL ) { * root = parent ; } parent -> color = 0 ; parent -> right -> color = 1 ; checkForCase2 ( parent -> right , 0 , 1 , root ) ; } else { // Left Rotate toDelete -> par -> left = toDelete -> right ; if ( toDelete -> right != NULL ) { toDelete -> right -> par = toDelete -> par ; } parent = leftRotate ( sibling ) ; // Check if the root is rotated if ( parent -> par == NULL ) { * root = parent ; } printf ( \"\\nroot - %d - %d\\n\" , parent -> val , parent -> left -> val ) ; parent -> color = 0 ; parent -> left -> color = 1 ; checkForCase2 ( parent -> left , 0 , 0 , root ) ; } } }",
    "resources/C/data_structures/binary_trees/red_black_tree.c@deleteNode": "void deleteNode ( int val , Node * * root ) { Node * buffRoot = * root ; // Search for the element in the tree while ( 1 ) { if ( val == buffRoot -> val ) { // Node Found break ; } if ( val > buffRoot -> val ) { if ( buffRoot -> right != NULL ) { buffRoot = buffRoot -> right ; } else { printf ( \"Node Not Found!!!\" ) ; return ; } } else { if ( buffRoot -> left != NULL ) { buffRoot = buffRoot -> left ; } else { printf ( \"Node Not Found!!!\" ) ; return ; } } } Node * toDelete = buffRoot ; // Look for the leftmost of right node or right most of left node if ( toDelete -> left != NULL ) { toDelete = toDelete -> left ; while ( toDelete -> right != NULL ) { toDelete = toDelete -> right ; } } else if ( toDelete -> right != NULL ) { toDelete = toDelete -> right ; while ( toDelete -> left != NULL ) { toDelete = toDelete -> left ; } } if ( toDelete == * root ) { * root = NULL ; return ; } // Swap the values buffRoot -> val = toDelete -> val ; toDelete -> val = val ; // Checking for case 1 if ( toDelete -> color == 1 || ( toDelete -> left != NULL && toDelete -> left -> color == 1 ) || ( toDelete -> right != NULL && toDelete -> right -> color == 1 ) ) { // if it is a leaf if ( toDelete -> left == NULL && toDelete -> right == NULL ) { // Delete instantly if ( toDelete -> par -> left == toDelete ) { toDelete -> par -> left = NULL ; } else { toDelete -> par -> right = NULL ; } } else { // else its child should be red // Check for the exitstence of left node if ( toDelete -> left != NULL ) { // The node should be right to its parent toDelete -> par -> right = toDelete -> left ; toDelete -> left -> par = toDelete -> par ; toDelete -> left -> color = 1 ; } else { // else the right node should be red toDelete -> par -> left = toDelete -> right ; toDelete -> right -> par = toDelete -> par ; toDelete -> right -> color = 1 ; } } // Remove the node from memory free ( toDelete ) ; } else { // Case 2 checkForCase2 ( toDelete , 1 , ( ( toDelete -> par -> right == toDelete ) ) , root ) ; } }",
    "resources/C/data_structures/binary_trees/red_black_tree.c@printInorder": "void printInorder ( Node * root ) { if ( root != NULL ) { printInorder ( root -> left ) ; printf ( \"%d c-%d \" , root -> val , root -> color ) ; printInorder ( root -> right ) ; } }",
    "resources/C/data_structures/binary_trees/red_black_tree.c@checkBlack": "void checkBlack ( Node * temp , int c ) { if ( temp == NULL ) { printf ( \"%d \" , c ) ; return ; } if ( temp -> color == 0 ) { c ++ ; } checkBlack ( temp -> left , c ) ; checkBlack ( temp -> right , c ) ; }",
    "resources/C/data_structures/binary_trees/red_black_tree.c@main": "int main ( ) { Node * root = NULL ; int scanValue , choice = 1 ; printf ( \"1 - Input\\n2 - Delete\\n3 - Inorder Traversel\\n0 - Quit\\n\\nPlease \" \"Enter the Choice - \" ) ; scanf ( \"%d\" , & choice ) ; while ( choice ) { switch ( choice ) { case 1 : printf ( \"\\n\\nPlease Enter A Value to insert - \" ) ; scanf ( \"%d\" , & scanValue ) ; if ( root == NULL ) { root = newNode ( scanValue , NULL ) ; root -> color = 0 ; } else { insertNode ( scanValue , & root ) ; } printf ( \"\\nSuccessfully Inserted %d in the tree\\n\\n\" , scanValue ) ; break ; case 2 : printf ( \"\\n\\nPlease Enter A Value to Delete - \" ) ; scanf ( \"%d\" , & scanValue ) ; deleteNode ( scanValue , & root ) ; printf ( \"\\nSuccessfully Inserted %d in the tree\\n\\n\" , scanValue ) ; break ; case 3 : printf ( \"\\nInorder Traversel - \" ) ; printInorder ( root ) ; printf ( \"\\n\\n\" ) ; // checkBlack(root,0); // printf(\"\\n\"); break ; default : if ( root != NULL ) { printf ( \"Root - %d\\n\" , root -> val ) ; } } printf ( \"1 - Input\\n2 - Delete\\n3 - Inorder Traversel\\n0 - \" \"Quit\\n\\nPlease Enter the Choice - \" ) ; scanf ( \"%d\" , & choice ) ; } }",
    "resources/C/data_structures/binary_trees/avl_tree.c@max": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@newNode": "avlNode * newNode ( int key ) { avlNode * node = ( avlNode * ) malloc ( sizeof ( avlNode ) ) ; if ( node == NULL ) printf ( \"!! Out of Space !!\\n\" ) ; else { node -> key = key ; node -> left = NULL ; node -> right = NULL ; node -> height = 0 ; } return node ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@nodeHeight": "int nodeHeight ( avlNode * node ) { if ( node == NULL ) return - 1 ; else return ( node -> height ) ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@heightDiff": "int heightDiff ( avlNode * node ) { if ( node == NULL ) return 0 ; else return ( nodeHeight ( node -> left ) - nodeHeight ( node -> right ) ) ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@minNode": "avlNode * minNode ( avlNode * node ) { avlNode * temp = node ; while ( temp -> left != NULL ) temp = temp -> left ; return temp ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@printAVL": "void printAVL ( avlNode * node , int level ) { int i ; if ( node != NULL ) { printAVL ( node -> right , level + 1 ) ; printf ( \"\\n\\n\" ) ; for ( i = 0 ; i < level ; i ++ ) printf ( \"\\t\" ) ; printf ( \"%d\" , node -> key ) ; printAVL ( node -> left , level + 1 ) ; } }",
    "resources/C/data_structures/binary_trees/avl_tree.c@rightRotate": "avlNode * rightRotate ( avlNode * z ) { avlNode * y = z -> left ; avlNode * T3 = y -> right ; y -> right = z ; z -> left = T3 ; z -> height = ( max ( nodeHeight ( z -> left ) , nodeHeight ( z -> right ) ) + 1 ) ; y -> height = ( max ( nodeHeight ( y -> left ) , nodeHeight ( y -> right ) ) + 1 ) ; return y ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@leftRotate": "avlNode * leftRotate ( avlNode * z ) { avlNode * y = z -> right ; avlNode * T3 = y -> left ; y -> left = z ; z -> right = T3 ; z -> height = ( max ( nodeHeight ( z -> left ) , nodeHeight ( z -> right ) ) + 1 ) ; y -> height = ( max ( nodeHeight ( y -> left ) , nodeHeight ( y -> right ) ) + 1 ) ; return y ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@LeftRightRotate": "avlNode * LeftRightRotate ( avlNode * z ) { z -> left = leftRotate ( z -> left ) ; return ( rightRotate ( z ) ) ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@RightLeftRotate": "avlNode * RightLeftRotate ( avlNode * z ) { z -> right = rightRotate ( z -> right ) ; return ( leftRotate ( z ) ) ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@insert": "avlNode * insert ( avlNode * node , int key ) { if ( node == NULL ) return ( newNode ( key ) ) ; /*Binary Search Tree insertion*/ if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; /*Recursive insertion in L subtree*/ else if ( key > node -> key ) node -> right = insert ( node -> right , key ) ; /*Recursive insertion in R subtree*/ /* Node  Height as per the AVL formula*/ node -> height = ( max ( nodeHeight ( node -> left ) , nodeHeight ( node -> right ) ) + 1 ) ; /*Checking for the balance condition*/ int balance = heightDiff ( node ) ; /*Left Left */ if ( balance > 1 && key < ( node -> left -> key ) ) return rightRotate ( node ) ; /*Right Right */ if ( balance < - 1 && key > ( node -> right -> key ) ) return leftRotate ( node ) ; /*Left Right */ if ( balance > 1 && key > ( node -> left -> key ) ) { node = LeftRightRotate ( node ) ; } /*Right Left */ if ( balance < - 1 && key < ( node -> right -> key ) ) { node = RightLeftRotate ( node ) ; } return node ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@delete": "avlNode * delete ( avlNode * node , int queryNum ) { if ( node == NULL ) return node ; if ( queryNum < node -> key ) node -> left = delete ( node -> left , queryNum ) ; /*Recursive deletion in L subtree*/ else if ( queryNum > node -> key ) node -> right = delete ( node -> right , queryNum ) ; /*Recursive deletion in R subtree*/ else { /*Single or No Children*/ if ( ( node -> left == NULL ) || ( node -> right == NULL ) ) { avlNode * temp = node -> left ? node -> left : node -> right ; /* No Children*/ if ( temp == NULL ) { temp = node ; node = NULL ; } else /*Single Child : copy data to the parent*/ * node = * temp ; free ( temp ) ; } else { /*Two Children*/ /*Get the smallest key in the R subtree*/ avlNode * temp = minNode ( node -> right ) ; node -> key = temp -> key ; /*Copy that to the root*/ node -> right = delete ( node -> right , temp -> key ) ; /*Delete the smallest in the R subtree.*/ } } /*single node in tree*/ if ( node == NULL ) return node ; /*Update height*/ node -> height = ( max ( nodeHeight ( node -> left ) , nodeHeight ( node -> right ) ) + 1 ) ; int balance = heightDiff ( node ) ; /*Left Left */ if ( ( balance > 1 ) && ( heightDiff ( node -> left ) >= 0 ) ) return rightRotate ( node ) ; /*Left Right */ if ( ( balance > 1 ) && ( heightDiff ( node -> left ) < 0 ) ) { node = LeftRightRotate ( node ) ; } /*Right Right */ if ( ( balance < - 1 ) && ( heightDiff ( node -> right ) >= 0 ) ) return leftRotate ( node ) ; /*Right Left */ if ( ( balance < - 1 ) && ( heightDiff ( node -> right ) < 0 ) ) { node = RightLeftRotate ( node ) ; } return node ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@findNode": "avlNode * findNode ( avlNode * node , int queryNum ) { if ( node != NULL ) { if ( queryNum < node -> key ) node = findNode ( node -> left , queryNum ) ; else if ( queryNum > node -> key ) node = findNode ( node -> right , queryNum ) ; } return node ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@printPreOrder": "void printPreOrder ( avlNode * node ) { if ( node == NULL ) return ; printf ( \"  %d  \" , ( node -> key ) ) ; printPreOrder ( node -> left ) ; printPreOrder ( node -> right ) ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@printInOrder": "void printInOrder ( avlNode * node ) { if ( node == NULL ) return ; printInOrder ( node -> left ) ; printf ( \"  %d  \" , ( node -> key ) ) ; printInOrder ( node -> right ) ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@printPostOrder": "void printPostOrder ( avlNode * node ) { if ( node == NULL ) return ; printPostOrder ( node -> left ) ; printPostOrder ( node -> right ) ; printf ( \"  %d  \" , ( node -> key ) ) ; }",
    "resources/C/data_structures/binary_trees/avl_tree.c@main": "int main ( ) { int choice ; int flag = 1 ; int insertNum ; int queryNum ; avlNode * root = NULL ; avlNode * tempNode ; while ( flag == 1 ) { printf ( \"\\n\\nEnter the Step to Run : \\n\" ) ; printf ( \"\\t1: Insert a node into AVL tree\\n\" ) ; printf ( \"\\t2: Delete a node in AVL tree\\n\" ) ; printf ( \"\\t3: Search a node into AVL tree\\n\" ) ; printf ( \"\\t4: printPreOrder (Ro L R) Tree\\n\" ) ; printf ( \"\\t5: printInOrder (L Ro R) Tree\\n\" ) ; printf ( \"\\t6: printPostOrder (L R Ro) Tree\\n\" ) ; printf ( \"\\t7: printAVL Tree\\n\" ) ; printf ( \"\\t0: EXIT\\n\" ) ; scanf ( \"%d\" , & choice ) ; switch ( choice ) { case 0 : { flag = 0 ; printf ( \"\\n\\t\\tExiting, Thank You !!\\n\" ) ; break ; } case 1 : { printf ( \"\\n\\tEnter the Number to insert: \" ) ; scanf ( \"%d\" , & insertNum ) ; tempNode = findNode ( root , insertNum ) ; if ( tempNode != NULL ) printf ( \"\\n\\t %d Already exists in the tree\\n\" , insertNum ) ; else { printf ( \"\\n\\tPrinting AVL Tree\\n\" ) ; printAVL ( root , 1 ) ; printf ( \"\\n\" ) ; root = insert ( root , insertNum ) ; printf ( \"\\n\\tPrinting AVL Tree\\n\" ) ; printAVL ( root , 1 ) ; printf ( \"\\n\" ) ; } break ; } case 2 : { printf ( \"\\n\\tEnter the Number to Delete: \" ) ; scanf ( \"%d\" , & queryNum ) ; tempNode = findNode ( root , queryNum ) ; if ( tempNode == NULL ) printf ( \"\\n\\t %d Does not exist in the tree\\n\" , queryNum ) ; else { printf ( \"\\n\\tPrinting AVL Tree\\n\" ) ; printAVL ( root , 1 ) ; printf ( \"\\n\" ) ; root = delete ( root , queryNum ) ; printf ( \"\\n\\tPrinting AVL Tree\\n\" ) ; printAVL ( root , 1 ) ; printf ( \"\\n\" ) ; } break ; } case 3 : { printf ( \"\\n\\tEnter the Number to Search: \" ) ; scanf ( \"%d\" , & queryNum ) ; tempNode = findNode ( root , queryNum ) ; if ( tempNode == NULL ) printf ( \"\\n\\t %d : Not Found\\n\" , queryNum ) ; else { printf ( \"\\n\\t %d : Found at height %d \\n\" , queryNum , tempNode -> height ) ; printf ( \"\\n\\tPrinting AVL Tree\\n\" ) ; printAVL ( root , 1 ) ; printf ( \"\\n\" ) ; } break ; } case 4 : { printf ( \"\\nPrinting Tree preOrder\\n\" ) ; printPreOrder ( root ) ; break ; } case 5 : { printf ( \"\\nPrinting Tree inOrder\\n\" ) ; printInOrder ( root ) ; break ; } case 6 : { printf ( \"\\nPrinting Tree PostOrder\\n\" ) ; printPostOrder ( root ) ; break ; } case 7 : { printf ( \"\\nPrinting AVL Tree\\n\" ) ; printAVL ( root , 1 ) ; break ; } default : { flag = 0 ; printf ( \"\\n\\t\\tExiting, Thank You !!\\n\" ) ; break ; } } } return 0 ; }",
    "resources/C/data_structures/binary_trees/binary_search_tree.c@newNode": "node * newNode ( int data ) { // creates a slug node * tmp = ( node * ) malloc ( sizeof ( node ) ) ; // initializes the slug tmp -> data = data ; tmp -> left = NULL ; tmp -> right = NULL ; return tmp ; }",
    "resources/C/data_structures/binary_trees/binary_search_tree.c@insert": "node * insert ( node * root , int data ) { // If the root of the subtree is null, insert key here if ( root == NULL ) { root = newNode ( data ) ; } else if ( data > root -> data ) { // If it isn't null and the input key is greater than the root key, // insert in the right leaf root -> right = insert ( root -> right , data ) ; } else if ( data < root -> data ) { // If it isn't null and the input key is lower than the root key, insert // in the left leaf root -> left = insert ( root -> left , data ) ; } // Returns the modified tree return root ; }",
    "resources/C/data_structures/binary_trees/binary_search_tree.c@getMax": "node * getMax ( node * root ) { // If there's no leaf to the right, then this is the maximum key value if ( root -> right != NULL ) { return getMax ( root -> right ) ; } return root ; }",
    "resources/C/data_structures/binary_trees/binary_search_tree.c@delete": "node * delete ( node * root , int data ) { // If the root is null, nothing to be done if ( root == NULL ) { return root ; } else if ( data > root -> data ) { // If the input key is greater than the root's, search in the right // subtree root -> right = delete ( root -> right , data ) ; } else if ( data < root -> data ) { // If the input key is lower than the root's, search in the left subtree root -> left = delete ( root -> left , data ) ; } else if ( data == root -> data ) { // If the input key matches the root's, check the following cases // termination condition if ( ( root -> left == NULL ) && ( root -> right == NULL ) ) { // Case 1: the root has no leaves, remove the node free ( root ) ; return NULL ; } else if ( root -> left == NULL ) { // Case 2: the root has one leaf, make the leaf the new root and // remove // the old root node * tmp = root ; root = root -> right ; free ( tmp ) ; return root ; } else if ( root -> right == NULL ) { node * tmp = root ; root = root -> left ; free ( tmp ) ; return root ; } else { // Case 3: the root has 2 leaves, find the greatest key in the left // subtree and switch with the root's // finds the biggest node in the left branch. node * tmp = getMax ( root -> left ) ; // sets the data of this node equal to the data of the biggest node // (lefts) root -> data = tmp -> data ; root -> left = delete ( root -> left , tmp -> data ) ; } } return root ; }",
    "resources/C/data_structures/binary_trees/binary_search_tree.c@find": "int find ( node * root , int data ) { // If the root is null, the key's not present if ( root == NULL ) { return 0 ; } else if ( data > root -> data ) { // If the input key is greater than the root's, search in the right // subtree return find ( root -> right , data ) ; } else if ( data < root -> data ) { // If the input key is lower than the root's, search in the left subtree return find ( root -> left , data ) ; } else if ( data == root -> data ) { // If the input and the root key match, return 1 return 1 ; } else { // unknown result!! return 0 ; } }",
    "resources/C/data_structures/binary_trees/binary_search_tree.c@height": "int height ( node * root ) { // If the root is null, this is the bottom of the tree (height 0) if ( root == NULL ) { return 0 ; } else { // Get the height from both left and right subtrees to check which is // the greatest int right_h = height ( root -> right ) ; int left_h = height ( root -> left ) ; // The final height is the height of the greatest subtree(left or right) // plus 1(which is the root's level) if ( right_h > left_h ) { return ( right_h + 1 ) ; } else { return ( left_h + 1 ) ; } } }",
    "resources/C/data_structures/binary_trees/binary_search_tree.c@purge": "void purge ( node * root ) { if ( root != NULL ) { if ( root -> left != NULL ) { purge ( root -> left ) ; } if ( root -> right != NULL ) { purge ( root -> right ) ; } free ( root ) ; root = NULL ; // reset pointer } }",
    "resources/C/data_structures/binary_trees/binary_search_tree.c@inOrder": "void inOrder ( node * root ) { if ( root != NULL ) { inOrder ( root -> left ) ; printf ( \"\\t[ %d ]\\t\" , root -> data ) ; inOrder ( root -> right ) ; } }",
    "resources/C/data_structures/binary_trees/binary_search_tree.c@main": "int main ( ) { // this reference don't change. // only the tree changes. node * root = NULL ; int opt = - 1 ; int data = 0 ; // event-loop. while ( opt != 0 ) { printf ( \"\\n\\n[1] Insert Node\\n[2] Delete Node\\n[3] Find a Node\\n[4] Get \" \"current Height\\n[5] Print Tree in Crescent Order\\n[0] Quit\\n\" ) ; scanf ( \"%d\" , & opt ) ; // reads the choice of the user // processes the choice switch ( opt ) { case 1 : printf ( \"Enter the new node's value:\\n\" ) ; scanf ( \"%d\" , & data ) ; root = insert ( root , data ) ; break ; case 2 : printf ( \"Enter the value to be removed:\\n\" ) ; if ( root != NULL ) { scanf ( \"%d\" , & data ) ; root = delete ( root , data ) ; } else { printf ( \"Tree is already empty!\\n\" ) ; } break ; case 3 : printf ( \"Enter the searched value:\\n\" ) ; scanf ( \"%d\" , & data ) ; find ( root , data ) ? printf ( \"The value is in the tree.\\n\" ) : printf ( \"The value is not in the tree.\\n\" ) ; break ; case 4 : printf ( \"Current height of the tree is: %d\\n\" , height ( root ) ) ; break ; case 5 : inOrder ( root ) ; break ; } } // deletes the tree from the heap. purge ( root ) ; return 0 ; }",
    "resources/C/data_structures/binary_trees/recursive_traversals.c@inOrderTraversal": "void inOrderTraversal ( struct node * node ) { if ( node == NULL ) // if tree is empty return ; inOrderTraversal ( node -> leftNode ) ; printf ( \"\\t%d\\t\" , node -> data ) ; inOrderTraversal ( node -> rightNode ) ; }",
    "resources/C/data_structures/binary_trees/recursive_traversals.c@preOrderTraversal": "void preOrderTraversal ( struct node * node ) { if ( node == NULL ) // if tree is empty return ; printf ( \"\\t%d\\t\" , node -> data ) ; preOrderTraversal ( node -> leftNode ) ; preOrderTraversal ( node -> rightNode ) ; }",
    "resources/C/data_structures/binary_trees/recursive_traversals.c@postOrderTraversal": "void postOrderTraversal ( struct node * node ) { if ( node == NULL ) // if tree is empty return ; postOrderTraversal ( node -> leftNode ) ; postOrderTraversal ( node -> rightNode ) ; printf ( \"\\t%d\\t\" , node -> data ) ; }",
    "resources/C/data_structures/binary_trees/recursive_traversals.c@main": "int main ( void ) { /* traversals can be done by simply invoking the\n       function with a pointer to the root node.\n    */ return 0 ; }",
    "resources/C/data_structures/heap/max_heap.c@main": "int main ( ) { Heap * head = create_heap ( head ) ; push ( head , 10 ) ; printf ( \"Pushing element : 10\\n\" ) ; push ( head , 3 ) ; printf ( \"Pushing element : 3\\n\" ) ; push ( head , 2 ) ; printf ( \"Pushing element : 2\\n\" ) ; push ( head , 8 ) ; printf ( \"Pushing element : 8\\n\" ) ; printf ( \"Top element = %d \\n\" , top ( head ) ) ; push ( head , 1 ) ; printf ( \"Pushing element : 1\\n\" ) ; push ( head , 7 ) ; printf ( \"Pushing element : 7\\n\" ) ; printf ( \"Top element = %d \\n\" , top ( head ) ) ; pop ( head ) ; printf ( \"Popping an element.\\n\" ) ; printf ( \"Top element = %d \\n\" , top ( head ) ) ; pop ( head ) ; printf ( \"Popping an element.\\n\" ) ; printf ( \"Top element = %d \\n\" , top ( head ) ) ; printf ( \"\\n\" ) ; return 0 ; }",
    "resources/C/data_structures/heap/max_heap.c@create_heap": "Heap * create_heap ( Heap * heap ) { heap = ( Heap * ) malloc ( sizeof ( Heap ) ) ; heap -> size = 1 ; heap -> p = ( int * ) malloc ( heap -> size * sizeof ( int ) ) ; heap -> count = 0 ; return heap ; }",
    "resources/C/data_structures/heap/max_heap.c@down_heapify": "void down_heapify ( Heap * heap , int index ) { if ( index >= heap -> count ) return ; int left = index * 2 + 1 ; int right = index * 2 + 2 ; int leftflag = 0 , rightflag = 0 ; int maximum = * ( ( heap -> p ) + index ) ; if ( left < heap -> count && maximum < * ( ( heap -> p ) + left ) ) { maximum = * ( ( heap -> p ) + left ) ; leftflag = 1 ; } if ( right < heap -> count && maximum < * ( ( heap -> p ) + right ) ) { maximum = * ( ( heap -> p ) + right ) ; leftflag = 0 ; rightflag = 1 ; } if ( leftflag ) { * ( ( heap -> p ) + left ) = * ( ( heap -> p ) + index ) ; * ( ( heap -> p ) + index ) = maximum ; down_heapify ( heap , left ) ; } if ( rightflag ) { * ( ( heap -> p ) + right ) = * ( ( heap -> p ) + index ) ; * ( ( heap -> p ) + index ) = maximum ; down_heapify ( heap , right ) ; } }",
    "resources/C/data_structures/heap/max_heap.c@up_heapify": "void up_heapify ( Heap * heap , int index ) { int parent = ( index - 1 ) / 2 ; if ( parent < 0 ) return ; if ( * ( ( heap -> p ) + index ) > * ( ( heap -> p ) + parent ) ) { int temp = * ( ( heap -> p ) + index ) ; * ( ( heap -> p ) + index ) = * ( ( heap -> p ) + parent ) ; * ( ( heap -> p ) + parent ) = temp ; up_heapify ( heap , parent ) ; } }",
    "resources/C/data_structures/heap/max_heap.c@push": "void push ( Heap * heap , int x ) { if ( heap -> count >= heap -> size ) return ; * ( ( heap -> p ) + heap -> count ) = x ; heap -> count ++ ; if ( 4 * heap -> count >= 3 * heap -> size ) { heap -> size *= 2 ; ( heap -> p ) = ( int * ) realloc ( ( heap -> p ) , ( heap -> size ) * sizeof ( int ) ) ; } up_heapify ( heap , heap -> count - 1 ) ; }",
    "resources/C/data_structures/heap/max_heap.c@pop": "void pop ( Heap * heap ) { if ( heap -> count == 0 ) return ; heap -> count -- ; int temp = * ( ( heap -> p ) + heap -> count ) ; * ( ( heap -> p ) + heap -> count ) = * ( heap -> p ) ; * ( heap -> p ) = temp ; down_heapify ( heap , 0 ) ; if ( 4 * heap -> count <= heap -> size ) { heap -> size /= 2 ; ( heap -> p ) = ( int * ) realloc ( ( heap -> p ) , ( heap -> size ) * sizeof ( int ) ) ; } }",
    "resources/C/data_structures/heap/max_heap.c@top": "int top ( Heap * heap ) { if ( heap -> count != 0 ) return * ( heap -> p ) ; else return INT_MIN ; }",
    "resources/C/data_structures/heap/max_heap.c@empty": "int empty ( Heap * heap ) { if ( heap -> count != 0 ) return 0 ; else return 1 ; }",
    "resources/C/data_structures/heap/max_heap.c@size": "int size ( Heap * heap ) { return heap -> count ; }",
    "resources/C/data_structures/heap/min_heap.c@main": "int main ( ) { Heap * head = create_heap ( head ) ; push ( head , 10 ) ; printf ( \"Pushing element : 10\\n\" ) ; push ( head , 3 ) ; printf ( \"Pushing element : 3\\n\" ) ; push ( head , 2 ) ; printf ( \"Pushing element : 2\\n\" ) ; push ( head , 8 ) ; printf ( \"Pushing element : 8\\n\" ) ; printf ( \"Top element = %d \\n\" , top ( head ) ) ; push ( head , 1 ) ; printf ( \"Pushing element : 1\\n\" ) ; push ( head , 7 ) ; printf ( \"Pushing element : 7\\n\" ) ; printf ( \"Top element = %d \\n\" , top ( head ) ) ; pop ( head ) ; printf ( \"Popping an element.\\n\" ) ; printf ( \"Top element = %d \\n\" , top ( head ) ) ; pop ( head ) ; printf ( \"Popping an element.\\n\" ) ; printf ( \"Top element = %d \\n\" , top ( head ) ) ; printf ( \"\\n\" ) ; return 0 ; }",
    "resources/C/data_structures/heap/min_heap.c@create_heap": "Heap * create_heap ( Heap * heap ) { heap = ( Heap * ) malloc ( sizeof ( Heap ) ) ; heap -> size = 1 ; heap -> p = ( int * ) malloc ( heap -> size * sizeof ( int ) ) ; heap -> count = 0 ; return heap ; }",
    "resources/C/data_structures/heap/min_heap.c@down_heapify": "void down_heapify ( Heap * heap , int index ) { if ( index >= heap -> count ) return ; int left = index * 2 + 1 ; int right = index * 2 + 2 ; int leftflag = 0 , rightflag = 0 ; int minimum = * ( ( heap -> p ) + index ) ; if ( left < heap -> count && minimum > * ( ( heap -> p ) + left ) ) { minimum = * ( ( heap -> p ) + left ) ; leftflag = 1 ; } if ( right < heap -> count && minimum > * ( ( heap -> p ) + right ) ) { minimum = * ( ( heap -> p ) + right ) ; leftflag = 0 ; rightflag = 1 ; } if ( leftflag ) { * ( ( heap -> p ) + left ) = * ( ( heap -> p ) + index ) ; * ( ( heap -> p ) + index ) = minimum ; down_heapify ( heap , left ) ; } if ( rightflag ) { * ( ( heap -> p ) + right ) = * ( ( heap -> p ) + index ) ; * ( ( heap -> p ) + index ) = minimum ; down_heapify ( heap , right ) ; } }",
    "resources/C/data_structures/heap/min_heap.c@up_heapify": "void up_heapify ( Heap * heap , int index ) { int parent = ( index - 1 ) / 2 ; if ( parent < 0 ) return ; if ( * ( ( heap -> p ) + index ) < * ( ( heap -> p ) + parent ) ) { int temp = * ( ( heap -> p ) + index ) ; * ( ( heap -> p ) + index ) = * ( ( heap -> p ) + parent ) ; * ( ( heap -> p ) + parent ) = temp ; up_heapify ( heap , parent ) ; } }",
    "resources/C/data_structures/heap/min_heap.c@push": "void push ( Heap * heap , int x ) { if ( heap -> count >= heap -> size ) return ; * ( ( heap -> p ) + heap -> count ) = x ; heap -> count ++ ; if ( 4 * heap -> count >= 3 * heap -> size ) { heap -> size *= 2 ; ( heap -> p ) = ( int * ) realloc ( ( heap -> p ) , ( heap -> size ) * sizeof ( int ) ) ; } up_heapify ( heap , heap -> count - 1 ) ; }",
    "resources/C/data_structures/heap/min_heap.c@pop": "void pop ( Heap * heap ) { if ( heap -> count == 0 ) return ; heap -> count -- ; int temp = * ( ( heap -> p ) + heap -> count ) ; * ( ( heap -> p ) + heap -> count ) = * ( heap -> p ) ; * ( heap -> p ) = temp ; down_heapify ( heap , 0 ) ; if ( 4 * heap -> count <= heap -> size ) { heap -> size /= 2 ; ( heap -> p ) = ( int * ) realloc ( ( heap -> p ) , ( heap -> size ) * sizeof ( int ) ) ; } }",
    "resources/C/data_structures/heap/min_heap.c@top": "int top ( Heap * heap ) { if ( heap -> count != 0 ) return * ( heap -> p ) ; else return INT_MIN ; }",
    "resources/C/data_structures/heap/min_heap.c@empty": "int empty ( Heap * heap ) { if ( heap -> count != 0 ) return 0 ; else return 1 ; }",
    "resources/C/data_structures/heap/min_heap.c@size": "int size ( Heap * heap ) { return heap -> count ; }",
    "resources/C/data_structures/dictionary/dict.c@create_dict": "Dictionary * create_dict ( void ) { Dictionary * p_dic = malloc ( sizeof ( Dictionary ) ) ; if ( p_dic ) { p_dic -> number_of_elements = 0 ; /* initializes the elemens of the array with NULL-pointer */ for ( int i = 0 ; i < MAXELEMENTS ; i ++ ) { p_dic -> elements [ i ] = NULL ; } return p_dic ; } else { printf ( \"unable to create a dictionary\\n\" ) ; return NULL ; } }",
    "resources/C/data_structures/dictionary/dict.c@get_hash": "int get_hash ( char s [ ] ) { unsigned int hash_code = 0 ; /* iterates over string at each character */ for ( int counter = 0 ; s [ counter ] != '\\0' ; counter ++ ) { /* actual computing of the hash code */ hash_code = s [ counter ] + ( hash_code << 6 ) + ( hash_code << 16 ) - hash_code ; } /* % modulo is for fitting the index in array. */ return hash_code % MAXELEMENTS ; }",
    "resources/C/data_structures/dictionary/dict.c@add_item_label": "int add_item_label ( Dictionary * dic , char label [ ] , void * item ) { unsigned int index = get_hash ( label ) ; /* make sure index is fitting */ if ( index < MAXELEMENTS ) { dic -> elements [ index ] = item ; return 0 ; } /* error case */ return - 1 ; }",
    "resources/C/data_structures/dictionary/dict.c@add_item_index": "int add_item_index ( Dictionary * dic , int index , void * item ) { /* make sure whether this place is already given */ if ( ! dic -> elements [ index ] ) { dic -> elements [ index ] = item ; return 0 ; } /* error case */ return - 1 ; }",
    "resources/C/data_structures/dictionary/dict.c@get_element_label": "void * get_element_label ( Dictionary * dict , char s [ ] ) { int index = get_hash ( s ) ; if ( dict -> elements [ index ] ) { return dict -> elements [ index ] ; } printf ( \"None entry at given label\\n\" ) ; return NULL ; }",
    "resources/C/data_structures/dictionary/dict.c@get_element_index": "void * get_element_index ( Dictionary * dict , int index ) { if ( index >= 0 && index < MAXELEMENTS ) { return dict -> elements [ index ] ; } printf ( \"index out of bounds!\\n\" ) ; return NULL ; }",
    "resources/C/data_structures/dictionary/dict.c@destroy": "void destroy ( Dictionary * dict ) { free ( dict ) ; }",
    "resources/C/data_structures/dictionary/test_program.c@main": "int main ( void ) { Dictionary * testObj1 ; Dictionary * testObj2 ; int value = 28 ; testObj1 = create_dict ( ) ; testObj2 = create_dict ( ) ; add_item_label ( testObj1 , \"age\" , & value ) ; add_item_label ( testObj2 , \"name\" , \"Christian\" ) ; /*\n        test for function add_item_label\n\n        attention:\n        The void* pointer must be convert into an int* pointer.\n        After that you can dereference it.\n    */ printf ( \"My age is %d\\n\" , * ( ( int * ) get_element_label ( testObj1 , \"age\" ) ) ) ; printf ( \"My name is %s\\n\" , get_element_label ( testObj2 , \"name\" ) ) ; /* test for function add_item_index */ if ( ! add_item_index ( testObj1 , 0 , & value ) ) { printf ( \"My age at index %d is %d\\n\" , 0 , * ( ( int * ) get_element_index ( testObj1 , 0 ) ) ) ; } /* error scenario */ /* get_element_label(testObj,\"none\"); */ /* tidy up */ destroy ( testObj1 ) ; destroy ( testObj2 ) ; return 0 ; }",
    "resources/C/data_structures/list/list.c@List_init": "List_T /* Initial list */ L List_init ( void ) { L list ; list = ( L ) malloc ( sizeof ( L ) ) ; list -> next = NULL ; return list ; }",
    "resources/C/data_structures/list/list.c@List_push": "List_T /* Initial list */ L List_init ( void ) { L list ; list = ( L ) malloc ( sizeof ( L ) ) ; list -> next = NULL ; return list ; } /* Push an element into top of the list */ L List_push ( L list , void * val ) { L new_elem = ( L ) malloc ( sizeof ( L ) ) ; new_elem -> val = val ; new_elem -> next = list ; return new_elem ; }",
    "resources/C/data_structures/list/list.c@List_length": "int List_length ( L list ) { int n ; for ( n = 0 ; list ; list = list -> next ) n ++ ; return n - 1 ; }",
    "resources/C/data_structures/list/list.c@List_toArray": "void * * List_toArray ( L list ) { int i , n = List_length ( list ) + 1 ; void * * array = ( void * * ) malloc ( ( n + 1 ) * sizeof ( * array ) ) ; for ( i = 0 ; i < n ; i ++ ) { array [ i ] = list -> val ; list = list -> next ; } array [ i ] = NULL ; return array ; }",
    "resources/C/data_structures/list/list.c@List_list": "List_T /* Initial list */ L List_init ( void ) { L list ; list = ( L ) malloc ( sizeof ( L ) ) ; list -> next = NULL ; return list ; } /* Push an element into top of the list */ L List_push ( L list , void * val ) { L new_elem = ( L ) malloc ( sizeof ( L ) ) ; new_elem -> val = val ; new_elem -> next = list ; return new_elem ; } /* Length of list */ int List_length ( L list ) { int n ; for ( n = 0 ; list ; list = list -> next ) n ++ ; return n - 1 ; } /* Convert list to array */ void * * List_toArray ( L list ) { int i , n = List_length ( list ) + 1 ; void * * array = ( void * * ) malloc ( ( n + 1 ) * sizeof ( * array ) ) ; for ( i = 0 ; i < n ; i ++ ) { array [ i ] = list -> val ; list = list -> next ; } array [ i ] = NULL ; return array ; } /* Create and return a list */ L List_list ( L list , void * val , ... ) { va_list ap ; L * p = & list ; va_start ( ap , val ) ; for ( ; val ; val = va_arg ( ap , void * ) ) { * p = malloc ( sizeof ( L ) ) ; ( * p ) -> val = val ; p = & ( * p ) -> next ; } * p = NULL ; va_end ( ap ) ; return list ; }",
    "resources/C/data_structures/list/list.c@List_append": "List_T /* Initial list */ L List_init ( void ) { L list ; list = ( L ) malloc ( sizeof ( L ) ) ; list -> next = NULL ; return list ; } /* Push an element into top of the list */ L List_push ( L list , void * val ) { L new_elem = ( L ) malloc ( sizeof ( L ) ) ; new_elem -> val = val ; new_elem -> next = list ; return new_elem ; } /* Length of list */ int List_length ( L list ) { int n ; for ( n = 0 ; list ; list = list -> next ) n ++ ; return n - 1 ; } /* Convert list to array */ void * * List_toArray ( L list ) { int i , n = List_length ( list ) + 1 ; void * * array = ( void * * ) malloc ( ( n + 1 ) * sizeof ( * array ) ) ; for ( i = 0 ; i < n ; i ++ ) { array [ i ] = list -> val ; list = list -> next ; } array [ i ] = NULL ; return array ; } /* Create and return a list */ L List_list ( L list , void * val , ... ) { va_list ap ; L * p = & list ; va_start ( ap , val ) ; for ( ; val ; val = va_arg ( ap , void * ) ) { * p = malloc ( sizeof ( L ) ) ; ( * p ) -> val = val ; p = & ( * p ) -> next ; } * p = NULL ; va_end ( ap ) ; return list ; } /* Append 2 lists together */ L List_append ( L list , L tail ) { L * p = & list ; while ( ( * p ) -> next ) { p = & ( * p ) -> next ; } * p = tail ; return list ; }",
    "resources/C/data_structures/list/main.c@print_list": "void print_list ( char * * array ) { int i ; for ( i = 0 ; array [ i ] ; i ++ ) printf ( \"%s\" , array [ i ] ) ; printf ( \"\\n\" ) ; }",
    "resources/C/data_structures/list/main.c@main": "int main ( ) { List_T list1 , list2 , list3 ; char * * str1 = ( char * * ) malloc ( 100 * sizeof ( char * ) ) ; list1 = List_init ( ) ; list1 = List_push ( list1 , \"Dang \" ) ; list1 = List_push ( list1 , \"Hoang \" ) ; list1 = List_push ( list1 , \"Hai \" ) ; printf ( \"List 1: \" ) ; str1 = ( char * * ) List_toArray ( list1 ) ; print_list ( str1 ) ; list2 = List_init ( ) ; list2 = List_list ( list2 , \"Mentor \" , \"Graphics \" , \"Siemens\" , NULL ) ; printf ( \"List 2: \" ) ; print_list ( ( char * * ) List_toArray ( list2 ) ) ; list3 = List_append ( list1 , list2 ) ; printf ( \"Test append list2 into list1: \" ) ; print_list ( ( char * * ) List_toArray ( list3 ) ) ; return 0 ; }",
    "resources/C/data_structures/queue/queue.c@main": "int main ( int argc , char const * argv [ ] ) { create ( ) ; enque ( 5 ) ; return 0 ; }",
    "resources/C/data_structures/queue/queue.c@create": "void create ( ) { head = NULL ; tail = NULL ; }",
    "resources/C/data_structures/queue/queue.c@enque": "void enque ( int x ) { if ( head == NULL ) { head = ( struct node * ) malloc ( sizeof ( struct node ) ) ; head -> data = x ; head -> pre = NULL ; tail = head ; } else { tmp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; tmp -> data = x ; tmp -> next = tail ; tail = tmp ; } }",
    "resources/C/data_structures/queue/queue.c@deque": "int deque ( ) { int returnData = 0 ; if ( head == NULL ) { printf ( \"ERROR: Deque from empty queue.\\n\" ) ; exit ( 1 ) ; } else { returnData = head -> data ; if ( head -> pre == NULL ) head = NULL ; else head = head -> pre ; head -> next = NULL ; } return returnData ; }",
    "resources/C/data_structures/queue/queue.c@size": "int size ( ) { return count ; }",
    "resources/C/data_structures/graphs/bfs_queue.c@findPathBFS": "",
    "resources/C/data_structures/graphs/bfs_queue.c@main": "int main ( void ) { int V = 10 ; Graph g = newGraph ( V ) ; Edge e ; e . v = 0 ; e . w = 1 ; insertEdge ( g , e ) ; e . v = 0 ; e . w = 2 ; insertEdge ( g , e ) ; e . v = 0 ; e . w = 5 ; insertEdge ( g , e ) ; e . v = 1 ; e . w = 5 ; insertEdge ( g , e ) ; e . v = 2 ; e . w = 3 ; insertEdge ( g , e ) ; e . v = 3 ; e . w = 4 ; insertEdge ( g , e ) ; e . v = 3 ; e . w = 5 ; insertEdge ( g , e ) ; e . v = 3 ; e . w = 8 ; insertEdge ( g , e ) ; e . v = 4 ; e . w = 5 ; insertEdge ( g , e ) ; e . v = 4 ; e . w = 7 ; insertEdge ( g , e ) ; e . v = 4 ; e . w = 8 ; insertEdge ( g , e ) ; e . v = 5 ; e . w = 6 ; insertEdge ( g , e ) ; e . v = 7 ; e . w = 8 ; insertEdge ( g , e ) ; e . v = 7 ; e . w = 9 ; insertEdge ( g , e ) ; e . v = 8 ; e . w = 9 ; insertEdge ( g , e ) ; int src = 0 , dest = 6 ; if ( findPathBFS ( g , V , src , dest ) ) { Vertex v = dest ; while ( v != src ) { printf ( \"%d - \" , v ) ; v = visited [ v ] ; } printf ( \"%d\\n\" , src ) ; } return 0 ; }",
    "resources/C/data_structures/graphs/dfs_recursive.c@dfsPathCheck": "",
    "resources/C/data_structures/graphs/dfs_recursive.c@findPathDFS": "",
    "resources/C/data_structures/graphs/dfs_recursive.c@main": "int main ( void ) { int V = 6 ; Graph g = newGraph ( V ) ; Edge e ; e . v = 0 ; e . w = 1 ; insertEdge ( g , e ) ; e . v = 0 ; e . w = 4 ; insertEdge ( g , e ) ; e . v = 0 ; e . w = 5 ; insertEdge ( g , e ) ; e . v = 5 ; e . w = 4 ; insertEdge ( g , e ) ; e . v = 4 ; e . w = 2 ; insertEdge ( g , e ) ; e . v = 4 ; e . w = 3 ; insertEdge ( g , e ) ; e . v = 5 ; e . w = 3 ; insertEdge ( g , e ) ; e . v = 1 ; e . w = 2 ; insertEdge ( g , e ) ; e . v = 3 ; e . w = 2 ; insertEdge ( g , e ) ; int src = 0 , dest = 5 ; if ( findPathDFS ( g , V , src , dest ) ) { Vertex v = dest ; while ( v != src ) { printf ( \"%d - \" , v ) ; v = visited [ v ] ; } printf ( \"%d\\n\" , src ) ; } return 0 ; }",
    "resources/C/data_structures/graphs/dijkstra.c@createGraph": "void createGraph ( struct Graph * G , int V ) { G -> vertexNum = V ; G -> edges = ( int * * ) malloc ( V * sizeof ( int * ) ) ; for ( int i = 0 ; i < V ; i ++ ) { G -> edges [ i ] = ( int * ) malloc ( V * sizeof ( int ) ) ; for ( int j = 0 ; j < V ; j ++ ) G -> edges [ i ] [ j ] = INT_MAX ; G -> edges [ i ] [ i ] = 0 ; } }",
    "resources/C/data_structures/graphs/dijkstra.c@addEdge": "void addEdge ( struct Graph * G , int src , int dst , int weight ) { G -> edges [ src ] [ dst ] = weight ; }",
    "resources/C/data_structures/graphs/dijkstra.c@minDistance": "int minDistance ( int mdist [ ] , int vset [ ] , int V ) { int minVal = INT_MAX ; static int minInd = - 1 ; //remembers the previous value if not modified in the loop for ( int i = 0 ; i < V ; i ++ ) if ( vset [ i ] == 0 && mdist [ i ] < minVal ) { minVal = mdist [ i ] ; minInd = i ; } return minInd ; }",
    "resources/C/data_structures/graphs/dijkstra.c@print": "void print ( int dist [ ] , int V ) { printf ( \"\\nVertex  Distance\\n\" ) ; for ( int i = 0 ; i < V ; i ++ ) { if ( dist [ i ] != INT_MAX ) printf ( \"%d\\t%d\\n\" , i , dist [ i ] ) ; else printf ( \"%d\\tINF\" , i ) ; } }",
    "resources/C/data_structures/graphs/dijkstra.c@Dijkstra": "void Dijkstra ( struct Graph * graph , int src ) { int V = graph -> vertexNum ; int mdist [ V ] ; // Stores updated distances to vertex int vset [ V ] ; // vset[i] is true if the vertex i included // in the shortest path tree // Initialise mdist and vset. Set distance of source as zero for ( int i = 0 ; i < V ; i ++ ) mdist [ i ] = INT_MAX , vset [ i ] = 0 ; mdist [ src ] = 0 ; // iterate to find shortest path for ( int count = 0 ; count < V - 1 ; count ++ ) { int u = minDistance ( mdist , vset , V ) ; vset [ u ] = 1 ; for ( int v = 0 ; v < V ; v ++ ) { if ( ! vset [ v ] && graph -> edges [ u ] [ v ] != INT_MAX && mdist [ u ] + graph -> edges [ u ] [ v ] < mdist [ v ] ) mdist [ v ] = mdist [ u ] + graph -> edges [ u ] [ v ] ; } } print ( mdist , V ) ; return ; }",
    "resources/C/data_structures/graphs/dijkstra.c@main": "int main ( ) { int V , E , gsrc ; int src , dst , weight ; struct Graph G ; printf ( \"Enter number of vertices: \" ) ; scanf ( \"%d\" , & V ) ; printf ( \"Enter number of edges: \" ) ; scanf ( \"%d\" , & E ) ; createGraph ( & G , V ) ; for ( int i = 0 ; i < E ; i ++ ) { printf ( \"\\nEdge %d \\nEnter source: \" , i + 1 ) ; scanf ( \"%d\" , & src ) ; printf ( \"Enter destination: \" ) ; scanf ( \"%d\" , & dst ) ; printf ( \"Enter weight: \" ) ; scanf ( \"%d\" , & weight ) ; addEdge ( & G , src , dst , weight ) ; } printf ( \"\\nEnter source:\" ) ; scanf ( \"%d\" , & gsrc ) ; Dijkstra ( & G , gsrc ) ; return 0 ; }",
    "resources/C/data_structures/graphs/transitive_closure.c@warshall": "void warshall ( ) { int i , s , t ; for ( s = 0 ; s < NODES ; s ++ ) for ( t = 0 ; t < NODES ; t ++ ) tc [ s ] [ t ] = digraph [ s ] [ t ] ; for ( i = 0 ; i < NODES ; i ++ ) for ( s = 0 ; s < NODES ; s ++ ) for ( t = 0 ; t < NODES ; t ++ ) if ( tc [ s ] [ i ] && tc [ i ] [ t ] ) tc [ s ] [ t ] = 1 ; }",
    "resources/C/data_structures/graphs/transitive_closure.c@main": "int main ( void ) { warshall ( ) ; int i , j ; for ( i = 0 ; i < NODES ; i ++ ) { for ( j = 0 ; j < NODES ; j ++ ) { printf ( \"%d \" , tc [ i ] [ j ] ) ; } putchar ( '\\n' ) ; } return 0 ; }",
    "resources/C/data_structures/graphs/bellman_ford.c@createGraph": "void createGraph ( struct Graph * G , int V , int E ) { G -> vertexNum = V ; G -> edgeNum = E ; G -> edges = ( struct Edge * ) malloc ( E * sizeof ( struct Edge ) ) ; }",
    "resources/C/data_structures/graphs/bellman_ford.c@addEdge": "void addEdge ( struct Graph * G , int src , int dst , int weight ) { static int ind ; struct Edge newEdge ; newEdge . src = src ; newEdge . dst = dst ; newEdge . weight = weight ; G -> edges [ ind ++ ] = newEdge ; }",
    "resources/C/data_structures/graphs/bellman_ford.c@minDistance": "int minDistance ( int mdist [ ] , int vset [ ] , int V ) { int minVal = INT_MAX , minInd ; for ( int i = 0 ; i < V ; i ++ ) if ( vset [ i ] == 0 && mdist [ i ] < minVal ) { minVal = mdist [ i ] ; minInd = i ; } return minInd ; }",
    "resources/C/data_structures/graphs/bellman_ford.c@print": "void print ( int dist [ ] , int V ) { printf ( \"\\nVertex  Distance\\n\" ) ; for ( int i = 0 ; i < V ; i ++ ) { if ( dist [ i ] != INT_MAX ) printf ( \"%d\\t%d\\n\" , i , dist [ i ] ) ; else printf ( \"%d\\tINF\" , i ) ; } }",
    "resources/C/data_structures/graphs/bellman_ford.c@BellmanFord": "void BellmanFord ( struct Graph * graph , int src ) { int V = graph -> vertexNum ; int E = graph -> edgeNum ; int dist [ V ] ; // Initialize distances array as INF for all except source // Intialize source as zero for ( int i = 0 ; i < V ; i ++ ) dist [ i ] = INT_MAX ; dist [ src ] = 0 ; // Calculate shortest path distance from source to all edges // A path can contain maximum (|V|-1) edges for ( int i = 0 ; i <= V - 1 ; i ++ ) for ( int j = 0 ; j < E ; j ++ ) { int u = graph -> edges [ j ] . src ; int v = graph -> edges [ j ] . dst ; int w = graph -> edges [ j ] . weight ; if ( dist [ u ] != INT_MAX && dist [ u ] + w < dist [ v ] ) dist [ v ] = dist [ u ] + w ; } // Iterate inner loop once more to check for negative cycle for ( int j = 0 ; j < E ; j ++ ) { int u = graph -> edges [ j ] . src ; int v = graph -> edges [ j ] . dst ; int w = graph -> edges [ j ] . weight ; if ( dist [ u ] != INT_MAX && dist [ u ] + w < dist [ v ] ) { printf ( \"Graph contains negative weight cycle. Hence, shortest \" \"distance not guaranteed.\" ) ; return ; } } print ( dist , V ) ; return ; }",
    "resources/C/data_structures/graphs/bellman_ford.c@main": "int main ( ) { int V , E , gsrc ; int src , dst , weight ; struct Graph G ; printf ( \"Enter number of vertices: \" ) ; scanf ( \"%d\" , & V ) ; printf ( \"Enter number of edges: \" ) ; scanf ( \"%d\" , & E ) ; createGraph ( & G , V , E ) ; for ( int i = 0 ; i < E ; i ++ ) { printf ( \"\\nEdge %d \\nEnter source: \" , i + 1 ) ; scanf ( \"%d\" , & src ) ; printf ( \"Enter destination: \" ) ; scanf ( \"%d\" , & dst ) ; printf ( \"Enter weight: \" ) ; scanf ( \"%d\" , & weight ) ; addEdge ( & G , src , dst , weight ) ; } printf ( \"\\nEnter source:\" ) ; scanf ( \"%d\" , & gsrc ) ; BellmanFord ( & G , gsrc ) ; return 0 ; }",
    "resources/C/data_structures/graphs/queue.c@newQueue": "queue newQueue ( ) { queue Q = malloc ( sizeof ( QueueRep ) ) ; Q -> length = 0 ; Q -> head = NULL ; Q -> tail = NULL ; return Q ; }",
    "resources/C/data_structures/graphs/queue.c@dropQueue": "void dropQueue ( queue Q ) { NodeT * curr = Q -> head ; while ( curr != NULL ) { NodeT * temp = curr -> next ; free ( curr ) ; curr = temp ; } free ( Q ) ; }",
    "resources/C/data_structures/graphs/queue.c@QueueIsEmpty": "int QueueIsEmpty ( queue Q ) { return ( Q -> length == 0 ) ; }",
    "resources/C/data_structures/graphs/queue.c@QueueEnqueue": "void QueueEnqueue ( queue Q , int v ) { NodeT * new = malloc ( sizeof ( NodeT ) ) ; assert ( new != NULL ) ; new -> data = v ; new -> next = NULL ; if ( Q -> tail != NULL ) { Q -> tail -> next = new ; Q -> tail = new ; } else { Q -> head = new ; Q -> tail = new ; } Q -> length ++ ; }",
    "resources/C/data_structures/graphs/queue.c@QueueDequeue": "int QueueDequeue ( queue Q ) { assert ( Q -> length > 0 ) ; NodeT * p = Q -> head ; Q -> head = Q -> head -> next ; if ( Q -> head == NULL ) { Q -> tail = NULL ; } Q -> length -- ; int d = p -> data ; free ( p ) ; return d ; }",
    "resources/C/data_structures/graphs/euler.c@degree": "int degree ( Graph g , int nV , Vertex v ) { int deg = 0 ; Vertex w ; for ( w = 0 ; w < nV ; w ++ ) if ( adjacent ( g , v , w ) ) deg ++ ; return deg ; }",
    "resources/C/data_structures/graphs/euler.c@hasEulerPath": "",
    "resources/C/data_structures/graphs/euler.c@main": "int main ( void ) { Edge e ; int n ; printf ( \"Enter the number of vertices: \" ) ; scanf ( \"%d\" , & n ) ; Graph g = newGraph ( n ) ; Vertex src , dest ; printf ( \"Enter source node: \" ) ; scanf ( \"%d\" , & src ) ; printf ( \"Enter destination node: \" ) ; scanf ( \"%d\" , & dest ) ; printf ( \"Enter an edge (from): \" ) ; while ( scanf ( \"%d\" , & e . v ) == 1 ) { printf ( \"Enter an edge (to): \" ) ; scanf ( \"%d\" , & e . w ) ; insertEdge ( g , e ) ; printf ( \"Enter an edge (from): \" ) ; } printf ( \"Finished.\\n\" ) ; printf ( \"The graph has \" ) ; if ( hasEulerPath ( g , n , src , dest ) ) printf ( \"an\" ) ; else printf ( \"no\" ) ; printf ( \" Euler path from %d to %d.\\n\" , src , dest ) ; freeGraph ( g ) ; return 0 ; }",
    "resources/C/data_structures/graphs/kruskal.c@createGraph": "struct Graph * createGraph ( int V , int E ) { struct Graph * graph = ( struct Graph * ) ( malloc ( sizeof ( struct Graph ) ) ) ; graph -> V = V ; graph -> E = E ; graph -> edge = ( struct Edge * ) malloc ( sizeof ( struct Edge ) * E ) ; return graph ; }",
    "resources/C/data_structures/graphs/kruskal.c@find": "int find ( struct subset subsets [ ] , int i ) { // find root and make root as parent of i // (path compression) if ( subsets [ i ] . parent != i ) subsets [ i ] . parent = find ( subsets , subsets [ i ] . parent ) ; return subsets [ i ] . parent ; }",
    "resources/C/data_structures/graphs/kruskal.c@Union": "void Union ( struct subset subsets [ ] , int x , int y ) { int xroot = find ( subsets , x ) ; int yroot = find ( subsets , y ) ; // Attach smaller rank tree under root of high // rank tree (Union by Rank) if ( subsets [ xroot ] . rank < subsets [ yroot ] . rank ) subsets [ xroot ] . parent = yroot ; else if ( subsets [ xroot ] . rank > subsets [ yroot ] . rank ) subsets [ yroot ] . parent = xroot ; // If ranks are same, then make one as root and // increment its rank by one else { subsets [ yroot ] . parent = xroot ; subsets [ xroot ] . rank ++ ; } }",
    "resources/C/data_structures/graphs/kruskal.c@myComp": "int myComp ( const void * a , const void * b ) { struct Edge * a1 = ( struct Edge * ) a ; struct Edge * b1 = ( struct Edge * ) b ; return a1 -> weight > b1 -> weight ; }",
    "resources/C/data_structures/graphs/kruskal.c@KruskalMST": "void KruskalMST ( struct Graph * graph ) { int V = graph -> V ; struct Edge result [ V ] ; // Tnis will store the resultant MST int e = 0 ; // An index variable, used for result[] int i = 0 ; // An index variable, used for sorted edges // Step 1: Sort all the edges in non-decreasing // order of their weight. If we are not allowed to // change the given graph, we can create a copy of // array of edges qsort ( graph -> edge , graph -> E , sizeof ( graph -> edge [ 0 ] ) , myComp ) ; // Allocate memory for creating V ssubsets struct subset * subsets = ( struct subset * ) malloc ( V * sizeof ( struct subset ) ) ; // Create V subsets with single elements for ( int v = 0 ; v < V ; ++ v ) { subsets [ v ] . parent = v ; subsets [ v ] . rank = 0 ; } // Number of edges to be taken is equal to V-1 while ( e < V - 1 && i < graph -> E ) { // Step 2: Pick the smallest edge. And increment // the index for next iteration struct Edge next_edge = graph -> edge [ i ++ ] ; int x = find ( subsets , next_edge . src ) ; int y = find ( subsets , next_edge . dest ) ; // If including this edge does't cause cycle, // include it in result and increment the index // of result for next edge if ( x != y ) { result [ e ++ ] = next_edge ; Union ( subsets , x , y ) ; } // Else discard the next_edge } // print the contents of result[] to display the // built MST printf ( \"Following are the edges in the constructed MST\\n\" ) ; for ( i = 0 ; i < e ; ++ i ) printf ( \"%d -- %d == %d\\n\" , result [ i ] . src , result [ i ] . dest , result [ i ] . weight ) ; return ; }",
    "resources/C/data_structures/graphs/kruskal.c@main": "int main ( ) { /* Let us create following weighted graph\n            10\n        0--------1\n        | \\\t |\n    6| 5\\ |15\n        |\t \\ |\n        2--------3\n            4\t */ int V = 4 ; // Number of vertices in graph int E = 5 ; // Number of edges in graph struct Graph * graph = createGraph ( V , E ) ; // add edge 0-1 graph -> edge [ 0 ] . src = 0 ; graph -> edge [ 0 ] . dest = 1 ; graph -> edge [ 0 ] . weight = 10 ; // add edge 0-2 graph -> edge [ 1 ] . src = 0 ; graph -> edge [ 1 ] . dest = 2 ; graph -> edge [ 1 ] . weight = 6 ; // add edge 0-3 graph -> edge [ 2 ] . src = 0 ; graph -> edge [ 2 ] . dest = 3 ; graph -> edge [ 2 ] . weight = 5 ; // add edge 1-3 graph -> edge [ 3 ] . src = 1 ; graph -> edge [ 3 ] . dest = 3 ; graph -> edge [ 3 ] . weight = 15 ; // add edge 2-3 graph -> edge [ 4 ] . src = 2 ; graph -> edge [ 4 ] . dest = 3 ; graph -> edge [ 4 ] . weight = 4 ; KruskalMST ( graph ) ; return 0 ; }",
    "resources/C/data_structures/graphs/floyd_warshall.c@createGraph": "void createGraph ( struct Graph * G , int V ) { G -> vertexNum = V ; G -> edges = ( int * * ) malloc ( V * sizeof ( int * ) ) ; for ( int i = 0 ; i < V ; i ++ ) { G -> edges [ i ] = ( int * ) malloc ( V * sizeof ( int ) ) ; for ( int j = 0 ; j < V ; j ++ ) G -> edges [ i ] [ j ] = INT_MAX ; G -> edges [ i ] [ i ] = 0 ; } }",
    "resources/C/data_structures/graphs/floyd_warshall.c@addEdge": "void addEdge ( struct Graph * G , int src , int dst , int weight ) { G -> edges [ src ] [ dst ] = weight ; }",
    "resources/C/data_structures/graphs/floyd_warshall.c@print": "void print ( int dist [ ] , int V ) { printf ( \"\\nThe Distance matrix for Floyd - Warshall\\n\" ) ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( dist [ i * V + j ] != INT_MAX ) printf ( \"%d\\t\" , dist [ i * V + j ] ) ; else printf ( \"INF\\t\" ) ; } printf ( \"\\n\" ) ; } }",
    "resources/C/data_structures/graphs/floyd_warshall.c@FloydWarshall": "void FloydWarshall ( struct Graph * graph ) { int V = graph -> vertexNum ; int dist [ V ] [ V ] ; // Initialise distance array for ( int i = 0 ; i < V ; i ++ ) for ( int j = 0 ; j < V ; j ++ ) dist [ i ] [ j ] = graph -> edges [ i ] [ j ] ; // Calculate distances for ( int k = 0 ; k < V ; k ++ ) // Choose an intermediate vertex for ( int i = 0 ; i < V ; i ++ ) // Choose a source vertex for given intermediate for ( int j = 0 ; j < V ; j ++ ) // Choose a destination vertex for above source vertex if ( dist [ i ] [ k ] != INT_MAX && dist [ k ] [ j ] != INT_MAX && dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) // If the distance through intermediate vertex is less than // direct edge then update value in distance array dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; // Convert 2d array to 1d array for print int dist1d [ V * V ] ; for ( int i = 0 ; i < V ; i ++ ) for ( int j = 0 ; j < V ; j ++ ) dist1d [ i * V + j ] = dist [ i ] [ j ] ; print ( dist1d , V ) ; }",
    "resources/C/data_structures/graphs/floyd_warshall.c@main": "int main ( ) { int V , E ; int src , dst , weight ; struct Graph G ; printf ( \"Enter number of vertices: \" ) ; scanf ( \"%d\" , & V ) ; printf ( \"Enter number of edges: \" ) ; scanf ( \"%d\" , & E ) ; createGraph ( & G , V ) ; for ( int i = 0 ; i < E ; i ++ ) { printf ( \"\\nEdge %d \\nEnter source: \" , i + 1 ) ; scanf ( \"%d\" , & src ) ; printf ( \"Enter destination: \" ) ; scanf ( \"%d\" , & dst ) ; printf ( \"Enter weight: \" ) ; scanf ( \"%d\" , & weight ) ; addEdge ( & G , src , dst , weight ) ; } FloydWarshall ( & G ) ; return 0 ; }",
    "resources/C/data_structures/graphs/hamiltonian.c@hamiltonR": "",
    "resources/C/data_structures/graphs/hamiltonian.c@hasHamiltonianPath": "",
    "resources/C/data_structures/graphs/hamiltonian.c@main": "int main ( void ) { Edge e ; int n ; printf ( \"Enter the number of vertices: \" ) ; scanf ( \"%d\" , & n ) ; Graph g = newGraph ( n ) ; Vertex src , dest ; printf ( \"Enter source node: \" ) ; scanf ( \"%d\" , & src ) ; printf ( \"Enter destination node: \" ) ; scanf ( \"%d\" , & dest ) ; printf ( \"Enter an edge (from): \" ) ; while ( scanf ( \"%d\" , & e . v ) == 1 ) { printf ( \"Enter an edge (to): \" ) ; scanf ( \"%d\" , & e . w ) ; insertEdge ( g , e ) ; printf ( \"Enter an edge (from): \" ) ; } printf ( \"Finished.\\n\" ) ; printf ( \"The graph has \" ) ; if ( hasHamiltonianPath ( g , n , src , dest ) ) printf ( \"a\" ) ; else printf ( \"no\" ) ; printf ( \" Hamiltonian path from %d to %d.\\n\" , src , dest ) ; freeGraph ( g ) ; return 0 ; }",
    "resources/C/data_structures/graphs/dfs.c@main": "int main ( ) { int vertices , edges , source , i , src , dst ; printf ( \"Enter the number of vertices\\n\" ) ; scanf ( \"%d\" , & vertices ) ; struct Graph * graph = createGraph ( vertices ) ; printf ( \"Enter the number of edges\\n\" ) ; scanf ( \"%d\" , & edges ) ; for ( i = 0 ; i < edges ; i ++ ) { printf ( \"Edge %d \\nEnter source: \" , i + 1 ) ; scanf ( \"%d\" , & src ) ; printf ( \"Enter destination: \" ) ; scanf ( \"%d\" , & dst ) ; addEdge ( graph , src , dst ) ; } printf ( \"Enter source of DFS\\n\" ) ; scanf ( \"%d\" , & source ) ; printf ( \"DFS from %d is:\\n\" , source ) ; dfs ( graph , source ) ; printf ( \"\\n\" ) ; // Uncomment below part to get a ready-made example /*struct Graph* graph = createGraph(4);\n    addEdge(graph, 0, 1);\n    addEdge(graph, 0, 2);\n    addEdge(graph, 1, 2);\n    addEdge(graph, 2, 3);\n    printf(\"DFS from 0 is:\\n\");\n    dfs(graph,0);\n    printf(\"\\n\");*/ return 0 ; }",
    "resources/C/data_structures/graphs/dfs.c@dfs": "void dfs ( struct Graph * graph , int vertex ) { struct node * adjList = graph -> adjLists [ vertex ] ; struct node * temp = adjList ; // Add vertex to visited list and print it graph -> visited [ vertex ] = 1 ; printf ( \"%d \" , vertex ) ; // Recursively call the dfs function on all unvisited neighbours while ( temp != NULL ) { int connectedVertex = temp -> vertex ; if ( graph -> visited [ connectedVertex ] == 0 ) { dfs ( graph , connectedVertex ) ; } temp = temp -> next ; } }",
    "resources/C/data_structures/graphs/dfs.c@createNode": "struct node * createNode ( int v ) { struct node * newNode = malloc ( sizeof ( struct node ) ) ; newNode -> vertex = v ; newNode -> next = NULL ; return newNode ; }",
    "resources/C/data_structures/graphs/dfs.c@createGraph": "struct Graph * createGraph ( int vertices ) { struct Graph * graph = malloc ( sizeof ( struct Graph ) ) ; graph -> numVertices = vertices ; graph -> adjLists = malloc ( vertices * sizeof ( struct node * ) ) ; graph -> visited = malloc ( vertices * sizeof ( int ) ) ; int i ; for ( i = 0 ; i < vertices ; i ++ ) { graph -> adjLists [ i ] = NULL ; graph -> visited [ i ] = 0 ; } return graph ; }",
    "resources/C/data_structures/graphs/dfs.c@addEdge": "void addEdge ( struct Graph * graph , int src , int dest ) { // Add edge from src to dest struct node * newNode = createNode ( dest ) ; newNode -> next = graph -> adjLists [ src ] ; graph -> adjLists [ src ] = newNode ; // Add edge from dest to src newNode = createNode ( src ) ; newNode -> next = graph -> adjLists [ dest ] ; graph -> adjLists [ dest ] = newNode ; }",
    "resources/C/data_structures/graphs/dfs.c@printGraph": "void printGraph ( struct Graph * graph ) { int v ; for ( v = 0 ; v < graph -> numVertices ; v ++ ) { struct node * temp = graph -> adjLists [ v ] ; printf ( \"\\n Adjacency list of vertex %d\\n \" , v ) ; while ( temp ) { printf ( \"%d -> \" , temp -> vertex ) ; temp = temp -> next ; } printf ( \"\\n\" ) ; } }",
    "resources/C/data_structures/graphs/graph.c@newGraph": "Graph newGraph ( int V ) { assert ( V >= 0 ) ; int i ; Graph g = malloc ( sizeof ( GraphRep ) ) ; assert ( g != NULL ) ; g -> nV = V ; g -> nE = 0 ; // allocate memory for each row g -> edges = malloc ( V * sizeof ( int * ) ) ; assert ( g -> edges != NULL ) ; // allocate memory for each column and initialise with 0 for ( i = 0 ; i < V ; i ++ ) { g -> edges [ i ] = calloc ( V , sizeof ( int ) ) ; assert ( g -> edges [ i ] != NULL ) ; } return g ; }",
    "resources/C/data_structures/graphs/graph.c@validV": "",
    "resources/C/data_structures/graphs/graph.c@insertEdge": "void insertEdge ( Graph g , Edge e ) { assert ( g != NULL && validV ( g , e . v ) && validV ( g , e . w ) ) ; if ( ! g -> edges [ e . v ] [ e . w ] ) { // edge e not in graph g -> edges [ e . v ] [ e . w ] = 1 ; g -> edges [ e . w ] [ e . v ] = 1 ; g -> nE ++ ; } }",
    "resources/C/data_structures/graphs/graph.c@removeEdge": "void removeEdge ( Graph g , Edge e ) { assert ( g != NULL && validV ( g , e . v ) && validV ( g , e . w ) ) ; if ( g -> edges [ e . v ] [ e . w ] ) { // edge e in graph g -> edges [ e . v ] [ e . w ] = 0 ; g -> edges [ e . w ] [ e . v ] = 0 ; g -> nE -- ; } }",
    "resources/C/data_structures/graphs/graph.c@adjacent": "",
    "resources/C/data_structures/graphs/graph.c@showGraph": "void showGraph ( Graph g ) { assert ( g != NULL ) ; int i , j ; printf ( \"Number of vertices: %d\\n\" , g -> nV ) ; printf ( \"Number of edges: %d\\n\" , g -> nE ) ; for ( i = 0 ; i < g -> nV ; i ++ ) for ( j = i + 1 ; j < g -> nV ; j ++ ) if ( g -> edges [ i ] [ j ] ) printf ( \"Edge %d - %d\\n\" , i , j ) ; }",
    "resources/C/data_structures/graphs/graph.c@freeGraph": "void freeGraph ( Graph g ) { assert ( g != NULL ) ; int i ; for ( i = 0 ; i < g -> nV ; i ++ ) free ( g -> edges [ i ] ) ; free ( g -> edges ) ; free ( g ) ; }",
    "resources/C/data_structures/graphs/topological_sort.c@main": "int main ( ) { int vertices , edges , i , src , dst ; printf ( \"Enter the number of vertices\\n\" ) ; scanf ( \"%d\" , & vertices ) ; struct Graph * graph = createGraph ( vertices ) ; printf ( \"Enter the number of edges\\n\" ) ; scanf ( \"%d\" , & edges ) ; for ( i = 0 ; i < edges ; i ++ ) { printf ( \"Edge %d \\nEnter source: \" , i + 1 ) ; scanf ( \"%d\" , & src ) ; printf ( \"Enter destination: \" ) ; scanf ( \"%d\" , & dst ) ; addEdge ( graph , src , dst ) ; } printf ( \"One topological sort order is:\\n\" ) ; topologicalSort ( graph ) ; printf ( \"\\n\" ) ; // Uncomment below part to get a ready-made example /*struct Graph* graph2 = createGraph(4);\n    addEdge(graph2, 0, 1);\n    addEdge(graph2, 0, 2);\n    addEdge(graph2, 1, 2);\n    addEdge(graph2, 2, 3);\n    printf(\"One topological sort is:\\n\");\n    topologicalSort(graph2);\n    printf(\"\\n\");*/ return 0 ; }",
    "resources/C/data_structures/graphs/topological_sort.c@topologicalSortHelper": "void topologicalSortHelper ( int vertex , struct Graph * graph , struct Stack * stack ) { graph -> visited [ vertex ] = 1 ; struct node * adjList = graph -> adjLists [ vertex ] ; struct node * temp = adjList ; // First add all dependents (that is, children) to stack while ( temp != NULL ) { int connectedVertex = temp -> vertex ; if ( graph -> visited [ connectedVertex ] == 0 ) { topologicalSortHelper ( connectedVertex , graph , stack ) ; } temp = temp -> next ; } // and then add itself push ( stack , vertex ) ; }",
    "resources/C/data_structures/graphs/topological_sort.c@topologicalSort": "void topologicalSort ( struct Graph * graph ) { struct Stack * stack = createStack ( ) ; int i = 0 ; for ( i = 0 ; i < graph -> numVertices ; i ++ ) { // Execute topological sort on all elements if ( graph -> visited [ i ] == 0 ) { topologicalSortHelper ( i , graph , stack ) ; } } while ( stack -> top != - 1 ) printf ( \"%d \" , pop ( stack ) ) ; }",
    "resources/C/data_structures/graphs/topological_sort.c@createNode": "struct node * createNode ( int v ) { struct node * newNode = malloc ( sizeof ( struct node ) ) ; newNode -> vertex = v ; newNode -> next = NULL ; return newNode ; }",
    "resources/C/data_structures/graphs/topological_sort.c@createGraph": "struct Graph * createGraph ( int vertices ) { struct Graph * graph = malloc ( sizeof ( struct Graph ) ) ; graph -> numVertices = vertices ; graph -> adjLists = malloc ( vertices * sizeof ( struct node * ) ) ; graph -> visited = malloc ( vertices * sizeof ( int ) ) ; int i ; for ( i = 0 ; i < vertices ; i ++ ) { graph -> adjLists [ i ] = NULL ; graph -> visited [ i ] = 0 ; } return graph ; }",
    "resources/C/data_structures/graphs/topological_sort.c@addEdge": "void addEdge ( struct Graph * graph , int src , int dest ) { // Add edge from src to dest struct node * newNode = createNode ( dest ) ; newNode -> next = graph -> adjLists [ src ] ; graph -> adjLists [ src ] = newNode ; }",
    "resources/C/data_structures/graphs/topological_sort.c@printGraph": "void printGraph ( struct Graph * graph ) { int v ; for ( v = 0 ; v < graph -> numVertices ; v ++ ) { struct node * temp = graph -> adjLists [ v ] ; printf ( \"\\n Adjacency list of vertex %d\\n \" , v ) ; while ( temp ) { printf ( \"%d -> \" , temp -> vertex ) ; temp = temp -> next ; } printf ( \"\\n\" ) ; } }",
    "resources/C/data_structures/graphs/topological_sort.c@createStack": "struct Stack * createStack ( ) { struct Stack * stack = malloc ( sizeof ( struct Stack ) ) ; stack -> top = - 1 ; return stack ; }",
    "resources/C/data_structures/graphs/topological_sort.c@push": "void push ( struct Stack * stack , int element ) { stack -> arr [ ++ stack -> top ] = element ; // Increment then add, as we start from -1 }",
    "resources/C/data_structures/graphs/topological_sort.c@pop": "int pop ( struct Stack * stack ) { if ( stack -> top == - 1 ) return INT_MIN ; else return stack -> arr [ stack -> top -- ] ; }",
    "resources/C/data_structures/graphs/strongly_connected_components.c@main": "int main ( ) { int vertices , edges , i , src , dst ; printf ( \"Enter the number of vertices\\n\" ) ; scanf ( \"%d\" , & vertices ) ; struct Graph * graph = createGraph ( vertices ) ; printf ( \"Enter the number of edges\\n\" ) ; scanf ( \"%d\" , & edges ) ; for ( i = 0 ; i < edges ; i ++ ) { printf ( \"Edge %d \\nEnter source: \" , i + 1 ) ; scanf ( \"%d\" , & src ) ; printf ( \"Enter destination: \" ) ; scanf ( \"%d\" , & dst ) ; addEdge ( graph , src , dst ) ; } printf ( \"The strongly connected conponents are:\\n\" ) ; scc ( graph ) ; printf ( \"\\n\" ) ; // Uncomment below part to get a ready-made example /*struct Graph* graph2 = createGraph(4);\n    addEdge(graph2, 0, 1);\n    addEdge(graph2, 1, 2);\n    addEdge(graph2, 2, 0);\n    addEdge(graph2, 2, 3);\n    printf(\"The strongly connected components are:\\n\");\n    scc(graph2);\n    printf(\"\\n\");*/ return 0 ; }",
    "resources/C/data_structures/graphs/strongly_connected_components.c@fillOrder": "void fillOrder ( int vertex , struct Graph * graph , struct Stack * stack ) { graph -> visited [ vertex ] = 1 ; struct node * adjList = graph -> adjLists [ vertex ] ; struct node * temp = adjList ; // First add all dependents (that is, children) to stack while ( temp != NULL ) { int connectedVertex = temp -> vertex ; if ( graph -> visited [ connectedVertex ] == 0 ) { fillOrder ( connectedVertex , graph , stack ) ; } temp = temp -> next ; } // and then add itself push ( stack , vertex ) ; }",
    "resources/C/data_structures/graphs/strongly_connected_components.c@transpose": "struct Graph * transpose ( struct Graph * g ) { struct Graph * graph = createGraph ( g -> numVertices ) ; // Number of vertices is same int i = 0 ; for ( i = 0 ; i < g -> numVertices ; i ++ ) { struct node * temp = g -> adjLists [ i ] ; while ( temp != NULL ) { addEdge ( graph , temp -> vertex , i ) ; // Reverse all edges temp = temp -> next ; } } return graph ; }",
    "resources/C/data_structures/graphs/strongly_connected_components.c@dfs": "void dfs ( struct Graph * graph , int vertex ) { struct node * adjList = graph -> adjLists [ vertex ] ; struct node * temp = adjList ; // Add vertex to visited list and print it graph -> visited [ vertex ] = 1 ; printf ( \"%d \" , vertex ) ; // Recursively call the dfs function on all unvisited neighbours while ( temp != NULL ) { int connectedVertex = temp -> vertex ; if ( graph -> visited [ connectedVertex ] == 0 ) { dfs ( graph , connectedVertex ) ; } temp = temp -> next ; } }",
    "resources/C/data_structures/graphs/strongly_connected_components.c@scc": "void scc ( struct Graph * graph ) { // Step I: Create a topological sort of the graph and store it in a stack struct Stack * stack = createStack ( ) ; int i = 0 ; for ( i = 0 ; i < graph -> numVertices ; i ++ ) { // Execute topological sort on all elements if ( graph -> visited [ i ] == 0 ) { fillOrder ( i , graph , stack ) ; } } // Step 2: Get the transpose graph struct Graph * graphT = transpose ( graph ) ; // Step 3: Perform a simple dfs by popping nodes from stack while ( stack -> top != - 1 ) { int v = pop ( stack ) ; if ( graphT -> visited [ v ] == 0 ) { dfs ( graphT , v ) ; printf ( \"\\n\" ) ; } } }",
    "resources/C/data_structures/graphs/strongly_connected_components.c@createNode": "struct node * createNode ( int v ) { struct node * newNode = malloc ( sizeof ( struct node ) ) ; newNode -> vertex = v ; newNode -> next = NULL ; return newNode ; }",
    "resources/C/data_structures/graphs/strongly_connected_components.c@createGraph": "struct Graph * createGraph ( int vertices ) { struct Graph * graph = malloc ( sizeof ( struct Graph ) ) ; graph -> numVertices = vertices ; graph -> adjLists = malloc ( vertices * sizeof ( struct node * ) ) ; graph -> visited = malloc ( vertices * sizeof ( int ) ) ; int i ; for ( i = 0 ; i < vertices ; i ++ ) { graph -> adjLists [ i ] = NULL ; graph -> visited [ i ] = 0 ; } return graph ; }",
    "resources/C/data_structures/graphs/strongly_connected_components.c@addEdge": "void addEdge ( struct Graph * graph , int src , int dest ) { // Add edge from src to dest struct node * newNode = createNode ( dest ) ; newNode -> next = graph -> adjLists [ src ] ; graph -> adjLists [ src ] = newNode ; }",
    "resources/C/data_structures/graphs/strongly_connected_components.c@printGraph": "void printGraph ( struct Graph * graph ) { int v ; for ( v = 0 ; v < graph -> numVertices ; v ++ ) { struct node * temp = graph -> adjLists [ v ] ; printf ( \"\\n Adjacency list of vertex %d\\n \" , v ) ; while ( temp ) { printf ( \"%d -> \" , temp -> vertex ) ; temp = temp -> next ; } printf ( \"\\n\" ) ; } }",
    "resources/C/data_structures/graphs/strongly_connected_components.c@createStack": "struct Stack * createStack ( ) { struct Stack * stack = malloc ( sizeof ( struct Stack ) ) ; stack -> top = - 1 ; return stack ; }",
    "resources/C/data_structures/graphs/strongly_connected_components.c@push": "void push ( struct Stack * stack , int element ) { stack -> arr [ ++ stack -> top ] = element ; // Increment then add, as we start from -1 }",
    "resources/C/data_structures/graphs/strongly_connected_components.c@pop": "int pop ( struct Stack * stack ) { if ( stack -> top == - 1 ) return INT_MIN ; else return stack -> arr [ stack -> top -- ] ; }",
    "resources/C/data_structures/graphs/bfs.c@main": "int main ( ) { int vertices , edges , source , i , src , dst ; printf ( \"Enter the number of vertices\\n\" ) ; scanf ( \"%d\" , & vertices ) ; struct Graph * graph = createGraph ( vertices ) ; printf ( \"Enter the number of edges\\n\" ) ; scanf ( \"%d\" , & edges ) ; for ( i = 0 ; i < edges ; i ++ ) { printf ( \"Edge %d \\nEnter source: \" , i + 1 ) ; scanf ( \"%d\" , & src ) ; printf ( \"Enter destination: \" ) ; scanf ( \"%d\" , & dst ) ; addEdge ( graph , src , dst ) ; } printf ( \"Enter source of bfs\\n\" ) ; scanf ( \"%d\" , & source ) ; bfs ( graph , source ) ; // Uncomment below part to get a ready-made example /*struct Graph* graph = createGraph(6);\n    addEdge(graph, 0, 1);\n    addEdge(graph, 0, 2);\n    addEdge(graph, 1, 2);\n    addEdge(graph, 1, 4);\n    addEdge(graph, 1, 3);\n    addEdge(graph, 2, 4);\n    addEdge(graph, 3, 4);\n    bfs(graph,0);*/ return 0 ; }",
    "resources/C/data_structures/graphs/bfs.c@bfs": "void bfs ( struct Graph * graph , int startVertex ) { struct queue * q = createQueue ( ) ; // Add to visited list and put in queue graph -> visited [ startVertex ] = 1 ; enqueue ( q , startVertex ) ; printf ( \"Breadth first traversal from vertex %d is:\\n\" , startVertex ) ; // Iterate while queue not empty while ( ! isEmpty ( q ) ) { printf ( \"%d \" , pollQueue ( q ) ) ; int currentVertex = dequeue ( q ) ; struct node * temp = graph -> adjLists [ currentVertex ] ; // Add all unvisited neighbours of current vertex to queue to be printed // next while ( temp ) { int adjVertex = temp -> vertex ; // Only add if neighbour is unvisited if ( graph -> visited [ adjVertex ] == 0 ) { graph -> visited [ adjVertex ] = 1 ; enqueue ( q , adjVertex ) ; } temp = temp -> next ; } } }",
    "resources/C/data_structures/graphs/bfs.c@createNode": "struct node * createNode ( int v ) { struct node * newNode = malloc ( sizeof ( struct node ) ) ; newNode -> vertex = v ; newNode -> next = NULL ; return newNode ; }",
    "resources/C/data_structures/graphs/bfs.c@createGraph": "struct Graph * createGraph ( int vertices ) { struct Graph * graph = malloc ( sizeof ( struct Graph ) ) ; graph -> numVertices = vertices ; graph -> adjLists = malloc ( vertices * sizeof ( struct node * ) ) ; graph -> visited = malloc ( vertices * sizeof ( int ) ) ; int i ; for ( i = 0 ; i < vertices ; i ++ ) { graph -> adjLists [ i ] = NULL ; graph -> visited [ i ] = 0 ; } return graph ; }",
    "resources/C/data_structures/graphs/bfs.c@addEdge": "void addEdge ( struct Graph * graph , int src , int dest ) { // Add edge from src to dest struct node * newNode = createNode ( dest ) ; newNode -> next = graph -> adjLists [ src ] ; graph -> adjLists [ src ] = newNode ; // Add edge from dest to src; comment it out for directed graph newNode = createNode ( src ) ; newNode -> next = graph -> adjLists [ dest ] ; graph -> adjLists [ dest ] = newNode ; }",
    "resources/C/data_structures/graphs/bfs.c@createQueue": "struct queue * createQueue ( ) { struct queue * q = malloc ( sizeof ( struct queue ) ) ; q -> front = - 1 ; q -> rear = - 1 ; return q ; }",
    "resources/C/data_structures/graphs/bfs.c@isEmpty": "int isEmpty ( struct queue * q ) { if ( q -> rear == - 1 ) return 1 ; else return 0 ; }",
    "resources/C/data_structures/graphs/bfs.c@enqueue": "void enqueue ( struct queue * q , int value ) { if ( q -> rear == SIZE - 1 ) printf ( \"\\nQueue is Full!!\" ) ; else { if ( q -> front == - 1 ) q -> front = 0 ; q -> rear ++ ; q -> items [ q -> rear ] = value ; } }",
    "resources/C/data_structures/graphs/bfs.c@dequeue": "int dequeue ( struct queue * q ) { int item ; if ( isEmpty ( q ) ) { printf ( \"Queue is empty\" ) ; item = - 1 ; } else { item = q -> items [ q -> front ] ; q -> front ++ ; if ( q -> front > q -> rear ) { q -> front = q -> rear = - 1 ; } } return item ; }",
    "resources/C/data_structures/graphs/bfs.c@pollQueue": "int pollQueue ( struct queue * q ) { return q -> items [ q -> front ] ; }",
    "resources/C/data_structures/stack/stack.c@initStack": "void initStack ( ) { array = malloc ( sizeof ( void * ) * max ) ; assert ( array ) ; /* tests whether pointer is assigned to memory. */ }",
    "resources/C/data_structures/stack/stack.c@grow": "void grow ( ) { max += 10 ; /* increases the capacity */ int i ; // for the loop void * * tmp = malloc ( sizeof ( void * ) * max ) ; /* copies the elements from the origin array in the new one. */ for ( i = 0 ; i < max - 10 ; i ++ ) { * ( tmp + i ) = * ( array + i ) ; } /*free the memory */ free ( array ) ; array = tmp ; }",
    "resources/C/data_structures/stack/stack.c@push": "void push ( void * object ) { assert ( object ) ; /* tests whether pointer isn't null */ if ( counter < max ) { offset ++ ; /* increases the element-pointer */ /*\n            moves pointer by the offset address\n            pushs the object onto stack\n         */ * ( array + offset ) = object ; /* increases the inner counter */ counter ++ ; } else /* stack is full */ { grow ( ) ; /* lets grow stack */ push ( object ) ; /* recursive call */ } }",
    "resources/C/data_structures/stack/stack.c@pop": "void * pop ( ) { void * top = * ( array + offset ) ; /* check pointers */ assert ( top ) ; /* if use the pop-function, stack must not empty. */ assert ( ! isEmpty ( ) ) ; /* decreases the offset address for pointing of\n        the new top element */ offset -- ; /* decreases the inner counter */ counter -- ; return top ; }",
    "resources/C/data_structures/stack/stack.c@size": "int size ( ) { return counter ; }",
    "resources/C/data_structures/stack/stack.c@isEmpty": "int isEmpty ( ) { return counter == 0 ; }",
    "resources/C/data_structures/stack/stack.c@top": "void * top ( ) { /* offset address points to the top element */ return array [ offset ] ; }",
    "resources/C/data_structures/stack/main.c@main": "int main ( ) { int x ; while ( 1 ) { printf ( \"\\n0 or CTRL-C to Exit \" ) ; printf ( \"\\n1. Push\" ) ; printf ( \"\\n2. Pop\" ) ; printf ( \"\\n3. Peek\" ) ; printf ( \"\\n4. Update\" ) ; printf ( \"\\n5. Display\" ) ; printf ( \"\\nEnter your choice? \\n\" ) ; scanf ( \"%d\" , & x ) ; switch ( x ) { case 0 : return 0 ; case 1 : push ( ) ; break ; case 2 : pop ( ) ; break ; case 3 : peek ( ) ; break ; case 4 : update ( ) ; break ; case 5 : display ( ) ; break ; default : printf ( \"\\nInvalid choice,\\nPlease try again.\\n\" ) ; } } return ( 0 ) ; }",
    "resources/C/data_structures/stack/main.c@push": "void push ( ) { int n = 0 ; printf ( \"\\nEnter the value to be inserted: \" ) ; scanf ( \"%d\" , & n ) ; top += 1 ; a [ top ] = n ; }",
    "resources/C/data_structures/stack/main.c@pop": "void pop ( ) { if ( top == - 1 ) { printf ( \"\\nStack is empty\" ) ; } else { int item ; item = a [ top ] ; top -= 1 ; printf ( \"\\nPoped item is %d \" , item ) ; } }",
    "resources/C/data_structures/stack/main.c@peek": "void peek ( ) { if ( top >= 0 ) printf ( \"\\nThe top element is %d\" , a [ top ] ) ; else printf ( \"\\nStack is empty\" ) ; }",
    "resources/C/data_structures/stack/main.c@update": "void update ( ) { int i , n ; printf ( \"\\nEnter the position to update? \" ) ; scanf ( \"%d\" , & i ) ; printf ( \"\\nEnter the item to insert? \" ) ; scanf ( \"%d\" , & n ) ; if ( top - i + 1 < 0 ) { printf ( \"\\nUnderflow condition \" ) ; } else { a [ top - i + 1 ] = n ; } }",
    "resources/C/data_structures/stack/main.c@display": "void display ( ) { if ( top == - 1 ) { printf ( \"\\nStack is empty\" ) ; } else { for ( int i = top ; i >= 0 ; i -- ) { printf ( \"%d\\n\" , a [ i ] ) ; } } }",
    "resources/C/data_structures/stack/stack_linked_list/stack.c@Stack_init": "Stack_T typedef struct elem { void * val ; struct elem * next ; } elem_t ; struct T { int count ; elem_t * head ; } ; /* Initial stack */ T Stack_init ( void ) { T stack ; stack = ( T ) malloc ( sizeof ( T ) ) ; stack -> count = 0 ; stack -> head = NULL ; return stack ; }",
    "resources/C/data_structures/stack/stack_linked_list/stack.c@Stack_empty": "int Stack_empty ( T stack ) { assert ( stack ) ; return stack -> count == 0 ; }",
    "resources/C/data_structures/stack/stack_linked_list/stack.c@Stack_size": "int Stack_size ( T stack ) { assert ( stack ) ; return stack -> count ; }",
    "resources/C/data_structures/stack/stack_linked_list/stack.c@Stack_push": "void Stack_push ( T stack , void * val ) { elem_t * t ; assert ( stack ) ; t = ( elem_t * ) malloc ( sizeof ( elem_t ) ) ; t -> val = val ; t -> next = stack -> head ; stack -> head = t ; stack -> count ++ ; }",
    "resources/C/data_structures/stack/stack_linked_list/stack.c@Stack_pop": "void * Stack_pop ( T stack ) { void * val ; elem_t * t ; assert ( stack ) ; assert ( stack -> count > 0 ) ; t = stack -> head ; stack -> head = t -> next ; stack -> count -- ; val = t -> val ; free ( t ) ; return val ; }",
    "resources/C/data_structures/stack/stack_linked_list/stack.c@Stack_print": "void Stack_print ( Stack_T stack ) { assert ( stack ) ; int i , size = Stack_size ( stack ) ; elem_t * current_elem = stack -> head ; printf ( \"Stack [Top --- Bottom]: \" ) ; for ( i = 0 ; i < size ; ++ i ) { printf ( \"%p \" , ( int * ) current_elem -> val ) ; current_elem = current_elem -> next ; } printf ( \"\\n\" ) ; }",
    "resources/C/data_structures/stack/stack_linked_list/main.c@main": "int main ( ) { Stack_T stk ; stk = Stack_init ( ) ; Stack_push ( stk , ( int * ) 1 ) ; Stack_push ( stk , ( int * ) 2 ) ; Stack_push ( stk , ( int * ) 3 ) ; Stack_push ( stk , ( int * ) 4 ) ; printf ( \"Size: %d\\n\" , Stack_size ( stk ) ) ; Stack_print ( stk ) ; Stack_pop ( stk ) ; printf ( \"Stack after popping: \\n\" ) ; Stack_print ( stk ) ; Stack_pop ( stk ) ; printf ( \"Stack after popping: \\n\" ) ; Stack_print ( stk ) ; return 0 ; }",
    "resources/C/data_structures/stack/parenthesis.c@push": "void push ( char x ) // function for pushing { struct node * p = head , * temp ; temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = x ; if ( head == NULL ) // will be execute only one time i.e, 1st time push is called { head = temp ; p = head ; p -> link = NULL ; c ++ ; } else { temp -> link = p ; p = temp ; head = p ; c ++ ; } }",
    "resources/C/data_structures/stack/parenthesis.c@pop": "char pop ( void ) // function for pop { char x ; struct node * p = head ; x = p -> data ; head = p -> link ; free ( p ) ; c -- ; return x ; }",
    "resources/C/data_structures/stack/parenthesis.c@isBalanced": "int isBalanced ( char * s ) { int i = 0 ; char x ; while ( s [ i ] != '\\0' ) // loop for covering entire string of brackets { // printf(\"\\t s[i]=%c\\n\", s[i]); //DEBUG if ( s [ i ] == '{' || s [ i ] == '(' || s [ i ] == '[' ) // if opening bracket then push push ( s [ i ] ) ; else { if ( c <= 0 ) // i.e, stack is empty as only opening brackets are // added to stack return 0 ; x = pop ( ) ; if ( x == '{' && s [ i ] != '}' ) return 0 ; if ( x == '[' && s [ i ] != ']' ) return 0 ; if ( x == '(' && s [ i ] != ')' ) return 0 ; } i ++ ; } // at end if stack is empy which means whole process has been performed // correctly so return 1 return ( c == 0 ) ? 1 : 0 ; }",
    "resources/C/data_structures/stack/parenthesis.c@destroyStack": "void destroyStack ( void ) { struct node * p = head ; if ( c > 0 ) { while ( p -> link ) { struct node * tmp = p ; p = p -> link ; free ( tmp ) ; } c = 0 ; } }",
    "resources/C/data_structures/stack/parenthesis.c@main": "int main ( void ) { int t ; printf ( \"\\t\\tBalanced parenthesis\\n\\n\" ) ; printf ( \"\\nPlease enter the number of processing rounds? \" ) ; scanf ( \"%d\" , & t ) ; for ( int a0 = 0 ; a0 < t ; a0 ++ ) { char s [ SIZE ] ; printf ( \"\\nPlease enter the expression? \" ) ; scanf ( \"%s\" , s ) ; if ( isBalanced ( s ) ) printf ( \"\\nYES\\n\" ) ; else printf ( \"\\nNO\\n\" ) ; /* tidy up stack for new round */ destroyStack ( ) ; } return 0 ; }",
    "resources/C/data_structures/stack/dynamic_stack.c@create_stack": "DArrayStack * create_stack ( int cap ) { DArrayStack * ptr ; ptr = ( DArrayStack * ) malloc ( sizeof ( DArrayStack ) ) ; ptr -> capacity = cap ; ptr -> top = - 1 ; ptr -> arrPtr = ( int * ) malloc ( sizeof ( int ) * cap ) ; printf ( \"\\nStack of capacity %d is successfully created.\\n\" , ptr -> capacity ) ; return ( ptr ) ; }",
    "resources/C/data_structures/stack/dynamic_stack.c@double_array": "DArrayStack * double_array ( DArrayStack * ptr , int cap ) { int newCap = 2 * cap ; int * temp ; temp = ( int * ) malloc ( sizeof ( int ) * newCap ) ; for ( int i = 0 ; i < ( ptr -> top ) + 1 ; i ++ ) { temp [ i ] = ptr -> arrPtr [ i ] ; } free ( ptr -> arrPtr ) ; ptr -> arrPtr = temp ; ptr -> capacity = newCap ; return ptr ; }",
    "resources/C/data_structures/stack/dynamic_stack.c@shrink_array": "DArrayStack * shrink_array ( DArrayStack * ptr , int cap ) { int newCap = cap / 2 ; int * temp ; temp = ( int * ) malloc ( sizeof ( int ) * newCap ) ; for ( int i = 0 ; i < ( ptr -> top ) + 1 ; i ++ ) { temp [ i ] = ptr -> arrPtr [ i ] ; } free ( ptr -> arrPtr ) ; ptr -> arrPtr = temp ; ptr -> capacity = newCap ; return ptr ; }",
    "resources/C/data_structures/stack/dynamic_stack.c@push": "int push ( DArrayStack * ptr , int data ) { if ( ptr -> top == ( ptr -> capacity ) - 1 ) { ptr = double_array ( ptr , ptr -> capacity ) ; ptr -> top ++ ; ptr -> arrPtr [ ptr -> top ] = data ; } else { ptr -> top ++ ; ptr -> arrPtr [ ptr -> top ] = data ; } printf ( \"Successfully pushed : %d\\n\" , data ) ; return ptr -> top ; }",
    "resources/C/data_structures/stack/dynamic_stack.c@pop": "int pop ( DArrayStack * ptr ) { if ( ptr -> top == - 1 ) { printf ( \"Stack is empty UNDERFLOW \\n\" ) ; return - 1 ; } int ele = ptr -> arrPtr [ ptr -> top ] ; ptr -> arrPtr [ ptr -> top ] = 0 ; ptr -> top = ( ptr -> top - 1 ) ; if ( ( ptr -> capacity ) % 2 == 0 ) { if ( ptr -> top <= ( ptr -> capacity / 2 ) - 1 ) { ptr = shrink_array ( ptr , ptr -> capacity ) ; } } printf ( \"Successfully popped: %d\\n\" , ele ) ; return ele ; }",
    "resources/C/data_structures/stack/dynamic_stack.c@peek": "int peek ( DArrayStack * ptr ) { if ( ptr -> top == - 1 ) { printf ( \"Stack is empty UNDERFLOW \\n\" ) ; return - 1 ; } return ptr -> arrPtr [ ptr -> top ] ; }",
    "resources/C/data_structures/stack/dynamic_stack.c@show_capacity": "int show_capacity ( DArrayStack * ptr ) { return ptr -> capacity ; }",
    "resources/C/data_structures/stack/dynamic_stack.c@isempty": "int isempty ( DArrayStack * ptr ) { if ( ptr -> top == - 1 ) { return 1 ; } return 0 ; }",
    "resources/C/data_structures/stack/dynamic_stack.c@stack_size": "int stack_size ( DArrayStack * ptr ) { return ptr -> top + 1 ; }",
    "resources/C/data_structures/stack/dynamic_stack.c@test": "static void test ( ) { DArrayStack * NewStack ; int capacity = 1 ; NewStack = create_stack ( capacity ) ; uint64_t arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 } ; printf ( \"\\nTesting Empty stack: \" ) ; assert ( stack_size ( NewStack ) == 0 ) ; assert ( isempty ( NewStack ) == 1 ) ; printf ( \"Size of an empty stack is %d\\n\" , stack_size ( NewStack ) ) ; printf ( \"\\nTesting PUSH operation:\\n\" ) ; for ( int i = 0 ; i < 12 ; ++ i ) { int topVal = push ( NewStack , arr [ i ] ) ; printf ( \"Size: %d, Capacity: %d\\n\\n\" , stack_size ( NewStack ) , show_capacity ( NewStack ) ) ; assert ( topVal == i ) ; assert ( peek ( NewStack ) == arr [ i ] ) ; assert ( stack_size ( NewStack ) == i + 1 ) ; assert ( isempty ( NewStack ) == 0 ) ; } printf ( \"\\nTesting POP operation:\\n\" ) ; for ( int i = 11 ; i > - 1 ; -- i ) { peek ( NewStack ) ; assert ( peek ( NewStack ) == arr [ i ] ) ; int ele = pop ( NewStack ) ; assert ( ele == arr [ i ] ) ; assert ( stack_size ( NewStack ) == i ) ; } printf ( \"\\nTesting Empty stack size: \" ) ; assert ( stack_size ( NewStack ) == 0 ) ; assert ( isempty ( NewStack ) == 1 ) ; printf ( \"Size of an empty stack is %d\\n\" , stack_size ( NewStack ) ) ; printf ( \"\\nTesting POP operation on empty stack: \" ) ; assert ( pop ( NewStack ) == - 1 ) ; }",
    "resources/C/data_structures/stack/dynamic_stack.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/project_euler/problem_401/sol1.c@is_in": "char is_in ( uint64_t N , uint64_t * D , uint64_t L ) { uint64_t i ; for ( i = 0 ; i < L ; i ++ ) { if ( D [ i ] == N ) { return 1 ; } } return 0 ; }",
    "resources/C/project_euler/problem_401/sol1.c@get_divisors": "uint64_t get_divisors ( uint64_t N , uint64_t * D ) { uint64_t q , r ; int64_t i , num = 0 ; if ( N == 1 ) { D [ 0 ] = 1 ; return 1 ; } // search till sqrt(N) // because after this, the pair of divisors will repeat themselves for ( i = 1 ; i * i <= N + 1 ; i ++ ) { r = N % i ; // get reminder // reminder = 0 if 'i' is a divisor of 'N' if ( r == 0 ) { q = N / i ; if ( ! is_in ( i , D , num ) ) // if divisor was already stored { D [ num ] = i ; num ++ ; } if ( ! is_in ( q , D , num ) ) // if divisor was already stored { D [ num ] = q ; num ++ ; } } if ( num == MAX_LENGTH ) { // limit of array reached, allocate more space D = ( uint64_t * ) realloc ( D , MAX_LENGTH * sizeof ( uint64_t ) << 1 ) ; } } return num ; }",
    "resources/C/project_euler/problem_401/sol1.c@sigma2": "uint64_t sigma2 ( uint64_t N ) { uint64_t sum = 0 , L ; int64_t i ; uint64_t * D = ( uint64_t * ) malloc ( MAX_LENGTH * sizeof ( uint64_t ) ) ; L = get_divisors ( N , D ) ; for ( i = 1 ; i < L ; i ++ ) { uint64_t DD = ( D [ i ] * D [ i ] ) % MOD_LIMIT ; sum += DD ; } free ( D ) ; return sum % MOD_LIMIT ; }",
    "resources/C/project_euler/problem_401/sol1.c@sigma": "uint64_t sigma ( uint64_t N ) { uint64_t s , sum = 0 ; int64_t i ; # ifdef _OPENMP // parallelize on threads # pragma omp parallel for reduction ( + : sum ) # endif for ( i = 0 ; i <= N ; i ++ ) { s = sigma2 ( i ) ; sum += s ; } return sum % MOD_LIMIT ; }",
    "resources/C/project_euler/problem_401/sol1.c@main": "int main ( int argc , char * * argv ) { uint64_t N = 1000 ; if ( argc == 2 ) { N = strtoll ( argv [ 1 ] , NULL , 10 ) ; } else if ( argc > 2 ) { fprintf ( stderr , \"Wrong number of input arguments!\\n\" ) ; printf ( \"Usage:\\t ./sol1.c [N=1000]\" ) ; return - 1 ; } clock_t start_time = clock ( ) ; uint64_t result = sigma ( N ) ; double dtime = clock ( ) - start_time ; printf ( \"N = %\" PRIu64 \"\\nSum: %\" PRIu64 \"\\n\" , N , result ) ; printf ( \"Time taken: %.4gms\\n\" , dtime * 1e3 / CLOCKS_PER_SEC ) ; return 0 ; }",
    "resources/C/project_euler/problem_5/sol3.c@gcd": "unsigned long gcd ( unsigned long a , unsigned long b ) { unsigned long r ; if ( a > b ) { unsigned long t = a ; a = b ; b = t ; } while ( ( r = ( a % b ) ) ) { a = b ; b = r ; } return b ; }",
    "resources/C/project_euler/problem_5/sol3.c@lcm": "unsigned long lcm ( unsigned long a , unsigned long b ) { unsigned long long p = ( unsigned long long ) a * b ; return p / gcd ( a , b ) ; }",
    "resources/C/project_euler/problem_5/sol3.c@main": "int main ( void ) { unsigned long ans = 1 ; unsigned long i ; for ( i = 1 ; i <= 20 ; i ++ ) { ans = lcm ( ans , i ) ; } printf ( \"%lu\\n\" , ans ) ; return 0 ; }",
    "resources/C/project_euler/problem_5/sol2.c@check_number": "static int check_number ( unsigned long long n ) { for ( size_t i = 0 ; i < 7 ; ++ i ) { if ( n % divisors [ i ] != 0 ) { return 0 ; } } return 1 ; }",
    "resources/C/project_euler/problem_5/sol2.c@main": "int main ( void ) { for ( unsigned long long n = 20 ; ; n += 20 ) { if ( check_number ( n ) ) { printf ( \"Result: %llu\\n\" , n ) ; break ; } } return 0 ; }",
    "resources/C/project_euler/problem_5/sol1.c@check_number": "static char check_number ( unsigned long long n ) { for ( unsigned long long i = 1 ; i <= 20 ; ++ i ) { if ( n % i != 0 ) { return 0 ; } } return 1 ; }",
    "resources/C/project_euler/problem_5/sol1.c@main": "int main ( void ) { for ( unsigned long long n = 1 ; ; ++ n ) { if ( check_number ( n ) ) { printf ( \"Result: %llu\\n\" , n ) ; break ; } } return 0 ; }",
    "resources/C/project_euler/problem_2/so1.c@main": "int main ( ) { int n = 0 ; int sum = 0 ; int i = 1 ; int j = 2 ; int temp ; scanf ( \"%d\" , & n ) ; while ( j <= n ) { if ( ( j & 1 ) == 0 ) // can also use(j%2 == 0) sum += j ; temp = i ; i = j ; j = temp + i ; } printf ( \"%d\\n\" , sum ) ; return 0 ; }",
    "resources/C/project_euler/problem_3/sol2.c@main": "int main ( ) { int n = 0 ; scanf ( \"%d\" , & n ) ; int prime = 1 ; int i = 2 ; while ( i * i <= n ) { while ( n % i == 0 ) { prime = i ; n /= i ; } i += 1 ; } if ( n > 1 ) prime = n ; printf ( \"%d\\n\" , prime ) ; return 0 ; }",
    "resources/C/project_euler/problem_3/sol1.c@isprime": "char isprime ( int no ) { int sq ; if ( no == 2 ) { return 1 ; } else if ( no % 2 == 0 ) { return 0 ; } sq = ( ( int ) ( sqrt ( no ) ) ) + 1 ; for ( int i = 3 ; i < sq ; i += 2 ) { if ( no % i == 0 ) { return 0 ; } } return 1 ; }",
    "resources/C/project_euler/problem_3/sol1.c@main": "int main ( ) { int maxNumber = 0 ; int n = 0 ; int n1 ; scanf ( \"%d\" , & n ) ; if ( isprime ( n ) == 1 ) printf ( \"%d\" , n ) ; else { while ( n % 2 == 0 ) { n = n / 2 ; } if ( isprime ( n ) == 1 ) { printf ( \"%d\\n\" , n ) ; } else { n1 = ( ( int ) ( sqrt ( n ) ) ) + 1 ; for ( int i = 3 ; i < n1 ; i += 2 ) { if ( n % i == 0 ) { if ( isprime ( ( int ) ( n / i ) ) == 1 ) { maxNumber = n / i ; break ; } else if ( isprime ( i ) == 1 ) { maxNumber = i ; } } } printf ( \"%d\\n\" , maxNumber ) ; } } return 0 ; }",
    "resources/C/project_euler/problem_4/sol.c@is_palindromic": "int is_palindromic ( unsigned int n ) { unsigned int reversed = 0 , t = n ; while ( t > 0 ) { reversed = 10 * reversed + ( t % 10 ) ; t /= 10 ; } return reversed == n ; }",
    "resources/C/project_euler/problem_4/sol.c@main": "int main ( void ) { unsigned int i , j , max = 0 ; for ( i = 100 ; i <= 999 ; i ++ ) { for ( j = 100 ; j <= 999 ; j ++ ) { unsigned int p = i * j ; if ( is_palindromic ( p ) && p > max ) { max = p ; } } } printf ( \"%u\\n\" , max ) ; return 0 ; }",
    "resources/C/project_euler/problem_19/sol1.c@get_month_days": "char get_month_days ( short month ) { if ( month == 1 ) /* February has 28 days. Adjust leap year in the loop */ return 28 ; else if ( month <= 6 ) /* odd months till July have 30 days - Jan = 0 (even)*/ { if ( month & 0x01 ) return 30 ; else return 31 ; } // else if (month >= 7) /* odd months after July have 31 days*/ if ( month & 0x01 ) return 31 ; return 30 ; }",
    "resources/C/project_euler/problem_19/sol1.c@is_leap_year": "char is_leap_year ( short year ) { if ( ( year % 400 == 0 ) || ( ( year % 4 == 0 ) && ( year % 100 != 0 ) ) ) return 1 ; return 0 ; }",
    "resources/C/project_euler/problem_19/sol1.c@main": "int main ( int argc , char * * argv ) { int count_sundays = 0 ; const short start_year = 1901 ; const short end_year = 2000 ; /*\r\n     * Let us identify days i.e., Sunday thru Saturday with integers - 0 thru 6\r\n     * respectively Jan 1 1901 was a Tuesday\r\n     */ char start_day = 2 ; for ( int year = start_year ; year <= end_year ; year ++ ) { char is_leap = is_leap_year ( year ) ; for ( char month = 0 ; month < 12 ; month ++ ) { /*\r\n             * These two for-loops count the start of day for the next month.\r\n             * Hence, we have to skip the last December count\r\n             */ if ( year == end_year && month == 11 ) continue ; int days = get_month_days ( month ) ; if ( is_leap && month == 1 ) /* for a leap year february, add a day */ days ++ ; # ifdef DEBUG if ( year == end_year ) { printf ( \"Year: %d\\t Month: %d\\t Days: %d\\t First of day: %s\\n\" , year , month , days , day_string ( start_day ) ) ; } # endif /* Main Algorithm:\r\n             * every week has 7 days hence, the start of next day would be\r\n             * modulo 7 add to this, the current start date and ensure the\r\n             * result is still modulo 7!\r\n             */ start_day = ( ( days % 7 ) + start_day ) % 7 ; /* If start-day is a Sunday, increment counter */ if ( start_day == 0 ) count_sundays ++ ; } } printf ( \"Total number of Sundays that happened on the 1st of a month in the \" \"last century: %d\\n\" , count_sundays ) ; return 0 ; }",
    "resources/C/project_euler/problem_26/sol1.c@compare": "int compare ( const void * a , const void * b ) { return ( * ( unsigned short * ) a - * ( unsigned short * ) b ) ; }",
    "resources/C/project_euler/problem_26/sol1.c@main": "int main ( int argc , char * argv [ ] ) { unsigned short max_digits = 0 , max_idx_number = 0 ; clock_t start_time = clock ( ) ; short deno ; # ifdef _OPENMP # pragma omp for # endif for ( deno = 2 ; deno < MAX_DENO ; deno ++ ) { unsigned short remainders [ MAX_LEN ] ; unsigned short rem = 1 , * rem_ptr = remainders ; memset ( remainders , ( unsigned short ) - 1 , MAX_LEN * sizeof ( unsigned short ) ) ; // remainders[0] = 1; // printf(\"1/%-4u\\t \", deno); unsigned short index = 0 , num_digits ; while ( rem != 0 ) { rem = ( rem * 10 ) % deno ; if ( rem == 0 ) { index = 0 ; break ; } rem_ptr = ( unsigned short * ) bsearch ( & rem , remainders , MAX_LEN , sizeof ( unsigned short ) , compare ) ; // printf(\"%2d, \", rem); // printf(\"(%14p), \", rem_ptr); if ( rem_ptr != NULL ) break ; remainders [ index ] = rem ; rem_ptr = remainders ; index ++ ; } num_digits = index - ( rem_ptr - remainders ) ; // printf(\"\\n\\t(%14p, %14p, %4u, %4u)\\n\", rem_ptr, remainders, index, // num_digits); # ifdef _OPENMP # pragma omp critical { # endif if ( num_digits > max_digits ) { max_digits = num_digits ; max_idx_number = deno ; // printf(\"\\t (%u, %u)\\n \", max_digits, max_idx_number); } # ifdef _OPENMP } # endif } clock_t end_time = clock ( ) ; printf ( \"Time taken: %.4g ms\\n\" , 1e3 * ( double ) ( end_time - start_time ) / CLOCKS_PER_SEC ) ; printf ( \"Maximum digits: %hu\\t Denominator: %hu\\n\" , max_digits , max_idx_number ) ; return 0 ; }",
    "resources/C/project_euler/problem_21/sol1.c@sum_of_divisors": "unsigned long sum_of_divisors ( unsigned int N ) { unsigned long sum = 1 + N ; /* 1 and itself are always a divisor */ /* divisors are symmertically distributed about the square-root */ for ( unsigned int i = 2 ; i * i < N ; i ++ ) { if ( ( N % i ) != 0 ) /* i is not a divisor of N */ continue ; // #ifdef DEBUG //         printf(\"%4d, %4d,\", i, N / i); // #endif sum += i + ( N / i ) ; } // #ifdef DEBUG //     printf(\"\\nSum of divisors of %4d: %4d\\n\", N, sum); // #endif return sum ; }",
    "resources/C/project_euler/problem_21/sol1.c@main": "int main ( int argc , char * * argv ) { unsigned long sum = 0 ; unsigned int MAX_N = 500 ; if ( argc == 2 ) MAX_N = atoi ( argv [ 1 ] ) ; /*\n     * We use an array of flags to check if a number at the index was:\n     * not-processed = 0\n     * is amicable = 1\n     * not amicable = -1\n     */ char * flags = ( char * ) calloc ( MAX_N , sizeof ( char ) ) ; clock_t start_time = clock ( ) ; int i ; /* there are no such numbers till 10. Lets search from there on */ for ( i = 10 ; i < MAX_N ; i ++ ) { if ( flags [ i ] != 0 ) /* already processed, skip */ continue ; unsigned int b = sum_of_divisors ( i ) ; if ( b >= MAX_N ) flags [ i ] = - 1 ; else if ( flags [ b ] == - 1 ) continue ; unsigned int c = sum_of_divisors ( b ) ; if ( c == i && b != i ) { /* found amicable */ flags [ b ] = 1 ; flags [ i ] = 1 ; sum += b + i ; # ifdef DEBUG printf ( \"Amicable: %4d : %4d\\n\" , i , b ) ; # endif } else { flags [ i ] = - 1 ; if ( b < MAX_N ) flags [ b ] = - 1 ; } } clock_t end_time = clock ( ) ; printf ( \"\\nTime taken: %.4g millisecond\\n\" , 1e3 * ( end_time - start_time ) / CLOCKS_PER_SEC ) ; printf ( \"Sum of all numbers = %lu\\n\" , sum ) ; free ( flags ) ; return 0 ; }",
    "resources/C/project_euler/problem_10/sol2.c@main": "int main ( int argc , char * argv [ ] ) { long n = 100 ; long long sum = 0 ; char * sieve = NULL ; if ( argc == 2 ) /* if command line argument is provided */ n = atol ( argv [ 1 ] ) ; /* use that as the upper limit */ /* allocate memory for the sieve */ sieve = calloc ( n , sizeof ( * sieve ) ) ; if ( ! sieve ) { perror ( \"Unable to allocate memory!\" ) ; return - 1 ; } /* build sieve of Eratosthenes\n        In the array,\n        * if i^th cell is '1', then 'i' is composite\n        * if i^th cell is '0', then 'i' is prime\n    */ for ( long i = 2 ; i < sqrtl ( n ) ; i ++ ) { /* if i^th element is prime, mark all its multiples\n        as composites */ if ( ! sieve [ i ] ) { for ( long j = i * i ; j < n + 1 ; j += i ) { sieve [ j ] = 1 ; } sum += i ; } } for ( long i = sqrtl ( n ) + 1 ; i < n ; i ++ ) if ( ! sieve [ i ] ) sum += i ; free ( sieve ) ; printf ( \"%ld: %lld\\n\" , n , sum ) ; return 0 ; }",
    "resources/C/project_euler/problem_10/sol1.c@is_prime": "char is_prime ( unsigned long n ) { for ( unsigned long i = 2 ; i < sqrtl ( n ) + 1 ; i ++ ) if ( n % i == 0 ) return 0 ; return 1 ; }",
    "resources/C/project_euler/problem_10/sol1.c@sum_of_primes": "unsigned long long sum_of_primes ( unsigned long N ) { unsigned long long sum = 2 ; for ( long i = 3 ; i < N ; i += 2 ) /* skip even numbers */ if ( is_prime ( i ) ) sum += i ; return sum ; }",
    "resources/C/project_euler/problem_10/sol1.c@main": "int main ( int argc , char * argv [ ] ) { unsigned long n = 100 ; if ( argc == 2 ) /* if command line argument is provided */ n = atol ( argv [ 1 ] ) ; /* use that as the upper limit */ printf ( \"%ld: %llu\\n\" , n , sum_of_primes ( n ) ) ; return 0 ; }",
    "resources/C/project_euler/problem_16/sol1.c@main": "int main ( int argc , char * * argv ) { const double tmp = log ( 10 ) / log ( 2 ) ; /* required to get number of digits */ unsigned long MAX_NUM_DIGITS ; uint8_t * digits = NULL ; /* array to store individual digits. index 0 = units place */ int N = 1000 , sum = 0 ; if ( argc == 2 ) N = atoi ( argv [ 1 ] ) ; MAX_NUM_DIGITS = ( N + tmp ) / tmp ; digits = calloc ( MAX_NUM_DIGITS , sizeof ( uint8_t ) ) ; digits [ 0 ] = 1 ; if ( ! digits ) { perror ( \"Unable to allocate memory!\" ) ; return - 1 ; } for ( int i = 0 ; i < N ; i ++ ) { int carry = 0 ; for ( int j = 0 ; j < MAX_NUM_DIGITS ; j ++ ) { digits [ j ] = ( digits [ j ] << 1 ) + carry ; /* digit * 2 + carry */ // printf(\"\\t value: %d\\t\", digits[j]); if ( digits [ j ] > 9 ) { carry = 1 ; digits [ j ] -= 10 ; } else carry = 0 ; // printf(\"carry: %d\\t value: %d\\n\", carry, digits[j]); /* accumulate sum for last multiplication */ if ( i == N - 1 ) sum += digits [ j ] ; } } printf ( \"2^%d = \" , N ) ; for ( int i = MAX_NUM_DIGITS - 1 ; i >= 0 ; i -- ) putchar ( digits [ i ] + 0x30 ) ; printf ( \"\\n\\t Sum: %d\\t Num. digits: %lu\\n\" , sum , MAX_NUM_DIGITS ) ; free ( digits ) ; return 0 ; }",
    "resources/C/project_euler/problem_20/sol1.c@add_digit": "big_int * add_digit ( big_int * digit , char value ) { if ( digit == NULL ) { digit = ( big_int * ) malloc ( sizeof ( big_int ) ) ; if ( ! digit ) { perror ( \"Unable to allocate memory!\" ) ; return NULL ; } digit -> value = value ; digit -> next_digit = NULL ; digit -> prev_digit = NULL ; return digit ; } if ( digit -> next_digit ) { digit -> next_digit -> value = value ; return digit -> next_digit ; } digit -> next_digit = ( big_int * ) malloc ( sizeof ( big_int ) ) ; if ( digit -> next_digit == NULL ) { perror ( \"Unable to allocate memory!\" ) ; return NULL ; } digit -> next_digit -> value = value ; digit -> next_digit -> next_digit = NULL ; digit -> next_digit -> prev_digit = digit ; return digit -> next_digit ; }",
    "resources/C/project_euler/problem_20/sol1.c@remove_digits": "char remove_digits ( big_int * digit , int N ) { if ( digit == NULL ) return 0 ; if ( digit -> next_digit == NULL ) { free ( digit ) ; digit = NULL ; return 0 ; } if ( N > 0 ) return remove_digits ( digit -> next_digit , N - 1 ) ; return remove_digits ( digit -> next_digit , 0 ) ; }",
    "resources/C/project_euler/problem_20/sol1.c@main": "int main ( int argc , char * * argv ) { unsigned int N = 5 ; big_int * ptr = add_digit ( NULL , 1 ) ; /* start with 1 */ const big_int * ptr0 = ptr ; /* save the first location */ unsigned long sum_digits = 0 ; unsigned long num_digits = 0 ; if ( argc == 2 ) N = atoi ( argv [ 1 ] ) ; clock_t start_time = clock ( ) ; for ( unsigned int i = 1 ; i <= N ; i ++ ) { int carry = 0 ; # ifdef DEBUG printf ( \"%3d: \" , i ) ; # endif ptr = ( big_int * ) ptr0 ; /* multiply every digit with i */ while ( ptr ) { # ifdef DEBUG printf ( \"%p\\t\" , ptr ) ; # endif unsigned int tmp = ptr -> value * i + carry ; if ( tmp >= 10 ) { div_t tmp2 = div ( tmp , 10 ) ; carry = tmp2 . quot ; tmp = tmp2 . rem ; } else carry = 0 ; if ( carry > 0 && ptr -> next_digit == NULL ) add_digit ( ptr , 0 ) ; ptr -> value = tmp ; if ( i == N ) /*\n                 * sum digits on the last iteration\n                 * this avoid having another loop over all digits\n                 */ sum_digits += tmp ; if ( ptr -> next_digit ) /* more digits available */ ptr = ptr -> next_digit ; else /* no more digits left - reached MSB */ break ; } # ifdef DEBUG printf ( \"\\n\" ) ; # endif } clock_t end_time = clock ( ) ; # ifdef DEBUG printf ( \"ptr = %p\\n\" , ptr ) ; printf ( \"%d! = \" , N ) ; # endif /* Notice that in the loop above, we make sure that at the end of the loop,\n     * ptr is pointing to the last digit. Thus we can avoid using another loop.\n     */ // ptr = &my_int; // /* move ptr to the MSB digit */ // while (ptr->next_digit) //     ptr = ptr->next_digit; do { putchar ( ptr -> value + 0x30 ) ; /* convert digit to ASCII char */ ptr = ptr -> prev_digit ; num_digits ++ ; } while ( ptr ) ; /* after coming to units place, there will be no valid ptr */ printf ( \"\\nTime taken: %.4g millisecond\\n\" , 1e3 * ( end_time - start_time ) / CLOCKS_PER_SEC ) ; printf ( \"Digit Sum = %lu\\tNumber of digits = %lu\\tStorage space = %.3gkb\\t \\n\" , sum_digits , num_digits , num_digits * sizeof ( big_int ) / 1024.0 ) ; remove_digits ( ( big_int * ) ptr0 , - 1 ) ; return 0 ; }",
    "resources/C/project_euler/problem_8/sol2.c@main": "int main ( int argc , char * argv [ ] ) { int position = 0 , num_bad_chars = 0 ; int num_digits = 4 ; char ch ; unsigned char num , num_prev ; unsigned char * buffer = NULL ; long long int prod = 1 , max_prod = 0 ; /* if second command-line argument is given,\n     * use it as the number of digits to compute\n     * successive product for\n     */ if ( argc == 2 ) num_digits = atoi ( argv [ 1 ] ) ; /* allocate memory to store past values */ buffer = calloc ( num_digits , sizeof ( unsigned char ) ) ; if ( ! buffer ) { perror ( \"Unable to allocate memory for buffer\" ) ; return - 1 ; } /* open file to read digits from */ FILE * fp = fopen ( \"digits.txt\" , \"rt\" ) ; if ( ! fp ) { perror ( \"Unable to open file\" ) ; free ( buffer ) ; /* free allocated memory */ return - 1 ; } /* loop through all digits in the file */ do { /* get character from file */ ch = getc ( fp ) ; /* the ASCII codes of digits is between 0x30 and 0x39.\n         * any character not in this range implies an invalid character\n         */ if ( ch < 0x30 || ch > 0x39 ) { num_bad_chars ++ ; /* this is used to get the bad characters in the\n                                sequence of 13 characters */ continue ; } else if ( num_bad_chars > 0 ) num_bad_chars -- ; num = ch - 0x30 ; /* convert character digit to number */ num_prev = buffer [ 0 ] ; /* previous n^th digit */ /* left shift the buffer -\n         *  using a for loop or a faster memory move\n         */ memmove ( buffer , buffer + 1 , num_digits - 1 ) ; /*\n        for (int i = 1; i < num_digits; i++)\n            buffer[i-1] = buffer[i];\n        */ buffer [ num_digits - 1 ] = num ; /* save the latest number in buffer */ if ( num_prev != 0 ) { /* since product is accumulated, the new product can be obtained by\n             * simply multiplying the new digit and dividing with the oldest\n             * digit\n             */ prod /= num_prev ; /* divide first to avoid over-flows */ prod *= num ; } else { prod = 1 ; for ( int i = 0 ; i < num_digits ; i ++ ) { if ( buffer [ i ] == 0 ) { prod = 0 ; break ; /* break innermost for-loop */ } prod *= buffer [ i ] ; } } /* check if a new maxima was found */ if ( prod > max_prod ) { max_prod = prod ; position = ftell ( fp ) - num_bad_chars - num_digits - 1 ; } } while ( ! feof ( fp ) ) ; /* loop till end of file is reached */ printf ( \"Maximum product: %lld\\t Location: %d^th position\\n\\t\" , max_prod , position ) ; fseek ( fp , position , SEEK_SET ) ; /* move cursor to identified position in file */ /* loop through all digits */ for ( ; num_digits > 0 ; num_digits -- ) { char ch = getc ( fp ) ; /* get character */ /* skip invalid character */ if ( ch < 0x30 || ch > 0x39 ) continue ; if ( num_digits > 1 ) printf ( \"%c x \" , ch ) ; else printf ( \"%c = %lld\\n\" , ch , max_prod ) ; } fclose ( fp ) ; /* close file */ free ( buffer ) ; /* free allocated memory */ return 0 ; }",
    "resources/C/project_euler/problem_8/sol1.c@get_product": "long long int get_product ( FILE * fp , long start_pos , int num_digits ) { char ch = ' ' ; /* temporary variable to store character read from file */ unsigned char num = 0 ; /* temporary variable to store digit read */ long long int prod = 1 ; /* product accumulator */ int count = 0 ; /* we use this variable to count number of bytes of file read */ /* accumulate product for num_digits */ for ( int i = 0 ; i < num_digits ; i ++ , count ++ ) { /* get character from file */ ch = getc ( fp ) ; /* the ASCII codes of digits is between 0x30 and 0x39.\n         * any character not in this range implies an invalid character\n         */ if ( ch < 0x30 || ch > 0x39 ) { if ( ch == EOF ) return 0 ; i -- ; continue ; } num = ch - 0x30 ; /* convert character digit to number */ if ( num == 0 ) { /* If number is zero, we can skip the next 'num_digits'\n             * because this '0' will repeat in the next 'num_digit'\n             * multiplications. Hence, we also do not update the file position\n             */ /* NOTE: this is not needed but helps get results faster :) */ return 0 ; } prod *= num ; /* accumulate product */ } /* set file position to the next starting character + 1 */ fseek ( fp , - count + 1 , SEEK_CUR ) ; return prod ; }",
    "resources/C/project_euler/problem_8/sol1.c@main": "int main ( int argc , char * argv [ ] ) { int position = 0 ; int num_digits = 4 ; long long int prod , max_prod = 0 ; /* if second command-line argument is ge=iven,\n     * use it as the number of digits to compute\n     * successive product for\n     */ if ( argc == 2 ) num_digits = atoi ( argv [ 1 ] ) ; /* open file to read digits from */ FILE * fp = fopen ( \"digits.txt\" , \"rt\" ) ; if ( ! fp ) { perror ( \"Unable to open file\" ) ; return - 1 ; } /* loop through all digits in the file */ do { /* get product of 'num_digits' from current position in file */ prod = get_product ( fp , ftell ( fp ) , num_digits ) ; if ( prod > max_prod ) { max_prod = prod ; position = ftell ( fp ) - 1 ; } } while ( ! feof ( fp ) ) ; /* loop till end of file is reached */ printf ( \"Maximum product: %lld\\t Location: %d^th position\\n\\t\" , max_prod , position ) ; fseek ( fp , position , SEEK_SET ) ; /* move cursor to identified position in file */ /* loop through all digits */ for ( ; num_digits > 0 ; num_digits -- ) { char ch = getc ( fp ) ; /* get character */ /* skip invalid character */ if ( ch < 0x30 || ch > 0x39 ) continue ; if ( num_digits > 1 ) printf ( \"%c x \" , ch ) ; else printf ( \"%c = %lld\\n\" , ch , max_prod ) ; } fclose ( fp ) ; /* close file */ return 0 ; }",
    "resources/C/project_euler/problem_1/sol4.c@main": "int main ( ) { int t ; printf ( \"Enter number of times you want to try\" ) ; scanf ( \"%d\" , & t ) ; while ( t -- ) { unsigned long long N , p = 0 , sum = 0 ; printf ( \"Enter the value of N \" ) ; scanf ( \"%lld\" , & N ) ; // Take input of N from user for ( int i = 0 ; i < N ; i ++ ) { if ( i % 3 == 0 || i % 5 == 0 ) { sum = sum + i ; } } printf ( \"%lld\\n\" , sum ) ; // print the sum of all numbers that are // multiples of 3 & 5 below N } return 0 ; }",
    "resources/C/project_euler/problem_1/sol3.c@main": "int main ( ) { int n = 0 ; int sum = 0 ; int num = 0 ; scanf ( \"%d\" , & n ) ; while ( 1 ) { num += 3 ; if ( num >= n ) break ; sum += num ; num += 2 ; if ( num >= n ) break ; sum += num ; num += 1 ; if ( num >= n ) break ; sum += num ; num += 3 ; if ( num >= n ) break ; sum += num ; num += 1 ; if ( num >= n ) break ; sum += num ; num += 2 ; if ( num >= n ) break ; sum += num ; num += 3 ; if ( num >= n ) break ; sum += num ; } printf ( \"%d\\n\" , sum ) ; return 0 ; }",
    "resources/C/project_euler/problem_1/sol2.c@main": "int main ( ) { int n = 0 ; int sum = 0 ; scanf ( \"%d\" , & n ) ; int terms = ( n - 1 ) / 3 ; sum += ( ( terms ) * ( 6 + ( terms - 1 ) * 3 ) ) / 2 ; // sum of an A.P. terms = ( n - 1 ) / 5 ; sum += ( ( terms ) * ( 10 + ( terms - 1 ) * 5 ) ) / 2 ; terms = ( n - 1 ) / 15 ; sum -= ( ( terms ) * ( 30 + ( terms - 1 ) * 15 ) ) / 2 ; printf ( \"%d\\n\" , sum ) ; }",
    "resources/C/project_euler/problem_1/sol1.c@main": "int main ( ) { int t ; printf ( \"Enter number of times you want to try\" ) ; scanf ( \"%d\" , & t ) ; while ( t -- ) // while t > 0, decrement 't' before every iteration { unsigned long long N , p = 0 , sum = 0 ; printf ( \"Enter the value of N \" ) ; scanf ( \"%lld\" , & N ) ; // Take input of N from user p = ( N - 1 ) / 3 ; sum = ( ( 3 * p * ( p + 1 ) ) / 2 ) ; p = ( N - 1 ) / 5 ; sum = sum + ( ( 5 * p * ( p + 1 ) ) / 2 ) ; p = ( N - 1 ) / 15 ; sum = sum - ( ( 15 * p * ( p + 1 ) ) / 2 ) ; printf ( \"%lld\\n\" , sum ) ; // print the sum of all numbers that are // multiples of 3 & 5 below N } return 0 ; }",
    "resources/C/project_euler/problem_6/sol.c@main": "int main ( void ) { unsigned s1 = 0 , s2 = 0 , i ; for ( i = 1 ; i <= 100 ; i ++ ) { s1 += i * i ; s2 += i ; } unsigned ans = s2 * s2 - s1 ; printf ( \"%u\\n\" , ans ) ; return 0 ; }",
    "resources/C/project_euler/problem_7/sol.c@main": "int main ( void ) { char * sieve ; size_t i ; unsigned count = 0 ; size_t n = 1000000 ; const unsigned target = 10001 ; sieve = ( char * ) calloc ( n , sizeof ( char ) ) ; for ( i = 2 ; i < n ; i ++ ) { if ( ! sieve [ i ] ) { size_t j ; count ++ ; if ( count == target ) { printf ( \"%lu\\n\" , i ) ; break ; } for ( j = i * 2 ; j < n ; j += i ) { sieve [ j ] = 1 ; } } } free ( sieve ) ; return 0 ; }",
    "resources/C/project_euler/problem_7/sol2.c@main": "int main ( ) { int n ; scanf ( \"%d\" , & n ) ; int number_of_prime = 0 ; for ( int i = 2 ; ; i ++ ) { int divisors = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { if ( i % j == 0 ) { divisors ++ ; } } if ( divisors == 2 ) { number_of_prime ++ ; if ( number_of_prime == n ) { printf ( \"%d\" , i ) ; break ; } } } return 0 ; }",
    "resources/C/project_euler/problem_9/sol2.c@main": "int main ( void ) { int N = 1000 ; for ( int a = 1 ; a < 300 ; a ++ ) { long tmp1 = N * N - 2 * a * N ; long tmp2 = 2 * ( N - a ) ; div_t tmp3 = div ( tmp1 , tmp2 ) ; int b = tmp3 . quot ; int c = N - a - b ; if ( a * a + b * b == c * c ) { printf ( \"%d x %d x %d = %ld\\n\" , a , b , c , ( long int ) a * b * c ) ; return 0 ; } } return 0 ; }",
    "resources/C/project_euler/problem_9/sol1.c@main": "int main ( void ) { for ( int a = 1 ; a < 300 ; a ++ ) for ( int b = a + 1 ; b < 400 ; b ++ ) for ( int c = b + 1 ; c < 500 ; c ++ ) { if ( a * a + b * b == c * c ) if ( a + b + c == 1000 ) { printf ( \"%d x %d x %d = %ld\\n\" , a , b , c , ( long int ) a * b * c ) ; return 0 ; } } return 0 ; }",
    "resources/C/project_euler/problem_22/sol1.c@shell_sort": "void shell_sort ( char data [ ] [ MAX_NAME_LEN ] , int LEN ) { const int gaps [ ] = { 701 , 301 , 132 , 57 , 23 , 10 , 4 , 1 } ; const int gap_len = 8 ; int i , j , g ; for ( g = 0 ; g < gap_len ; g ++ ) { int gap = gaps [ g ] ; for ( i = gap ; i < LEN ; i ++ ) { char tmp_buffer [ MAX_NAME_LEN ] ; strcpy ( tmp_buffer , data [ i ] ) ; for ( j = i ; j >= gap && strcmp ( data [ j - gap ] , tmp_buffer ) > 0 ; j -= gap ) strcpy ( data [ j ] , data [ j - gap ] ) ; strcpy ( data [ j ] , tmp_buffer ) ; } } # ifdef DEBUG for ( i = 0 ; i < LEN ; i ++ ) printf ( \"%s\\t\" , data [ i ] ) ; # endif }",
    "resources/C/project_euler/problem_22/sol1.c@lazy_sort": "void lazy_sort ( char data [ ] [ MAX_NAME_LEN ] , int LEN ) { int i , j ; for ( i = 0 ; i < LEN ; i ++ ) { for ( j = i + 1 ; j < LEN ; j ++ ) { if ( strcmp ( data [ i ] , data [ j ] ) > 0 ) { char tmp_buffer [ MAX_NAME_LEN ] ; strcpy ( tmp_buffer , data [ i ] ) ; strcpy ( data [ i ] , data [ j ] ) ; strcpy ( data [ j ] , tmp_buffer ) ; } } } # ifdef DEBUG for ( i = 0 ; i < LEN ; i ++ ) printf ( \"%s\\t\" , data [ i ] ) ; # endif }",
    "resources/C/project_euler/problem_22/sol1.c@main": "int main ( int argc , char * * argv ) { unsigned long COUNT = 0 ; char * fname = \"names.txt\" ; char names [ MAX_NAMES ] [ MAX_NAME_LEN ] ; short method = 0 ; /* sorting algorithm to use. 0 = lazy, 1 = shell-sort */ if ( argc == 2 ) method = atoi ( argv [ 1 ] ) ; FILE * fp = fopen ( fname , \"rt\" ) ; if ( ! fp ) { perror ( \"Unable to open file\" ) ; return - 1 ; } /*\n     * Loops to get total number of rows and columns in the file\n     */ do { int ret = fscanf ( fp , \"\\\"%[^\\\",]\\\",\" , names [ COUNT ++ ] ) ; if ( ret <= 0 ) continue ; // printf(\"%s\\t\", names[COUNT - 1]); } while ( ! feof ( fp ) ) ; fclose ( fp ) ; printf ( \"\\nTotal number of names: %lu\\n\" , COUNT ) ; if ( method == 0 ) { clock_t start_time = clock ( ) ; shell_sort ( names , COUNT ) ; clock_t end_time = clock ( ) ; printf ( \"\\nShell sort: %.4g millisecond\\n\" , 1e3 * ( end_time - start_time ) / CLOCKS_PER_SEC ) ; } else if ( method == 1 ) { clock_t start_time = clock ( ) ; lazy_sort ( names , COUNT ) ; clock_t end_time = clock ( ) ; printf ( \"\\nLazy sort: %.4g millisecond\\n\" , 1e3 * ( end_time - start_time ) / CLOCKS_PER_SEC ) ; } long sum_score = 0 ; clock_t start_time = clock ( ) ; int i ; # ifdef _OPENMP # pragma omp parallel for schedule ( runtime ) reduction ( + : sum_score ) # endif # ifdef DEBUG for ( i = 935 ; i < 940 ; i ++ ) # else for ( i = 0 ; i < COUNT ; i ++ ) # endif { long score = 0 ; /* score the alphabets in i^th name */ for ( int j = 0 ; names [ i ] [ j ] != '\\0' ; j ++ ) score += names [ i ] [ j ] - 'A' + 1 ; /* convert ASCII character to integer score */ sum_score += score * ( i + 1 ) ; # ifdef DEBUG printf ( \"Name: %s\\tScore: %u x %u = %lu\\n\" , names [ i ] , score , i + 1 , ( unsigned long ) score * ( i + 1 ) ) ; # endif } clock_t end_time = clock ( ) ; printf ( \"Scoring time: %.4g millisecond\\n\" , 1e3 * ( end_time - start_time ) / CLOCKS_PER_SEC ) ; printf ( \"Total Score = %lu\\n\" , sum_score ) ; return 0 ; }",
    "resources/C/project_euler/problem_25/sol1.c@add_numbers": "unsigned int add_numbers ( unsigned char * a , unsigned char * b , unsigned char * c , int N ) { unsigned char carry = 0 ; unsigned int i ; for ( i = 0 ; i < N ; i ++ ) { // printf(\"\\t%d + %d + %d \", a[i], b[i], carry); c [ i ] = carry + a [ i ] + b [ i ] ; if ( c [ i ] > 9 ) /* check for carry */ { carry = 1 ; c [ i ] -= 10 ; } else { carry = 0 ; } // printf(\"= %d, %d\\n\", carry, c[i]); } while ( carry != 0 ) { // printf(\"\\t\\t...adding new digit\\n\"); // printf(\"\\t0 + %d + %d \", b[i], carry); c [ i ] = carry + c [ i ] ; if ( c [ i ] > 9 ) { carry = 1 ; c [ i ] -= 10 ; } else { carry = 0 ; } // printf(\"= %d, %d\\n\", carry, c[i]); i ++ ; } return i ; }",
    "resources/C/project_euler/problem_25/sol1.c@print_number": "int print_number ( unsigned char * number , int N ) { int start_pos = N - 1 ; /* skip all initial zeros */ while ( number [ start_pos ] == 0 ) start_pos -- ; for ( int i = start_pos ; i >= 0 ; i -- ) putchar ( number [ i ] + 0x30 ) ; return 0 ; }",
    "resources/C/project_euler/problem_25/sol1.c@get_digits": "unsigned int get_digits ( unsigned char * number ) { unsigned int digits = MAX_DIGITS ; while ( number [ digits ] == 0 ) digits -- ; return digits ; }",
    "resources/C/project_euler/problem_25/sol1.c@main": "int main ( int argc , char * argv [ ] ) { unsigned char fn [ MAX_DIGITS + 1 ] ; /* array to store digits of a large number */ unsigned char fn1 [ MAX_DIGITS + 1 ] ; unsigned char sum [ MAX_DIGITS + 1 ] ; memset ( fn , 0 , MAX_DIGITS ) ; memset ( fn1 , 0 , MAX_DIGITS ) ; memset ( sum , 0 , MAX_DIGITS ) ; fn [ 0 ] = 1 ; fn1 [ 1 ] = 1 ; unsigned int index = 1 , digit_count = 1 ; clock_t start_time = clock ( ) ; do { digit_count = add_numbers ( fn , fn1 , sum , digit_count ) ; // digit_count = get_digits(sum); // printf(\"%5u (%u) (%u) \", index, digit_count, get_digits(sum)); // print_number(sum, digit_count); // putchar('\\n'); if ( digit_count == MAX_DIGITS ) { break ; } memcpy ( fn , fn1 , MAX_DIGITS ) ; memcpy ( fn1 , sum , MAX_DIGITS ) ; index ++ ; } while ( digit_count < MAX_DIGITS ) ; clock_t end_time = clock ( ) ; printf ( \"Time taken: %.4g ms\\n\" , 1e3 * ( end_time - start_time ) / CLOCKS_PER_SEC ) ; printf ( \"The nth term for %d digits: %u \\n\" , MAX_DIGITS , index -- ) ; print_number ( sum , digit_count ) ; return 0 ; }",
    "resources/C/project_euler/problem_13/sol1.c@get_number": "int get_number ( FILE * fp , char * buffer , uint8_t * out_int ) { long l = fscanf ( fp , \"%s\\n\" , buffer ) ; if ( ! l ) { perror ( \"Error reading line.\" ) ; return - 1 ; } // printf(\"Number: %s\\t length: %ld, %ld\\n\", buffer, strlen(buffer), l); long L = strlen ( buffer ) ; for ( int i = 0 ; i < L ; i ++ ) { if ( buffer [ i ] < 0x30 || buffer [ i ] > 0x39 ) { perror ( \"found inavlid character in the number!\" ) ; return - 1 ; } else { out_int [ L - i - 1 ] = buffer [ i ] - 0x30 ; } } return 0 ; }",
    "resources/C/project_euler/problem_13/sol1.c@add_numbers": "int add_numbers ( uint8_t * a , uint8_t * b , uint8_t N ) { int carry = 0 ; uint8_t * c = b ; /* accumulate the result in the array 'b' */ for ( int i = 0 ; i < N ; i ++ ) { // printf(\"\\t%d + %d + %d \", a[i], b[i], carry); c [ i ] = carry + a [ i ] + b [ i ] ; // NOLINT // This is a known false-positive if ( c [ i ] > 9 ) /* check for carry */ { carry = 1 ; c [ i ] -= 10 ; } else { carry = 0 ; } // printf(\"= %d, %d\\n\", carry, c[i]); } for ( int i = N ; i < N + 10 ; i ++ ) { if ( carry == 0 ) { break ; } // printf(\"\\t0 + %d + %d \", b[i], carry); c [ i ] = carry + c [ i ] ; if ( c [ i ] > 9 ) { carry = 1 ; c [ i ] -= 10 ; } else { carry = 0 ; } // printf(\"= %d, %d\\n\", carry, c[i]); } return 0 ; }",
    "resources/C/project_euler/problem_13/sol1.c@print_number": "int print_number ( uint8_t * number , uint8_t N , int8_t num_digits_to_print ) { uint8_t start_pos = N - 1 ; uint8_t end_pos ; /* skip all initial zeros */ while ( number [ start_pos ] == 0 ) start_pos -- ; /* if end_pos < 0, print all digits */ if ( num_digits_to_print < 0 ) { end_pos = 0 ; } else if ( num_digits_to_print <= start_pos ) { end_pos = start_pos - num_digits_to_print + 1 ; } else { fprintf ( stderr , \"invalid number of digits argumet!\\n\" ) ; return - 1 ; } for ( int i = start_pos ; i >= end_pos ; i -- ) putchar ( number [ i ] + 0x30 ) ; putchar ( '\\n' ) ; return 0 ; }",
    "resources/C/project_euler/problem_13/sol1.c@main": "int main ( void ) { /* number of digits of the large number */ const int N = 10 ; /* number of digits in output number */ const int N2 = N + 10 ; // const char N = 50, N2 = N+10;          /* length of numbers */ char * txt_buffer = ( char * ) calloc ( N + 5 , sizeof ( char ) ) ; /* temporary buffer */ uint8_t * number = ( uint8_t * ) calloc ( N , sizeof ( uint8_t ) ) ; /* array to store digits of a large number */ uint8_t * sum = ( uint8_t * ) calloc ( N2 , sizeof ( uint8_t ) ) ; /* array to store the sum of the large\nnumbers. For safety, we make it twice the length of a number. */ FILE * fp = fopen ( \"num.txt\" , \"rt\" ) ; /* open text file to read */ if ( ! fp ) { perror ( \"Unable to open file 'num.txt'.\" ) ; free ( txt_buffer ) ; free ( sum ) ; free ( number ) ; return - 1 ; } int count = 0 ; get_number ( fp , txt_buffer , sum ) ; /* 0 + = first_number = first_number */ do { count ++ ; if ( get_number ( fp , txt_buffer , number ) != 0 ) { break ; } add_numbers ( number , sum , N ) ; } while ( ! feof ( fp ) ) ; printf ( \"\\nSum   : \" ) ; print_number ( sum , N2 , - 1 ) ; printf ( \"first 10 digits: \\t\" ) ; print_number ( sum , N2 , 10 ) ; fclose ( fp ) ; /* close file */ free ( txt_buffer ) ; free ( sum ) ; free ( number ) ; return 0 ; }",
    "resources/C/project_euler/problem_14/sol1.c@collatz": "long long collatz ( long long start_num ) { long long length = 1 ; while ( start_num != 1 ) /* loop till we reach 1 */ { if ( start_num & 0x01 ) /* check for odd */ start_num = 3 * start_num + 1 ; else start_num >>= 1 ; /* simpler divide by 2 */ length ++ ; } return length ; }",
    "resources/C/project_euler/problem_14/sol1.c@main": "int main ( int argc , char * * argv ) { long long max_len = 0 , max_len_num = 0 ; long long MAX_NUM = 1000000 ; if ( argc == 2 ) /* set commandline argumnet as the maximum iteration number */ { MAX_NUM = atoll ( argv [ 1 ] ) ; printf ( \"Maximum number: %lld\\n\" , MAX_NUM ) ; } long long i ; # ifdef _OPENMP # pragma omp parallel for shared ( max_len , max_len_num ) schedule ( guided ) # endif for ( i = 1 ; i < MAX_NUM ; i ++ ) { long long L = collatz ( i ) ; if ( L > max_len ) { max_len = L ; /* length of sequence */ max_len_num = i ; /* starting number */ } # if defined ( _OPENMP ) && defined ( DEBUG ) printf ( \"Thread: %2d\\t %3lld: \\t%5lld\\n\" , omp_get_thread_num ( ) , i , L ) ; # elif defined ( DEBUG ) printf ( \"%3lld: \\t%5lld\\n\" , i , L ) ; # endif } printf ( \"Start: %3lld: \\tLength: %5lld\\n\" , max_len_num , max_len ) ; return 0 ; }",
    "resources/C/project_euler/problem_15/sol1.c@number_of_paths": "unsigned long long number_of_paths ( int N ) { unsigned long long path = 1 ; for ( int i = 0 ; i < N ; i ++ ) { path *= ( N << 1 ) - i ; path /= i + 1 ; } return path ; }",
    "resources/C/project_euler/problem_15/sol1.c@main": "int main ( int argc , char * * argv ) { int N = 20 ; if ( argc == 2 ) N = atoi ( argv [ 1 ] ) ; printf ( \"Number of ways to traverse diagonal of %dx%d grid = %llu\\n\" , N , N , number_of_paths ( N ) ) ; return 0 ; }",
    "resources/C/project_euler/problem_12/sol1.c@count_divisors": "long count_divisors ( long long n ) { long num_divisors = 0 ; for ( long long i = 1 ; i < sqrtl ( n ) + 1 ; i ++ ) if ( n % i == 0 ) num_divisors += 2 ; else if ( i * i == n ) num_divisors += 1 ; return num_divisors ; }",
    "resources/C/project_euler/problem_12/sol1.c@main": "int main ( int argc , char * * argv ) { int MAX_DIVISORS = 500 ; long i = 1 , num_divisors ; long long triangle_number = 1 ; if ( argc == 2 ) MAX_DIVISORS = atoi ( argv [ 1 ] ) ; while ( 1 ) { i ++ ; triangle_number += i ; num_divisors = count_divisors ( triangle_number ) ; if ( num_divisors > MAX_DIVISORS ) break ; } printf ( \"First Triangle number with more than %d divisors: %lld\\n\" , MAX_DIVISORS , triangle_number ) ; return 0 ; }",
    "resources/C/project_euler/problem_23/sol2.c@get_perfect_number": "char get_perfect_number ( unsigned long N ) { unsigned long sum = 1 ; char ret = 0 ; for ( unsigned long i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { sum += i ; unsigned long tmp = N / i ; if ( tmp != i ) { sum += tmp ; } } } ret = sum == N ? 0 : ( sum > N ? 1 : - 1 ) ; # ifdef DEBUG printf ( \"%5lu: %5lu : %d\\n\" , N , sum , ret ) ; # endif return ret ; }",
    "resources/C/project_euler/problem_23/sol2.c@is_abundant": "char is_abundant ( unsigned long N ) { // return abundant_flags[N >> 3] & (1 << N % 8) ? 1 : 0; return abundant_flags [ N >> 3 ] & ( 1 << ( N & 7 ) ) ? 1 : 0 ; /* optimized modulo operation */ }",
    "resources/C/project_euler/problem_23/sol2.c@get_next_abundant": "unsigned long get_next_abundant ( unsigned long N ) { unsigned long i ; /* keep checking successive numbers till an abundant number is found */ for ( i = N + 1 ; ! is_abundant ( i ) ; ++ i ) { ; } return i ; }",
    "resources/C/project_euler/problem_23/sol2.c@is_sum_of_abundant": "char is_sum_of_abundant ( unsigned long N ) { /* optimized logic:\n     * i + j = N   where both i and j should be abundant\n     * hence we can simply check for j = N - i as we loop through i\n     */ for ( unsigned long i = get_next_abundant ( 1 ) ; i <= ( N >> 1 ) ; i = get_next_abundant ( i ) ) { if ( is_abundant ( N - i ) ) { # ifdef DEBUG printf ( \"\\t%4lu + %4lu = %4lu\\n\" , i , N - i , N ) ; # endif return 1 ; } } return 0 ; }",
    "resources/C/project_euler/problem_23/sol2.c@main": "int main ( int argc , char * * argv ) { long MAX_N = 28123 ; /* Limit of numbers to check */ unsigned long sum = 0 ; if ( argc == 2 ) { MAX_N = strtoul ( argv [ 1 ] , NULL , 10 ) ; } /* byte array to store flags to identify abundant numbers\n     * the flags are identified by bits\n     */ abundant_flags = ( char * ) calloc ( MAX_N >> 3 , 1 ) ; if ( ! abundant_flags ) { perror ( \"Unable to allocate memoey!\" ) ; return - 1 ; } # ifdef _OPENMP printf ( \"Using OpenMP parallleization with %d threads\\n\" , omp_get_max_threads ( ) ) ; # else printf ( \"Not using parallleization!\\n\" ) ; # endif clock_t start_time = clock ( ) ; /* Loop to set abundant flags */ long N ; # ifdef _OPENMP # pragma omp for schedule ( runtime ) # endif for ( N = 1 ; N <= MAX_N ; N ++ ) { char ret = get_perfect_number ( N ) ; if ( ret == 1 ) { // int byte_offset = N % 8, index = N >> 3; int byte_offset = N & 7 , index = N >> 3 ; # ifdef _OPENMP # pragma omp critical # endif abundant_flags [ index ] |= ret << byte_offset ; } // if (i % 100 == 0) //     printf(\"... %5lu: %8lu\\r\", i, sum); } clock_t end_time = clock ( ) ; double t1 = 1e3 * ( end_time - start_time ) / CLOCKS_PER_SEC ; printf ( \"Time taken to get abundant numbers: %.4g ms\\n\" , t1 ) ; clock_t t2 = 0 ; long i ; # ifdef _OPENMP # pragma omp parallel for schedule ( runtime ) reduction ( + : sum ) # endif for ( i = 1 ; i < MAX_N ; i ++ ) { clock_t start_time1 = clock ( ) ; if ( ! is_sum_of_abundant ( i ) ) { // #ifdef _OPENMP // #pragma omp critical // #endif sum += i ; } clock_t end_time1 = clock ( ) ; # ifdef _OPENMP # pragma omp critical # endif t2 += end_time1 - start_time1 ; printf ( \"... %5lu: %8lu\\r\" , i , sum ) ; if ( i % 100 == 0 ) { fflush ( stdout ) ; } } # ifdef DEBUG putchar ( '\\n' ) ; # endif double t22 = 1e3 * t2 / CLOCKS_PER_SEC ; printf ( \"Time taken for final sum: %.4g ms\\nTotal Time taken: %.4g ms\\n\" , t22 , t1 + t22 ) ; printf ( \"Memory used: %lu bytes\\n\" , MAX_N >> 3 ) ; printf ( \"Sum of numbers that cannot be represented as sum of two abundant \" \"numbers : %lu\\n\" , sum ) ; free ( abundant_flags ) ; return 0 ; }",
    "resources/C/project_euler/problem_23/sol1.c@get_perfect_number": "char get_perfect_number ( unsigned long N ) { unsigned long sum = 1 ; char ret = 0 ; for ( unsigned long i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { sum += i ; unsigned long tmp = N / i ; if ( tmp != i ) { sum += tmp ; } } } ret = sum == N ? 0 : ( sum > N ? 1 : - 1 ) ; // #ifdef DEBUG //     printf(\"%5lu: %5lu : %d\\n\", N, sum, ret); // #endif return ret ; }",
    "resources/C/project_euler/problem_23/sol1.c@is_abundant": "unsigned long is_abundant ( unsigned long N ) { return get_perfect_number ( N ) == 1 ? 1 : 0 ; }",
    "resources/C/project_euler/problem_23/sol1.c@get_next_abundant": "unsigned long get_next_abundant ( unsigned long N ) { unsigned long i ; for ( i = N + 1 ; ! is_abundant ( i ) ; i ++ ) { ; } return i ; }",
    "resources/C/project_euler/problem_23/sol1.c@is_sum_of_abundant": "char is_sum_of_abundant ( unsigned long N ) { /* optimized logic:\n     * i + j = N   where both i and j should be abundant\n     * hence we can simply check for j = N - i as we loop through i\n     */ for ( unsigned long i = get_next_abundant ( 1 ) ; i <= ( N >> 1 ) ; i = get_next_abundant ( i ) ) { if ( is_abundant ( N - i ) ) { # ifdef DEBUG printf ( \"\\t%4lu + %4lu = %4lu\\n\" , i , N - i , N ) ; # endif return 1 ; } } return 0 ; }",
    "resources/C/project_euler/problem_23/sol1.c@main": "int main ( int argc , char * * argv ) { unsigned long MAX_N = 28123 ; /* upper limit of numbers to check */ unsigned long sum = 0 ; if ( argc == 2 ) { MAX_N = strtoul ( argv [ 1 ] , NULL , 10 ) ; } # ifdef _OPENMP printf ( \"Using OpenMP parallleization with %d threads\\n\" , omp_get_max_threads ( ) ) ; # else printf ( \"Not using parallleization!\\n\" ) ; # endif double total_duration = 0.f ; long i ; # ifdef _OPENMP # pragma omp parallel for reduction ( + : sum ) schedule ( runtime ) # endif for ( i = 1 ; i <= MAX_N ; i ++ ) { clock_t start_time = clock ( ) ; if ( ! is_sum_of_abundant ( i ) ) { sum += i ; } clock_t end_time = clock ( ) ; total_duration += ( double ) ( end_time - start_time ) / CLOCKS_PER_SEC ; printf ( \"... %5lu: %8lu\\r\" , i , sum ) ; if ( i % 100 == 0 ) { fflush ( stdout ) ; } } printf ( \"Time taken: %.4g s\\n\" , total_duration ) ; printf ( \"Sum of numbers that cannot be represented as sum of two abundant \" \"numbers : %lu\\n\" , sum ) ; return 0 ; }",
    "resources/C/hash/hash_djb2.c@djb2": "uint64_t djb2 ( const char * s ) { uint64_t hash = 5381 ; /* init value */ size_t i = 0 ; while ( s [ i ] != '\\0' ) { hash = ( ( hash << 5 ) + hash ) + s [ i ] ; i ++ ; } return hash ; }",
    "resources/C/hash/hash_djb2.c@test_djb2": "void test_djb2 ( void ) { assert ( djb2 ( \"Hello World\" ) == 13827776004929097857 ) ; assert ( djb2 ( \"Hello World!\" ) == 13594750393630990530 ) ; assert ( djb2 ( \"Hello world\" ) == 13827776004967047329 ) ; assert ( djb2 ( \"Hello world!\" ) == 13594750394883323106 ) ; printf ( \"Tests passed\\n\" ) ; }",
    "resources/C/hash/hash_djb2.c@main": "int main ( ) { test_djb2 ( ) ; return 0 ; }",
    "resources/C/hash/hash_xor8.c@xor8": "uint8_t xor8 ( const char * s ) { uint8_t hash = 0 ; size_t i = 0 ; while ( s [ i ] != '\\0' ) { hash = ( hash + s [ i ] ) & 0xff ; i ++ ; } return ( ( ( hash ^ 0xff ) + 1 ) & 0xff ) ; }",
    "resources/C/hash/hash_xor8.c@test_xor8": "void test_xor8 ( ) { assert ( xor8 ( \"Hello World\" ) == 228 ) ; assert ( xor8 ( \"Hello World!\" ) == 195 ) ; assert ( xor8 ( \"Hello world\" ) == 196 ) ; assert ( xor8 ( \"Hello world!\" ) == 163 ) ; printf ( \"Tests passed\\n\" ) ; }",
    "resources/C/hash/hash_xor8.c@main": "int main ( ) { test_xor8 ( ) ; return 0 ; }",
    "resources/C/hash/hash_adler32.c@adler32": "uint32_t adler32 ( const char * s ) { uint32_t a = 1 ; uint32_t b = 0 ; const uint32_t MODADLER = 65521 ; size_t i = 0 ; while ( s [ i ] != '\\0' ) { a = ( a + s [ i ] ) % MODADLER ; b = ( b + a ) % MODADLER ; i ++ ; } return ( b << 16 ) | a ; }",
    "resources/C/hash/hash_adler32.c@test_adler32": "void test_adler32 ( ) { assert ( adler32 ( \"Hello World\" ) == 403375133 ) ; assert ( adler32 ( \"Hello World!\" ) == 474547262 ) ; assert ( adler32 ( \"Hello world\" ) == 413860925 ) ; assert ( adler32 ( \"Hello world!\" ) == 487130206 ) ; printf ( \"Tests passed\\n\" ) ; }",
    "resources/C/hash/hash_adler32.c@main": "int main ( ) { test_adler32 ( ) ; return 0 ; }",
    "resources/C/hash/hash_sdbm.c@sdbm": "uint64_t sdbm ( const char * s ) { uint64_t hash = 0 ; size_t i = 0 ; while ( s [ i ] != '\\0' ) { hash = s [ i ] + ( hash << 6 ) + ( hash << 16 ) - hash ; i ++ ; } return hash ; }",
    "resources/C/hash/hash_sdbm.c@test_sdbm": "void test_sdbm ( ) { assert ( sdbm ( \"Hello World\" ) == 12881824461405877380U ) ; assert ( sdbm ( \"Hello World!\" ) == 7903571203300273309 ) ; assert ( sdbm ( \"Hello world\" ) == 15154913742888948900U ) ; assert ( sdbm ( \"Hello world!\" ) == 15254999417003201661U ) ; printf ( \"Tests passed\\n\" ) ; }",
    "resources/C/hash/hash_sdbm.c@main": "int main ( ) { test_sdbm ( ) ; return 0 ; }",
    "resources/C/hash/hash_crc32.c@crc32": "uint32_t crc32 ( const char * s ) { uint32_t crc = 0xffffffff ; size_t i = 0 ; while ( s [ i ] != '\\0' ) { uint8_t byte = s [ i ] ; crc = crc ^ byte ; for ( uint8_t j = 8 ; j > 0 ; -- j ) { crc = ( crc >> 1 ) ^ ( 0xEDB88320 & ( - ( crc & 1 ) ) ) ; } i ++ ; } return crc ^ 0xffffffff ; }",
    "resources/C/hash/hash_crc32.c@test_crc32": "void test_crc32 ( ) { assert ( crc32 ( \"Hello World\" ) == 1243066710 ) ; assert ( crc32 ( \"Hello World!\" ) == 472456355 ) ; assert ( crc32 ( \"Hello world\" ) == 2346098258 ) ; assert ( crc32 ( \"Hello world!\" ) == 461707669 ) ; printf ( \"Tests passed\\n\" ) ; }",
    "resources/C/hash/hash_crc32.c@main": "int main ( ) { test_crc32 ( ) ; return 0 ; }",
    "resources/C/hash/hash_blake2b.c@u128_fill": "static inline void u128_fill ( u128 dest , size_t n ) { dest [ 0 ] = n & UINT64_MAX ; if ( sizeof ( n ) > 8 ) { /* The C standard does not specify a maximum length for size_t,\n         * although most machines implement it to be the same length as\n         * uint64_t. On machines where size_t is 8 bytes long this will issue a\n         * compiler warning, which is why it is suppressed. But on a machine\n         * where size_t is greater than 8 bytes, this will work as normal. */ dest [ 1 ] = n >> 64 ; } else { dest [ 1 ] = 0 ; } }",
    "resources/C/hash/hash_blake2b.c@u128_increment": "static inline void u128_increment ( u128 dest , uint64_t n ) { /* Check for overflow */ if ( UINT64_MAX - dest [ 0 ] <= n ) { dest [ 1 ] ++ ; } dest [ 0 ] += n ; }",
    "resources/C/hash/hash_blake2b.c@G": "static void G ( block_t v , uint8_t a , uint8_t b , uint8_t c , uint8_t d , uint64_t x , uint64_t y ) { v [ a ] += v [ b ] + x ; v [ d ] = ROTR64 ( v [ d ] ^ v [ a ] , R1 ) ; v [ c ] += v [ d ] ; v [ b ] = ROTR64 ( v [ b ] ^ v [ c ] , R2 ) ; v [ a ] += v [ b ] + y ; v [ d ] = ROTR64 ( v [ d ] ^ v [ a ] , R3 ) ; v [ c ] += v [ d ] ; v [ b ] = ROTR64 ( v [ b ] ^ v [ c ] , R4 ) ; }",
    "resources/C/hash/hash_blake2b.c@F": "static void F ( uint64_t h [ 8 ] , block_t m , u128 t , int f ) { int i ; block_t v ; /* v[0..7] := h[0..7] */ for ( i = 0 ; i < 8 ; i ++ ) { v [ i ] = h [ i ] ; } /* v[8..15] := IV[0..7] */ for ( ; i < 16 ; i ++ ) { v [ i ] = blake2b_iv [ i - 8 ] ; } v [ 12 ] ^= t [ 0 ] ; /* v[12] ^ (t mod 2**w) */ v [ 13 ] ^= t [ 1 ] ; /* v[13] ^ (t >> w) */ if ( f ) { v [ 14 ] = ~ v [ 14 ] ; } for ( i = 0 ; i < 12 ; i ++ ) { const uint8_t * s = blake2b_sigma [ i ] ; G ( v , 0 , 4 , 8 , 12 , m [ s [ 0 ] ] , m [ s [ 1 ] ] ) ; G ( v , 1 , 5 , 9 , 13 , m [ s [ 2 ] ] , m [ s [ 3 ] ] ) ; G ( v , 2 , 6 , 10 , 14 , m [ s [ 4 ] ] , m [ s [ 5 ] ] ) ; G ( v , 3 , 7 , 11 , 15 , m [ s [ 6 ] ] , m [ s [ 7 ] ] ) ; G ( v , 0 , 5 , 10 , 15 , m [ s [ 8 ] ] , m [ s [ 9 ] ] ) ; G ( v , 1 , 6 , 11 , 12 , m [ s [ 10 ] ] , m [ s [ 11 ] ] ) ; G ( v , 2 , 7 , 8 , 13 , m [ s [ 12 ] ] , m [ s [ 13 ] ] ) ; G ( v , 3 , 4 , 9 , 14 , m [ s [ 14 ] ] , m [ s [ 15 ] ] ) ; } for ( i = 0 ; i < 8 ; i ++ ) { h [ i ] ^= v [ i ] ^ v [ i + 8 ] ; } }",
    "resources/C/hash/hash_blake2b.c@BLAKE2B": "static int BLAKE2B ( uint8_t * dest , block_t * d , size_t dd , u128 ll , uint8_t kk , uint8_t nn ) { uint8_t bytes [ 8 ] ; uint64_t i , j ; uint64_t h [ 8 ] ; u128 t = U128_ZERO ; /* h[0..7] = IV[0..7] */ for ( i = 0 ; i < 8 ; i ++ ) { h [ i ] = blake2b_iv [ i ] ; } h [ 0 ] ^= 0x01010000 ^ ( kk << 8 ) ^ nn ; if ( dd > 1 ) { for ( i = 0 ; i < dd - 1 ; i ++ ) { u128_increment ( t , bb ) ; F ( h , d [ i ] , t , 0 ) ; } } if ( kk != 0 ) { u128_increment ( ll , bb ) ; } F ( h , d [ dd - 1 ] , ll , 1 ) ; /* copy bytes from h to destination buffer */ for ( i = 0 ; i < nn ; i ++ ) { if ( i % sizeof ( uint64_t ) == 0 ) { /* copy values from uint64 to 8 u8's */ for ( j = 0 ; j < sizeof ( uint64_t ) ; j ++ ) { uint16_t offset = 8 * j ; uint64_t mask = 0xFF ; mask <<= offset ; bytes [ j ] = ( h [ i / 8 ] & ( mask ) ) >> offset ; } } dest [ i ] = bytes [ i % 8 ] ; } return 0 ; }",
    "resources/C/hash/hash_blake2b.c@blake2b": "uint8_t * blake2b ( const uint8_t * message , size_t len , const uint8_t * key , uint8_t kk , uint8_t nn ) { uint8_t * dest = NULL ; uint64_t long_hold ; size_t dd , has_key , i ; size_t block_index , word_in_block ; u128 ll ; block_t * blocks ; if ( message == NULL ) { len = 0 ; } if ( key == NULL ) { kk = 0 ; } kk = MIN ( kk , KK_MAX ) ; nn = MIN ( nn , NN_MAX ) ; dd = MAX ( CEIL ( kk , bb ) + CEIL ( len , bb ) , 1 ) ; blocks = calloc ( dd , sizeof ( block_t ) ) ; if ( blocks == NULL ) { return NULL ; } dest = malloc ( nn * sizeof ( uint8_t ) ) ; if ( dest == NULL ) { free ( blocks ) ; return NULL ; } /* If there is a secret key it occupies the first block */ for ( i = 0 ; i < kk ; i ++ ) { long_hold = key [ i ] ; long_hold <<= 8 * ( i % 8 ) ; word_in_block = ( i % bb ) / 8 ; /* block_index will always be 0 because kk <= 64 and bb = 128*/ blocks [ 0 ] [ word_in_block ] |= long_hold ; } has_key = kk > 0 ? 1 : 0 ; for ( i = 0 ; i < len ; i ++ ) { /* long_hold exists because the bit-shifting will overflow if we don't\n         * store the value */ long_hold = message [ i ] ; long_hold <<= 8 * ( i % 8 ) ; block_index = has_key + ( i / bb ) ; word_in_block = ( i % bb ) / 8 ; blocks [ block_index ] [ word_in_block ] |= long_hold ; } u128_fill ( ll , len ) ; BLAKE2B ( dest , blocks , dd , ll , kk , nn ) ; free ( blocks ) ; return dest ; }",
    "resources/C/hash/hash_blake2b.c@assert_bytes": "static void assert_bytes ( const uint8_t * expected , const uint8_t * actual , uint8_t len ) { uint8_t i ; assert ( expected != NULL ) ; assert ( actual != NULL ) ; assert ( len > 0 ) ; for ( i = 0 ; i < len ; i ++ ) { assert ( expected [ i ] == actual [ i ] ) ; } }",
    "resources/C/hash/hash_blake2b.c@test": "static void test ( ) { uint8_t * digest = NULL ; /* \"abc\" example straight out of RFC-7693 */ uint8_t abc [ 3 ] = { 'a' , 'b' , 'c' } ; uint8_t abc_answer [ 64 ] = { 0xBA , 0x80 , 0xA5 , 0x3F , 0x98 , 0x1C , 0x4D , 0x0D , 0x6A , 0x27 , 0x97 , 0xB6 , 0x9F , 0x12 , 0xF6 , 0xE9 , 0x4C , 0x21 , 0x2F , 0x14 , 0x68 , 0x5A , 0xC4 , 0xB7 , 0x4B , 0x12 , 0xBB , 0x6F , 0xDB , 0xFF , 0xA2 , 0xD1 , 0x7D , 0x87 , 0xC5 , 0x39 , 0x2A , 0xAB , 0x79 , 0x2D , 0xC2 , 0x52 , 0xD5 , 0xDE , 0x45 , 0x33 , 0xCC , 0x95 , 0x18 , 0xD3 , 0x8A , 0xA8 , 0xDB , 0xF1 , 0x92 , 0x5A , 0xB9 , 0x23 , 0x86 , 0xED , 0xD4 , 0x00 , 0x99 , 0x23 } ; digest = blake2b ( abc , 3 , NULL , 0 , 64 ) ; assert_bytes ( abc_answer , digest , 64 ) ; free ( digest ) ; uint8_t key [ 64 ] = { 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0d , 0x0e , 0x0f , 0x10 , 0x11 , 0x12 , 0x13 , 0x14 , 0x15 , 0x16 , 0x17 , 0x18 , 0x19 , 0x1a , 0x1b , 0x1c , 0x1d , 0x1e , 0x1f , 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 , 0x28 , 0x29 , 0x2a , 0x2b , 0x2c , 0x2d , 0x2e , 0x2f , 0x30 , 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , 0x39 , 0x3a , 0x3b , 0x3c , 0x3d , 0x3e , 0x3f } ; uint8_t key_answer [ 64 ] = { 0x10 , 0xeb , 0xb6 , 0x77 , 0x00 , 0xb1 , 0x86 , 0x8e , 0xfb , 0x44 , 0x17 , 0x98 , 0x7a , 0xcf , 0x46 , 0x90 , 0xae , 0x9d , 0x97 , 0x2f , 0xb7 , 0xa5 , 0x90 , 0xc2 , 0xf0 , 0x28 , 0x71 , 0x79 , 0x9a , 0xaa , 0x47 , 0x86 , 0xb5 , 0xe9 , 0x96 , 0xe8 , 0xf0 , 0xf4 , 0xeb , 0x98 , 0x1f , 0xc2 , 0x14 , 0xb0 , 0x05 , 0xf4 , 0x2d , 0x2f , 0xf4 , 0x23 , 0x34 , 0x99 , 0x39 , 0x16 , 0x53 , 0xdf , 0x7a , 0xef , 0xcb , 0xc1 , 0x3f , 0xc5 , 0x15 , 0x68 } ; digest = blake2b ( NULL , 0 , key , 64 , 64 ) ; assert_bytes ( key_answer , digest , 64 ) ; free ( digest ) ; uint8_t zero [ 1 ] = { 0 } ; uint8_t zero_key [ 64 ] = { 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0d , 0x0e , 0x0f , 0x10 , 0x11 , 0x12 , 0x13 , 0x14 , 0x15 , 0x16 , 0x17 , 0x18 , 0x19 , 0x1a , 0x1b , 0x1c , 0x1d , 0x1e , 0x1f , 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 , 0x28 , 0x29 , 0x2a , 0x2b , 0x2c , 0x2d , 0x2e , 0x2f , 0x30 , 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , 0x39 , 0x3a , 0x3b , 0x3c , 0x3d , 0x3e , 0x3f } ; uint8_t zero_answer [ 64 ] = { 0x96 , 0x1f , 0x6d , 0xd1 , 0xe4 , 0xdd , 0x30 , 0xf6 , 0x39 , 0x01 , 0x69 , 0x0c , 0x51 , 0x2e , 0x78 , 0xe4 , 0xb4 , 0x5e , 0x47 , 0x42 , 0xed , 0x19 , 0x7c , 0x3c , 0x5e , 0x45 , 0xc5 , 0x49 , 0xfd , 0x25 , 0xf2 , 0xe4 , 0x18 , 0x7b , 0x0b , 0xc9 , 0xfe , 0x30 , 0x49 , 0x2b , 0x16 , 0xb0 , 0xd0 , 0xbc , 0x4e , 0xf9 , 0xb0 , 0xf3 , 0x4c , 0x70 , 0x03 , 0xfa , 0xc0 , 0x9a , 0x5e , 0xf1 , 0x53 , 0x2e , 0x69 , 0x43 , 0x02 , 0x34 , 0xce , 0xbd } ; digest = blake2b ( zero , 1 , zero_key , 64 , 64 ) ; assert_bytes ( zero_answer , digest , 64 ) ; free ( digest ) ; uint8_t filled [ 64 ] = { 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0d , 0x0e , 0x0f , 0x10 , 0x11 , 0x12 , 0x13 , 0x14 , 0x15 , 0x16 , 0x17 , 0x18 , 0x19 , 0x1a , 0x1b , 0x1c , 0x1d , 0x1e , 0x1f , 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 , 0x28 , 0x29 , 0x2a , 0x2b , 0x2c , 0x2d , 0x2e , 0x2f , 0x30 , 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , 0x39 , 0x3a , 0x3b , 0x3c , 0x3d , 0x3e , 0x3f } ; uint8_t filled_key [ 64 ] = { 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0d , 0x0e , 0x0f , 0x10 , 0x11 , 0x12 , 0x13 , 0x14 , 0x15 , 0x16 , 0x17 , 0x18 , 0x19 , 0x1a , 0x1b , 0x1c , 0x1d , 0x1e , 0x1f , 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 , 0x28 , 0x29 , 0x2a , 0x2b , 0x2c , 0x2d , 0x2e , 0x2f , 0x30 , 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , 0x39 , 0x3a , 0x3b , 0x3c , 0x3d , 0x3e , 0x3f } ; uint8_t filled_answer [ 64 ] = { 0x65 , 0x67 , 0x6d , 0x80 , 0x06 , 0x17 , 0x97 , 0x2f , 0xbd , 0x87 , 0xe4 , 0xb9 , 0x51 , 0x4e , 0x1c , 0x67 , 0x40 , 0x2b , 0x7a , 0x33 , 0x10 , 0x96 , 0xd3 , 0xbf , 0xac , 0x22 , 0xf1 , 0xab , 0xb9 , 0x53 , 0x74 , 0xab , 0xc9 , 0x42 , 0xf1 , 0x6e , 0x9a , 0xb0 , 0xea , 0xd3 , 0x3b , 0x87 , 0xc9 , 0x19 , 0x68 , 0xa6 , 0xe5 , 0x09 , 0xe1 , 0x19 , 0xff , 0x07 , 0x78 , 0x7b , 0x3e , 0xf4 , 0x83 , 0xe1 , 0xdc , 0xdc , 0xcf , 0x6e , 0x30 , 0x22 } ; digest = blake2b ( filled , 64 , filled_key , 64 , 64 ) ; assert_bytes ( filled_answer , digest , 64 ) ; free ( digest ) ; printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/hash/hash_blake2b.c@main": "int main ( ) { test ( ) ; return 0 ; }",
    "resources/C/conversions/binary_to_decimal.c@convert_to_decimal": "int convert_to_decimal ( uint64_t number ) { int decimal_number = 0 , i = 0 ; while ( number > 0 ) { decimal_number += ( number % 10 ) * pow ( 2 , i ) ; number = number / 10 ; i ++ ; } return decimal_number ; }",
    "resources/C/conversions/binary_to_decimal.c@tests": "static void tests ( ) { assert ( convert_to_decimal ( 111 ) == 7 ) ; assert ( convert_to_decimal ( 101 ) == 5 ) ; assert ( convert_to_decimal ( 1010 ) == 10 ) ; assert ( convert_to_decimal ( 1101 ) == 13 ) ; assert ( convert_to_decimal ( 100001 ) == 33 ) ; assert ( convert_to_decimal ( 10101001 ) == 169 ) ; assert ( convert_to_decimal ( 111010 ) == 58 ) ; assert ( convert_to_decimal ( 100000000 ) == 256 ) ; assert ( convert_to_decimal ( 10000000000 ) == 1024 ) ; assert ( convert_to_decimal ( 101110111 ) == 375 ) ; printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/conversions/binary_to_decimal.c@main": "int main ( ) { tests ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/conversions/infix_to_postfix2.c@push": "void push ( char opd ) { if ( st . top == 9 ) { // overflow condition printf ( \"Stack overflow...\" ) ; exit ( 1 ) ; } st . top ++ ; st . stack [ st . top ] = opd ; }",
    "resources/C/conversions/infix_to_postfix2.c@pop": "char pop ( ) { char item ; ///< to store the popped value to be returned if ( st . top == - 1 ) { // underflow condition printf ( \"Stack underflow...\" ) ; exit ( 1 ) ; } item = st . stack [ st . top ] ; st . top -- ; return item ; }",
    "resources/C/conversions/infix_to_postfix2.c@isEmpty": "uint16_t isEmpty ( ) { if ( st . top == - 1 ) { return 1 ; } return 0 ; }",
    "resources/C/conversions/infix_to_postfix2.c@Top": "char Top ( ) { return st . stack [ st . top ] ; }",
    "resources/C/conversions/infix_to_postfix2.c@priority": "int16_t priority ( char opr ) { if ( opr == '+' || opr == '-' ) { return 0 ; } else if ( opr == '/' || opr == '*' || opr == '%' ) { return 1 ; } else { return - 1 ; } }",
    "resources/C/conversions/infix_to_postfix2.c@convert": "char * convert ( char inf [ ] ) { static char post [ 25 ] ; ///< to store the postfix expression int i ; ///< loop iterator int j = 0 ; ///< keeps track of end of postfix string for ( i = 0 ; i < strlen ( inf ) ; i ++ ) { if ( isalnum ( inf [ i ] ) ) { // if scanned element is an alphabet or number post [ j ] = inf [ i ] ; // append in postfix expression j ++ ; } else if ( inf [ i ] == '(' ) { // if scanned element is opening parentheses push ( inf [ i ] ) ; // push on stack. } else if ( inf [ i ] == ')' ) { // if scanned element is closing parentheses, while ( Top ( ) != '(' ) { // pop elements from stack and append in postfix expression post [ j ] = pop ( ) ; // until opening parentheses becomes top. j ++ ; } pop ( ) ; // pop opening parentheses } else { // if scanned element is an operator while ( ( ! isEmpty ( ) ) && ( priority ( inf [ i ] ) <= priority ( Top ( ) ) ) ) { // pop and append until stack becomes post [ j ] = pop ( ) ; // empty or priority of top operator j ++ ; // becomes smaller than scanned operator } // '(' has priority -1 push ( inf [ i ] ) ; // push the scanned operator } } while ( ! isEmpty ( ) ) { // pop and append residual operators from stack post [ j ] = pop ( ) ; j ++ ; } post [ j ] = '\\0' ; // end postfix string with null character return post ; }",
    "resources/C/conversions/infix_to_postfix2.c@test": "static void test ( ) { /* check sample test case\n\t   input- \"(A/(B-C)*D+E)\"\n\t   expected output- \"ABC-/D*E+\"\n\t */ assert ( strcmp ( convert ( \"(A/(B-C)*D+E)\" ) , \"ABC-/D*E+\" ) == 0 ) ; /// this ensures that the algorithm works as expected /* input- \"7-(2*3+5)*(8-4/2)\"\n\t   expected output- \"723*5+842/-*-\"\n\t */ assert ( strcmp ( convert ( \"7-(2*3+5)*(8-4/2)\" ) , \"723*5+842/-*-\" ) == 0 ) ; /// this ensures that the algorithm works as expected printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/conversions/infix_to_postfix2.c@main": "int main ( ) { st . top = - 1 ; /// initialize test ( ) ; /// run self-test implementations char inf [ 25 ] ; ///< to store input infix expression printf ( \"Enter infix: \" ) ; scanf ( \"%s\" , inf ) ; printf ( \"Postfix: %s\" , convert ( inf ) ) ; return 0 ; }",
    "resources/C/conversions/int_to_string.c@int_to_string": "char * int_to_string ( uint16_t value , char * dest , int base ) { const char hex_table [ ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' } ; int len = 0 ; do { dest [ len ++ ] = hex_table [ value % base ] ; value /= base ; } while ( value != 0 ) ; /* reverse characters */ for ( int i = 0 , limit = len / 2 ; i < limit ; ++ i ) { char t = dest [ i ] ; dest [ i ] = dest [ len - 1 - i ] ; dest [ len - 1 - i ] = t ; } dest [ len ] = '\\0' ; return dest ; }",
    "resources/C/conversions/int_to_string.c@test": "static void test ( ) { const int MAX_SIZE = 100 ; char * str1 = ( char * ) calloc ( sizeof ( char ) , MAX_SIZE ) ; char * str2 = ( char * ) calloc ( sizeof ( char ) , MAX_SIZE ) ; for ( int i = 1 ; i <= 100 ; ++ i ) /* test 100 random numbers */ { /* Generate value from 0 to 100 */ int value = rand ( ) % 100 ; // assert(strcmp(itoa(value, str1, 2), int_to_string(value, str2, 2)) == //        0); snprintf ( str1 , MAX_SIZE , \"%o\" , value ) ; //* standard C - to octal */ assert ( strcmp ( str1 , int_to_string ( value , str2 , 8 ) ) == 0 ) ; snprintf ( str1 , MAX_SIZE , \"%d\" , value ) ; /* standard C - to decimal */ assert ( strcmp ( str1 , int_to_string ( value , str2 , 10 ) ) == 0 ) ; snprintf ( str1 , MAX_SIZE , \"%x\" , value ) ; /* standard C - to hexadecimal */ assert ( strcmp ( str1 , int_to_string ( value , str2 , 16 ) ) == 0 ) ; } free ( str1 ) ; free ( str2 ) ; }",
    "resources/C/conversions/int_to_string.c@main": "int main ( ) { /* Intializes random number generator */ srand ( time ( NULL ) ) ; test ( ) ; return 0 ; }",
    "resources/C/conversions/binary_to_hexadecimal.c@main": "int main ( ) { long int binary , hexa = 0 , i = 1 , remainder ; printf ( \"Enter the binary number: \" ) ; scanf ( \"%ld\" , & binary ) ; while ( binary != 0 ) { remainder = binary % 10 ; hexa = hexa + remainder * i ; i = i * 2 ; binary = binary / 10 ; } printf ( \"The equivalent hexadecimal value: %lX\" , hexa ) ; return 0 ; }",
    "resources/C/conversions/decimal_to_octal.c@main": "int main ( ) { long decimalnum ; printf ( \"Enter the decimal number: \" ) ; scanf ( \"%ld\" , & decimalnum ) ; decimal2Octal ( decimalnum ) ; return 0 ; }",
    "resources/C/conversions/decimal_to_octal.c@decimal2Octal": "void decimal2Octal ( long decimalnum ) { long remainder , quotient ; int octalNumber [ 100 ] , i = 1 , j ; quotient = decimalnum ; while ( quotient != 0 ) { octalNumber [ i ++ ] = quotient % 8 ; quotient = quotient / 8 ; } for ( j = i - 1 ; j > 0 ; j -- ) printf ( \"%d\" , octalNumber [ j ] ) ; printf ( \"\\n\" ) ; }",
    "resources/C/conversions/binary_to_octal.c@three_digits": "int three_digits ( int n ) { int r , d = 0 , p = 1 ; for ( int i = 0 ; i < 3 ; i ++ ) { r = n % 10 ; d += r * p ; p *= 10 ; n /= 10 ; } return d ; }",
    "resources/C/conversions/binary_to_octal.c@main": "int main ( void ) { int binary_num , d = 0 , base = 1 , remainder , td , res = 0 , ord = 1 ; printf ( \"Enter the binary no: \" ) ; scanf ( \"%d\" , & binary_num ) ; while ( binary_num > 0 ) { if ( binary_num > 111 ) // Checking if binary number is greater than three digits td = three_digits ( binary_num ) ; else td = binary_num ; binary_num /= 1000 ; d = 0 , base = 1 ; // Converting the last three digits to decimal while ( td > 0 ) { remainder = td % 10 ; td /= 10 ; d += ( base * remainder ) ; base *= 2 ; } res += d * ord ; // Calculating the octal value ord *= 10 ; } printf ( \"\\nOctal equivalent is: %d\" , res ) ; return 0 ; }",
    "resources/C/conversions/infix_to_postfix.c@main": "int main ( ) { char infix [ 20 ] , postfix [ 20 ] ; // initialize empty infix and postfix array printf ( \"Enter infix expression: \" ) ; // example : A+B-C*D/E$F scanf ( \"%s\" , infix ) ; // get values for infix array convert ( infix , postfix ) ; printf ( \"Postfix expression is %s\" , postfix ) ; // output : AB+CD*EF$/- return 0 ; }",
    "resources/C/conversions/infix_to_postfix.c@push": "void push ( struct Stack * p , char x ) { if ( p -> tos == 9 ) // check if stack has reached its max limit { printf ( \"Stack Overflow!\" ) ; return ; } p -> tos += 1 ; // increment tos p -> arr [ p -> tos ] = x ; // assign char x to index of stack pointed by tos }",
    "resources/C/conversions/infix_to_postfix.c@pop": "char pop ( struct Stack * p ) { char x ; if ( p -> tos == - 1 ) { printf ( \"Stack Underflow!\" ) ; return '\\0' ; } x = p -> arr [ p -> tos ] ; // assign the value of stack at index tos to x p -> tos -= 1 ; // decrement tos return x ; }",
    "resources/C/conversions/infix_to_postfix.c@isOprnd": "int isOprnd ( char ch ) { if ( ( ch >= 65 && ch <= 90 ) || ( ch >= 97 && ch <= 122 ) || // check if ch is an operator or ( ch >= 48 && ch <= 57 ) ) // operand using ASCII values { return 1 ; // return for true result } else { return 0 ; // return for false result } }",
    "resources/C/conversions/infix_to_postfix.c@isEmpty": "int isEmpty ( struct Stack s ) { if ( s . tos == - 1 ) // check if stack is empty { return 1 ; // return for true result } else { return 0 ; // return for false result } }",
    "resources/C/conversions/infix_to_postfix.c@convert": "void convert ( char infix [ ] , char postfix [ ] ) { struct Stack s ; // initialze object reference of stack s . tos = - 1 ; // initalize the tos int i , j = 0 , pr ; char ch , temp ; for ( i = 0 ; infix [ i ] != '\\0' ; i ++ ) { ch = infix [ i ] ; if ( isOprnd ( ch ) == 1 ) // check if char is operand or operator { postfix [ j ] = ch ; // assign ch to postfix array with index j j ++ ; // incement j } else { if ( ch == '(' ) { push ( & s , ch ) ; } else { if ( ch == ')' ) { while ( ( temp = pop ( & s ) ) != '(' ) { postfix [ j ] = temp ; j ++ ; } } else { while ( isEmpty ( s ) == 0 ) // check if stack is empty { pr = getPrecedence ( ch , s . arr [ s . tos ] ) ; // check operator precedence if ( pr == 1 ) { break ; // if ch has a greater precedence than // s.arr[s.top] } postfix [ j ] = pop ( & s ) ; j ++ ; } push ( & s , ch ) ; // push ch to stack } } } } while ( isEmpty ( s ) == 0 ) // check if stack is empty { postfix [ j ] = pop ( & s ) ; j ++ ; } postfix [ j ] = '\\0' ; }",
    "resources/C/conversions/infix_to_postfix.c@getPrecedence": "int getPrecedence ( char op1 , char op2 ) { if ( op2 == '$' ) { return 0 ; } else if ( op1 == '$' ) { return 1 ; } else if ( op2 == '*' || op2 == '/' || op2 == '%' ) { return 0 ; } else if ( op1 == '*' || op1 == '/' || op1 == '%' ) { return 1 ; } else if ( op2 == '+' || op2 == '-' ) { return 0 ; } else { return 1 ; } }",
    "resources/C/conversions/decimal_to_any_base.c@isbad_alphabet": "",
    "resources/C/conversions/decimal_to_any_base.c@converted_len": "uint64_t converted_len ( uint64_t nb , short base ) { /* Counting the number of characters translated to the base*/ if ( nb > base - 1 ) { return ( converted_len ( nb / base , base ) + 1 ) ; } return 1 ; }",
    "resources/C/conversions/decimal_to_any_base.c@convertion": "void convertion ( uint64_t nb , const char * alphabet , short base , char * converted ) { /* Recursive convertion */ * ( converted ) = * ( alphabet + nb % base ) ; if ( nb > base - 1 ) { convertion ( nb / base , alphabet , base , -- converted ) ; } }",
    "resources/C/conversions/decimal_to_any_base.c@decimal_to_anybase": "char * decimal_to_anybase ( uint64_t nb , const char * alphabet ) { char * converted ; /* Verify that alphabet is valid */ if ( isbad_alphabet ( alphabet ) ) { return NULL ; } /* Convertion */ uint64_t base = strlen ( alphabet ) ; uint64_t final_len = converted_len ( nb , base ) ; converted = malloc ( sizeof ( char ) * ( final_len + 1 ) ) ; converted [ final_len ] = 0 ; convertion ( nb , alphabet , base , converted + final_len - 1 ) ; return converted ; }",
    "resources/C/conversions/decimal_to_any_base.c@test": "static void test ( ) { char * ret = NULL ; char * reference = NULL ; /* min dec*/ reference = \"0\" ; ret = decimal_to_anybase ( 0 , \"0123456789\" ) ; for ( int i = 0 ; i < strlen ( reference ) && i < strlen ( ret ) ; i ++ ) { assert ( ret [ i ] == reference [ i ] ) ; } if ( ret != NULL ) { free ( ret ) ; } /* max dec*/ reference = \"18446744073709551615\" ; ret = decimal_to_anybase ( 18446744073709551615 , \"0123456789\" ) ; for ( int i = 0 ; i < strlen ( reference ) && i < strlen ( ret ) ; i ++ ) { assert ( ret [ i ] == reference [ i ] ) ; } if ( ret != NULL ) { free ( ret ) ; } /* negative dec*/ reference = \"18446744073709551615\" ; ret = decimal_to_anybase ( - 1 , \"0123456789\" ) ; for ( int i = 0 ; i < strlen ( reference ) && i < strlen ( ret ) ; i ++ ) { assert ( ret [ i ] == reference [ i ] ) ; } if ( ret != NULL ) { free ( ret ) ; } /* bin */ reference = \"101010\" ; ret = decimal_to_anybase ( 42 , \"01\" ) ; for ( int i = 0 ; i < strlen ( reference ) && i < strlen ( ret ) ; i ++ ) { assert ( ret [ i ] == reference [ i ] ) ; } if ( ret != NULL ) { free ( ret ) ; } /* octal */ reference = \"52\" ; ret = decimal_to_anybase ( 42 , \"01234567\" ) ; for ( int i = 0 ; i < strlen ( reference ) && i < strlen ( ret ) ; i ++ ) { assert ( ret [ i ] == reference [ i ] ) ; } if ( ret != NULL ) { free ( ret ) ; } /* hexa */ reference = \"2A\" ; ret = decimal_to_anybase ( 42 , \"0123456789ABCDEF\" ) ; for ( int i = 0 ; i < strlen ( reference ) && i < strlen ( ret ) ; i ++ ) { assert ( ret [ i ] == reference [ i ] ) ; } if ( ret != NULL ) { free ( ret ) ; } printf ( \"[+] All tests have successfully passed!\\n\" ) ; }",
    "resources/C/conversions/decimal_to_any_base.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/conversions/roman_numerals_to_decimal.c@symbol": "int symbol ( char symbol ) { int value = 0 ; switch ( symbol ) { case 'I' : value = 1 ; break ; case 'V' : value = 5 ; break ; case 'X' : value = 10 ; break ; case 'L' : value = 50 ; break ; case 'C' : value = 100 ; break ; case 'D' : value = 500 ; break ; case 'M' : value = 1000 ; break ; } return value ; }",
    "resources/C/conversions/roman_numerals_to_decimal.c@roman_to_decimal": "int roman_to_decimal ( char input [ ] ) { int result = 0 ; // result in decimal for ( int i = 0 ; i < strlen ( input ) ; i ++ ) { if ( strlen ( input ) > i + 1 ) { if ( symbol ( input [ i ] ) >= symbol ( input [ i + 1 ] ) ) { result += symbol ( input [ i ] ) ; // add value to sum } else { result += symbol ( input [ i + 1 ] ) - symbol ( input [ i ] ) ; // if the current symbol is smaller than the next (ex. IV), subtract it from the next symbol i ++ ; // skip over an extra symbol  } } else { result += symbol ( input [ i ] ) ; // add value to sum } } return result ; }",
    "resources/C/conversions/roman_numerals_to_decimal.c@test": "static void test ( ) { // 1st test char input [ ] = \"MCMIV\" ; int expected = 1904 ; int output = roman_to_decimal ( input ) ; printf ( \"TEST 1\\n\" ) ; printf ( \"Input: %s\\n\" , input ) ; printf ( \"Expected Output: %d\\n\" , expected ) ; printf ( \"Output: %d\\n\" , output ) ; assert ( output == expected ) ; printf ( \"== TEST PASSED ==\\n\\n\" ) ; // 2nd test char input2 [ ] = \"MMMDCCXXIV\" ; expected = 3724 ; output = roman_to_decimal ( input2 ) ; printf ( \"TEST 2\\n\" ) ; printf ( \"Input: %s\\n\" , input2 ) ; printf ( \"Expected Output: %d\\n\" , expected ) ; printf ( \"Output: %d\\n\" , output ) ; assert ( output == expected ) ; printf ( \"== TEST PASSED ==\\n\\n\" ) ; // 3rd test char input3 [ ] = \"III\" ; expected = 3 ; output = roman_to_decimal ( input3 ) ; printf ( \"TEST 3\\n\" ) ; printf ( \"Input: %s\\n\" , input3 ) ; printf ( \"Expected Output: %d\\n\" , expected ) ; printf ( \"Output: %d\\n\" , output ) ; assert ( output == expected ) ; printf ( \"== TEST PASSED ==\\n\\n\" ) ; }",
    "resources/C/conversions/roman_numerals_to_decimal.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/conversions/hexadecimal_to_octal2.c@hex_to_oct": "const char * hex_to_oct ( const char * hex ) { # define MAX_OCT_STR_LEN 23 /* 17_7777_7777_7777_7777_7777 */ static char octal [ MAX_OCT_STR_LEN ] ; memset ( octal , '\\0' , MAX_OCT_STR_LEN ) ; // Initialize as NULL string unsigned long long decimal = 0 ; int i = 0 ; int len ; if ( hex == NULL ) { // Return an empty string return octal ; } /* Hexadecimal to decimal conversion */ while ( * hex != '\\n' && * hex != '\\0' ) { char ch = * hex ; if ( ch >= '0' && ch <= '9' ) { ch -= '0' ; } else if ( ch >= 'a' && ch <= 'f' ) { ch = ch - 'a' + 10 ; } else if ( ch >= 'A' && ch <= 'F' ) { ch = ch - 'A' + 10 ; } else { printf ( \"Invalid hexadecimal input: %c\\n\" , ch ) ; break ; } decimal *= 16 ; decimal += ch ; hex ++ ; } /* Decimal to octal conversion */ if ( decimal == 0 ) { octal [ 0 ] = '0' ; len = 1 ; } else { i = 0 ; while ( decimal > 0 ) { octal [ i ] = '0' + decimal % 8 ; i ++ ; decimal /= 8 ; } len = i ; } octal [ len ] = '\\0' ; /* Reverse the octal string */ for ( i = 0 ; i < len / 2 ; i ++ ) { char tmp = octal [ i ] ; octal [ i ] = octal [ len - i - 1 ] ; octal [ len - i - 1 ] = tmp ; } return octal ; }",
    "resources/C/conversions/hexadecimal_to_octal2.c@main": "int main ( ) { # define MAX_HEX_STR_LEN 17 /* FFFF_FFFF_FFFF_FFFF */ char hex [ MAX_HEX_STR_LEN ] ; /* Input hexadecimal number from user */ printf ( \"Enter any hexadecimal number: \" ) ; fgets ( hex , MAX_HEX_STR_LEN , stdin ) ; const char * octal = hex_to_oct ( hex ) ; printf ( \"Hexadecimal number = %s\\n\" , hex ) ; printf ( \"Octal number = %s\\n\" , octal ) ; return 0 ; }",
    "resources/C/conversions/to_decimal.c@main": "int main ( void ) { int base , i , j ; char number [ 100 ] ; unsigned long decimal = 0 ; printf ( \"Enter the base: \" ) ; scanf ( \"%d\" , & base ) ; printf ( \"Enter the number: \" ) ; scanf ( \"%s\" , & number [ 0 ] ) ; for ( i = 0 ; number [ i ] != '\\0' ; i ++ ) { if ( isdigit ( number [ i ] ) ) number [ i ] -= '0' ; else if ( isupper ( number [ i ] ) ) number [ i ] -= 'A' - 10 ; else if ( islower ( number [ i ] ) ) number [ i ] -= 'a' - 10 ; else number [ i ] = base + 1 ; if ( number [ i ] >= base ) { printf ( \"invalid number\\n\" ) ; return 0 ; } } for ( j = 0 ; j < i ; j ++ ) { decimal *= base ; decimal += number [ j ] ; } printf ( \"%lu\\n\" , decimal ) ; }",
    "resources/C/conversions/c_atoi_str_to_integer.c@c_atoi": "int c_atoi ( const char * str ) { int i ; int sign ; long value ; long prev ; i = 0 ; sign = 1 ; value = 0 ; /* skipping the spaces */ while ( ( ( str [ i ] <= 13 && str [ i ] >= 9 ) || str [ i ] == 32 ) && str [ i ] != '\\0' ) i ++ ; /* store the sign if it is negative sign */ if ( str [ i ] == '-' ) { sign = - 1 ; i ++ ; } else if ( str [ i ] == '+' ) { sign = 1 ; i ++ ; } /* converting char by char to a numeric value */ while ( str [ i ] >= 48 && str [ i ] <= 57 && str [ i ] != '\\0' ) { prev = value ; value = value * 10 + sign * ( str [ i ] - '0' ) ; /* managing the overflow */ if ( sign == 1 && prev > value ) return ( - 1 ) ; else if ( sign == - 1 && prev < value ) return ( 0 ) ; i ++ ; } return ( value ) ; }",
    "resources/C/conversions/c_atoi_str_to_integer.c@test_c_atoi": "void test_c_atoi ( ) { printf ( \"<<<< TEST FUNCTION >>>>\\n\" ) ; assert ( c_atoi ( \"123\" ) == atoi ( \"123\" ) ) ; assert ( c_atoi ( \"-123\" ) == atoi ( \"-123\" ) ) ; assert ( c_atoi ( \"\" ) == atoi ( \"\" ) ) ; assert ( c_atoi ( \"-h23\" ) == atoi ( \"-h23\" ) ) ; assert ( c_atoi ( \"         23\" ) == atoi ( \"         23\" ) ) ; assert ( c_atoi ( \"999999999\" ) == atoi ( \"999999999\" ) ) ; printf ( \"<<<< TEST DONE >>>>\\n\" ) ; }",
    "resources/C/conversions/c_atoi_str_to_integer.c@main": "int main ( int argc , char * * argv ) { test_c_atoi ( ) ; if ( argc == 2 ) { printf ( \"Your number + 5 is %d\\n\" , c_atoi ( argv [ 1 ] ) + 5 ) ; return ( 0 ) ; } printf ( \"wrong number of parmeters\\n\" ) ; return ( 1 ) ; }",
    "resources/C/conversions/octal_to_decimal.c@convertValue": "int convertValue ( int num , int i ) { return num * pow ( 8 , i ) ; }",
    "resources/C/conversions/octal_to_decimal.c@toDecimal": "long long toDecimal ( int octal_value ) { int decimal_value = 0 , i = 0 ; while ( octal_value ) { // Extracts right-most digit and then multiplies by 8^i decimal_value += convertValue ( octal_value % 10 , i ++ ) ; // Shift right in base 10 octal_value /= 10 ; } return decimal_value ; }",
    "resources/C/conversions/octal_to_decimal.c@main": "int main ( ) { printf ( \"Enter octal value: \" ) ; int octal_value ; scanf ( \"%d\" , & octal_value ) ; long long result = toDecimal ( octal_value ) ; printf ( \"%d in decimal is %lld\\n\" , octal_value , result ) ; return 0 ; }",
    "resources/C/conversions/hexadecimal_to_octal.c@main": "int main ( ) { # define MAX_STR_LEN 17 char hex [ MAX_STR_LEN ] ; long long octal , bin , place ; int i = 0 , rem , val ; /* Input hexadecimal number from user */ printf ( \"Enter any hexadecimal number: \" ) ; fgets ( hex , MAX_STR_LEN , stdin ) ; octal = 0ll ; bin = 0ll ; place = 0ll ; /* Hexadecimal to binary conversion */ for ( i = 0 ; hex [ i ] != '\\0' ; i ++ ) { bin = bin * place ; switch ( hex [ i ] ) { case '0' : bin += 0 ; break ; case '1' : bin += 1 ; break ; case '2' : bin += 10 ; break ; case '3' : bin += 11 ; break ; case '4' : bin += 100 ; break ; case '5' : bin += 101 ; break ; case '6' : bin += 110 ; break ; case '7' : bin += 111 ; break ; case '8' : bin += 1000 ; break ; case '9' : bin += 1001 ; break ; case 'a' : case 'A' : bin += 1010 ; break ; case 'b' : case 'B' : bin += 1011 ; break ; case 'c' : case 'C' : bin += 1100 ; break ; case 'd' : case 'D' : bin += 1101 ; break ; case 'e' : case 'E' : bin += 1110 ; break ; case 'f' : case 'F' : bin += 1111 ; break ; default : printf ( \"Invalid hexadecimal input.\" ) ; } place = 10000 ; } place = 1 ; /* Binary to octal conversion */ while ( bin > 0 ) { rem = bin % 1000 ; switch ( rem ) { case 0 : val = 0 ; break ; case 1 : val = 1 ; break ; case 10 : val = 2 ; break ; case 11 : val = 3 ; break ; case 100 : val = 4 ; break ; case 101 : val = 5 ; break ; case 110 : val = 6 ; break ; case 111 : val = 7 ; break ; } octal = ( val * place ) + octal ; bin /= 1000 ; place *= 10 ; } printf ( \"Hexadecimal number = %s\\n\" , hex ) ; printf ( \"Octal number = %lld\" , octal ) ; return 0 ; }",
    "resources/C/conversions/decimal_to_hexa.c@main": "int main ( ) { long decimalnum ; printf ( \"Enter decimal number: \" ) ; scanf ( \"%ld\" , & decimalnum ) ; decimal2Hexadecimal ( decimalnum ) ; return 0 ; }",
    "resources/C/conversions/decimal_to_hexa.c@decimal2Hexadecimal": "void decimal2Hexadecimal ( long num ) { long decimalnum = num ; long quotient , remainder ; int i , j = 0 ; char hexadecimalnum [ 100 ] ; quotient = decimalnum ; while ( quotient != 0 ) { remainder = quotient % 16 ; if ( remainder < 10 ) hexadecimalnum [ j ++ ] = 48 + remainder ; else hexadecimalnum [ j ++ ] = 55 + remainder ; quotient = quotient / 16 ; } // print the hexadecimal number for ( i = j ; i >= 0 ; i -- ) { printf ( \"%c\" , hexadecimalnum [ i ] ) ; } printf ( \"\\n\" ) ; }",
    "resources/C/conversions/decimal_to_binary.c@main": "int main ( ) { // input of the user int inputNumber ; // for the remainder int re ; // contains the bits 0/1 int bits [ MAXBITS ] ; // for the loops int j ; int i = 0 ; printf ( \"\\t\\tConverter decimal --> binary\\n\\n\" ) ; // reads a decimal number from the user. printf ( \"\\nenter a positive integer number: \" ) ; scanf ( \"%d\" , & inputNumber ) ; // make sure the input number is a positive integer. if ( inputNumber < 0 ) { printf ( \"only positive integers >= 0\\n\" ) ; return 1 ; } // actual processing while ( inputNumber > 0 ) { // computes the remainder by modulo 2 re = inputNumber % 2 ; // computes the quotient of division by 2 inputNumber = inputNumber / 2 ; bits [ i ] = re ; i ++ ; } printf ( \"\\n the number in binary is: \" ) ; // iterates backwards over all bits for ( j = i - 1 ; j >= 0 ; j -- ) { printf ( \"%d\" , bits [ j ] ) ; } // for the case the input number is 0 if ( i == 0 ) { printf ( \"0\" ) ; } return 0 ; }",
    "resources/C/conversions/decimal_to_binary_recursion.c@decimal_to_binary": "int decimal_to_binary ( unsigned int number ) { return number == 0 ? 0 : number % 2 + 10 * decimal_to_binary ( number / 2 ) ; }",
    "resources/C/conversions/decimal_to_binary_recursion.c@test": "void test ( ) { const int sets [ ] [ 2 ] = { { 0 , 0 } , { 1 , 1 } , { 2 , 10 } , { 3 , 11 } , { 4 , 100 } , { 6 , 110 } , { 7 , 111 } , /* add more data sets to test */ } ; for ( int i = 0 , size = sizeof ( sets ) / sizeof ( sets [ 0 ] ) ; i < size ; ++ i ) { assert ( decimal_to_binary ( sets [ i ] [ 0 ] ) == sets [ i ] [ 1 ] ) ; } }",
    "resources/C/conversions/decimal_to_binary_recursion.c@main": "int main ( ) { test ( ) ; return 0 ; }",
    "resources/C/conversions/octal_to_binary.c@octalToBinary": "long octalToBinary ( int octalnum ) { int decimalnum = 0 , i = 0 ; long binarynum = 0 ; /* This loop converts octal number \"octalnum\" to the\n     * decimal number \"decimalnum\"\n     */ while ( octalnum != 0 ) { decimalnum = decimalnum + ( octalnum % 10 ) * pow ( 8 , i ) ; i ++ ; octalnum = octalnum / 10 ; } // i is re-initialized i = 1 ; /* This loop converts the decimal number \"decimalnum\" to the binary\n     * number \"binarynum\"\n     */ while ( decimalnum != 0 ) { binarynum = binarynum + ( long ) ( decimalnum % 2 ) * i ; decimalnum = decimalnum / 2 ; i = i * 10 ; } // Returning the binary number that we got from octal number return binarynum ; }",
    "resources/C/conversions/octal_to_binary.c@main": "int main ( ) { int octalnum ; printf ( \"Enter an octal number: \" ) ; scanf ( \"%d\" , & octalnum ) ; // Calling the function octaltoBinary printf ( \"Equivalent binary number is: %ld\" , octalToBinary ( octalnum ) ) ; return 0 ; }",
    "resources/C/conversions/octal_to_hexadecimal.c@octalToDecimal": "long octalToDecimal ( long octalValue ) { long decimalValue = 0 ; int i = 0 ; while ( octalValue ) { // Extracts right-most digit, multiplies it with 8^i, and increment i by 1 decimalValue += ( long ) ( octalValue % 10 ) * pow ( 8 , i ++ ) ; // Shift right in base 10 octalValue /= 10 ; } return decimalValue ; }",
    "resources/C/conversions/octal_to_hexadecimal.c@octalToHexadecimal": "char * octalToHexadecimal ( long octalValue ) { char * hexadecimalValue = malloc ( 256 * sizeof ( char ) ) ; sprintf ( hexadecimalValue , \"%lX\" , octalToDecimal ( octalValue ) ) ; return hexadecimalValue ; }",
    "resources/C/conversions/octal_to_hexadecimal.c@test": "static void test ( ) { /* test that hexadecimal value of octal number 213 is 8B */ assert ( strcmp ( octalToHexadecimal ( 213 ) , \"8B\" ) == 0 ) ; /* test that hexadecimal value of octal number 174 is 7C */ assert ( strcmp ( octalToHexadecimal ( 174 ) , \"7C\" ) == 0 ) ; }",
    "resources/C/conversions/octal_to_hexadecimal.c@main": "int main ( ) { // execute the tests test ( ) ; // get the value of octal number as input int octalValue ; printf ( \"Enter an octal number: \" ) ; scanf ( \"%d\" , & octalValue ) ; // call the function octalToHexadecimal and print the hexadecimal value char * hexadecimalValue = octalToHexadecimal ( octalValue ) ; printf ( \"Equivalent hexadecimal number is: %s\" , hexadecimalValue ) ; // free the memory allocated dynamically in function octalToHexadecimal free ( hexadecimalValue ) ; // return 0 and exit return 0 ; }",
    "resources/C/conversions/celsius_to_fahrenheit.c@celcius_to_fahrenheit": "double celcius_to_fahrenheit ( double celsius ) { return ( celsius * 9.0 / 5.0 ) + 32.0 ; }",
    "resources/C/conversions/celsius_to_fahrenheit.c@test": "static void test ( ) { // 1st test double input = 0.0 ; double expected = 32.0 ; double output = celcius_to_fahrenheit ( input ) ; // 1st test printf ( \"TEST 1\\n\" ) ; printf ( \"Input: %f\\n\" , input ) ; printf ( \"Expected Output: %f\\n\" , expected ) ; printf ( \"Output: %f\\n\" , output ) ; assert ( output == expected ) ; printf ( \"== TEST PASSED ==\\n\\n\" ) ; // 2nd test input = 100.0 ; expected = 212.0 ; output = celcius_to_fahrenheit ( input ) ; printf ( \"TEST 2\\n\" ) ; printf ( \"Input: %f\\n\" , input ) ; printf ( \"Expected Output: %f\\n\" , expected ) ; printf ( \"Output: %f\\n\" , output ) ; assert ( output == expected ) ; printf ( \"== TEST PASSED ==\\n\\n\" ) ; // 3rd test input = 22.5 ; expected = 72.5 ; output = celcius_to_fahrenheit ( input ) ; printf ( \"TEST 3\\n\" ) ; printf ( \"Input: %f\\n\" , input ) ; printf ( \"Expected Output: %f\\n\" , expected ) ; printf ( \"Output: %f\\n\" , output ) ; assert ( output == expected ) ; printf ( \"== TEST PASSED ==\\n\\n\" ) ; }",
    "resources/C/conversions/celsius_to_fahrenheit.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/conversions/decimal_to_octal_recursion.c@decimal_to_octal": "int decimal_to_octal ( int decimal ) { if ( ( decimal < 8 ) && ( decimal > 0 ) ) { return decimal ; } else if ( decimal == 0 ) { return 0 ; } else { return ( ( decimal_to_octal ( decimal / 8 ) * 10 ) + decimal % 8 ) ; } }",
    "resources/C/conversions/decimal_to_octal_recursion.c@main": "int main ( ) { int octalNumber , decimalNumber ; printf ( \"\\nEnter your decimal number : \" ) ; scanf ( \"%d\" , & decimalNumber ) ; octalNumber = decimal_to_octal ( decimalNumber ) ; printf ( \"\\nThe octal of %d is : %d\" , decimalNumber , octalNumber ) ; return 0 ; }",
    "resources/C/leetcode/src/1838.c@compare": "int compare ( const int * i , const int * j ) { return * i - * j ; }",
    "resources/C/leetcode/src/1838.c@maxFrequency": "int maxFrequency ( int * nums , int numsSize , int k ) { qsort ( nums , numsSize , sizeof ( int ) , ( int ( * ) ( const void * , const void * ) ) compare ) ; long * prefixSum = malloc ( numsSize * sizeof ( long ) ) ; prefixSum [ 0 ] = nums [ 0 ] ; for ( int i = 0 ; i < numsSize - 1 ; i ++ ) { prefixSum [ i + 1 ] = prefixSum [ i ] + nums [ i ] ; } int leftWindowPosition = 0 ; int result = 0 ; for ( int rightWindowPosition = 0 ; rightWindowPosition < numsSize ; rightWindowPosition ++ ) { long rightSum = prefixSum [ rightWindowPosition ] ; long leftSum = prefixSum [ leftWindowPosition ] ; while ( ( long ) nums [ rightWindowPosition ] * ( rightWindowPosition - leftWindowPosition ) - ( rightSum - leftSum ) > k ) { leftWindowPosition += 1 ; } result = max ( result , rightWindowPosition - leftWindowPosition + 1 ) ; } free ( prefixSum ) ; return result ; }",
    "resources/C/leetcode/src/1769.c@minOperations": "int * minOperations ( char * boxes , int * returnSize ) { int leftOnes = 0 ; int leftCommonDistance = 0 ; int rightOnes = 0 ; int rightCommonDistance = 0 ; int boxesLength = strlen ( boxes ) ; * returnSize = boxesLength ; int * result = malloc ( boxesLength * sizeof ( int ) ) ; for ( int i = 0 ; i < boxesLength ; i ++ ) { if ( boxes [ i ] == '1' ) { rightOnes += 1 ; rightCommonDistance += i ; } } for ( int i = 0 ; i < boxesLength ; i ++ ) { if ( boxes [ i ] == '1' ) { rightOnes -= 1 ; leftOnes += 1 ; } result [ i ] = rightCommonDistance + leftCommonDistance ; rightCommonDistance -= rightOnes ; leftCommonDistance += leftOnes ; } return result ; }",
    "resources/C/leetcode/src/540.c@singleNonDuplicate": "int singleNonDuplicate ( int * nums , int numsSize ) { int left = 0 , right = numsSize - 1 ; while ( left < right ) { int mid = ( right + left ) / 2 ; if ( mid % 2 == 0 ) { if ( nums [ mid ] == nums [ mid + 1 ] ) left = mid + 2 ; else right = mid ; } else { if ( nums [ mid ] == nums [ mid - 1 ] ) left = mid + 1 ; else right = mid - 1 ; } } return nums [ left ] ; }",
    "resources/C/leetcode/src/404.c@isleaf": "bool isleaf ( struct TreeNode * root ) { return root -> left == NULL && root -> right == NULL ; }",
    "resources/C/leetcode/src/404.c@sumOfLeftLeaves": "int sumOfLeftLeaves ( struct TreeNode * root ) { if ( root == NULL ) return 0 ; if ( root -> left ) { if ( isleaf ( root -> left ) ) return root -> left -> val + sumOfLeftLeaves ( root -> right ) ; } return sumOfLeftLeaves ( root -> left ) + sumOfLeftLeaves ( root -> right ) ; }",
    "resources/C/leetcode/src/27.c@removeElement": "int removeElement ( int * nums , int numsSize , int val ) { int i , start = 0 ; for ( i = 0 ; i < numsSize ; i ++ ) { if ( nums [ i ] != val ) nums [ start ++ ] = nums [ i ] ; } return start ; }",
    "resources/C/leetcode/src/63.c@uniquePathsWithObstacles": "int uniquePathsWithObstacles ( int * * obstacleGrid , int obstacleGridSize , int * obstacleGridColSize ) { if ( obstacleGrid [ obstacleGridSize - 1 ] [ * obstacleGridColSize - 1 ] == 1 ) { return 0 ; } int paths [ obstacleGridSize ] [ * obstacleGridColSize ] ; for ( int i = 0 ; i < obstacleGridSize ; i ++ ) { for ( int j = 0 ; j < * obstacleGridColSize ; j ++ ) { if ( obstacleGrid [ i ] [ j ] ) { paths [ i ] [ j ] = 0 ; } else { paths [ i ] [ j ] = ( i == 0 && j == 0 ) ? 1 : ( ( i == 0 ? 0 : paths [ i - 1 ] [ j ] ) + ( j == 0 ? 0 : paths [ i ] [ j - 1 ] ) ) ; } } } return paths [ obstacleGridSize - 1 ] [ * obstacleGridColSize - 1 ] ; }",
    "resources/C/leetcode/src/700.c@searchBST": "struct TreeNode * searchBST ( struct TreeNode * root , int val ) { if ( ! root ) return NULL ; if ( root -> val == val ) { return root ; } else if ( root -> val > val ) { return searchBST ( root -> left , val ) ; } else { return searchBST ( root -> right , val ) ; } }",
    "resources/C/leetcode/src/69.c@mySqrt": "int mySqrt ( int x ) { int start = 0 ; int end = x ; long long int ans = 0 ; while ( start <= end ) { long long int mid = ( start + end ) / 2 ; long long int val = mid * mid ; if ( val == x ) { return mid ; } //if mid is less than the square root of the number(x) store the value of mid in ans. if ( val < x ) { ans = mid ; start = mid + 1 ; } //if mid is greater than the square root of the number(x) then ssign the value mid-1 to end.                if ( val > x ) { end = mid - 1 ; } } return ans ; }",
    "resources/C/leetcode/src/561.c@cmpval": "int cmpval ( const void * a , const void * b ) { return * ( int * ) a - * ( int * ) b ; }",
    "resources/C/leetcode/src/561.c@arrayPairSum": "int arrayPairSum ( int * nums , int numsSize ) { int sum = 0 , i ; qsort ( nums , numsSize , sizeof ( int ) , cmpval ) ; for ( i = 0 ; i < numsSize ; i = i + 2 ) sum = sum + nums [ i ] ; return sum ; }",
    "resources/C/leetcode/src/2222.c@numberOfWaysForChar": "long numberOfWaysForChar ( char * s , char c ) { long firstBuildingAppearNumber = 0 ; long secondBuildingAppearNumber = 0 ; long result = 0 ; int sLength = strlen ( s ) ; for ( int i = 0 ; i < sLength ; i ++ ) { if ( s [ i ] == c ) { result += secondBuildingAppearNumber ; firstBuildingAppearNumber += 1 ; continue ; } secondBuildingAppearNumber += firstBuildingAppearNumber ; } return result ; }",
    "resources/C/leetcode/src/2222.c@numberOfWays": "long long numberOfWays ( char * s ) { return numberOfWaysForChar ( s , '0' ) + numberOfWaysForChar ( s , '1' ) ; }",
    "resources/C/leetcode/src/997.c@findJudge": "int findJudge ( int n , int * * trust , int trustSize , int * trustColSize ) { int * personsToTrust = calloc ( n + 1 , sizeof ( int ) ) ; int * personsFromTrust = calloc ( n + 1 , sizeof ( int ) ) ; for ( int i = 0 ; i < trustSize ; i ++ ) { int * currentTrust = trust [ i ] ; personsToTrust [ currentTrust [ 1 ] ] += 1 ; personsFromTrust [ currentTrust [ 0 ] ] += 1 ; } int potentialJudjeNumber = - 1 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( personsToTrust [ i ] == n - 1 && personsFromTrust [ i ] == 0 ) { if ( potentialJudjeNumber > - 1 ) { return - 1 ; } potentialJudjeNumber = i ; } } free ( personsToTrust ) ; free ( personsFromTrust ) ; return potentialJudjeNumber ; }",
    "resources/C/leetcode/src/704.c@search": "int search ( int * nums , int numsSize , int target ) { int * ret = bsearch ( & target , nums , numsSize , sizeof ( int ) , cmpint ) ; if ( ret ) return ( ret - nums ) ; else return - 1 ; }",
    "resources/C/leetcode/src/704.c@cmpint": "int cmpint ( const void * a , const void * b ) { return * ( int * ) a - * ( int * ) b ; }",
    "resources/C/leetcode/src/110.c@max": "int max ( int a , int b ) { return a >= b ? a : b ; }",
    "resources/C/leetcode/src/110.c@height": "int height ( struct TreeNode * root ) { if ( root == NULL ) return 0 ; else return 1 + max ( height ( root -> left ) , height ( root -> right ) ) ; }",
    "resources/C/leetcode/src/110.c@isBalanced": "bool isBalanced ( struct TreeNode * root ) { if ( root == NULL ) return 1 ; int left = height ( root -> left ) ; int right = height ( root -> right ) ; return abs ( left - right ) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ) ; }",
    "resources/C/leetcode/src/231.c@isPowerOfTwo": "bool isPowerOfTwo ( int n ) { return ( n > 0 ) && ( ( n & ( n - 1 ) ) == 0 ) ; }",
    "resources/C/leetcode/src/461.c@hammingDistance": "int hammingDistance ( int x , int y ) { int difference = x ^ y ; // The XOR operator generates the bitwise difference in the // binary representation of two numbers If bit in ith position // of both numbers is same, bit in difference is 0, otherwise 1 int TotalBits = sizeof ( difference ) * 8 ; // total number of bits int i , distance = 0 ; for ( i = 0 ; i < TotalBits ; i ++ ) { if ( difference & ( UINT32_C ( 1 ) << i ) ) // if the bit on the ith position of 32 bit input is 1, // then proceed Further note the use of UINT32_C to convert // 1 to unsigned 32 bit int, as just 1 is treated as int // which cannot be shifted left more than 30 times distance += 1 ; } return distance ; }",
    "resources/C/leetcode/src/42.c@trap": "int trap ( int * height , int heightSize ) { int * rightMaxStack = malloc ( heightSize * sizeof ( int ) ) ; rightMaxStack [ heightSize - 1 ] = height [ heightSize - 1 ] ; for ( int i = heightSize - 2 ; i >= 0 ; i -- ) { rightMaxStack [ i ] = max ( rightMaxStack [ i + 1 ] , height [ i ] ) ; } int leftMax = 0 ; int result = 0 ; for ( int i = 0 ; i < heightSize ; i ++ ) { leftMax = max ( leftMax , height [ i ] ) ; result += max ( 0 , min ( leftMax , rightMaxStack [ i ] ) - height [ i ] ) ; } free ( rightMaxStack ) ; return result ; }",
    "resources/C/leetcode/src/29.c@divide": "int divide ( int dividend , int divisor ) { int sign = 1 ; long int output = 0 ; if ( dividend < 0 ) { sign *= - 1 ; } else { dividend *= - 1 ; } if ( divisor < 0 ) { sign *= - 1 ; } else { divisor *= - 1 ; } while ( dividend <= divisor ) { long int tmp = 0 ; long int div = divisor ; while ( dividend <= div ) { tmp += ( tmp + 1 ) ; dividend -= div ; div += div ; } if ( output >= INT_MAX ) { if ( sign == - 1 ) { return INT_MIN ; } else { return INT_MAX ; } } output += tmp ; } return output * sign ; }",
    "resources/C/leetcode/src/1137.c@tribonacci": "int tribonacci ( int n ) { int t0 = 0 ; int t1 = 1 ; int t2 = 1 ; if ( n == 0 ) { return t0 ; } if ( n == 1 ) { return t1 ; } if ( n == 2 ) { return t2 ; } for ( int i = 0 ; i < n - 2 ; i ++ ) { int nextT = t0 + t1 + t2 ; t0 = t1 ; t1 = t2 ; t2 = nextT ; } return t2 ; }",
    "resources/C/leetcode/src/16.c@cmp": "int cmp ( const void * a , const void * b ) { const int * A = a , * B = b ; return ( * A > * B ) - ( * A < * B ) ; }",
    "resources/C/leetcode/src/16.c@threeSumClosest": "int threeSumClosest ( int * nums , int nums_size , int target ) { int i , j , k , result , sum3 ; qsort ( nums , nums_size , sizeof ( int ) , cmp ) ; result = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] ; for ( i = 0 ; i < nums_size - 2 ; i ++ ) { j = i + 1 ; k = nums_size - 1 ; while ( j < k ) { sum3 = nums [ i ] + nums [ j ] + nums [ k ] ; if ( abs ( target - sum3 ) < abs ( target - result ) ) { result = sum3 ; } if ( sum3 < target ) { j ++ ; } else if ( sum3 > target ) { k -- ; } else { return sum3 ; } } } return result ; }",
    "resources/C/leetcode/src/125.c@isPalindrome": "bool isPalindrome ( char * s ) { int start = 0 , end = strlen ( s ) - 1 ; while ( start < end ) { if ( ! isalpha ( s [ start ] ) && ! isalnum ( s [ start ] ) ) { start ++ ; } else if ( ! isalpha ( s [ end ] ) && ! isalnum ( s [ end ] ) ) { end -- ; } else { char c1 = tolower ( s [ start ] ) ; char c2 = tolower ( s [ end ] ) ; if ( c1 != c2 ) return 0 ; start ++ ; end -- ; } } return 1 ; }",
    "resources/C/leetcode/src/3.c@lengthOfLongestSubstring": "int lengthOfLongestSubstring ( char * s ) { int cur_max = 0 , max = 0 ; int counter [ 255 ] ; int end = 0 ; memset ( counter , 0 , sizeof ( int ) * 255 ) ; while ( end < strlen ( s ) ) { if ( counter [ s [ end ] ] == 0 ) { counter [ s [ end ] ] ++ ; end ++ ; cur_max ++ ; } else { char c = s [ end ] ; memset ( counter , 0 , 255 * sizeof ( int ) ) ; if ( cur_max >= max ) max = cur_max ; cur_max = 0 ; while ( s [ end - 1 ] != c ) end -- ; } } if ( cur_max >= max ) max = cur_max ; return max ; }",
    "resources/C/leetcode/src/901.c@stockSpannerCreate": "StockSpanner * stockSpannerCreate ( ) { Stack * sentry = ( Stack * ) malloc ( sizeof ( Stack ) ) ; StockSpanner * result = ( StockSpanner * ) malloc ( sizeof ( StockSpanner ) ) ; result -> index = 0 ; result -> sentry = sentry ; result -> stackPointer = sentry ; return result ; }",
    "resources/C/leetcode/src/901.c@stockSpannerNext": "int stockSpannerNext ( StockSpanner * obj , int price ) { while ( obj -> stackPointer != obj -> sentry && obj -> stackPointer -> price <= price ) { Stack * currStackPointer = obj -> stackPointer ; obj -> stackPointer = obj -> stackPointer -> previous ; free ( currStackPointer ) ; } obj -> index += 1 ; int result = obj -> index ; if ( obj -> stackPointer != obj -> sentry ) { result -= obj -> stackPointer -> index ; } Stack * newStackItem = ( Stack * ) malloc ( sizeof ( Stack ) ) ; newStackItem -> index = obj -> index ; newStackItem -> price = price ; newStackItem -> previous = obj -> stackPointer ; obj -> stackPointer = newStackItem ; return result ; }",
    "resources/C/leetcode/src/901.c@stockSpannerFree": "void stockSpannerFree ( StockSpanner * obj ) { while ( obj -> stackPointer != obj -> sentry ) { Stack * currStackPointer = obj -> stackPointer ; obj -> stackPointer = obj -> stackPointer -> previous ; free ( currStackPointer ) ; } free ( obj -> sentry ) ; free ( obj ) ; }",
    "resources/C/leetcode/src/1184.c@distanceBetweenBusStops": "int distanceBetweenBusStops ( int * distance , int distanceSize , int start , int destination ) { int sum1 = 0 , sum2 = 0 ; if ( start > destination ) { int tmp = start ; start = destination ; destination = tmp ; } for ( auto i = 0 ; i < distanceSize ; ++ i ) { if ( i >= start && i < destination ) sum1 += distance [ i ] ; else sum2 += distance [ i ] ; } return sum1 < sum2 ? sum1 : sum2 ; }",
    "resources/C/leetcode/src/1752.c@check": "bool check ( int * nums , int numsSize ) { if ( numsSize == 1 ) { return true ; } bool wasShift = false ; for ( int i = 1 ; i < numsSize ; i ++ ) { if ( nums [ i - 1 ] > nums [ i ] ) { if ( wasShift ) { return false ; } wasShift = true ; } } return ! wasShift || nums [ 0 ] >= nums [ numsSize - 1 ] ; }",
    "resources/C/leetcode/src/9.c@isPalindrome": "bool isPalindrome ( int x ) { if ( x < 0 || ( x % 10 == 0 && x != 0 ) ) { return false ; } int revertedNumber = 0 ; while ( x > revertedNumber ) { revertedNumber = revertedNumber * 10 + x % 10 ; x /= 10 ; } return x == revertedNumber || x == revertedNumber / 10 ; }",
    "resources/C/leetcode/src/2095.c@deleteMiddle": "struct ListNode * deleteMiddle ( struct ListNode * head ) { if ( head == NULL || head -> next == NULL ) return NULL ; struct ListNode * fast , * slow , * prev ; int n = 0 ; fast = head ; slow = head ; while ( fast != NULL ) { n = n + 1 ; fast = fast -> next ; } fast = head ; while ( fast -> next != NULL && fast -> next -> next != NULL ) // finds mid node { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } if ( n % 2 == 0 ) { prev = slow ; slow = slow -> next ; prev -> next = slow -> next ; } else prev -> next = slow -> next ; return head ; }",
    "resources/C/leetcode/src/1008.c@bstFromPreorder": "struct TreeNode * bstFromPreorder ( int * preorder , int preorderSize ) { struct TreeNode * new ; int left_ptr ; new = malloc ( sizeof ( struct TreeNode ) ) ; new -> val = preorder [ 0 ] ; if ( preorderSize == 1 ) { new -> right = NULL ; new -> left = NULL ; return new ; } left_ptr = 1 ; while ( ( left_ptr < preorderSize ) && ( preorder [ left_ptr ] < preorder [ 0 ] ) ) left_ptr ++ ; if ( left_ptr == 1 ) new -> left = NULL ; else new -> left = bstFromPreorder ( preorder + 1 , left_ptr - 1 ) ; if ( left_ptr < preorderSize ) new -> right = bstFromPreorder ( preorder + left_ptr , preorderSize - left_ptr ) ; else new -> right = NULL ; return new ; }",
    "resources/C/leetcode/src/37.c@initSet": "int * * initSet ( int size ) { int * * result = ( int * * ) malloc ( size * sizeof ( int * ) ) ; for ( int i = 0 ; i < size ; i ++ ) { result [ i ] = ( int * ) calloc ( size , sizeof ( int ) ) ; } return result ; }",
    "resources/C/leetcode/src/37.c@getTripletId": "int getTripletId ( int i , int j ) { return ( i / 3 ) * 3 + ( j / 3 ) ; }",
    "resources/C/leetcode/src/37.c@sudokuSolver": "bool sudokuSolver ( int startI , int startJ , char * * board , int boardSize , int * boardColSize , int * * horizontalsSets , int * * verticalsSets , int * * tripletsSets ) { for ( int i = startI ; i < boardSize ; i ++ ) { for ( int j = startJ ; j < boardColSize [ i ] ; j ++ ) { if ( board [ i ] [ j ] != '.' ) { continue ; } // Find the sets of the current point (i, j) int * horizontalSet = horizontalsSets [ i ] ; int * verticalSet = verticalsSets [ j ] ; int * tripletsSet = tripletsSets [ getTripletId ( i , j ) ] ; for ( int z = 1 ; z < 10 ; z ++ ) { if ( horizontalSet [ z ] || verticalSet [ z ] || tripletsSet [ z ] ) { continue ; } // If the z doesn't belong to occupations sets, we check this value to be in place horizontalSet [ z ] = 1 ; verticalSet [ z ] = 1 ; tripletsSet [ z ] = 1 ; if ( sudokuSolver ( i , j + 1 , board , boardSize , boardColSize , horizontalsSets , verticalsSets , tripletsSets ) ) { board [ i ] [ j ] = z + '0' ; return true ; } horizontalSet [ z ] = 0 ; verticalSet [ z ] = 0 ; tripletsSet [ z ] = 0 ; } // We tried all possible values in range 1-10. No variants - returns false; return false ; } // startJ to begin of the row. startJ = 0 ; } // Reach it when the end of the board - then all previous values are setup correctly. return true ; }",
    "resources/C/leetcode/src/37.c@solveSudoku": "void solveSudoku ( char * * board , int boardSize , int * boardColSize ) { // Declare sets for cheking occupation of numbers by horizontals, verticals lines and triplets. int * * horizontalsSets = initSet ( boardSize + 1 ) ; int * * verticalsSets = initSet ( boardSize + 1 ) ; int * * tripletsSets = initSet ( getTripletId ( boardSize + 1 , boardSize + 1 ) ) ; // Populate sets with values from the board. for ( int i = 0 ; i < boardSize ; i ++ ) { for ( int j = 0 ; j < boardColSize [ i ] ; j ++ ) { if ( board [ i ] [ j ] == '.' ) { continue ; } int value = board [ i ] [ j ] - '0' ; horizontalsSets [ i ] [ value ] = 1 ; verticalsSets [ j ] [ value ] = 1 ; tripletsSets [ getTripletId ( i , j ) ] [ value ] = 1 ; } } // Solving sudokuSolver ( 0 , 0 , board , boardSize , boardColSize , horizontalsSets , verticalsSets , tripletsSets ) ; // Free resources free ( horizontalsSets ) ; free ( verticalsSets ) ; free ( tripletsSets ) ; }",
    "resources/C/leetcode/src/104.c@maxval": "int maxval ( int a , int b ) { if ( a > b ) return a ; else return b ; }",
    "resources/C/leetcode/src/104.c@maxDepth": "int maxDepth ( struct TreeNode * root ) { if ( root == NULL ) return 0 ; else return 1 + maxval ( maxDepth ( root -> left ) , maxDepth ( root -> right ) ) ; }",
    "resources/C/leetcode/src/344.c@reverseString": "void reverseString ( char * s , int sSize ) { int last = sSize - 1 , i ; for ( i = 0 ; i < last ; i ++ ) { char tmp = s [ i ] ; s [ i ] = s [ last ] ; s [ last ] = tmp ; last -- ; } }",
    "resources/C/leetcode/src/94.c@processTraversal": "void processTraversal ( struct TreeNode * root , int * res , int * size ) { if ( ! root ) return ; processTraversal ( root -> left , res , size ) ; res [ * size ] = root -> val ; * size = * size + 1 ; processTraversal ( root -> right , res , size ) ; }",
    "resources/C/leetcode/src/94.c@inorderTraversal": "int * inorderTraversal ( struct TreeNode * root , int * returnSize ) { int * res = malloc ( 256 * sizeof ( int ) ) ; * returnSize = 0 ; processTraversal ( root , res , returnSize ) ; return res ; }",
    "resources/C/leetcode/src/12.c@getOne": "char * getOne ( char c ) { switch ( c ) { case '9' : return \"IX\" ; case '8' : return \"VIII\" ; case '7' : return \"VII\" ; case '6' : return \"VI\" ; case '5' : return \"V\" ; case '4' : return \"IV\" ; case '3' : return \"III\" ; case '2' : return \"II\" ; case '1' : return \"I\" ; case '0' : return \"\" ; default : return NULL ; } }",
    "resources/C/leetcode/src/12.c@getTen": "char * getTen ( char c ) { switch ( c ) { case '9' : return \"XC\" ; case '8' : return \"LXXX\" ; case '7' : return \"LXX\" ; case '6' : return \"LX\" ; case '5' : return \"L\" ; case '4' : return \"XL\" ; case '3' : return \"XXX\" ; case '2' : return \"XX\" ; case '1' : return \"X\" ; case '0' : return \"\" ; default : return NULL ; } }",
    "resources/C/leetcode/src/12.c@getHundred": "char * getHundred ( char c ) { switch ( c ) { case '9' : return \"CM\" ; case '8' : return \"DCCC\" ; case '7' : return \"DCC\" ; case '6' : return \"DC\" ; case '5' : return \"D\" ; case '4' : return \"CD\" ; case '3' : return \"CCC\" ; case '2' : return \"CC\" ; case '1' : return \"C\" ; case '0' : return \"\" ; default : return NULL ; } }",
    "resources/C/leetcode/src/12.c@getThousand": "char * getThousand ( char c ) { switch ( c ) { case '3' : return \"MMM\" ; case '2' : return \"MM\" ; case '1' : return \"M\" ; default : return NULL ; } }",
    "resources/C/leetcode/src/12.c@intToRoman": "char * intToRoman ( int num ) { int length ; char number [ 5 ] ; char * s = malloc ( 16 * sizeof ( char ) ) ; sprintf ( number , \"%i\" , num ) ; length = strlen ( number ) ; switch ( length ) { case 4 : sprintf ( s , \"%s%s%s%s\" , getThousand ( number [ 0 ] ) , getHundred ( number [ 1 ] ) , getTen ( number [ 2 ] ) , getOne ( number [ 3 ] ) ) ; break ; case 3 : sprintf ( s , \"%s%s%s\" , getHundred ( number [ 0 ] ) , getTen ( number [ 1 ] ) , getOne ( number [ 2 ] ) ) ; break ; case 2 : sprintf ( s , \"%s%s\" , getTen ( number [ 0 ] ) , getOne ( number [ 1 ] ) ) ; break ; case 1 : s = getOne ( number [ 0 ] ) ; break ; default : break ; } return s ; }",
    "resources/C/leetcode/src/121.c@maxcmp": "int maxcmp ( int a , int b ) { return ( a >= b ) ? a : b ; }",
    "resources/C/leetcode/src/121.c@maxProfit": "int maxProfit ( int * prices , int pricesSize ) { /* maxCur: current maximum\n     * maxSoFar: found maximum for subarray so far\n     */ int maxCur = 0 , maxSoFar = 0 ; for ( int i = 1 ; i < pricesSize ; i ++ ) { maxCur = maxcmp ( 0 , maxCur + prices [ i ] - prices [ i - 1 ] ) ; maxSoFar = maxcmp ( maxSoFar , maxCur ) ; } return maxSoFar ; }",
    "resources/C/leetcode/src/79.c@getPointKey": "int getPointKey ( int i , int j , int boardSize , int boardColSize ) { return boardSize * boardColSize * i + j ; }",
    "resources/C/leetcode/src/79.c@exitsWord": "bool exitsWord ( int i , int j , char * * board , int boardSize , int * boardColSize , int wordIndex , char * word , int * vistedPointSet ) { if ( board [ i ] [ j ] != word [ wordIndex ] ) { return false ; } if ( wordIndex == strlen ( word ) - 1 ) { return true ; } for ( int k = 0 ; k < directionsSize ; k ++ ) { int nextI = i + directions [ k ] [ 0 ] ; int nextJ = j + directions [ k ] [ 1 ] ; if ( nextI < 0 || nextI >= boardSize || nextJ < 0 || nextJ >= boardColSize [ i ] ) { continue ; } int key = getPointKey ( nextI , nextJ , boardSize , boardColSize [ i ] ) ; if ( vistedPointSet [ key ] == 1 ) { continue ; } vistedPointSet [ key ] = 1 ; if ( exitsWord ( nextI , nextJ , board , boardSize , boardColSize , wordIndex + 1 , word , vistedPointSet ) ) { return true ; } vistedPointSet [ key ] = 0 ; } return false ; }",
    "resources/C/leetcode/src/79.c@exist": "bool exist ( char * * board , int boardSize , int * boardColSize , char * word ) { int * vistedPointSet = ( int * ) calloc ( getPointKey ( boardSize , boardColSize [ 0 ] , boardSize , boardColSize [ 0 ] ) , sizeof ( int ) ) ; for ( int i = 0 ; i < boardSize ; i ++ ) { for ( int j = 0 ; j < boardColSize [ i ] ; j ++ ) { int key = getPointKey ( i , j , boardSize , boardColSize [ i ] ) ; vistedPointSet [ key ] = 1 ; if ( exitsWord ( i , j , board , boardSize , boardColSize , 0 , word , vistedPointSet ) ) { return true ; } ; vistedPointSet [ key ] = 0 ; } } return false ; }",
    "resources/C/leetcode/src/771.c@numJewelsInStones": "int numJewelsInStones ( char * j , char * s ) { // as strlen is O(n), store it once rather than using it in for loop int cnt [ 500 ] , lens = strlen ( s ) , lenj = strlen ( j ) , sol = 0 ; memset ( cnt , 0 , sizeof ( cnt ) ) ; // lookup to know which character occurs in j for ( int i = 0 ; i < lenj ; i ++ ) cnt [ j [ i ] ] ++ ; // count the characters in s for ( int i = 0 ; i < lens ; i ++ ) sol += cnt [ s [ i ] ] ; return sol ; }",
    "resources/C/leetcode/src/7.c@reverse": "int reverse ( int x ) { int rev = 0 ; while ( x != 0 ) { int pop = x % 10 ; x /= 10 ; if ( rev > INT_MAX / 10 || ( rev == INT_MAX / 10 && pop > 7 ) ) return 0 ; if ( rev < INT_MIN / 10 || ( rev == INT_MIN / 10 && pop < - 8 ) ) return 0 ; rev = rev * 10 + pop ; } return rev ; }",
    "resources/C/leetcode/src/841.c@visitRooms": "void visitRooms ( int key , int * * rooms , int roomsSize , int * roomsColSize , int * visitedRooms ) { if ( visitedRooms [ key ] == 1 ) { return ; } visitedRooms [ key ] = 1 ; for ( int i = 0 ; i < roomsColSize [ key ] ; i ++ ) { visitRooms ( rooms [ key ] [ i ] , rooms , roomsSize , roomsColSize , visitedRooms ) ; } }",
    "resources/C/leetcode/src/841.c@canVisitAllRooms": "bool canVisitAllRooms ( int * * rooms , int roomsSize , int * roomsColSize ) { int * visitedRooms = calloc ( roomsSize , sizeof ( int ) ) ; visitRooms ( 0 , rooms , roomsSize , roomsColSize , visitedRooms ) ; int visitedRoomsNumber = 0 ; for ( int i = 0 ; i < roomsSize ; i ++ ) { if ( visitedRooms [ i ] == 1 ) { visitedRoomsNumber ++ ; } } return visitedRoomsNumber == roomsSize ; }",
    "resources/C/leetcode/src/905.c@sortArrayByParity": "int * sortArrayByParity ( int * A , int ASize , int * returnSize ) { int * retArr = malloc ( ASize * sizeof ( int ) ) ; int oddIndex = ASize - 1 ; int evenIndex = 0 ; * returnSize = ASize ; for ( int i = 0 ; i < ASize ; i ++ ) { if ( A [ i ] % 2 == 0 ) { retArr [ evenIndex ] = A [ i ] ; evenIndex ++ ; } else { retArr [ oddIndex ] = A [ i ] ; oddIndex -- ; } } return retArr ; }",
    "resources/C/leetcode/src/153.c@findMin": "int findMin ( int * nums , int numsSize ) { int low = 0 , high = numsSize - 1 ; while ( low < high ) { int mid = low + ( high - low ) / 2 ; /* minimum is on left side */ if ( nums [ mid ] < nums [ high ] ) high = mid ; /* minimum is on right side */ else low = mid + 1 ; } return nums [ low ] ; }",
    "resources/C/leetcode/src/977.c@sortedSquares": "int * sortedSquares ( int * A , int ASize , int * returnSize ) { int * res = malloc ( ASize * sizeof ( int ) ) ; for ( int i = 0 ; i < ASize ; i ++ ) res [ i ] = A [ i ] * A [ i ] ; * returnSize = ASize ; qsort ( res , ASize , sizeof ( int ) , cmpval ) ; return res ; }",
    "resources/C/leetcode/src/977.c@cmpval": "int cmpval ( const void * a , const void * b ) { return * ( int * ) a - * ( int * ) b ; }",
    "resources/C/leetcode/src/278.c@firstBadVersion": "int firstBadVersion ( int n ) { int low = 1 , high = n ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( isBadVersion ( mid ) ) { high = mid - 1 ; } else { low = mid + 1 ; } } return low ; }",
    "resources/C/leetcode/src/647.c@countSubstrings": "int countSubstrings ( char * s ) { int len = strlen ( s ) ; int i ; int count = 0 ; for ( i = 0 ; i < len ; i ++ ) { // cases handled for both odd and even lenghted Palindrome count += countPalin ( s , i , i , len ) ; if ( i != len - 1 ) count += countPalin ( s , i , i + 1 , len ) ; } return count ; }",
    "resources/C/leetcode/src/647.c@countPalin": "int countPalin ( char * s , int head , int tail , int len ) { int ret = ( s [ head ] == s [ tail ] ) ? 1 : 0 ; if ( ret && head - 1 >= 0 && tail + 1 < len ) ret += countPalin ( s , head - 1 , tail + 1 , len ) ; return ret ; }",
    "resources/C/leetcode/src/852.c@peakIndexInMountainArray": "int peakIndexInMountainArray ( int * A , int ASize ) { int low = 1 , high = ASize ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( A [ mid - 1 ] < A [ mid ] && A [ mid ] > A [ mid + 1 ] ) return mid ; else if ( A [ mid - 1 ] < A [ mid ] && A [ mid ] < A [ mid + 1 ] ) low = mid + 1 ; else high = mid - 1 ; } return - 1 ; }",
    "resources/C/leetcode/src/709.c@toLowerCase": "char * toLowerCase ( char * str ) { for ( int i = 0 ; i < strlen ( str ) ; i ++ ) str [ i ] = tolower ( str [ i ] ) ; return str ; }",
    "resources/C/leetcode/src/236.c@findTargetPath": "bool findTargetPath ( struct TreeNode * node , struct TreeNode * target , struct ListItem * path ) { if ( node == NULL ) { return false ; } struct ListItem * pathItem = malloc ( sizeof ( struct ListItem ) ) ; pathItem -> node = node ; pathItem -> next = NULL ; path -> next = pathItem ; if ( node -> val == target -> val ) { return true ; } if ( findTargetPath ( node -> left , target , pathItem ) ) { return true ; } if ( findTargetPath ( node -> right , target , pathItem ) ) { return true ; } path -> next = NULL ; free ( pathItem ) ; return false ; }",
    "resources/C/leetcode/src/236.c@freeList": "void freeList ( struct ListItem * target ) { if ( target -> next != NULL ) { freeList ( target -> next ) ; } free ( target ) ; }",
    "resources/C/leetcode/src/236.c@lowestCommonAncestor": "struct TreeNode * lowestCommonAncestor ( struct TreeNode * root , struct TreeNode * p , struct TreeNode * q ) { struct ListItem * pPath = malloc ( sizeof ( struct ListItem ) ) ; struct ListItem * qPath = malloc ( sizeof ( struct ListItem ) ) ; findTargetPath ( root , p , pPath ) ; findTargetPath ( root , q , qPath ) ; struct TreeNode * lowestTreeNode = NULL ; struct ListItem * pPathCursor = pPath -> next ; struct ListItem * qPathCursor = qPath -> next ; while ( pPathCursor != NULL && qPathCursor != NULL ) { if ( pPathCursor -> node -> val == qPathCursor -> node -> val ) { lowestTreeNode = pPathCursor -> node ; pPathCursor = pPathCursor -> next ; qPathCursor = qPathCursor -> next ; continue ; } break ; } freeList ( pPath ) ; freeList ( qPath ) ; return lowestTreeNode ; }",
    "resources/C/leetcode/src/191.c@hammingWeight": "int hammingWeight ( uint32_t n ) { int TotalBits = 32 ; int i , weight = 0 ; for ( i = 0 ; i < TotalBits ; i ++ ) { if ( n & ( UINT32_C ( 1 ) << i ) ) // if the bit on the ith position of 32 bit input is 1, // then proceed Further note the use of UINT32_C to // convert 1 to unsigned 32 bit int, as just 1 is treated // as int which cannot be shifted left more than 30 times weight += 1 ; } return weight ; }",
    "resources/C/leetcode/src/45.c@jump": "int jump ( int * nums , int numsSize ) { if ( numsSize == 1 ) { return 0 ; } int step = 1 ; int * visitedCells = calloc ( numsSize , sizeof ( int ) ) ; int * queue = malloc ( numsSize * sizeof ( int ) ) ; queue [ 0 ] = 0 ; int queueLength = 1 ; while ( queueLength > 0 ) { int * nextQueue = malloc ( numsSize * sizeof ( int ) ) ; int nextQueueLength = 0 ; for ( int i = 0 ; i < queueLength ; i ++ ) { int cell = queue [ i ] ; int jump = nums [ cell ] ; if ( cell + jump >= numsSize - 1 ) { free ( visitedCells ) ; free ( queue ) ; free ( nextQueue ) ; return step ; } // populate next queue wave for searching for ( int nextCell = cell ; nextCell <= cell + jump ; nextCell ++ ) { if ( visitedCells [ nextCell ] == 0 ) { nextQueue [ nextQueueLength ++ ] = nextCell ; visitedCells [ nextCell ] = 1 ; } } } step ++ ; free ( queue ) ; queue = nextQueue ; queueLength = nextQueueLength ; } free ( visitedCells ) ; free ( queue ) ; return - 1 ; }",
    "resources/C/leetcode/src/24.c@swapPairs": "struct ListNode * swapPairs ( struct ListNode * head ) { if ( ! head || ! head -> next ) return head ; struct ListNode * tmp = head -> next ; head -> next = swapPairs ( head -> next -> next ) ; tmp -> next = head ; return tmp ; }",
    "resources/C/leetcode/src/2125.c@coundDevices": "int coundDevices ( char * bankRow ) { int result = 0 ; int bankRowSize = strlen ( bankRow ) ; for ( int i = 0 ; i < bankRowSize ; i ++ ) { if ( bankRow [ i ] == '1' ) { result ++ ; } } return result ; }",
    "resources/C/leetcode/src/2125.c@numberOfBeams": "int numberOfBeams ( char * * bank , int bankSize ) { int prevRowDevices = 0 ; int result = 0 ; for ( int i = 0 ; i < bankSize ; i ++ ) { int devices = coundDevices ( bank [ i ] ) ; if ( devices == 0 ) { continue ; } result += devices * prevRowDevices ; prevRowDevices = devices ; } return result ; }",
    "resources/C/leetcode/src/20.c@isValid": "bool isValid ( char * s ) { int i , k = 0 , len = strlen ( s ) ; char * store = calloc ( len , sizeof ( char ) ) ; for ( i = 0 ; s [ i ] != '\\0' ; i ++ ) { switch ( s [ i ] ) { case '(' : case '{' : case '[' : store [ k ++ ] = s [ i ] ; break ; case ')' : if ( k < 1 || store [ -- k ] != '(' ) goto out ; break ; case '}' : if ( k < 1 || store [ -- k ] != '{' ) goto out ; break ; case ']' : if ( k < 1 || store [ -- k ] != '[' ) goto out ; break ; } } out : free ( store ) ; return s [ i ] == '\\0' && k == 0 ; }",
    "resources/C/leetcode/src/485.c@max": "int max ( a , b ) { if ( a > b ) return a ; else return b ; }",
    "resources/C/leetcode/src/485.c@findMaxConsecutiveOnes": "int findMaxConsecutiveOnes ( int * nums , int numsSize ) { int count = 0 ; int result = 0 ; for ( int i = 0 ; i < numsSize ; i ++ ) { if ( nums [ i ] == 0 ) count = 0 ; else { count ++ ; result = max ( result , count ) ; } } return result ; }",
    "resources/C/leetcode/src/119.c@getRow": "int * getRow ( int rowIndex , int * returnSize ) { int colIndex = rowIndex + 1 ; int * ans = ( int * ) malloc ( sizeof ( int ) * colIndex ) ; for ( int i = 0 ; i < colIndex ; i ++ ) { ans [ i ] = 1 ; } * returnSize = colIndex ; for ( int r = 2 ; r <= rowIndex ; r ++ ) { for ( int c = r - 1 ; c > 0 ; c -- ) { ans [ c ] = ans [ c ] + ans [ c - 1 ] ; } } return ans ; }",
    "resources/C/leetcode/src/136.c@singleNumber": "int singleNumber ( int * nums , int numsSize ) { int i , result = 0 ; for ( i = 0 ; i < numsSize ; i ++ ) result = result ^ nums [ i ] ; return result ; }",
    "resources/C/leetcode/src/2304.c@minPathCost": "int minPathCost ( int * * grid , int gridSize , int * gridColSize , int * * moveCost , int moveCostSize , int * moveCostColSize ) { int * dp = ( int * ) calloc ( gridColSize [ 0 ] , sizeof ( int ) ) ; int * newDp = ( int * ) calloc ( gridColSize [ 0 ] , sizeof ( int ) ) ; for ( int i = 0 ; i < gridSize - 1 ; i ++ ) { int currGridColSize = gridColSize [ i ] ; for ( int j = 0 ; j < currGridColSize ; j ++ ) { newDp [ j ] = - 1 ; } for ( int j = 0 ; j < currGridColSize ; j ++ ) { int currGridItem = grid [ i ] [ j ] ; for ( int z = 0 ; z < currGridColSize ; z ++ ) { int currMoveCost = dp [ j ] + moveCost [ currGridItem ] [ z ] + currGridItem ; newDp [ z ] = ( newDp [ z ] == - 1 ) ? currMoveCost : min ( newDp [ z ] , currMoveCost ) ; } } for ( int j = 0 ; j < currGridColSize ; j ++ ) { dp [ j ] = newDp [ j ] ; } } // Find minimum value. int minValue = dp [ 0 ] + grid [ gridSize - 1 ] [ 0 ] ; for ( int j = 1 ; j < gridColSize [ 0 ] ; j ++ ) { minValue = min ( minValue , dp [ j ] + grid [ gridSize - 1 ] [ j ] ) ; } // free resources free ( dp ) ; free ( newDp ) ; return minValue ; }",
    "resources/C/leetcode/src/1524.c@numOfSubarrays": "int numOfSubarrays ( int * arr , int arrSize ) { int result = 0 ; int curSumm = 0 ; int currOddSumms = 0 ; int currEvenSumm = 0 ; int modulo = 1000000000 + 7 ; for ( int i = 0 ; i < arrSize ; i ++ ) { curSumm += arr [ i ] ; if ( curSumm % 2 == 0 ) { currEvenSumm ++ ; result = ( result + currOddSumms ) % modulo ; } else { currOddSumms ++ ; result = ( result + 1 + currEvenSumm ) % modulo ; } } return result % modulo ; }",
    "resources/C/leetcode/src/509.c@fib": "int fib ( int N ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return 1 ; return fib ( N - 1 ) + fib ( N - 2 ) ; }",
    "resources/C/leetcode/src/979.c@getDisturb": "struct NodeDistributeInfo * getDisturb ( struct TreeNode * node ) { struct NodeDistributeInfo * result = malloc ( sizeof ( struct NodeDistributeInfo ) ) ; if ( node == NULL ) { result -> distributeMoves = 0 ; result -> distributeExcess = 1 ; return result ; } struct NodeDistributeInfo * leftDistribute = getDisturb ( node -> left ) ; struct NodeDistributeInfo * rightDistribute = getDisturb ( node -> right ) ; int coinsToLeft = 1 - leftDistribute -> distributeExcess ; int coinsToRight = 1 - rightDistribute -> distributeExcess ; // Calculate moves as excess and depth between left and right subtrees. result -> distributeMoves = leftDistribute -> distributeMoves + rightDistribute -> distributeMoves + abs ( coinsToLeft ) + abs ( coinsToRight ) ; result -> distributeExcess = node -> val - coinsToLeft - coinsToRight ; free ( leftDistribute ) ; free ( rightDistribute ) ; return result ; }",
    "resources/C/leetcode/src/979.c@distributeCoins": "int distributeCoins ( struct TreeNode * root ) { return getDisturb ( root ) -> distributeMoves ; }",
    "resources/C/leetcode/src/217.c@numcmp": "int numcmp ( const void * a , const void * b ) { return * ( int * ) a - * ( int * ) b ; }",
    "resources/C/leetcode/src/217.c@containsDuplicate": "bool containsDuplicate ( int * nums , int numsSize ) { int i ; qsort ( nums , numsSize , sizeof ( int ) , numcmp ) ; for ( i = 0 ; i < numsSize - 1 ; i ++ ) { if ( nums [ i ] == nums [ i + 1 ] ) return 1 ; } return 0 ; }",
    "resources/C/leetcode/src/83.c@deleteDuplicates": "struct ListNode * deleteDuplicates ( struct ListNode * head ) { struct ListNode * cur = head ; while ( cur && cur -> next ) { if ( cur -> val == cur -> next -> val ) cur -> next = cur -> next -> next ; else cur = cur -> next ; } return head ; }",
    "resources/C/leetcode/src/617.c@newNode": "struct TreeNode * newNode ( int item ) { struct TreeNode * node = ( struct TreeNode * ) malloc ( sizeof ( struct TreeNode ) ) ; node -> val = item ; node -> left = node -> right = NULL ; return node ; }",
    "resources/C/leetcode/src/617.c@mergeTrees": "struct TreeNode * mergeTrees ( struct TreeNode * t1 , struct TreeNode * t2 ) { if ( t1 == NULL && t2 == NULL ) return NULL ; int item = ( t1 == NULL ? 0 : t1 -> val ) + ( t2 == NULL ? 0 : t2 -> val ) ; struct TreeNode * node = newNode ( item ) ; node -> left = mergeTrees ( t1 == NULL ? NULL : t1 -> left , t2 == NULL ? NULL : t2 -> left ) ; node -> right = mergeTrees ( t1 == NULL ? NULL : t1 -> right , t2 == NULL ? NULL : t2 -> right ) ; return node ; }",
    "resources/C/leetcode/src/109.c@buildBST": "struct TreeNode * buildBST ( struct ListNode * head , struct ListNode * tail ) { if ( head == tail ) return NULL ; struct ListNode * slow = head , * fast = head ; while ( fast != tail && fast -> next != tail ) { fast = fast -> next -> next ; slow = slow -> next ; } struct TreeNode * node = malloc ( sizeof ( struct TreeNode ) ) ; node -> val = slow -> val ; node -> left = buildBST ( head , slow ) ; node -> right = buildBST ( slow -> next , tail ) ; return node ; }",
    "resources/C/leetcode/src/109.c@sortedListToBST": "struct TreeNode * sortedListToBST ( struct ListNode * head ) { if ( ! head ) return NULL ; else return buildBST ( head , NULL ) ; }",
    "resources/C/leetcode/src/1283.c@getSum": "long getSum ( int * nums , int numsSize , int divizor ) { long result = 0 ; for ( int i = 0 ; i < numsSize ; i ++ ) { int value = nums [ i ] / divizor ; if ( value * divizor != nums [ i ] ) { value ++ ; } result += value ; } return result ; }",
    "resources/C/leetcode/src/1283.c@smallestDivisor": "int smallestDivisor ( int * nums , int numsSize , int threshold ) { int maxNum = 0 ; for ( int i = 0 ; i < numsSize ; i ++ ) { maxNum = max ( maxNum , nums [ i ] ) ; } int left = 1 ; int right = maxNum ; while ( left <= right ) { int middle = ( left + right ) / 2 ; long middleSum = getSum ( nums , numsSize , middle ) ; if ( middleSum <= threshold && ( middle == 1 || getSum ( nums , numsSize , middle - 1 ) > threshold ) ) { return middle ; } if ( middleSum > threshold ) { left = middle + 1 ; } else { right = middle - 1 ; } } return - 1 ; }",
    "resources/C/leetcode/src/2482.c@onesMinusZeros": "int * * onesMinusZeros ( int * * grid , int gridSize , int * gridColSize , int * returnSize , int * * returnColumnSizes ) { int n = gridSize ; int m = gridColSize [ 0 ] ; int * * result = malloc ( gridSize * sizeof ( int * ) ) ; for ( int i = 0 ; i < n ; i ++ ) { result [ i ] = malloc ( m * sizeof ( int ) ) ; } int * onesRows = calloc ( n , sizeof ( int ) ) ; int * onesCols = calloc ( m , sizeof ( int ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( grid [ i ] [ j ] == 1 ) { onesRows [ i ] += 1 ; onesCols [ j ] += 1 ; } } } for ( int i = 0 ; i < gridSize ; i ++ ) { for ( int j = 0 ; j < gridColSize [ i ] ; j ++ ) { result [ i ] [ j ] = onesRows [ i ] + onesCols [ j ] - ( m - onesRows [ i ] ) - ( n - onesCols [ j ] ) ; } } free ( onesRows ) ; free ( onesCols ) ; * returnSize = gridSize ; * returnColumnSizes = gridColSize ; return result ; }",
    "resources/C/leetcode/src/1189.c@maxNumberOfBalloons": "int maxNumberOfBalloons ( char * text ) { /*\n        0 -> b,\n        1 -> a,\n        2 -> l,\n        3 -> o,\n        4 -> n\n    */ int count_letters [ 5 ] = { 0 } ; int i , min_counter_ballons ; for ( char * ptr = text ; * ptr ; ptr ++ ) { if ( * ptr == 'b' ) { count_letters [ 0 ] ++ ; } else if ( * ptr == 'a' ) { count_letters [ 1 ] ++ ; } else if ( * ptr == 'l' ) { count_letters [ 2 ] ++ ; } else if ( * ptr == 'o' ) { count_letters [ 3 ] ++ ; } else if ( * ptr == 'n' ) { count_letters [ 4 ] ++ ; } } /* Divide by 2 the repeted letters */ count_letters [ 2 ] /= 2 ; count_letters [ 3 ] /= 2 ; /* Max number of times which we can write ballon is equal to min value of\n     * letters on count_letter */ min_counter_ballons = count_letters [ 0 ] ; for ( i = 1 ; i < 5 ; i ++ ) { if ( count_letters [ i ] < min_counter_ballons ) min_counter_ballons = count_letters [ i ] ; } return min_counter_ballons ; }",
    "resources/C/leetcode/src/268.c@missingNumber": "int missingNumber ( int * nums , int numsSize ) { int i , actual_sum = 0 , sum = 0 ; for ( i = 0 ; i < numsSize ; i ++ ) { sum = sum + nums [ i ] ; actual_sum = actual_sum + i ; } return actual_sum + numsSize - sum ; }",
    "resources/C/leetcode/src/203.c@removeElements": "struct ListNode * removeElements ( struct ListNode * head , int val ) { if ( head == NULL ) return NULL ; if ( head -> val == val ) { return removeElements ( head -> next , val ) ; } else { head -> next = removeElements ( head -> next , val ) ; } return head ; }",
    "resources/C/leetcode/src/11.c@min": "int min ( int a , int b ) { return ( ( a < b ) ? a : b ) ; }",
    "resources/C/leetcode/src/11.c@maxArea": "int maxArea ( int * height , int heightSize ) { // Start with maximum container width int start = 0 ; int end = heightSize - 1 ; int res = 0 ; while ( start < end ) { // Calculate current area by taking minimum of two heights int currArea = ( end - start ) * min ( height [ start ] , height [ end ] ) ; if ( currArea > res ) res = currArea ; if ( height [ start ] < height [ end ] ) start = start + 1 ; else end = end - 1 ; } return res ; }",
    "resources/C/leetcode/src/4.c@findMedianSortedArrays": "double findMedianSortedArrays ( int * nums1 , int nums1Size , int * nums2 , int nums2Size ) { int index1 = 0 ; int index2 = 0 ; int v [ nums1Size + nums2Size ] ; int v_index = 0 ; while ( index1 < nums1Size && index2 < nums2Size ) { if ( nums1 [ index1 ] <= nums2 [ index2 ] ) { v [ v_index ++ ] = nums1 [ index1 ++ ] ; } else { v [ v_index ++ ] = nums2 [ index2 ++ ] ; } } if ( index1 < nums1Size ) { while ( index1 < nums1Size ) { v [ v_index ++ ] = nums1 [ index1 ++ ] ; } } if ( index2 < nums2Size ) { while ( index2 < nums2Size ) { v [ v_index ++ ] = nums2 [ index2 ++ ] ; } } if ( v_index == 1 ) { return v [ 0 ] ; } if ( v_index % 2 == 0 ) { double n1 , n2 ; n1 = v [ v_index / 2 ] ; n2 = v [ ( v_index / 2 ) - 1 ] ; return ( n1 + n2 ) / 2 ; } int new_index = ( int ) v_index / 2 ; int i = 0 ; return v [ new_index ] ; }",
    "resources/C/leetcode/src/226.c@invertTree": "struct TreeNode * invertTree ( struct TreeNode * root ) { struct TreeNode * tmp ; if ( root == NULL ) return NULL ; tmp = root -> left ; root -> left = root -> right ; root -> right = tmp ; invertTree ( root -> left ) ; invertTree ( root -> right ) ; return root ; }",
    "resources/C/leetcode/src/476.c@findComplement": "int findComplement ( int num ) { int TotalBits = 0 ; int temp = num ; while ( temp ) { // To find position of MSB in given num. Since num is represented as a // standard size in memory, we cannot rely on size for that information. TotalBits ++ ; // increment TotalBits till temp becomes 0 temp >>= 1 ; // shift temp right by 1 bit every iteration; temp loses 1 // bit to underflow every iteration till it becomes 0 } int i , flipNumber = 1 ; // Eg: 1's complement of 101(binary) can be found as // 101^111 (XOR with 111 flips all bits that are 1 to 0 // and flips 0 to 1) for ( i = 1 ; i < TotalBits ; i ++ ) { flipNumber += UINT32_C ( 1 ) << i ; // Note the use of unsigned int to facilitate left // shift more than 31 times, if needed } num = num ^ flipNumber ; return num ; }",
    "resources/C/leetcode/src/1089.c@duplicateZeros": "void duplicateZeros ( int * arr , int arrSize ) { int i , start = 0 ; int * tmp = malloc ( arrSize * sizeof ( int ) ) ; /* Copy arr into tmp arr */ for ( i = 0 ; i < arrSize ; i ++ ) { tmp [ i ] = arr [ i ] ; } i = 0 ; for ( start = 0 ; start < arrSize ; start ++ ) { arr [ start ] = tmp [ i ] ; if ( tmp [ i ] == 0 ) { start ++ ; if ( start < arrSize ) arr [ start ] = 0 ; } i ++ ; } }",
    "resources/C/leetcode/src/917.c@reverseOnlyLetters": "char * reverseOnlyLetters ( char * S ) { int last = strlen ( S ) - 1 , i ; for ( i = 0 ; i < last ; ) { if ( ! isalpha ( S [ i ] ) ) { i ++ ; continue ; } if ( ! isalpha ( S [ last ] ) ) { last -- ; continue ; } char tmp = S [ i ] ; S [ i ] = S [ last ] ; S [ last ] = tmp ; i ++ ; last -- ; } return S ; }",
    "resources/C/leetcode/src/567.c@countCharsForStringSlice": "void countCharsForStringSlice ( int * charsCounter , char * s , int length , int sign ) { for ( int i = 0 ; i < length ; i ++ ) { charsCounter [ s [ i ] - 'a' ] += sign ; } }",
    "resources/C/leetcode/src/567.c@checkInclusion": "bool checkInclusion ( char * s1 , char * s2 ) { int lengthS1 = strlen ( s1 ) ; int lengthS2 = strlen ( s2 ) ; if ( lengthS1 > lengthS2 ) { return false ; } int * charsCounter = calloc ( EnglishLettersNumber , sizeof ( int ) ) ; // We keep counters of s1 with '-' sign. It has to be offset by s2 chars countCharsForStringSlice ( charsCounter , s1 , lengthS1 , - 1 ) ; countCharsForStringSlice ( charsCounter , s2 , lengthS1 , 1 ) ; int diffChars = 0 ; for ( int i = 0 ; i < EnglishLettersNumber ; i ++ ) { if ( charsCounter [ i ] != 0 ) { diffChars ++ ; } } if ( diffChars == 0 ) { return true ; } for ( int i = 0 ; i < lengthS2 - lengthS1 ; i ++ ) { int charNumberLeft = s2 [ i ] - 'a' ; int charNumberRight = s2 [ i + lengthS1 ] - 'a' ; charsCounter [ charNumberLeft ] -= 1 ; if ( charsCounter [ charNumberLeft ] == 0 ) { diffChars -= 1 ; } else if ( charsCounter [ charNumberLeft ] == - 1 ) { diffChars += 1 ; } charsCounter [ charNumberRight ] += 1 ; if ( charsCounter [ charNumberRight ] == 0 ) { diffChars -= 1 ; } else if ( charsCounter [ charNumberRight ] == 1 ) { diffChars += 1 ; } if ( diffChars == 0 ) { return true ; } } free ( charsCounter ) ; return false ; }",
    "resources/C/leetcode/src/442.c@cmpval": "int cmpval ( const void * a , const void * b ) { return * ( int * ) a - * ( int * ) b ; }",
    "resources/C/leetcode/src/442.c@findDuplicates": "int * findDuplicates ( int * nums , int numsSize , int * returnSize ) { int i ; qsort ( nums , numsSize , sizeof ( int ) , cmpval ) ; int * retArr = malloc ( numsSize * sizeof ( int ) ) ; * returnSize = 0 ; for ( i = 0 ; i < numsSize - 1 ; ) { if ( nums [ i ] == nums [ i + 1 ] ) { retArr [ * returnSize ] = nums [ i ] ; * returnSize = * returnSize + 1 ; i = i + 2 ; } else { i = i + 1 ; } } return retArr ; }",
    "resources/C/leetcode/src/669.c@trimBST": "struct TreeNode * trimBST ( struct TreeNode * root , int low , int high ) { if ( root == NULL ) { return NULL ; } if ( root -> val > high ) { return trimBST ( root -> left , low , high ) ; } if ( root -> val < low ) { return trimBST ( root -> right , low , high ) ; } root -> left = trimBST ( root -> left , low , high ) ; root -> right = trimBST ( root -> right , low , high ) ; return root ; }",
    "resources/C/leetcode/src/876.c@middleNode": "struct ListNode * middleNode ( struct ListNode * head ) { struct ListNode * fast , * slow ; fast = slow = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; }",
    "resources/C/leetcode/src/684.c@find": "int find ( int * sets , int index ) { while ( sets [ index ] != index ) { index = sets [ index ] ; } return index ; }",
    "resources/C/leetcode/src/684.c@unionSet": "void unionSet ( int * sets , int i1 , int i2 ) { int i1Parent = find ( sets , i1 ) ; int i2Parent = find ( sets , i2 ) ; sets [ i1Parent ] = i2Parent ; }",
    "resources/C/leetcode/src/684.c@findRedundantConnection": "int * findRedundantConnection ( int * * edges , int edgesSize , int * edgesColSize , int * returnSize ) { int setsSize = edgesSize + 1 ; int * sets = malloc ( setsSize * sizeof ( int ) ) ; for ( int i = 0 ; i < setsSize ; i ++ ) { sets [ i ] = i ; } int * result = malloc ( 2 * sizeof ( int ) ) ; * returnSize = 2 ; for ( int i = 0 ; i < edgesSize ; i ++ ) { int * edge = edges [ i ] ; int i0Parent = find ( sets , edge [ 0 ] ) ; int i1Parent = find ( sets , edge [ 1 ] ) ; if ( i0Parent == i1Parent ) { result [ 0 ] = edge [ 0 ] ; result [ 1 ] = edge [ 1 ] ; continue ; } unionSet ( sets , i0Parent , i1Parent ) ; } free ( sets ) ; return result ; }",
    "resources/C/leetcode/src/190.c@reverseBits": "uint32_t reverseBits ( uint32_t n ) { uint TotalBits = 32 ; uint32_t reverse_int = 0 ; // stored in memory as 32 bits, each bit valued 0 uint i ; for ( i = 0 ; i < TotalBits ; i ++ ) { if ( ( n & ( UINT32_C ( 1 ) << i ) ) ) // if the bit on the ith position of 32 bit input is // 1, then proceed Further note the use of UINT32_C // to convert 1 to unsigned 32 bit int, since just 1 // is treated as int which cannot be shifted left // more than 30 times reverse_int = reverse_int | ( UINT32_C ( 1 ) << ( TotalBits - 1 - i ) ) ; // Convert the ith bit from the end in reverse_int // from 0 to 1, if ith bit from beginning in n is 1 // This is achieved by using bitwise OR on // reverse_int (where ith bit from end is currently // 0) and 1 shifted left 31 - i bits (to ith bit from // the end) } return reverse_int ; }",
    "resources/C/leetcode/src/953.c@isWordLess": "bool isWordLess ( char * word1 , char * word2 , int * charOrder ) { int word1Length = strlen ( word1 ) ; int word2Length = strlen ( word2 ) ; for ( int i = 0 ; i < min ( word1Length , word2Length ) ; i ++ ) { int charWordsDiff = ( charOrder [ word1 [ i ] - 'a' ] - charOrder [ word2 [ i ] - 'a' ] ) ; if ( charWordsDiff < 0 ) { return true ; } if ( charWordsDiff > 0 ) { return false ; } } return word1Length <= word2Length ; }",
    "resources/C/leetcode/src/953.c@isAlienSorted": "bool isAlienSorted ( char * * words , int wordsSize , char * order ) { const int lowerCaseLettersNumber = 26 ; int charorder [ lowerCaseLettersNumber ] ; for ( int i = 0 ; i < lowerCaseLettersNumber ; i ++ ) { charorder [ order [ i ] - 'a' ] = i ; } for ( int i = 0 ; i < wordsSize - 1 ; i ++ ) { if ( ! isWordLess ( words [ i ] , words [ i + 1 ] , charorder ) ) { return false ; } } return true ; }",
    "resources/C/leetcode/src/938.c@rangeSumBST": "int rangeSumBST ( struct TreeNode * root , int L , int R ) { if ( root == NULL ) { return 0 ; } else if ( root -> val >= L && root -> val <= R ) { return root -> val + rangeSumBST ( root -> left , L , R ) + rangeSumBST ( root -> right , L , R ) ; } else { return rangeSumBST ( root -> left , L , R ) + rangeSumBST ( root -> right , L , R ) ; } }",
    "resources/C/leetcode/src/173.c@TraverseAndAssign": "void TraverseAndAssign ( struct TreeNode * root , BSTIterator * obj ) { if ( ! root ) return ; if ( root -> left ) TraverseAndAssign ( root -> left , obj ) ; obj -> values [ obj -> CurrentIndex ] = root -> val ; obj -> CurrentIndex ++ ; if ( root -> right ) TraverseAndAssign ( root -> right , obj ) ; }",
    "resources/C/leetcode/src/173.c@TotalNodes": "int TotalNodes ( struct TreeNode * root ) { if ( ! root ) return 0 ; int nodes_left = TotalNodes ( root -> left ) ; int nodes_right = TotalNodes ( root -> right ) ; return nodes_left + nodes_right + 1 ; }",
    "resources/C/leetcode/src/173.c@bSTIteratorCreate": "BSTIterator * bSTIteratorCreate ( struct TreeNode * root ) { int n = TotalNodes ( root ) ; int size = n + 1 ; printf ( \"%d\" , size ) ; BSTIterator * obj = ( BSTIterator * ) malloc ( sizeof ( BSTIterator ) ) ; obj -> values = ( int * ) calloc ( size , sizeof ( int ) ) ; obj -> CurrentIndex = 0 ; obj -> NumberOfNodes = n ; obj -> values [ size - 1 ] = INT_MAX ; TraverseAndAssign ( root , obj ) ; obj -> CurrentIndex = 0 ; return obj ; }",
    "resources/C/leetcode/src/173.c@bSTIteratorNext": "int bSTIteratorNext ( BSTIterator * obj ) { int NextValue = obj -> values [ obj -> CurrentIndex ] ; obj -> CurrentIndex ++ ; return NextValue ; }",
    "resources/C/leetcode/src/173.c@bSTIteratorHasNext": "bool bSTIteratorHasNext ( BSTIterator * obj ) { if ( ! obj -> NumberOfNodes ) { return false ; } printf ( \" Here \" ) ; return ( obj -> values [ obj -> CurrentIndex ] == INT_MAX ) ? false : true ; }",
    "resources/C/leetcode/src/173.c@bSTIteratorFree": "void bSTIteratorFree ( BSTIterator * obj ) { free ( obj -> values ) ; free ( obj ) ; }",
    "resources/C/leetcode/src/118.c@generate": "int * * generate ( int numRows , int * returnSize , int * * returnColumnSizes ) { * returnSize = numRows ; int * * ans = ( int * * ) malloc ( numRows * sizeof ( int * ) ) ; * returnColumnSizes = ( int * ) malloc ( numRows * sizeof ( int ) ) ; for ( int i = 0 ; i < numRows ; i ++ ) { ( * returnColumnSizes ) [ i ] = i + 1 ; ans [ i ] = ( int * ) malloc ( ( i + 1 ) * sizeof ( int ) ) ; } ans [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < numRows ; i ++ ) { ans [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i ; j ++ ) { ans [ i ] [ j ] = ans [ i - 1 ] [ j - 1 ] + ans [ i - 1 ] [ j ] ; } ans [ i ] [ i ] = 1 ; } return ans ; }",
    "resources/C/leetcode/src/112.c@hasPathSum": "bool hasPathSum ( struct TreeNode * root , int sum ) { if ( root == NULL ) return 0 ; if ( ! root -> left && ! root -> right && sum - root -> val == 0 ) return 1 ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ) ; }",
    "resources/C/leetcode/src/21.c@mergeTwoLists": "struct ListNode * mergeTwoLists ( struct ListNode * l1 , struct ListNode * l2 ) { if ( ! l1 ) return l2 ; if ( ! l2 ) return l1 ; if ( l1 -> val < l2 -> val ) { l1 -> next = mergeTwoLists ( l1 -> next , l2 ) ; return l1 ; } else { l2 -> next = mergeTwoLists ( l1 , l2 -> next ) ; return l2 ; } }",
    "resources/C/leetcode/src/1704.c@isVowel": "bool isVowel ( char chr ) { switch ( chr ) { case 'a' : case 'e' : case 'i' : case 'o' : case 'u' : case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : return true ; } return false ; }",
    "resources/C/leetcode/src/1704.c@halvesAreAlike": "bool halvesAreAlike ( char * s ) { int lenS = strlen ( s ) ; int halfVowels = 0 ; int currVowels = 0 ; for ( int i = 0 ; i < lenS ; i ++ ) { if ( isVowel ( s [ i ] ) ) { currVowels ++ ; } if ( 2 * ( i + 1 ) == lenS ) { halfVowels = currVowels ; } } return 2 * halfVowels == currVowels ; }",
    "resources/C/leetcode/src/82.c@deleteDuplicates": "struct ListNode * deleteDuplicates ( struct ListNode * head ) { if ( head == NULL ) return NULL ; if ( head -> next && head -> val == head -> next -> val ) { /* Remove all duplicate numbers */ while ( head -> next && head -> val == head -> next -> val ) { head = head -> next ; } return deleteDuplicates ( head -> next ) ; } else { head -> next = deleteDuplicates ( head -> next ) ; } return head ; }",
    "resources/C/leetcode/src/2024.c@maximizeTarget": "int maximizeTarget ( char * answerKey , char targetChar , int k ) { int leftIndex = - 1 ; int result = 0 ; int currTargetChars = 0 ; int lenAnswerKey = strlen ( answerKey ) ; for ( int rightIndex = 0 ; rightIndex < lenAnswerKey ; rightIndex ++ ) { char ch = answerKey [ rightIndex ] ; if ( ch == targetChar ) { currTargetChars ++ ; } while ( rightIndex - leftIndex > currTargetChars + k ) { leftIndex ++ ; if ( answerKey [ leftIndex ] == targetChar ) { currTargetChars -- ; } } result = max ( result , rightIndex - leftIndex ) ; } return result ; }",
    "resources/C/leetcode/src/2024.c@maxConsecutiveAnswers": "int maxConsecutiveAnswers ( char * answerKey , int k ) { return max ( maximizeTarget ( answerKey , 'T' , k ) , maximizeTarget ( answerKey , 'F' , k ) ) ; }",
    "resources/C/leetcode/src/50.c@powPositive": "double powPositive ( double x , int n ) { if ( n == 1 ) { return x ; } double val = powPositive ( x , n / 2 ) ; double result = val * val ; // if n is odd if ( n & 1 > 0 ) { result *= x ; } return result ; }",
    "resources/C/leetcode/src/50.c@myPow": "double myPow ( double x , int n ) { if ( n == 0 ) { return 1 ; } const int LOWER_BOUND = - 2147483648 ; // n is the minimum int, couldn't be converted in -n because maximum is 2147483647. // this case we use (1 / pow(x, -(n + 1))) * n if ( n == LOWER_BOUND ) { return 1 / ( powPositive ( x , - ( n + 1 ) ) * x ) ; } // 1 / pow(x, -(n + 1)) if ( n < 0 ) { return 1 / powPositive ( x , - n ) ; } return powPositive ( x , n ) ; }",
    "resources/C/leetcode/src/108.c@convertBST": "struct TreeNode * convertBST ( int * nums , int left , int right ) { if ( left > right ) return NULL ; else { int mid = ( right + left ) / 2 ; struct TreeNode * new_val = malloc ( sizeof ( struct TreeNode ) ) ; new_val -> val = nums [ mid ] ; new_val -> left = convertBST ( nums , left , mid - 1 ) ; new_val -> right = convertBST ( nums , mid + 1 , right ) ; return new_val ; } }",
    "resources/C/leetcode/src/108.c@sortedArrayToBST": "struct TreeNode * sortedArrayToBST ( int * nums , int numsSize ) { if ( numsSize == 0 ) return NULL ; else return convertBST ( nums , 0 , numsSize - 1 ) ; }",
    "resources/C/leetcode/src/2501.c@longestSquareStreakDp": "int longestSquareStreakDp ( int * numsSet , int numsSetSize , int * dp , long num ) { if ( dp [ num ] != 0 ) { return dp [ num ] ; } long numSquare = num * num ; dp [ num ] = 1 ; if ( numSquare <= numsSetSize && numsSet [ numSquare ] == 1 ) { dp [ num ] += longestSquareStreakDp ( numsSet , numsSetSize , dp , numSquare ) ; } return dp [ num ] ; }",
    "resources/C/leetcode/src/2501.c@longestSquareStreak": "int longestSquareStreak ( int * nums , int numsSize ) { // Find nums maximum int numMax = 0 ; for ( int i = 0 ; i < numsSize ; i ++ ) { numMax = max ( numMax , nums [ i ] ) ; } int * numsSet = calloc ( numMax + 1 , sizeof ( int ) ) ; int * dp = calloc ( numMax + 1 , sizeof ( int ) ) ; // Init set of nums for ( int i = 0 ; i < numsSize ; i ++ ) { numsSet [ nums [ i ] ] = 1 ; } // Find result int result = - 1 ; for ( int i = 0 ; i < numsSize ; i ++ ) { long num = nums [ i ] ; long numSquare = num * num ; if ( numSquare > numMax || numsSet [ numSquare ] == 0 ) { continue ; } result = max ( result , 1 + longestSquareStreakDp ( numsSet , numMax , dp , numSquare ) ) ; } free ( dp ) ; free ( numsSet ) ; return result ; }",
    "resources/C/leetcode/src/367.c@isPerfectSquare": "bool isPerfectSquare ( int num ) { for ( long i = 1 ; i * i <= num ; i ++ ) if ( i * i == num ) return true ; return false ; }",
    "resources/C/leetcode/src/223.c@intersectionSize": "int intersectionSize ( int p11 , int p12 , int p21 , int p22 ) { if ( p11 >= p22 || p12 <= p21 ) { return 0 ; } if ( p11 < p21 ) { return min ( p12 - p21 , p22 - p21 ) ; } return min ( p22 - p11 , p12 - p11 ) ; }",
    "resources/C/leetcode/src/223.c@computeArea": "int computeArea ( int ax1 , int ay1 , int ax2 , int ay2 , int bx1 , int by1 , int bx2 , int by2 ) { int areaA = ( ay2 - ay1 ) * ( ax2 - ax1 ) ; int areaB = ( by2 - by1 ) * ( bx2 - bx1 ) ; int areaInteresection = intersectionSize ( ax1 , ax2 , bx1 , bx2 ) * intersectionSize ( ay1 , ay2 , by1 , by2 ) ; return areaA + areaB - areaInteresection ; }",
    "resources/C/leetcode/src/169.c@majorityElement": "int majorityElement ( int * nums , int numsSize ) { int count = 1 ; int majorNum = nums [ 0 ] ; for ( int i = 1 ; i < numsSize ; i ++ ) { if ( count == 0 ) { majorNum = nums [ i ] ; count ++ ; } else if ( majorNum == nums [ i ] ) count ++ ; else count -- ; } return majorNum ; }",
    "resources/C/leetcode/src/242.c@isAnagram": "bool isAnagram ( char * s , char * t ) { int n = strlen ( s ) ; int m = strlen ( t ) ; int cnt_s [ 1000 ] , cnt_t [ 1000 ] ; for ( int c = 97 ; c < 97 + 26 ; c ++ ) cnt_s [ c ] = cnt_t [ c ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) cnt_s [ s [ i ] ] ++ ; for ( int i = 0 ; i < m ; i ++ ) cnt_t [ t [ i ] ] ++ ; for ( int c = 97 ; c < 97 + 26 ; c ++ ) if ( cnt_s [ c ] != cnt_t [ c ] ) return false ; return true ; }",
    "resources/C/leetcode/src/206.c@reverseList": "struct ListNode * reverseList ( struct ListNode * head ) { struct ListNode * res = NULL ; while ( head ) { struct ListNode * pre_node = head ; head = head -> next ; pre_node -> next = res ; res = pre_node ; } return res ; }",
    "resources/C/leetcode/src/985.c@sumEvenAfterQueries": "int * sumEvenAfterQueries ( int * nums , int numsSize , int * * queries , int queriesSize , int * queriesColSize , int * returnSize ) { int summ = 0 ; int * result = malloc ( queriesSize * sizeof ( int ) ) ; * returnSize = queriesSize ; for ( int i = 0 ; i < numsSize ; i ++ ) { if ( nums [ i ] % 2 == 0 ) { summ += nums [ i ] ; } } for ( int i = 0 ; i < queriesSize ; i ++ ) { int * query = queries [ i ] ; int val = query [ 0 ] ; int index = query [ 1 ] ; // sub index value from summ if it's even if ( nums [ index ] % 2 == 0 ) { summ -= nums [ index ] ; } // modify the nums[index] value nums [ index ] += val ; // add index value from summ if it's even if ( nums [ index ] % 2 == 0 ) { summ += nums [ index ] ; } result [ i ] = summ ; } return result ; }",
    "resources/C/leetcode/src/75.c@swap": "void swap ( int * x , int * y ) { if ( x == y ) return ; * x = * x + * y ; * y = * x - * y ; * x = * x - * y ; }",
    "resources/C/leetcode/src/75.c@sortColors": "void sortColors ( int * arr , int n ) { int start = 0 , mid = 0 , end = n - 1 ; while ( mid <= end ) { if ( arr [ mid ] == 1 ) mid ++ ; else if ( arr [ mid ] == 0 ) { swap ( & arr [ mid ] , & arr [ start ] ) ; mid ++ ; start ++ ; } else { swap ( & arr [ mid ] , & arr [ end ] ) ; end -- ; } } }",
    "resources/C/leetcode/src/1.c@twoSum": "int * twoSum ( int * nums , int numsSize , int target , int * returnSize ) { int i , j ; int * ret = calloc ( 2 , sizeof ( int ) ) ; for ( i = 0 ; i < numsSize ; i ++ ) { int key = target - nums [ i ] ; for ( j = i + 1 ; j < numsSize ; j ++ ) if ( nums [ j ] == key ) { ret [ 0 ] = i ; ret [ 1 ] = j ; } } * returnSize = 2 ; return ret ; }",
    "resources/C/leetcode/src/98.c@checkIsBst": "bool checkIsBst ( struct TreeNode * node , bool leftBoundInf , int leftBound , bool rightBoundInf , int rightBound ) { return ( node == NULL ) || ( leftBoundInf || node -> val > leftBound ) && ( rightBoundInf || node -> val < rightBound ) && checkIsBst ( node -> left , leftBoundInf , leftBound , false , node -> val ) && checkIsBst ( node -> right , false , node -> val , rightBoundInf , rightBound ) ; }",
    "resources/C/leetcode/src/98.c@isValidBST": "bool isValidBST ( struct TreeNode * root ) { return checkIsBst ( root , true , INT_MIN , true , INT_MAX ) ; }",
    "resources/C/leetcode/src/14.c@findMaxConsecutiveOnes": "int findMaxConsecutiveOnes ( int * nums , int numsSize ) { int i = 0 ; int maxCount = 0 ; int count = 0 ; while ( i < numsSize ) { while ( i < numsSize && nums [ i ] != 0 ) { count ++ ; i ++ ; } if ( maxCount <= count ) { maxCount = count ; } count = 0 ; while ( i < numsSize && nums [ i ] == 0 ) { i ++ ; } } return maxCount ; }",
    "resources/C/leetcode/src/5.c@longestPalindrome": "char * longestPalindrome ( char * s ) { int si_max = 0 , ei_max = 0 , sz_max = 0 , sz , i , delta_i ; char ch , * s_longest ; if ( s [ 1 ] == '\\0' ) return s ; for ( ch = s [ 1 ] , i = 1 ; ch != '\\0' ; ch = s [ ++ i ] ) { if ( s [ i - 1 ] == ch ) { sz = 2 ; delta_i = 1 ; while ( i - 1 - delta_i >= 0 && s [ i + delta_i ] != '\\0' && s [ i - 1 - delta_i ] == s [ i + delta_i ] ) { sz += 2 ; delta_i += 1 ; } if ( sz > sz_max ) { sz_max = sz ; si_max = i - 1 - delta_i + 1 ; ei_max = i + delta_i - 1 ; } } } for ( ch = s [ 0 ] , i = 1 ; ch != '\\0' ; ch = s [ ++ i ] ) { sz = 1 ; delta_i = 1 ; while ( i - delta_i >= 0 && s [ i + delta_i ] != '\\0' && s [ i - delta_i ] == s [ i + delta_i ] ) { sz += 2 ; delta_i += 1 ; } if ( sz > sz_max ) { sz_max = sz ; si_max = i - delta_i + 1 ; ei_max = i + delta_i - 1 ; } } if ( ( s_longest = ( char * ) malloc ( sizeof ( s ) ) ) == NULL ) { return NULL ; } strncpy ( s_longest , s + si_max , sz_max ) ; s_longest [ sz_max ] = '\\0' ; return s_longest ; }",
    "resources/C/leetcode/src/10.c@matchStar": "bool matchStar ( char ch , char * s , char * p ) { do { if ( isMatch ( s , p ) ) return true ; } while ( * s != '\\0' && ( * s ++ == ch || ch == '.' ) ) ; return false ; }",
    "resources/C/leetcode/src/10.c@isMatch": "bool isMatch ( char * s , char * p ) { if ( * p == '\\0' ) return * s == '\\0' ; if ( p [ 1 ] == '*' ) return matchStar ( p [ 0 ] , s , p + 2 ) ; if ( * s != '\\0' && ( p [ 0 ] == '.' || * p == * s ) ) { return isMatch ( s + 1 , p + 1 ) ; } return false ; }",
    "resources/C/leetcode/src/142.c@detectCycle": "struct ListNode * detectCycle ( struct ListNode * head ) { if ( head == NULL || head -> next == NULL ) return NULL ; struct ListNode * slow , * fast ; slow = fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { struct ListNode * entry = head ; while ( slow != entry ) { slow = slow -> next ; entry = entry -> next ; } return entry ; } } return NULL ; }",
    "resources/C/leetcode/src/35.c@searchInsert": "int searchInsert ( int * nums , int numsSize , int target ) { int idx = numsSize - 1 ; if ( numsSize > 0 ) { if ( target > nums [ idx ] ) { return numsSize ; } return searchInsert ( nums , numsSize - 1 , target ) ; } return 0 ; }",
    "resources/C/leetcode/src/2270.c@waysToSplitArray": "int waysToSplitArray ( int * nums , int numsSize ) { long sumNums = 0 ; for ( int i = 0 ; i < numsSize ; i ++ ) { sumNums += nums [ i ] ; } long prefixSum = 0 ; int result = 0 ; for ( int i = 0 ; i < numsSize - 1 ; i ++ ) { prefixSum += nums [ i ] ; if ( prefixSum >= sumNums - prefixSum ) { result += 1 ; } } return result ; }",
    "resources/C/leetcode/src/2130.c@pairSum": "int pairSum ( struct ListNode * head ) { struct ListNode * dup = head ; int count = 0 , i = 0 , max = 0 ; while ( head != NULL ) { count ++ ; head = head -> next ; } int * arr = malloc ( count * sizeof ( int ) ) ; while ( dup != NULL ) { arr [ i ++ ] = dup -> val ; dup = dup -> next ; } for ( i = 0 ; i < count / 2 ; ++ i ) { if ( arr [ i ] + arr [ count - i - 1 ] > max ) max = arr [ i ] + arr [ count - i - 1 ] ; } return max ; }",
    "resources/C/leetcode/src/807.c@maxIncreaseKeepingSkyline": "int maxIncreaseKeepingSkyline ( int * * grid , int gridSize , int * gridColSize ) { int * rowsMaxs = calloc ( gridSize , sizeof ( int ) ) ; int * colsMaxs = calloc ( gridSize , sizeof ( int ) ) ; // Find max of each row and column for ( int i = 0 ; i < gridSize ; i ++ ) { for ( int j = 0 ; j < gridSize ; j ++ ) { rowsMaxs [ i ] = max ( rowsMaxs [ i ] , grid [ i ] [ j ] ) ; colsMaxs [ j ] = max ( colsMaxs [ j ] , grid [ i ] [ j ] ) ; } } int result = 0 ; for ( int i = 0 ; i < gridSize ; i ++ ) { for ( int j = 0 ; j < gridSize ; j ++ ) { int rowMax = rowsMaxs [ i ] ; int colMax = colsMaxs [ j ] ; result += min ( rowMax - grid [ i ] [ j ] , colMax - grid [ i ] [ j ] ) ; } } free ( rowsMaxs ) ; free ( colsMaxs ) ; return result ; }",
    "resources/C/leetcode/src/26.c@removeDuplicates": "int removeDuplicates ( int * nums , int numsSize ) { int count = 0 , i ; for ( i = 1 ; i < numsSize ; i ++ ) { if ( nums [ i ] == nums [ i - 1 ] ) count ++ ; else nums [ i - count ] = nums [ i ] ; } return numsSize - count ; }",
    "resources/C/leetcode/src/1833.c@compare": "int compare ( const void * i , const void * j ) { return * ( ( int * ) i ) - * ( ( int * ) j ) ; }",
    "resources/C/leetcode/src/1833.c@maxIceCream": "int maxIceCream ( int * costs , int costsSize , int coins ) { qsort ( costs , costsSize , sizeof ( int ) , compare ) ; int result = 0 ; int leftCoins = coins ; for ( int i = 0 ; i < costsSize ; i ++ ) { if ( costs [ i ] > leftCoins ) { break ; } leftCoins -= costs [ i ] ; result ++ ; } return result ; }",
    "resources/C/leetcode/src/931.c@minFallingPathSum": "int minFallingPathSum ( int * * matrix , int matrixSize , int * matrixColSize ) { int * dp = calloc ( matrixSize , sizeof ( int ) ) ; for ( int i = 0 ; i < matrixSize ; i ++ ) { int * nextDp = calloc ( matrixSize , sizeof ( int ) ) ; for ( int j = 0 ; j < matrixSize ; j ++ ) { nextDp [ j ] = dp [ j ] + matrix [ i ] [ j ] ; // If not the first column - try to find minimum in prev column if ( j > 0 ) { nextDp [ j ] = min ( nextDp [ j ] , dp [ j - 1 ] + matrix [ i ] [ j ] ) ; } // If not the last column - try to find minimum in next column if ( j < matrixSize - 1 ) { nextDp [ j ] = min ( nextDp [ j ] , dp [ j + 1 ] + matrix [ i ] [ j ] ) ; } } free ( dp ) ; dp = nextDp ; } int result = dp [ 0 ] ; for ( int j = 1 ; j < matrixSize ; j ++ ) { result = min ( result , dp [ j ] ) ; } free ( dp ) ; return result ; }",
    "resources/C/leetcode/src/520.c@detectCapitalUse": "bool detectCapitalUse ( char * word ) { int len = strlen ( word ) ; for ( int i = 1 ; i < len ; i ++ ) { if ( isupper ( word [ i ] ) && ! isAllUpper ( word ) ) return 0 ; } return 1 ; }",
    "resources/C/leetcode/src/520.c@isAllUpper": "bool isAllUpper ( char * word ) { int len = strlen ( word ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( islower ( word [ i ] ) ) return 0 ; } return 1 ; }",
    "resources/C/leetcode/src/234.c@reverse": "struct ListNode * reverse ( struct ListNode * head ) { struct ListNode * res = NULL ; while ( head ) { struct ListNode * pre_node = head ; head = head -> next ; pre_node -> next = res ; res = pre_node ; } return res ; }",
    "resources/C/leetcode/src/234.c@isPalindrome": "bool isPalindrome ( struct ListNode * head ) { struct ListNode * slow = head ; struct ListNode * fast = head ; struct ListNode * last ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast != NULL ) slow = slow -> next ; last = reverse ( slow ) ; while ( last ) { if ( head -> val != last -> val ) return 0 ; head = head -> next ; last = last -> next ; } return 1 ; }",
    "resources/C/leetcode/src/701.c@insertIntoBST": "struct TreeNode * insertIntoBST ( struct TreeNode * root , int val ) { if ( root == NULL ) { struct TreeNode * new_val = malloc ( sizeof ( struct TreeNode ) ) ; new_val -> val = val ; new_val -> left = new_val -> right = NULL ; return new_val ; } else { if ( root -> val >= val ) root -> left = insertIntoBST ( root -> left , val ) ; else root -> right = insertIntoBST ( root -> right , val ) ; } return root ; }",
    "resources/C/leetcode/src/62.c@uniquePaths": "int uniquePaths ( int m , int n ) { int dp [ m ] [ n ] ; for ( int column = 0 ; column < n ; column ++ ) { dp [ 0 ] [ column ] = 1 ; } for ( int row = 1 ; row < m ; row ++ ) { dp [ row ] [ 0 ] = 1 ; } for ( int row = 1 ; row < m ; row ++ ) { for ( int column = 1 ; column < n ; column ++ ) { dp [ row ] [ column ] = dp [ row - 1 ] [ column ] + dp [ row ] [ column - 1 ] ; } } return dp [ m - 1 ] [ n - 1 ] ; }",
    "resources/C/leetcode/src/215.c@cmpval": "int * cmpval ( const void * a , const void * b ) { return * ( int * ) b - * ( int * ) a ; }",
    "resources/C/leetcode/src/215.c@findKthLargest": "int findKthLargest ( int * nums , int numsSize , int k ) { qsort ( nums , numsSize , sizeof ( int ) , cmpval ) ; return nums [ k - 1 ] ; }",
    "resources/C/leetcode/src/66.c@plusOne": "int * plusOne ( int * digits , int digitsSize , int * returnSize ) { for ( int i = digitsSize - 1 ; i >= 0 ; i -- ) { if ( digits [ i ] < 9 ) { digits [ i ] ++ ; * returnSize = digitsSize ; return digits ; } else { digits [ i ] = 0 ; } } int * newdigit = ( int * ) malloc ( ( digitsSize + 1 ) * sizeof ( int ) ) ; newdigit [ 0 ] = 1 ; for ( int i = 1 ; i < ( digitsSize + 1 ) ; i ++ ) { newdigit [ i ] = digits [ i - 1 ] ; } * returnSize = digitsSize + 1 ; return newdigit ; }",
    "resources/C/leetcode/src/274.c@diff": "int diff ( const int * i , const int * j ) { return * i - * j ; }",
    "resources/C/leetcode/src/274.c@hIndex": "int hIndex ( int * citations , int citationsSize ) { qsort ( citations , citationsSize , sizeof ( int ) , ( int ( * ) ( const void * , const void * ) ) diff ) ; for ( int i = 0 ; i < citationsSize ; i ++ ) { if ( citations [ citationsSize - 1 - i ] <= i ) { return i ; } } return citationsSize ; }",
    "resources/C/leetcode/src/28.c@strStr": "int strStr ( char * haystack , char * needle ) { int i = 0 ; /* index for haystack */ int j = 0 ; /* index for needle */ int len_needle = strlen ( needle ) ; int len_haystack = strlen ( haystack ) ; if ( ! len_needle ) return 0 ; int overlap [ len_needle ] ; fill_overlap ( needle , len_needle , overlap ) ; while ( i < len_haystack ) { if ( needle [ j ] == haystack [ i ] ) { i ++ ; j ++ ; } if ( j == len_needle ) { return ( i - j ) ; } else if ( i < len_haystack && needle [ j ] != haystack [ i ] ) { if ( j != 0 ) j = overlap [ j - 1 ] ; else i = i + 1 ; } } return - 1 ; }",
    "resources/C/leetcode/src/28.c@fill_overlap": "void fill_overlap ( char * needle , int len_needle , int * overlap ) { int len = 0 ; int i = 0 ; overlap [ 0 ] = 0 ; for ( i = 1 ; i < len_needle ; ) { if ( needle [ i ] == needle [ len ] ) { len ++ ; overlap [ i ++ ] = len ; } else { if ( len ) len = overlap [ len - 1 ] ; else overlap [ i ++ ] = 0 ; } } }",
    "resources/C/leetcode/src/1019.c@nextLargerNodes": "int * nextLargerNodes ( struct ListNode * head , int * returnSize ) { int * output , count = 0 ; struct ListNode * tmp = head , * tmp2 ; for ( ; tmp != NULL ; tmp = tmp -> next , count ++ ) ; output = ( int * ) calloc ( count , sizeof ( int ) ) ; * returnSize = count ; for ( tmp = head , count = 0 ; tmp -> next != NULL ; tmp = tmp -> next , count ++ ) { for ( tmp2 = tmp -> next ; tmp2 != NULL ; tmp2 = tmp2 -> next ) { if ( tmp2 -> val > tmp -> val ) { output [ count ] = tmp2 -> val ; break ; } } } return output ; }",
    "resources/C/leetcode/src/230.c@findKthSmallest": "struct TreeNode * findKthSmallest ( struct TreeNode * node , int * k ) { if ( node == NULL ) { return NULL ; } struct TreeNode * resultNode = findKthSmallest ( node -> left , k ) ; if ( resultNode != NULL ) { return resultNode ; } * k -= 1 ; if ( * k == 0 ) { return node ; } return findKthSmallest ( node -> right , k ) ; }",
    "resources/C/leetcode/src/230.c@kthSmallest": "int kthSmallest ( struct TreeNode * root , int k ) { return findKthSmallest ( root , & k ) -> val ; }",
    "resources/C/leetcode/src/8.c@myAtoi": "int myAtoi ( char * str ) { int minusFlag = 0 ; int length = strlen ( str ) ; long int result = 0 ; char numberBuffer [ 11 ] ; int counter = 0 ; while ( str [ counter ] == ' ' ) { counter ++ ; } str = & str [ counter ] ; counter = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i == 0 ) { if ( str [ 0 ] == '-' ) { minusFlag = 1 ; i ++ ; } else if ( str [ 0 ] == '+' ) { i ++ ; } } if ( counter > 10 ) { if ( minusFlag ) { return __INT_MAX__ * - 1 - 1 ; } else { return __INT_MAX__ ; } } if ( str [ i ] < '0' || str [ i ] > '9' ) { break ; } if ( counter == 0 && str [ i ] == '0' ) { continue ; } numberBuffer [ counter ] = str [ i ] ; counter ++ ; } int i = 0 ; while ( counter > 0 ) { if ( minusFlag ) { result -= ( numberBuffer [ i ] - '0' ) * pow ( 10.0 , counter - 1 ) ; } else { result += ( numberBuffer [ i ] - '0' ) * pow ( 10.0 , counter - 1 ) ; } i ++ ; counter -- ; } if ( result > __INT_MAX__ ) { return __INT_MAX__ ; } else if ( result < __INT_MAX__ * - 1 - 1 ) { return __INT_MAX__ * - 1 - 1 ; } return result ; }",
    "resources/C/leetcode/src/2.c@addTwoNumbers": "struct ListNode * addTwoNumbers ( struct ListNode * l1 , struct ListNode * l2 ) { struct ListNode * head = NULL ; struct ListNode * walk = NULL ; struct ListNode * tmp = NULL ; int carry = 0 ; int val1 = 0 ; int val2 = 0 ; int val = 0 ; while ( l1 != NULL || l2 != NULL || carry ) { val1 = 0 ; val2 = 0 ; val = 0 ; if ( l1 ) { val1 = l1 -> val ; l1 = l1 -> next ; } if ( l2 ) { val2 = l2 -> val ; l2 = l2 -> next ; } val = carry + val1 + val2 ; carry = val / 10 ; tmp = malloc ( sizeof ( struct ListNode ) ) ; tmp -> val = val % 10 ; tmp -> next = NULL ; if ( ! head ) { head = walk = tmp ; } else { walk -> next = tmp ; walk = walk -> next ; } } return head ; }",
    "resources/C/leetcode/src/124.c@recursiveSolve": "int recursiveSolve ( struct TreeNode * node , int * result ) { if ( node == NULL ) { return 0 ; } int leftSum = max ( recursiveSolve ( node -> left , result ) , 0 ) ; int rightSum = max ( recursiveSolve ( node -> right , result ) , 0 ) ; // Check if it's possible to make a maximum path from left right and current node int maxValueNode = node -> val + leftSum + rightSum ; * result = max ( maxValueNode , * result ) ; // Choose the max sum val path  return node -> val + max ( leftSum , rightSum ) ; }",
    "resources/C/leetcode/src/124.c@maxPathSum": "int maxPathSum ( struct TreeNode * root ) { const int LOWER_BOUND = - 2147483648 int result = LOWER_BOUND ; recursiveSolve ( root , & result ) ; return result ; }",
    "resources/C/leetcode/src/17.c@get_letters": "char * get_letters ( char digit ) { switch ( digit ) { case '2' : return \"abc\" ; case '3' : return \"def\" ; case '4' : return \"ghi\" ; case '5' : return \"jkl\" ; case '6' : return \"mno\" ; case '7' : return \"pqrs\" ; case '8' : return \"tuv\" ; case '9' : return \"wxyz\" ; default : return \"\" ; } }",
    "resources/C/leetcode/src/17.c@letterCombinations": "char * * letterCombinations ( char * digits , int * return_size ) { char * cp ; int i , j , k , l , ind , k_tot , l_tot , digits_size = 0 ; if ( * digits == '\\0' ) { * return_size = 0 ; return NULL ; } * return_size = 1 ; cp = digits ; while ( * cp != '\\0' ) { * return_size *= strlen ( get_letters ( * cp ) ) ; digits_size ++ ; cp ++ ; } char * * combs = malloc ( sizeof ( char * ) * ( * return_size ) ) ; for ( i = 0 ; i < * return_size ; i ++ ) { combs [ i ] = malloc ( sizeof ( char ) * ( digits_size + 1 ) ) ; combs [ i ] [ digits_size ] = '\\0' ; } k_tot = 1 ; l_tot = ( * return_size ) ; for ( i = 0 ; i < digits_size ; i ++ ) { // loop accross digits cp = get_letters ( digits [ i ] ) ; l_tot /= strlen ( cp ) ; for ( j = 0 ; j < strlen ( cp ) ; j ++ ) { // loop accross letters of the digit for ( k = 0 ; k < k_tot ; k ++ ) { // loop across the subset starting positions for each letter for ( l = 0 ; l < l_tot ; l ++ ) { // loop accross each subset positions for each letter ind = k * l_tot * strlen ( cp ) + l + l_tot * j ; combs [ ind ] [ i ] = cp [ j ] ; } } } k_tot *= strlen ( cp ) ; } return combs ; }",
    "resources/C/leetcode/src/434.c@countSegments": "int countSegments ( char * s ) { int sLen = strlen ( s ) ; int prevSpace = 1 ; int result = 0 ; char currChar ; for ( int i = 0 ; i < sLen ; i ++ ) { currChar = s [ i ] ; //A string of whitespaces will only be counted once as the condition below is only true when we transition from whitespace to non-whitespace. //Since we start with assumed whitespace (prevSpace = 1), initial whitespaces are handled as well, if any if ( s [ i ] != ' ' && prevSpace ) { result ++ ; } prevSpace = ( currChar == ' ' ) ; } return result ; }",
    "resources/C/leetcode/src/1026.c@recursiveSolve": "void recursiveSolve ( struct TreeNode * node , int * result , int minVal , int maxVal ) { if ( node == NULL ) { return ; } * result = max ( * result , abs ( minVal - node -> val ) ) ; * result = max ( * result , abs ( maxVal - node -> val ) ) ; minVal = min ( minVal , node -> val ) ; maxVal = max ( maxVal , node -> val ) ; recursiveSolve ( node -> left , result , minVal , maxVal ) ; recursiveSolve ( node -> right , result , minVal , maxVal ) ; }",
    "resources/C/leetcode/src/1026.c@maxAncestorDiff": "int maxAncestorDiff ( struct TreeNode * root ) { int result = 0 ; int maxVal = root -> val ; int minVal = root -> val ; recursiveSolve ( root , & result , minVal , maxVal ) ; return result ; }",
    "resources/C/leetcode/src/283.c@moveZeroes": "void moveZeroes ( int * nums , int numsSize ) { int i = 0 , start = 0 ; for ( i = 0 ; i < numsSize ; i ++ ) { if ( nums [ i ] ) nums [ start ++ ] = nums [ i ] ; } for ( start ; start < numsSize ; start ++ ) { nums [ start ] = 0 ; } }",
    "resources/C/leetcode/src/38.c@countAndSay": "char * countAndSay ( int n ) { // Calculating the length of array double result = 1.0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { result *= 1.4 ; } int k , j , count , convert = ( int ) result ; // Creating array with the length calculated above char * arr = malloc ( convert + 4 ) ; arr [ 0 ] = '1' ; arr [ 1 ] = '\\0' ; for ( int i = 2 , length ; i <= n ; i ++ ) { length = strlen ( arr ) ; char newArr [ length * 2 ] ; strcpy ( newArr , arr ) ; k = 0 ; j = 0 ; count = 1 ; while ( newArr [ j ] != '\\0' ) { if ( newArr [ j ] == newArr [ j + 1 ] ) { count ++ ; j ++ ; } else { arr [ k ] = ( 48 + count ) ; arr [ k + 1 ] = newArr [ j ] ; arr [ k + 2 ] = '\\0' ; j ++ ; k += 2 ; count = 1 ; } } } return arr ; }",
    "resources/C/leetcode/src/1009.c@bitwiseComplement": "int bitwiseComplement ( int n ) { if ( n == 0 ) { return 1 ; } int binary_number_length = ceil ( log2 ( n ) ) ; return ( ~ n ) & ( ( 1 << binary_number_length ) - 1 ) ; }",
    "resources/C/leetcode/src/53.c@maxcmp": "int maxcmp ( int a , int b ) { return a >= b ? a : b ; }",
    "resources/C/leetcode/src/53.c@maxSubArray": "int maxSubArray ( int * nums , int numsSize ) { int maxSoFar = nums [ 0 ] , maxEndingHere = nums [ 0 ] ; for ( int i = 1 ; i < numsSize ; i ++ ) { maxEndingHere = maxcmp ( maxEndingHere + nums [ i ] , nums [ i ] ) ; maxSoFar = maxcmp ( maxSoFar , maxEndingHere ) ; } return maxSoFar ; }",
    "resources/C/leetcode/src/160.c@getIntersectionNode": "struct ListNode * getIntersectionNode ( struct ListNode * headA , struct ListNode * headB ) { struct ListNode * cur1 = headA , * cur2 = headB ; if ( cur1 == NULL || cur2 == NULL ) return NULL ; while ( cur1 && cur2 && cur1 != cur2 ) { cur1 = cur1 -> next ; cur2 = cur2 -> next ; if ( cur1 == cur2 ) return cur1 ; if ( ! cur1 ) cur1 = headB ; if ( ! cur2 ) cur2 = headA ; } return cur1 ; }",
    "resources/C/leetcode/src/674.c@findLengthOfLCIS": "int findLengthOfLCIS ( int * nums , int numsSize ) { int maxval = 1 , i , count = 1 ; if ( numsSize == 0 ) return 0 ; for ( i = 1 ; i < numsSize ; i ++ ) { if ( nums [ i ] > nums [ i - 1 ] ) { count ++ ; if ( count >= maxval ) maxval = count ; } else { count = 1 ; } } return maxval ; }",
    "resources/C/leetcode/src/1147.c@equalSubstrings": "bool equalSubstrings ( char * text , int firstIndex , int secondIndex , int length ) { for ( int i = 0 ; i < length ; i ++ ) { if ( text [ firstIndex + i ] != text [ secondIndex + i ] ) { return false ; } } return true ; }",
    "resources/C/leetcode/src/1147.c@longestDecompositionDpCached": "int longestDecompositionDpCached ( char * text , int textLen , int index , int * dp ) { if ( 2 * index >= textLen ) { return 0 ; } if ( dp [ index ] == 0 ) { dp [ index ] = longestDecompositionDp ( text , textLen , index , dp ) ; } return dp [ index ] ; }",
    "resources/C/leetcode/src/1147.c@longestDecompositionDp": "int longestDecompositionDp ( char * text , int textLen , int index , int * dp ) { char ch = text [ index ] ; int result = 1 ; for ( int i = 0 ; i < ( textLen - 2 * index ) / 2 ; i ++ ) { if ( ch == text [ textLen - 1 - index - i ] && equalSubstrings ( text , index , textLen - 1 - index - i , i + 1 ) ) { return max ( result , 2 + longestDecompositionDpCached ( text , textLen , index + i + 1 , dp ) ) ; } } return result ; }",
    "resources/C/leetcode/src/1147.c@longestDecomposition": "int longestDecomposition ( char * text ) { int textLen = strlen ( text ) ; int * dp = calloc ( textLen , sizeof ( int ) ) ; int result = longestDecompositionDpCached ( text , textLen , 0 , dp ) ; free ( dp ) ; return result ; }",
    "resources/C/leetcode/src/101.c@checkSymmetric": "bool checkSymmetric ( struct TreeNode * left , struct TreeNode * right ) { if ( ! left || ! right ) return left == right ; if ( left -> val != right -> val ) return 0 ; return checkSymmetric ( left -> left , right -> right ) && checkSymmetric ( left -> right , right -> left ) ; }",
    "resources/C/leetcode/src/101.c@isSymmetric": "bool isSymmetric ( struct TreeNode * root ) { return root == NULL || checkSymmetric ( root -> left , root -> right ) ; }",
    "resources/C/leetcode/src/32.c@getEndValidIndexFromDp": "int getEndValidIndexFromDp ( int * dp , char * s , int index , int lenS ) { if ( index >= lenS ) { return notValid ; } if ( dp [ index ] == notCalculated ) { dp [ index ] = getEndValidIndex ( dp , s , index , lenS ) ; } return dp [ index ] ; }",
    "resources/C/leetcode/src/32.c@getEndValidIndex": "int getEndValidIndex ( int * dp , char * s , int index , int lenS ) { if ( s [ index ] == '(' ) { if ( index + 1 >= lenS ) { return notValid ; } if ( s [ index + 1 ] == ')' ) { return max ( index + 1 , getEndValidIndexFromDp ( dp , s , index + 2 , lenS ) ) ; } int nextEndValidIndex = getEndValidIndexFromDp ( dp , s , index + 1 , lenS ) ; if ( nextEndValidIndex == notValid || nextEndValidIndex + 1 >= lenS || s [ nextEndValidIndex + 1 ] != ')' ) { return notValid ; } return max ( nextEndValidIndex + 1 , getEndValidIndexFromDp ( dp , s , nextEndValidIndex + 2 , lenS ) ) ; } return notValid ; }",
    "resources/C/leetcode/src/32.c@longestValidParentheses": "int longestValidParentheses ( char * s ) { int lenS = strlen ( s ) ; if ( lenS == 0 ) { return 0 ; } int * dp = malloc ( lenS * sizeof ( int ) ) ; for ( int i = 0 ; i < lenS ; i ++ ) { dp [ i ] = notCalculated ; } int result = 0 ; for ( int i = 0 ; i < lenS ; i ++ ) { result = max ( result , getEndValidIndexFromDp ( dp , s , i , lenS ) - i + 1 ) ; } free ( dp ) ; return result ; }",
    "resources/C/leetcode/src/389.c@findTheDifference": "char findTheDifference ( char * s , char * t ) { int sum1 = 0 , sum2 = 0 ; int i ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) sum1 += s [ i ] ; for ( i = 0 ; i < strlen ( t ) ; i ++ ) sum2 += t [ i ] ; return ( char ) ( sum2 - sum1 ) ; }",
    "resources/C/leetcode/src/1207.c@cmpvalue": "int cmpvalue ( const void * a , const void * b ) { return * ( int * ) b - * ( int * ) a ; }",
    "resources/C/leetcode/src/1207.c@uniqueOccurrences": "bool uniqueOccurrences ( int * arr , int arrSize ) { int * map = calloc ( MAP_SIZE , sizeof ( int ) ) ; int i ; for ( i = 0 ; i < arrSize ; i ++ ) { if ( arr [ i ] < 0 ) map [ arr [ i ] + MAP_SIZE / 2 ] += 1 ; else map [ arr [ i ] ] += 1 ; } /* number of occurrences is sorted by decreasing order\n       Ex: 3 2 1 0 0 0 0 */ qsort ( map , MAP_SIZE , sizeof ( int ) , cmpvalue ) ; i = 0 ; while ( map [ i ] ) { if ( map [ i ] == map [ i + 1 ] ) return 0 ; i ++ ; } return 1 ; }",
    "resources/C/leetcode/src/1653.c@minimumDeletions": "int minimumDeletions ( char * s ) { int len = strlen ( s ) ; int aStateValue = s [ 0 ] == 'b' ; int bStateValue = 0 ; int newAStateValue ; int newBStateValue ; for ( int i = 1 ; i < len ; i ++ ) { newAStateValue = aStateValue + ( s [ i ] == 'b' ) ; newBStateValue = min ( aStateValue , bStateValue + ( s [ i ] == 'a' ) ) ; aStateValue = newAStateValue ; bStateValue = newBStateValue ; } return min ( aStateValue , bStateValue ) ; }",
    "resources/C/leetcode/src/189.c@rotate": "void rotate ( int * nums , int numsSize , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int j ; int lastElement ; lastElement = nums [ numsSize - 1 ] ; for ( j = numsSize - 1 ; j > 0 ; j -- ) { nums [ j ] = nums [ j - 1 ] ; } nums [ 0 ] = lastElement ; } }",
    "resources/C/leetcode/src/1657.c@charsCount": "int * charsCount ( char * word ) { int * result = calloc ( charLength , sizeof ( int ) ) ; int wordLen = strlen ( word ) ; for ( int i = 0 ; i < wordLen ; i ++ ) { result [ word [ i ] - 'a' ] ++ ; } return result ; }",
    "resources/C/leetcode/src/1657.c@diff": "int diff ( const int * i , const int * j ) { return * i - * j ; }",
    "resources/C/leetcode/src/1657.c@closeStrings": "bool closeStrings ( char * word1 , char * word2 ) { int * word1CharsCounter = charsCount ( word1 ) ; int * word2CharsCounter = charsCount ( word2 ) ; // The lengths of both string should be equal if ( strlen ( word1 ) != strlen ( word2 ) ) { return false ; } // The char should appear in both strings for ( int i = 0 ; i < charLength ; i ++ ) { if ( ( word1CharsCounter [ i ] != 0 && word2CharsCounter [ i ] == 0 ) || ( word1CharsCounter [ i ] == 0 && word2CharsCounter [ i ] != 0 ) ) { return false ; } } qsort ( word1CharsCounter , charLength , sizeof ( int ) , ( int ( * ) ( const void * , const void * ) ) diff ) ; qsort ( word2CharsCounter , charLength , sizeof ( int ) , ( int ( * ) ( const void * , const void * ) ) diff ) ; // appearing of chars should be the same in both strings. for ( int i = 0 ; i < charLength ; i ++ ) { if ( word1CharsCounter [ i ] != word2CharsCounter [ i ] ) { return false ; } } free ( word1CharsCounter ) ; free ( word2CharsCounter ) ; return true ; }",
    "resources/C/leetcode/src/2279.c@compare": "int compare ( const int * i , const int * j ) { return * i - * j ; }",
    "resources/C/leetcode/src/2279.c@maximumBags": "int maximumBags ( int * capacity , int capacitySize , int * rocks , int rocksSize , int additionalRocks ) { int * capacityLeft = malloc ( capacitySize * sizeof ( int ) ) ; for ( int i = 0 ; i < capacitySize ; i ++ ) { capacityLeft [ i ] = capacity [ i ] - rocks [ i ] ; } qsort ( capacityLeft , capacitySize , sizeof ( int ) , ( int ( * ) ( const void * , const void * ) ) compare ) ; int bags = 0 ; for ( int i = 0 ; i < capacitySize ; i ++ ) { if ( additionalRocks < capacityLeft [ i ] ) { break ; } additionalRocks -= capacityLeft [ i ] ; bags ++ ; } free ( capacityLeft ) ; return bags ; }",
    "resources/C/leetcode/src/387.c@firstUniqChar": "int firstUniqChar ( char * s ) { int * arr = calloc ( 256 , sizeof ( int ) ) ; int i ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) arr [ s [ i ] ] = arr [ s [ i ] ] + 1 ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { if ( arr [ s [ i ] ] == 1 ) return i ; } return - 1 ; }",
    "resources/C/leetcode/src/6.c@convert": "char * convert ( char * in , uint16_t numRows ) { uint16_t len = strlen ( in ) ; if ( len < numRows ) { numRows = len ; } char * out = calloc ( len + 1 , sizeof ( char ) ) ; if ( numRows < 2 ) { memcpy ( out , in , len + 1 ) ; return out ; } uint16_t max = numRows - 1 ; uint16_t rr = 2 * max ; uint16_t i = 0 ; uint16_t o = 0 ; uint16_t delta = 0 ; // first row while ( i < len ) { out [ o ++ ] = in [ i ] ; i += rr ; } // middle rows for ( uint16_t l = 1 ; l < max ; l ++ ) { i = l ; delta = 2 * l ; while ( i < len ) { out [ o ++ ] = in [ i ] ; delta = rr - delta ; i += delta ; } } // last row i = max ; while ( i < len ) { out [ o ++ ] = in [ i ] ; i += rr ; } return out ; }",
    "resources/C/leetcode/src/6.c@testZigZag": "static void testZigZag ( char * s , int numRows , char * expected ) { char * ret = convert ( s , numRows ) ; int len = strlen ( s ) ; int cmp = strncmp ( ret , expected , len ) ; assert ( ! cmp ) ; free ( ret ) ; }",
    "resources/C/leetcode/src/6.c@test": "static void test ( ) { char * s01 = \"PAYPALISHIRING\" ; char * r01 = \"PINALSIGYAHRPI\" ; testZigZag ( s01 , 4 , r01 ) ; char * r02 = \"PAHNAPLSIIGYIR\" ; testZigZag ( s01 , 3 , r02 ) ; char * s03 = \"A\" ; testZigZag ( s03 , 1 , s03 ) ; testZigZag ( s03 , 3 , s03 ) ; char * s04 = \"cbxdwjccgtdoqiscyspqzvuqivzptlpvooynyapgvswoaosaghrffnxnjyeeltzaiznicc\" \"ozwknwyhzgpqlwfkjqipuu\" \"jvwtxlbznryjdohbvghmyuiggtyqjtmuqinntqmihntkddnalwnmsxsatqqeldacnnpjfe\" \"rmrnyuqnwbjjpdjhdeavkn\" \"ykpoxhxclqqedqavdwzoiorrwwxyrhlsrdgqkduvtmzzczufvtvfioygkvedervvudnegh\" \"bctcbxdxezrzgbpfhzanff\" \"eccbgqfmzjqtlrsppxqiywjobspefujlxnmddurddiyobqfspvcoulcvdrzkmkwlyiqdch\" \"ghrgytzdnobqcvdeqjystm\" \"epxcaniewqmoxkjwpymqorluxedvywhcoghotpusfgiestckrpaigocfufbubiyrrffmwa\" \"eeimidfnnzcphkflpbqsvt\" \"dwludsgaungfzoihbxifoprwcjzsdxngtacw\" ; char * r04 = \"cbxdwjccgtdoqiscyspqzvuqivzptlpvooynyapgvswoaosaghrffnxnjyeeltzaiznicc\" \"ozwknwyhzgpqlwfkjqipuu\" \"jvwtxlbznryjdohbvghmyuiggtyqjtmuqinntqmihntkddnalwnmsxsatqqeldacnnpjfe\" \"rmrnyuqnwbjjpdjhdeavkn\" \"ykpoxhxclqqedqavdwzoiorrwwxyrhlsrdgqkduvtmzzczufvtvfioygkvedervvudnegh\" \"bctcbxdxezrzgbpfhzanff\" \"eccbgqfmzjqtlrsppxqiywjobspefujlxnmddurddiyobqfspvcoulcvdrzkmkwlyiqdch\" \"ghrgytzdnobqcvdeqjystm\" \"epxcaniewqmoxkjwpymqorluxedvywhcoghotpusfgiestckrpaigocfufbubiyrrffmwa\" \"eeimidfnnzwccpahtkgfnl\" \"xpdbsqzsjvctwdrwploufdisxgbahuinogzf\" ; testZigZag ( s04 , 472 , r04 ) ; }",
    "resources/C/leetcode/src/6.c@main": "int main ( void ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/leetcode/src/287.c@cmpval": "int cmpval ( const void * a , const void * b ) { return * ( int * ) a - * ( int * ) b ; }",
    "resources/C/leetcode/src/287.c@findDuplicate": "int findDuplicate ( int * nums , int numsSize ) { int i ; qsort ( nums , numsSize , sizeof ( int ) , cmpval ) ; for ( i = 0 ; i < numsSize - 1 ; i ++ ) { if ( nums [ i ] == nums [ i + 1 ] ) return nums [ i ] ; } return nums [ i ] ; }",
    "resources/C/leetcode/src/2256.c@minimumAverageDifference": "int minimumAverageDifference ( int * nums , int numsSize ) { long numsSum = 0 ; for ( int i = 0 ; i < numsSize ; i ++ ) { numsSum += nums [ i ] ; } long currSum = 0 ; long minAverage = 9223372036854775807 ; // Long max int minIndex = 0 ; for ( int i = 0 ; i < numsSize ; i ++ ) { currSum += nums [ i ] ; int leftItemsNumber = ( numsSize - i - 1 ) ; long leftItemsNumberAverage = 0 ; if ( leftItemsNumber != 0 ) { leftItemsNumberAverage = ( numsSum - currSum ) / leftItemsNumber ; } long currItemsNumberAverage = currSum / ( i + 1 ) ; long averageDiff = abs ( currItemsNumberAverage - leftItemsNumberAverage ) ; if ( averageDiff < minAverage ) { minAverage = averageDiff ; minIndex = i ; } } return minIndex ; }",
    "resources/C/leetcode/src/1695.c@maximumUniqueSubarray": "int maximumUniqueSubarray ( int * nums , int numsSize ) { short * numsSet = ( short * ) calloc ( 10001 , sizeof ( short ) ) ; numsSet [ nums [ 0 ] ] = 1 ; int maxSum = nums [ 0 ] ; int windowSumm = maxSum ; int leftIndex = 0 ; int num = 0 ; for ( int i = 1 ; i < numsSize ; i ++ ) { num = nums [ i ] ; while ( numsSet [ num ] != 0 ) { numsSet [ nums [ leftIndex ] ] = 0 ; windowSumm -= nums [ leftIndex ] ; leftIndex ++ ; } numsSet [ num ] = 1 ; windowSumm += num ; if ( maxSum < windowSumm ) { maxSum = windowSumm ; } } return maxSum ; }",
    "resources/C/leetcode/src/13.c@romanToInt": "int romanToInt ( char * s ) { int romanToInt = 0 ; for ( int i = 0 ; i < strlen ( s ) ; i ++ ) { switch ( s [ i ] ) { case 'I' : if ( i + 1 < strlen ( s ) ) { if ( s [ i + 1 ] == 'V' || s [ i + 1 ] == 'X' ) { romanToInt -= 1 ; break ; } } romanToInt += 1 ; break ; case 'V' : romanToInt += 5 ; break ; case 'X' : if ( i + 1 < strlen ( s ) ) { if ( s [ i + 1 ] == 'L' || s [ i + 1 ] == 'C' ) { romanToInt -= 10 ; break ; } } romanToInt += 10 ; break ; case 'L' : romanToInt += 50 ; break ; case 'C' : if ( i + 1 < strlen ( s ) ) { if ( s [ i + 1 ] == 'D' || s [ i + 1 ] == 'M' ) { romanToInt -= 100 ; break ; } } romanToInt += 100 ; break ; case 'D' : romanToInt += 500 ; break ; case 'M' : romanToInt += 1000 ; break ; default : break ; } } return romanToInt ; }",
    "resources/C/leetcode/src/965.c@isUnivalTree": "bool isUnivalTree ( struct TreeNode * root ) { if ( root == NULL ) return 1 ; if ( root -> left ) { if ( root -> left -> val != root -> val ) return 0 ; } if ( root -> right ) { if ( root -> right -> val != root -> val ) return 0 ; } return isUnivalTree ( root -> left ) && isUnivalTree ( root -> right ) ; }",
    "resources/C/leetcode/src/201.c@rangeBitwiseAnd": "int rangeBitwiseAnd ( int m , int n ) { while ( m < n ) { n &= n - 1 ; } return n ; }",
    "resources/C/leetcode/src/19.c@removeNthFromEnd": "struct ListNode * removeNthFromEnd ( struct ListNode * head , int n ) { struct ListNode entry , * p_free , * p = head ; int i , sz = 0 ; entry . next = head ; while ( p != NULL ) { p = p -> next ; sz ++ ; } for ( i = 0 , p = & entry ; i < sz - n ; i ++ , p = p -> next ) ; p_free = p -> next ; if ( n != 1 ) { p -> next = p -> next -> next ; } else { p -> next = NULL ; } free ( p_free ) ; return entry . next ; }",
    "resources/C/leetcode/src/141.c@hasCycle": "bool hasCycle ( struct ListNode * head ) { struct ListNode * fast = head , * slow = head ; while ( slow && fast && fast -> next ) { fast = fast -> next -> next ; slow = slow -> next ; if ( fast == slow ) return true ; } return false ; }",
    "resources/C/searching/other_binary_search.c@binarySearch": "int binarySearch ( int array [ ] , int leng , int searchX ) { int pos = - 1 , right , left , i = 0 ; left = 0 ; right = leng - 1 ; while ( left <= right ) { pos = left + ( right - left ) / 2 ; if ( array [ pos ] == searchX ) { return pos ; } else if ( array [ pos ] > searchX ) { right = pos - 1 ; } else { left = pos + 1 ; } } return - 1 ; /* not found */ }",
    "resources/C/searching/other_binary_search.c@main": "int main ( int argc , char * argv [ ] ) { int array [ len ] = { 5 , 8 , 10 , 14 , 16 } ; int position ; position = binarySearch ( array , len , 5 ) ; if ( position < 0 ) printf ( \"The number %d doesnt exist in array\\n\" , 5 ) ; else { printf ( \"The number %d exist in array at position : %d \\n\" , 5 , position ) ; } return 0 ; }",
    "resources/C/searching/ternary_search.c@ternarySearch": "int ternarySearch ( int l , int r , int key , int ar [ ] ) { if ( r >= l ) { // Find the mid1 and mid2 int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ; // Check if key is present at any mid if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } // Since key is not present at mid, // check in which region it is present // then repeat the Search operation // in that region if ( key < ar [ mid1 ] ) { // The key lies in between l and mid1 return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) { // The key lies in between mid2 and r return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else { // The key lies in between mid1 and mid2 return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } } // Key not found return - 1 ; }",
    "resources/C/searching/ternary_search.c@main": "int main ( ) { int l , r , p , key ; // Get the array // Sort the array if not sorted int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; // Starting index l = 0 ; // length of array r = 9 ; // Checking for 5 // Key to be searched in the array key = 5 ; // Search the key using ternarySearch p = ternarySearch ( l , r , key , ar ) ; // Print the result printf ( \"Index of %d is %d\\n\" , key , p ) ; // Checking for 50 // Key to be searched in the array key = 50 ; // Search the key using ternarySearch p = ternarySearch ( l , r , key , ar ) ; // Print the result printf ( \"Index of %d is %d\" , key , p ) ; }",
    "resources/C/searching/fibonacci_search.c@fibMonaccianSearch": "int fibMonaccianSearch ( int arr [ ] , int x , int n ) { /* Initialize fibonacci numbers */ int fibMMm2 = 0 ; // (m-2)'th Fibonacci No. int fibMMm1 = 1 ; // (m-1)'th Fibonacci No. int fibM = fibMMm2 + fibMMm1 ; // m'th Fibonacci /* fibM is going to store the smallest Fibonacci\n       Number greater than or equal to n */ while ( fibM < n ) { fibMMm2 = fibMMm1 ; fibMMm1 = fibM ; fibM = fibMMm2 + fibMMm1 ; } // Marks the eliminated range from front int offset = - 1 ; /* while there are elements to be inspected. Note that\n       we compare arr[fibMm2] with x. When fibM becomes 1,\n       fibMm2 becomes 0 */ while ( fibM > 1 ) { // Check if fibMm2 is a valid location // sets i to the min. of (offset+fibMMm2) and (n-1) int i = ( ( offset + fibMMm2 ) < ( n - 1 ) ) ? ( offset + fibMMm2 ) : ( n - 1 ) ; /* If x is greater than the value at index fibMm2,\n           cut the subarray array from offset to i */ if ( arr [ i ] < x ) { fibM = fibMMm1 ; fibMMm1 = fibMMm2 ; fibMMm2 = fibM - fibMMm1 ; offset = i ; } /* If x is greater than the value at index fibMm2,\n           cut the subarray after i+1  */ else if ( arr [ i ] > x ) { fibM = fibMMm2 ; fibMMm1 = fibMMm1 - fibMMm2 ; fibMMm2 = fibM - fibMMm1 ; } /* element found. return index */ else return i ; } /* comparing the last element with x */ if ( fibMMm1 && arr [ offset + 1 ] == x ) return offset + 1 ; /*element not found. return -1 */ return - 1 ; }",
    "resources/C/searching/fibonacci_search.c@main": "int main ( void ) { int arr [ ] = { 10 , 22 , 35 , 40 , 45 , 50 , 80 , 82 , 85 , 90 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 85 ; printf ( \"Found at index: %d\" , fibMonaccianSearch ( arr , x , n ) ) ; return 0 ; }",
    "resources/C/searching/interpolation_search.c@interpolationSearch": "int interpolationSearch ( int arr [ ] , int n , int key ) { int low = 0 , high = n - 1 ; while ( low <= high && key >= arr [ low ] && key <= arr [ high ] ) { /* Calculate the nearest posible position of key */ int pos = low + ( ( key - arr [ low ] ) * ( high - low ) ) / ( arr [ high ] - arr [ low ] ) ; if ( key > arr [ pos ] ) low = pos + 1 ; else if ( key < arr [ pos ] ) high = pos - 1 ; else /* Found */ return pos ; } /* Not found */ return - 1 ; }",
    "resources/C/searching/interpolation_search.c@main": "int main ( ) { int x ; int arr [ ] = { 10 , 12 , 13 , 16 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 33 , 35 , 42 , 47 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \"Array: \" ) ; for ( int i = 0 ; i < n ; i ++ ) printf ( \"%d \" , arr [ i ] ) ; printf ( \"\\nEnter the number to be searched: \" ) ; scanf ( \"%d\" , & x ) ; /* Element to be searched */ int index = interpolationSearch ( arr , n , x ) ; /* If element was found */ if ( index != - 1 ) printf ( \"Element found at position: %d\\n\" , index ) ; else printf ( \"Element not found.\\n\" ) ; return 0 ; }",
    "resources/C/searching/jump_search.c@jump_search": "int jump_search ( const int * arr , int x , size_t n ) { int step = floor ( sqrt ( n ) ) ; int prev = 0 ; while ( arr [ min ( step , n ) - 1 ] < x ) { prev = step ; step += floor ( sqrt ( n ) ) ; if ( prev >= n ) { return - 1 ; } } while ( arr [ prev ] < x ) { prev = prev + 1 ; if ( prev == min ( step , n ) ) { return - 1 ; } } if ( arr [ prev ] == x ) { return prev ; } return - 1 ; }",
    "resources/C/searching/jump_search.c@test": "void test ( ) { int arr [ ] = { 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 } ; size_t n = sizeof ( arr ) / sizeof ( int ) ; int x = 55 ; printf ( \"Test 1.... \" ) ; int index = jump_search ( arr , x , n ) ; assert ( index == 10 ) ; printf ( \"passed\\nTest 2.... \" ) ; x = 56 ; index = jump_search ( arr , x , n ) ; assert ( index == - 1 ) ; printf ( \"passed\\nTest 3.... \" ) ; x = 13 ; index = jump_search ( arr , x , n ) ; assert ( index == 7 ) ; printf ( \"passed\\n\" ) ; }",
    "resources/C/searching/jump_search.c@main": "int main ( ) { test ( ) ; return 0 ; }",
    "resources/C/searching/binary_search.c@binarysearch1": "int binarysearch1 ( const int * arr , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; // If element is present at middle if ( arr [ mid ] == x ) return mid ; // If element is smaller than middle if ( arr [ mid ] > x ) return binarysearch1 ( arr , l , mid - 1 , x ) ; // Else element is in right subarray return binarysearch1 ( arr , mid + 1 , r , x ) ; } // When element is not present in array return - 1 ; }",
    "resources/C/searching/binary_search.c@binarysearch2": "int binarysearch2 ( const int * arr , int l , int r , int x ) { int mid = l + ( r - l ) / 2 ; while ( arr [ mid ] != x ) { if ( r <= l || r < 0 ) return - 1 ; if ( arr [ mid ] > x ) // If element is smaller than middle r = mid - 1 ; else // Else element is in right subarray l = mid + 1 ; mid = l + ( r - l ) / 2 ; } // When element is not present in array return mid ; }",
    "resources/C/searching/binary_search.c@test": "void test ( ) { // give function an array to work with int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; // get size of array int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \"Test 1.... \" ) ; // set value to look for int x = 10 ; // set result to what is returned from binarysearch int result = binarysearch1 ( arr , 0 , n - 1 , x ) ; assert ( result == 3 ) ; printf ( \"passed recursive... \" ) ; result = binarysearch2 ( arr , 0 , n - 1 , x ) ; assert ( result == 3 ) ; printf ( \"passed iterative...\\n\" ) ; printf ( \"Test 2.... \" ) ; x = 5 ; // set result to what is returned from binarysearch result = binarysearch1 ( arr , 0 , n - 1 , x ) ; assert ( result == - 1 ) ; printf ( \"passed recursive... \" ) ; result = binarysearch2 ( arr , 0 , n - 1 , x ) ; assert ( result == - 1 ) ; printf ( \"passed iterative...\\n\" ) ; }",
    "resources/C/searching/binary_search.c@main": "int main ( void ) { test ( ) ; return 0 ; }",
    "resources/C/searching/sentinel_linear_search.c@sentinel_linear_search": "int sentinel_linear_search ( int arr [ ] , int len , int key ) { if ( key == arr [ len - 1 ] ) { return len - 1 ; } int temp = arr [ len - 1 ] ; arr [ len - 1 ] = key ; int i = 0 ; while ( arr [ len - 1 ] != arr [ i ] ) { i ++ ; } arr [ len - 1 ] = temp ; return i != len - 1 ? i : - 1 ; }",
    "resources/C/searching/sentinel_linear_search.c@test": "static void test ( ) { int n , i ; n = 5 ; /* init array */ int arr [ ] = { 1 , 2 , 2 , 6 , 99 , 100 , 999 } ; assert ( sentinel_linear_search ( arr , n , 1 ) == 0 ) ; assert ( sentinel_linear_search ( arr , n , 2 ) == 1 ) ; assert ( sentinel_linear_search ( arr , n , 6 ) == 3 ) ; assert ( sentinel_linear_search ( arr , n , 101 ) == - 1 ) ; printf ( \"All test cases have successfully passed!\\n\" ) ; }",
    "resources/C/searching/sentinel_linear_search.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/searching/pattern_search/rabin_karp_search.c@rabin_karp_search": "void rabin_karp_search ( char * str , char * pattern , int d , int q ) { int len_str = strlen ( str ) ; int len_pat = strlen ( pattern ) ; int i , h = 1 ; int hash_s = 0 ; /* hash value for string text */ int hash_p = 0 ; /* hash value for pattern */ /* h = pow(d, len_pat - 1) % q */ for ( i = 0 ; i < len_pat - 1 ; i ++ ) h = d * h % q ; /* Calculating hashing of pattern and the 1st window of text */ for ( i = 0 ; i < len_pat ; i ++ ) { hash_p = ( d * hash_p + pattern [ i ] ) % q ; hash_s = ( d * hash_s + str [ i ] ) % q ; } for ( i = 0 ; i <= len_str - len_pat ; i ++ ) { /* Check hash value of current window of text, and pattern\n           If it is match, check each character to make sure pattern\n           is match with current window of text */ if ( hash_p == hash_s ) { int j ; for ( j = 0 ; j < len_pat ; j ++ ) { if ( pattern [ j ] != str [ i + j ] ) break ; } if ( len_pat == j ) printf ( \"--Pattern is found at: %d\\n\" , i ) ; } /* Calculate hash value for next window by removing the leading\n           element of current window text, and adding its trailing */ hash_s = ( d * ( hash_s - str [ i ] * h ) + str [ i + len_pat ] ) % q ; /* Converting hash value to positive when it is negative */ if ( hash_s < 0 ) hash_s = hash_s + q ; } }",
    "resources/C/searching/pattern_search/rabin_karp_search.c@main": "int main ( ) { char str [ ] = \"AABCAB12AFAABCABFFEGABCAB\" ; char pat1 [ ] = \"ABCAB\" ; char pat2 [ ] = \"FFF\" ; /* not found */ char pat3 [ ] = \"CAB\" ; printf ( \"String test: %s\\n\" , str ) ; printf ( \"Test1: search pattern %s\\n\" , pat1 ) ; rabin_karp_search ( str , pat1 , 256 , 29 ) ; printf ( \"Test2: search pattern %s\\n\" , pat2 ) ; rabin_karp_search ( str , pat2 , 256 , 29 ) ; printf ( \"Test3: search pattern %s\\n\" , pat3 ) ; rabin_karp_search ( str , pat3 , 256 , 29 ) ; return 0 ; }",
    "resources/C/searching/pattern_search/boyer_moore_search.c@max": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }",
    "resources/C/searching/pattern_search/boyer_moore_search.c@computeArray": "void computeArray ( char * pattern , int size , int arr [ NUM_OF_CHARS ] ) { int i ; for ( i = 0 ; i < NUM_OF_CHARS ; i ++ ) arr [ i ] = - 1 ; /* Fill the actual value of last occurrence of a character */ for ( i = 0 ; i < size ; i ++ ) arr [ ( int ) pattern [ i ] ] = i ; }",
    "resources/C/searching/pattern_search/boyer_moore_search.c@boyer_moore_search": "void boyer_moore_search ( char * str , char * pattern ) { int n = strlen ( str ) ; int m = strlen ( pattern ) ; int shift = 0 ; int arr [ NUM_OF_CHARS ] ; computeArray ( pattern , m , arr ) ; while ( shift <= ( n - m ) ) { int j = m - 1 ; while ( j >= 0 && pattern [ j ] == str [ shift + j ] ) j -- ; if ( j < 0 ) { printf ( \"--Pattern is found at: %d\\n\" , shift ) ; shift += ( shift + m < n ) ? m - arr [ str [ shift + m ] ] : 1 ; } else { shift += max ( 1 , j - arr [ str [ shift + j ] ] ) ; } } }",
    "resources/C/searching/pattern_search/boyer_moore_search.c@main": "int main ( ) { char str [ ] = \"AABCAB12AFAABCABFFEGABCAB\" ; char pat1 [ ] = \"ABCAB\" ; char pat2 [ ] = \"FFF\" ; /* not found */ char pat3 [ ] = \"CAB\" ; printf ( \"String test: %s\\n\" , str ) ; printf ( \"Test1: search pattern %s\\n\" , pat1 ) ; boyer_moore_search ( str , pat1 ) ; printf ( \"Test2: search pattern %s\\n\" , pat2 ) ; boyer_moore_search ( str , pat2 ) ; printf ( \"Test3: search pattern %s\\n\" , pat3 ) ; boyer_moore_search ( str , pat3 ) ; return 0 ; }",
    "resources/C/searching/pattern_search/naive_search.c@naive_search": "void naive_search ( char * str , char * pattern ) { int len_str = strlen ( str ) ; int len_pat = strlen ( pattern ) ; for ( int i = 0 ; i <= len_str - len_pat ; i ++ ) { int j ; for ( j = 0 ; j < len_pat ; j ++ ) { if ( str [ i + j ] != pattern [ j ] ) break ; } if ( j == len_pat ) printf ( \"--Pattern is found at: %d\\n\" , i ) ; } }",
    "resources/C/searching/pattern_search/naive_search.c@main": "int main ( ) { char str [ ] = \"AABCAB12AFAABCABFFEGABCAB\" ; char pat1 [ ] = \"ABCAB\" ; char pat2 [ ] = \"FFF\" ; /* not found */ char pat3 [ ] = \"CAB\" ; printf ( \"String test: %s\\n\" , str ) ; printf ( \"Test1: search pattern %s\\n\" , pat1 ) ; naive_search ( str , pat1 ) ; printf ( \"Test2: search pattern %s\\n\" , pat2 ) ; naive_search ( str , pat2 ) ; printf ( \"Test3: search pattern %s\\n\" , pat3 ) ; naive_search ( str , pat3 ) ; return 0 ; }",
    "resources/C/searching/linear_search.c@linearsearch": "int linearsearch ( int * arr , int size , int val ) { int i ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] == val ) return 1 ; } return 0 ; }",
    "resources/C/searching/linear_search.c@main": "int main ( ) { int n , i , v ; printf ( \"Enter the size of the array:\\n\" ) ; scanf ( \"%d\" , & n ) ; // Taking input for the size of Array int * a = ( int * ) malloc ( n * sizeof ( int ) ) ; printf ( \"Enter the contents for an array of size %d:\\n\" , n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( \"%d\" , & a [ i ] ) ; // accepts the values of array elements until the // loop terminates// printf ( \"Enter the value to be searched:\\n\" ) ; scanf ( \"%d\" , & v ) ; // Taking input the value to be searched if ( linearsearch ( a , n , v ) ) printf ( \"Value %d is in the array.\\n\" , v ) ; else printf ( \"Value %d is not in the array.\\n\" , v ) ; free ( a ) ; return 0 ; }",
    "resources/C/searching/exponential_search.c@exponential_search": "int64_t exponential_search ( const int64_t * arr , const uint16_t length , const int64_t n ) { if ( length == 0 ) { return - 1 ; } // find the upperbound uint32_t upper_bound = 1 ; while ( upper_bound <= length && arr [ upper_bound ] < n ) { upper_bound = upper_bound * 2 ; } // calculate the range ( between lower_boud and upper_bound ) uint16_t lower_bound = upper_bound / 2 ; if ( upper_bound > length ) { upper_bound = length ; } // apply the binary search in the range return binary_search ( arr , lower_bound , upper_bound , n ) ; }",
    "resources/C/searching/exponential_search.c@binary_search": "int64_t binary_search ( const int64_t * arr , const uint16_t l_index , const uint16_t r_index , const int64_t n ) { // calculate the middle index of the array uint16_t middle_index = l_index + ( r_index - l_index ) / 2 ; // base cases if ( l_index > r_index ) { return - 1 ; } if ( arr [ middle_index ] == n ) { return middle_index ; } // recursion if ( arr [ middle_index ] > n ) { return binary_search ( arr , l_index , middle_index - 1 , n ) ; } // left return binary_search ( arr , middle_index + 1 , r_index , n ) ; // right }",
    "resources/C/searching/exponential_search.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/searching/exponential_search.c@test": "static void test ( ) { // empty array int64_t arr_empty [ ] = { 0 } ; assert ( exponential_search ( arr_empty , 0 , 10 ) == - 1 ) ; // elent not found int64_t arr_found [ ] = { 1 , 2 , 3 } ; assert ( exponential_search ( arr_found , 3 , 10 ) == - 1 ) ; // element found in an array of length 1 int64_t arr_one [ ] = { 1 } ; assert ( exponential_search ( arr_found , 1 , 1 ) == 0 ) ; // find the first element in an array of length 2 int64_t arr_first_2 [ ] = { 1 , 2 } ; assert ( exponential_search ( arr_first_2 , 2 , 1 ) == 0 ) ; // find the last element in an array of length 2 int64_t arr_last_2 [ ] = { 1 , 2 } ; assert ( exponential_search ( arr_last_2 , 2 , 2 ) == 1 ) ; // find the first element in an array of length n int64_t arr_first_n [ ] = { - 1 , 2 , 4 , 6 , 8 } ; assert ( exponential_search ( arr_first_n , 5 , - 1 ) == 0 ) ; // find the last element in an array of length n int64_t arr_last_n [ ] = { - 1 , 2 , 4 , 6 , 8 } ; assert ( exponential_search ( arr_last_n , 5 , 8 ) == 4 ) ; // find an element in an array of length n int64_t arr_middle [ ] = { - 1 , 2 , 4 , 6 , 8 } ; assert ( exponential_search ( arr_middle , 5 , 6 ) == 3 ) ; printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/searching/floyd_cycle_detection_algorithm.c@duplicateNumber": "uint32_t duplicateNumber ( const uint32_t * in_arr , size_t n ) { if ( n <= 1 ) { // to find duplicate in an array its size should be at least 2 return - 1 ; } uint32_t tortoise = in_arr [ 0 ] ; ///< variable tortoise is used for the longer ///< jumps in the array uint32_t hare = in_arr [ 0 ] ; ///< variable hare is used for shorter jumps in the array do { // loop to enter the cycle tortoise = in_arr [ tortoise ] ; // tortoise is moving by one step hare = in_arr [ in_arr [ hare ] ] ; // hare is moving by two steps } while ( tortoise != hare ) ; tortoise = in_arr [ 0 ] ; while ( tortoise != hare ) { // loop to find the entry point of cycle tortoise = in_arr [ tortoise ] ; hare = in_arr [ hare ] ; } return tortoise ; }",
    "resources/C/searching/floyd_cycle_detection_algorithm.c@test": "static void test ( ) { uint32_t arr [ ] = { 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 } ; // input array size_t n = sizeof ( arr ) / sizeof ( int ) ; printf ( \"1st test... \" ) ; uint32_t index = duplicateNumber ( arr , n ) ; // calling the duplicateNumber function to check which number occurs twice in the array assert ( index == 1 ) ; // the number which occurs twice is 1 or not printf ( \"passed\\n\" ) ; }",
    "resources/C/searching/floyd_cycle_detection_algorithm.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/searching/modified_binary_search.c@binarySearch": "int binarySearch ( const int * * mat , int i , int j_low , int j_high , int x ) { while ( j_low <= j_high ) { int j_mid = ( j_low + j_high ) / 2 ; // Element found if ( mat [ i ] [ j_mid ] == x ) { printf ( \"Found at (%d,%d)\\n\" , i , j_mid ) ; return j_mid ; } else if ( mat [ i ] [ j_mid ] > x ) j_high = j_mid - 1 ; else j_low = j_mid + 1 ; } // element not found printf ( \"element not found\\n\" ) ; return - 1 ; }",
    "resources/C/searching/modified_binary_search.c@modifiedBinarySearch": "void modifiedBinarySearch ( const int * * mat , int n , int m , int x ) { // If Single row matrix if ( n == 1 ) { binarySearch ( mat , 0 , 0 , m - 1 , x ) ; return ; } // Do binary search in middle column. // Condition to terminate the loop when the 2 desired rows are found. int i_low = 0 , i_high = n - 1 , j_mid = m / 2 ; while ( ( i_low + 1 ) < i_high ) { int i_mid = ( i_low + i_high ) / 2 ; // element found if ( mat [ i_mid ] [ j_mid ] == x ) { printf ( \"Found at (%d,%d)\\n\" , i_mid , j_mid ) ; return ; } else if ( mat [ i_mid ] [ j_mid ] > x ) i_high = i_mid ; else i_low = i_mid ; } // If element is present on the mid of the two rows if ( mat [ i_low ] [ j_mid ] == x ) printf ( \"Found at (%d,%d)\\n\" , i_low , j_mid ) ; else if ( mat [ i_low + 1 ] [ j_mid ] == x ) printf ( \"Found at (%d,%d)\\n\" , i_low + 1 , j_mid ) ; // Search element on 1st half of 1st row else if ( x <= mat [ i_low ] [ j_mid - 1 ] ) binarySearch ( mat , i_low , 0 , j_mid - 1 , x ) ; // Search element on 2nd half of 1st row else if ( x >= mat [ i_low ] [ j_mid + 1 ] && x <= mat [ i_low ] [ m - 1 ] ) binarySearch ( mat , i_low , j_mid + 1 , m - 1 , x ) ; // Search element on 1st half of 2nd row else if ( x <= mat [ i_low + 1 ] [ j_mid - 1 ] ) binarySearch ( mat , i_low + 1 , 0 , j_mid - 1 , x ) ; // search element on 2nd half of 2nd row else binarySearch ( mat , i_low + 1 , j_mid + 1 , m - 1 , x ) ; }",
    "resources/C/searching/modified_binary_search.c@main": "int main ( ) { int x ; // element to be searched int m , n ; // m = columns, n = rows scanf ( \"%d %d %d\\n\" , & n , & m , & x ) ; int * * mat = ( int * * ) malloc ( n * sizeof ( int * ) ) ; for ( int i = 0 ; i < m ; i ++ ) mat [ i ] = ( int * ) malloc ( m * sizeof ( int ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { scanf ( \"%d\" , & mat [ i ] [ j ] ) ; } } modifiedBinarySearch ( mat , n , m , x ) ; for ( int i = 0 ; i < n ; i ++ ) free ( mat [ i ] ) ; free ( mat ) ; return 0 ; }",
    "resources/C/machine_learning/k_means_clustering.c@calculateNearst": "int calculateNearst ( observation * o , cluster clusters [ ] , int k ) { double minD = DBL_MAX ; double dist = 0 ; int index = - 1 ; int i = 0 ; for ( ; i < k ; i ++ ) { /* Calculate Squared Distance*/ dist = ( clusters [ i ] . x - o -> x ) * ( clusters [ i ] . x - o -> x ) + ( clusters [ i ] . y - o -> y ) * ( clusters [ i ] . y - o -> y ) ; if ( dist < minD ) { minD = dist ; index = i ; } } return index ; }",
    "resources/C/machine_learning/k_means_clustering.c@calculateCentroid": "void calculateCentroid ( observation observations [ ] , size_t size , cluster * centroid ) { size_t i = 0 ; centroid -> x = 0 ; centroid -> y = 0 ; centroid -> count = size ; for ( ; i < size ; i ++ ) { centroid -> x += observations [ i ] . x ; centroid -> y += observations [ i ] . y ; observations [ i ] . group = 0 ; } centroid -> x /= centroid -> count ; centroid -> y /= centroid -> count ; }",
    "resources/C/machine_learning/k_means_clustering.c@kMeans": "cluster * kMeans ( observation observations [ ] , size_t size , int k ) { cluster * clusters = NULL ; if ( k <= 1 ) { /*\n        If we have to cluster them only in one group\n        then calculate centroid of observations and\n        that will be a ingle cluster\n        */ clusters = ( cluster * ) malloc ( sizeof ( cluster ) ) ; memset ( clusters , 0 , sizeof ( cluster ) ) ; calculateCentroid ( observations , size , clusters ) ; } else if ( k < size ) { clusters = malloc ( sizeof ( cluster ) * k ) ; memset ( clusters , 0 , k * sizeof ( cluster ) ) ; /* STEP 1 */ for ( size_t j = 0 ; j < size ; j ++ ) { observations [ j ] . group = rand ( ) % k ; } size_t changed = 0 ; size_t minAcceptedError = size / 10000 ; // Do until 99.99 percent points are in correct cluster int t = 0 ; do { /* Initialize clusters */ for ( int i = 0 ; i < k ; i ++ ) { clusters [ i ] . x = 0 ; clusters [ i ] . y = 0 ; clusters [ i ] . count = 0 ; } /* STEP 2*/ for ( size_t j = 0 ; j < size ; j ++ ) { t = observations [ j ] . group ; clusters [ t ] . x += observations [ j ] . x ; clusters [ t ] . y += observations [ j ] . y ; clusters [ t ] . count ++ ; } for ( int i = 0 ; i < k ; i ++ ) { clusters [ i ] . x /= clusters [ i ] . count ; clusters [ i ] . y /= clusters [ i ] . count ; } /* STEP 3 and 4 */ changed = 0 ; // this variable stores change in clustering for ( size_t j = 0 ; j < size ; j ++ ) { t = calculateNearst ( observations + j , clusters , k ) ; if ( t != observations [ j ] . group ) { changed ++ ; observations [ j ] . group = t ; } } } while ( changed > minAcceptedError ) ; // Keep on grouping until we have // got almost best clustering } else { /* If no of clusters is more than observations\n           each observation can be its own cluster\n        */ clusters = ( cluster * ) malloc ( sizeof ( cluster ) * k ) ; memset ( clusters , 0 , k * sizeof ( cluster ) ) ; for ( int j = 0 ; j < size ; j ++ ) { clusters [ j ] . x = observations [ j ] . x ; clusters [ j ] . y = observations [ j ] . y ; clusters [ j ] . count = 1 ; observations [ j ] . group = j ; } } return clusters ; }",
    "resources/C/machine_learning/k_means_clustering.c@printEPS": "void printEPS ( observation pts [ ] , size_t len , cluster cent [ ] , int k ) { int W = 400 , H = 400 ; double min_x = DBL_MAX , max_x = DBL_MIN , min_y = DBL_MAX , max_y = DBL_MIN ; double scale = 0 , cx = 0 , cy = 0 ; double * colors = ( double * ) malloc ( sizeof ( double ) * ( k * 3 ) ) ; int i ; size_t j ; double kd = k * 1.0 ; for ( i = 0 ; i < k ; i ++ ) { * ( colors + 3 * i ) = ( 3 * ( i + 1 ) % k ) / kd ; * ( colors + 3 * i + 1 ) = ( 7 * i % k ) / kd ; * ( colors + 3 * i + 2 ) = ( 9 * i % k ) / kd ; } for ( j = 0 ; j < len ; j ++ ) { if ( max_x < pts [ j ] . x ) { max_x = pts [ j ] . x ; } if ( min_x > pts [ j ] . x ) { min_x = pts [ j ] . x ; } if ( max_y < pts [ j ] . y ) { max_y = pts [ j ] . y ; } if ( min_y > pts [ j ] . y ) { min_y = pts [ j ] . y ; } } scale = W / ( max_x - min_x ) ; if ( scale > ( H / ( max_y - min_y ) ) ) { scale = H / ( max_y - min_y ) ; } ; cx = ( max_x + min_x ) / 2 ; cy = ( max_y + min_y ) / 2 ; printf ( \"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\" , W + 10 , H + 10 ) ; printf ( \"/l {rlineto} def /m {rmoveto} def\\n\" \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\" \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \" \"\tgsave 1 setgray fill grestore gsave 3 setlinewidth\" \" 1 setgray stroke grestore 0 setgray stroke }def\\n\" ) ; for ( int i = 0 ; i < k ; i ++ ) { printf ( \"%g %g %g setrgbcolor\\n\" , * ( colors + 3 * i ) , * ( colors + 3 * i + 1 ) , * ( colors + 3 * i + 2 ) ) ; for ( j = 0 ; j < len ; j ++ ) { if ( pts [ j ] . group != i ) { continue ; } printf ( \"%.3f %.3f c\\n\" , ( pts [ j ] . x - cx ) * scale + W / 2 , ( pts [ j ] . y - cy ) * scale + H / 2 ) ; } printf ( \"\\n0 setgray %g %g s\\n\" , ( cent [ i ] . x - cx ) * scale + W / 2 , ( cent [ i ] . y - cy ) * scale + H / 2 ) ; } printf ( \"\\n%%%%EOF\" ) ; // free accquired memory free ( colors ) ; }",
    "resources/C/machine_learning/k_means_clustering.c@test": "static void test ( ) { size_t size = 100000L ; observation * observations = ( observation * ) malloc ( sizeof ( observation ) * size ) ; double maxRadius = 20.00 ; double radius = 0 ; double ang = 0 ; size_t i = 0 ; for ( ; i < size ; i ++ ) { radius = maxRadius * ( ( double ) rand ( ) / RAND_MAX ) ; ang = 2 * M_PI * ( ( double ) rand ( ) / RAND_MAX ) ; observations [ i ] . x = radius * cos ( ang ) ; observations [ i ] . y = radius * sin ( ang ) ; } int k = 5 ; // No of clusters cluster * clusters = kMeans ( observations , size , k ) ; printEPS ( observations , size , clusters , k ) ; // Free the accquired memory free ( observations ) ; free ( clusters ) ; }",
    "resources/C/machine_learning/k_means_clustering.c@test2": "void test2 ( ) { size_t size = 1000000L ; observation * observations = ( observation * ) malloc ( sizeof ( observation ) * size ) ; double maxRadius = 20.00 ; double radius = 0 ; double ang = 0 ; size_t i = 0 ; for ( ; i < size ; i ++ ) { radius = maxRadius * ( ( double ) rand ( ) / RAND_MAX ) ; ang = 2 * M_PI * ( ( double ) rand ( ) / RAND_MAX ) ; observations [ i ] . x = radius * cos ( ang ) ; observations [ i ] . y = radius * sin ( ang ) ; } int k = 11 ; // No of clusters cluster * clusters = kMeans ( observations , size , k ) ; printEPS ( observations , size , clusters , k ) ; // Free the accquired memory free ( observations ) ; free ( clusters ) ; }",
    "resources/C/machine_learning/k_means_clustering.c@main": "int main ( ) { srand ( time ( NULL ) ) ; test ( ) ; /* test2(); */ return 0 ; }",
    "resources/C/machine_learning/kohonen_som_trace.c@_random": "double _random ( double a , double b ) { int r = rand ( ) % 100 ; return ( ( b - a ) * r / 100.f ) + a ; }",
    "resources/C/machine_learning/kohonen_som_trace.c@save_nd_data": "int save_nd_data ( const char * fname , double * * X , int num_points , int num_features ) { FILE * fp = fopen ( fname , \"wt\" ) ; if ( ! fp ) // error with fopen { char msg [ 120 ] ; sprintf ( msg , \"File error (%s): \" , fname ) ; perror ( msg ) ; return - 1 ; } for ( int i = 0 ; i < num_points ; i ++ ) // for each point in the array { for ( int j = 0 ; j < num_features ; j ++ ) // for each feature in the array { fprintf ( fp , \"%.4g\" , X [ i ] [ j ] ) ; // print the feature value if ( j < num_features - 1 ) // if not the last feature fprintf ( fp , \",\" ) ; // suffix comma } if ( i < num_points - 1 ) // if not the last row fprintf ( fp , \"\\n\" ) ; // start a new line } fclose ( fp ) ; return 0 ; }",
    "resources/C/machine_learning/kohonen_som_trace.c@kohonen_get_min_1d": "void kohonen_get_min_1d ( double const * X , int N , double * val , int * idx ) { val [ 0 ] = INFINITY ; // initial min value for ( int i = 0 ; i < N ; i ++ ) // check each value { if ( X [ i ] < val [ 0 ] ) // if a lower value is found { // save the value and its index idx [ 0 ] = i ; val [ 0 ] = X [ i ] ; } } }",
    "resources/C/machine_learning/kohonen_som_trace.c@kohonen_update_weights": "void kohonen_update_weights ( double const * x , double * const * W , double * D , int num_out , int num_features , double alpha , int R ) { int j , k ; # ifdef _OPENMP # pragma omp for # endif // step 1: for each output point for ( j = 0 ; j < num_out ; j ++ ) { D [ j ] = 0.f ; // compute Euclidian distance of each output // point from the current sample for ( k = 0 ; k < num_features ; k ++ ) D [ j ] += ( W [ j ] [ k ] - x [ k ] ) * ( W [ j ] [ k ] - x [ k ] ) ; } // step 2:  get closest node i.e., node with smallest Euclidian distance to // the current pattern int d_min_idx ; double d_min ; kohonen_get_min_1d ( D , num_out , & d_min , & d_min_idx ) ; // step 3a: get the neighborhood range int from_node = max ( 0 , d_min_idx - R ) ; int to_node = min ( num_out , d_min_idx + R + 1 ) ; // step 3b: update the weights of nodes in the // neighborhood # ifdef _OPENMP # pragma omp for # endif for ( j = from_node ; j < to_node ; j ++ ) for ( k = 0 ; k < num_features ; k ++ ) // update weights of nodes in the neighborhood W [ j ] [ k ] += alpha * ( x [ k ] - W [ j ] [ k ] ) ; }",
    "resources/C/machine_learning/kohonen_som_trace.c@kohonen_som_tracer": "void kohonen_som_tracer ( double * * X , double * const * W , int num_samples , int num_features , int num_out , double alpha_min ) { int R = num_out >> 2 , iter = 0 ; double alpha = 1.f ; double * D = ( double * ) malloc ( num_out * sizeof ( double ) ) ; // Loop alpha from 1 to alpha_min for ( ; alpha > alpha_min ; alpha -= 0.01 , iter ++ ) { // Loop for each sample pattern in the data set for ( int sample = 0 ; sample < num_samples ; sample ++ ) { const double * x = X [ sample ] ; // update weights for the current input pattern sample kohonen_update_weights ( x , W , D , num_out , num_features , alpha , R ) ; } // every 10th iteration, reduce the neighborhood range if ( iter % 10 == 0 && R > 1 ) R -- ; } free ( D ) ; }",
    "resources/C/machine_learning/kohonen_som_trace.c@test_circle": "void test_circle ( double * const * data , int N ) { const double R = 0.75 , dr = 0.3 ; double a_t = 0. , b_t = 2.f * M_PI ; // theta random between 0 and 2*pi double a_r = R - dr , b_r = R + dr ; // radius random between R-dr and R+dr int i ; # ifdef _OPENMP # pragma omp for # endif for ( i = 0 ; i < N ; i ++ ) { double r = _random ( a_r , b_r ) ; // random radius double theta = _random ( a_t , b_t ) ; // random theta data [ i ] [ 0 ] = r * cos ( theta ) ; // convert from polar to cartesian data [ i ] [ 1 ] = r * sin ( theta ) ; } }",
    "resources/C/machine_learning/kohonen_som_trace.c@test1": "void test1 ( ) { int j , N = 500 ; int features = 2 ; int num_out = 50 ; // 2D space, hence size = number of rows * 2 double * * X = ( double * * ) malloc ( N * sizeof ( double * ) ) ; // number of clusters nodes * 2 double * * W = ( double * * ) malloc ( num_out * sizeof ( double * ) ) ; for ( int i = 0 ; i < max ( num_out , N ) ; i ++ ) // loop till max(N, num_out) { if ( i < N ) // only add new arrays if i < N X [ i ] = ( double * ) malloc ( features * sizeof ( double ) ) ; if ( i < num_out ) // only add new arrays if i < num_out { W [ i ] = ( double * ) malloc ( features * sizeof ( double ) ) ; # ifdef _OPENMP # pragma omp for # endif // preallocate with random initial weights for ( j = 0 ; j < features ; j ++ ) W [ i ] [ j ] = _random ( - 1 , 1 ) ; } } test_circle ( X , N ) ; // create test data around circumference of a circle save_nd_data ( \"test1.csv\" , X , N , features ) ; // save test data points save_nd_data ( \"w11.csv\" , W , num_out , features ) ; // save initial random weights kohonen_som_tracer ( X , W , N , features , num_out , 0.1 ) ; // train the SOM save_nd_data ( \"w12.csv\" , W , num_out , features ) ; // save the resultant weights for ( int i = 0 ; i < max ( num_out , N ) ; i ++ ) { if ( i < N ) free ( X [ i ] ) ; if ( i < num_out ) free ( W [ i ] ) ; } }",
    "resources/C/machine_learning/kohonen_som_trace.c@test_lamniscate": "void test_lamniscate ( double * const * data , int N ) { const double dr = 0.2 ; int i ; # ifdef _OPENMP # pragma omp for # endif for ( i = 0 ; i < N ; i ++ ) { double dx = _random ( - dr , dr ) ; // random change in x double dy = _random ( - dr , dr ) ; // random change in y double theta = _random ( 0 , M_PI ) ; // random theta data [ i ] [ 0 ] = dx + cos ( theta ) ; // convert from polar to cartesian data [ i ] [ 1 ] = dy + sin ( 2. * theta ) / 2.f ; } }",
    "resources/C/machine_learning/kohonen_som_trace.c@test2": "void test2 ( ) { int j , N = 500 ; int features = 2 ; int num_out = 20 ; double * * X = ( double * * ) malloc ( N * sizeof ( double * ) ) ; double * * W = ( double * * ) malloc ( num_out * sizeof ( double * ) ) ; for ( int i = 0 ; i < max ( num_out , N ) ; i ++ ) { if ( i < N ) // only add new arrays if i < N X [ i ] = ( double * ) malloc ( features * sizeof ( double ) ) ; if ( i < num_out ) // only add new arrays if i < num_out { W [ i ] = ( double * ) malloc ( features * sizeof ( double ) ) ; # ifdef _OPENMP # pragma omp for # endif // preallocate with random initial weights for ( j = 0 ; j < features ; j ++ ) W [ i ] [ j ] = _random ( - 1 , 1 ) ; } } test_lamniscate ( X , N ) ; // create test data around the lamniscate save_nd_data ( \"test2.csv\" , X , N , features ) ; // save test data points save_nd_data ( \"w21.csv\" , W , num_out , features ) ; // save initial random weights kohonen_som_tracer ( X , W , N , features , num_out , 0.01 ) ; // train the SOM save_nd_data ( \"w22.csv\" , W , num_out , features ) ; // save the resultant weights for ( int i = 0 ; i < max ( num_out , N ) ; i ++ ) { if ( i < N ) free ( X [ i ] ) ; if ( i < num_out ) free ( W [ i ] ) ; } free ( X ) ; free ( W ) ; }",
    "resources/C/machine_learning/kohonen_som_trace.c@test_3d_classes": "void test_3d_classes ( double * const * data , int N ) { const double R = 0.1 ; // radius of cluster int i ; const int num_classes = 4 ; const double centres [ ] [ 3 ] = { // centres of each class cluster { .5 , .5 , .5 } , // centre of class 1 { .5 , - .5 , - .5 } , // centre of class 2 { - .5 , .5 , .5 } , // centre of class 3 { - .5 , - .5 - .5 } // centre of class 4 } ; # ifdef _OPENMP # pragma omp for # endif for ( i = 0 ; i < N ; i ++ ) { int class = rand ( ) % num_classes ; // select a random class for the point // create random coordinates (x,y,z) around the centre of the class data [ i ] [ 0 ] = _random ( centres [ class ] [ 0 ] - R , centres [ class ] [ 0 ] + R ) ; data [ i ] [ 1 ] = _random ( centres [ class ] [ 1 ] - R , centres [ class ] [ 1 ] + R ) ; data [ i ] [ 2 ] = _random ( centres [ class ] [ 2 ] - R , centres [ class ] [ 2 ] + R ) ; /* The follosing can also be used\n        for (int j = 0; j < 3; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */ } }",
    "resources/C/machine_learning/kohonen_som_trace.c@test3": "void test3 ( ) { int j , N = 200 ; int features = 3 ; int num_out = 20 ; double * * X = ( double * * ) malloc ( N * sizeof ( double * ) ) ; double * * W = ( double * * ) malloc ( num_out * sizeof ( double * ) ) ; for ( int i = 0 ; i < max ( num_out , N ) ; i ++ ) { if ( i < N ) // only add new arrays if i < N X [ i ] = ( double * ) malloc ( features * sizeof ( double ) ) ; if ( i < num_out ) // only add new arrays if i < num_out { W [ i ] = ( double * ) malloc ( features * sizeof ( double ) ) ; # ifdef _OPENMP # pragma omp for # endif // preallocate with random initial weights for ( j = 0 ; j < features ; j ++ ) W [ i ] [ j ] = _random ( - 1 , 1 ) ; } } test_3d_classes ( X , N ) ; // create test data around the lamniscate save_nd_data ( \"test3.csv\" , X , N , features ) ; // save test data points save_nd_data ( \"w31.csv\" , W , num_out , features ) ; // save initial random weights kohonen_som_tracer ( X , W , N , features , num_out , 0.01 ) ; // train the SOM save_nd_data ( \"w32.csv\" , W , num_out , features ) ; // save the resultant weights for ( int i = 0 ; i < max ( num_out , N ) ; i ++ ) { if ( i < N ) free ( X [ i ] ) ; if ( i < num_out ) free ( W [ i ] ) ; } free ( X ) ; free ( W ) ; }",
    "resources/C/machine_learning/kohonen_som_trace.c@get_clock_diff": "double get_clock_diff ( clock_t start_t , clock_t end_t ) { return ( double ) ( end_t - start_t ) / ( double ) CLOCKS_PER_SEC ; }",
    "resources/C/machine_learning/kohonen_som_trace.c@main": "int main ( int argc , char * * argv ) { # ifdef _OPENMP printf ( \"Using OpenMP based parallelization\\n\" ) ; # else printf ( \"NOT using OpenMP based parallelization\\n\" ) ; # endif clock_t start_clk = clock ( ) ; test1 ( ) ; clock_t end_clk = clock ( ) ; printf ( \"Test 1 completed in %.4g sec\\n\" , get_clock_diff ( start_clk , end_clk ) ) ; start_clk = clock ( ) ; test2 ( ) ; end_clk = clock ( ) ; printf ( \"Test 2 completed in %.4g sec\\n\" , get_clock_diff ( start_clk , end_clk ) ) ; start_clk = clock ( ) ; test3 ( ) ; end_clk = clock ( ) ; printf ( \"Test 3 completed in %.4g sec\\n\" , get_clock_diff ( start_clk , end_clk ) ) ; printf ( \"(Note: Calculated times include: creating test sets, training \" \"model and writing files to disk.)\\n\\n\" ) ; return 0 ; }",
    "resources/C/machine_learning/kohonen_som_topology.c@kohonen_data_3d": "double * kohonen_data_3d ( const struct kohonen_array_3d * arr , int x , int y , int z ) { int offset = ( x * arr -> dim2 * arr -> dim3 ) + ( y * arr -> dim3 ) + z ; return arr -> data + offset ; }",
    "resources/C/machine_learning/kohonen_som_topology.c@_random": "double _random ( double a , double b ) { return ( ( b - a ) * ( rand ( ) % 100 ) / 100.f ) + a ; }",
    "resources/C/machine_learning/kohonen_som_topology.c@save_2d_data": "int save_2d_data ( const char * fname , double * * X , int num_points , int num_features ) { FILE * fp = fopen ( fname , \"wt\" ) ; if ( ! fp ) // error with fopen { char msg [ 120 ] ; sprintf ( msg , \"File error (%s): \" , fname ) ; perror ( msg ) ; return - 1 ; } for ( int i = 0 ; i < num_points ; i ++ ) // for each point in the array { for ( int j = 0 ; j < num_features ; j ++ ) // for each feature in the array { fprintf ( fp , \"%.4g\" , X [ i ] [ j ] ) ; // print the feature value if ( j < num_features - 1 ) // if not the last feature fputc ( ',' , fp ) ; // suffix comma } if ( i < num_points - 1 ) // if not the last row fputc ( '\\n' , fp ) ; // start a new line } fclose ( fp ) ; return 0 ; }",
    "resources/C/machine_learning/kohonen_som_topology.c@save_u_matrix": "int save_u_matrix ( const char * fname , struct kohonen_array_3d * W ) { FILE * fp = fopen ( fname , \"wt\" ) ; if ( ! fp ) // error with fopen { char msg [ 120 ] ; sprintf ( msg , \"File error (%s): \" , fname ) ; perror ( msg ) ; return - 1 ; } int R = max ( W -> dim1 >> 3 , 2 ) ; /* neighborhood range */ for ( int i = 0 ; i < W -> dim1 ; i ++ ) // for each x { for ( int j = 0 ; j < W -> dim2 ; j ++ ) // for each y { double distance = 0.f ; int k ; int from_x = max ( 0 , i - R ) ; int to_x = min ( W -> dim1 , i + R + 1 ) ; int from_y = max ( 0 , j - R ) ; int to_y = min ( W -> dim2 , j + R + 1 ) ; int l ; # ifdef _OPENMP # pragma omp parallel for reduction ( + : distance ) # endif for ( l = from_x ; l < to_x ; l ++ ) // scan neighborhoor in x { for ( int m = from_y ; m < to_y ; m ++ ) // scan neighborhood in y { double d = 0.f ; for ( k = 0 ; k < W -> dim3 ; k ++ ) // for each feature { double * w1 = kohonen_data_3d ( W , i , j , k ) ; double * w2 = kohonen_data_3d ( W , l , m , k ) ; d += ( w1 [ 0 ] - w2 [ 0 ] ) * ( w1 [ 0 ] - w2 [ 0 ] ) ; // distance += w1[0] * w1[0]; } distance += sqrt ( d ) ; // distance += d; } } distance /= R * R ; // mean distance from neighbors fprintf ( fp , \"%.4g\" , distance ) ; // print the mean separation if ( j < W -> dim2 - 1 ) // if not the last column fputc ( ',' , fp ) ; // suffix comma } if ( i < W -> dim1 - 1 ) // if not the last row fputc ( '\\n' , fp ) ; // start a new line } fclose ( fp ) ; return 0 ; }",
    "resources/C/machine_learning/kohonen_som_topology.c@get_min_2d": "void get_min_2d ( double * * X , int N , double * val , int * x_idx , int * y_idx ) { val [ 0 ] = INFINITY ; // initial min value for ( int i = 0 ; i < N ; i ++ ) // traverse each x-index { for ( int j = 0 ; j < N ; j ++ ) // traverse each y-index { if ( X [ i ] [ j ] < val [ 0 ] ) // if a lower value is found { // save the value and its index x_idx [ 0 ] = i ; y_idx [ 0 ] = j ; val [ 0 ] = X [ i ] [ j ] ; } } } }",
    "resources/C/machine_learning/kohonen_som_topology.c@kohonen_update_weights": "double kohonen_update_weights ( const double * X , struct kohonen_array_3d * W , double * * D , int num_out , int num_features , double alpha , int R ) { int x , y , k ; double d_min = 0.f ; # ifdef _OPENMP # pragma omp for # endif // step 1: for each 2D output point for ( x = 0 ; x < num_out ; x ++ ) { for ( y = 0 ; y < num_out ; y ++ ) { D [ x ] [ y ] = 0.f ; // compute Euclidian distance of each output // point from the current sample for ( k = 0 ; k < num_features ; k ++ ) { double * w = kohonen_data_3d ( W , x , y , k ) ; D [ x ] [ y ] += ( w [ 0 ] - X [ k ] ) * ( w [ 0 ] - X [ k ] ) ; } D [ x ] [ y ] = sqrt ( D [ x ] [ y ] ) ; } } // step 2:  get closest node i.e., node with smallest Euclidian distance to // the current pattern int d_min_x , d_min_y ; get_min_2d ( D , num_out , & d_min , & d_min_x , & d_min_y ) ; // step 3a: get the neighborhood range int from_x = max ( 0 , d_min_x - R ) ; int to_x = min ( num_out , d_min_x + R + 1 ) ; int from_y = max ( 0 , d_min_y - R ) ; int to_y = min ( num_out , d_min_y + R + 1 ) ; // step 3b: update the weights of nodes in the // neighborhood # ifdef _OPENMP # pragma omp for # endif for ( x = from_x ; x < to_x ; x ++ ) { for ( y = from_y ; y < to_y ; y ++ ) { /* you can enable the following normalization if needed.\n               personally, I found it detrimental to convergence */ // const double s2pi = sqrt(2.f * M_PI); // double normalize = 1.f / (alpha * s2pi); /* apply scaling inversely proportional to distance from the\n               current node */ double d2 = ( d_min_x - x ) * ( d_min_x - x ) + ( d_min_y - y ) * ( d_min_y - y ) ; double scale_factor = exp ( - d2 / ( 2.f * alpha * alpha ) ) ; for ( k = 0 ; k < num_features ; k ++ ) { double * w = kohonen_data_3d ( W , x , y , k ) ; // update weights of nodes in the neighborhood w [ 0 ] += alpha * scale_factor * ( X [ k ] - w [ 0 ] ) ; } } } return d_min ; }",
    "resources/C/machine_learning/kohonen_som_topology.c@kohonen_som": "void kohonen_som ( double * * X , struct kohonen_array_3d * W , int num_samples , int num_features , int num_out , double alpha_min ) { int R = num_out >> 2 , iter = 0 ; double * * D = ( double * * ) malloc ( num_out * sizeof ( double * ) ) ; for ( int i = 0 ; i < num_out ; i ++ ) D [ i ] = ( double * ) malloc ( num_out * sizeof ( double ) ) ; double dmin = 1.f ; // average minimum distance of all samples // Loop alpha from 1 to slpha_min for ( double alpha = 1.f ; alpha > alpha_min && dmin > 1e-3 ; alpha -= 0.001 , iter ++ ) { dmin = 0.f ; // Loop for each sample pattern in the data set for ( int sample = 0 ; sample < num_samples ; sample ++ ) { // update weights for the current input pattern sample dmin += kohonen_update_weights ( X [ sample ] , W , D , num_out , num_features , alpha , R ) ; } // every 20th iteration, reduce the neighborhood range if ( iter % 100 == 0 && R > 1 ) R -- ; dmin /= num_samples ; printf ( \"iter: %5d\\t alpha: %.4g\\t R: %d\\td_min: %.4g\\r\" , iter , alpha , R , dmin ) ; } putchar ( '\\n' ) ; for ( int i = 0 ; i < num_out ; i ++ ) free ( D [ i ] ) ; free ( D ) ; }",
    "resources/C/machine_learning/kohonen_som_topology.c@test_2d_classes": "void test_2d_classes ( double * const * data , int N ) { const double R = 0.3 ; // radius of cluster int i ; const int num_classes = 4 ; const double centres [ ] [ 2 ] = { // centres of each class cluster { .5 , .5 } , // centre of class 1 { .5 , - .5 } , // centre of class 2 { - .5 , .5 } , // centre of class 3 { - .5 , - .5 } // centre of class 4 } ; # ifdef _OPENMP # pragma omp for # endif for ( i = 0 ; i < N ; i ++ ) { int class = rand ( ) % num_classes ; // select a random class for the point // create random coordinates (x,y,z) around the centre of the class data [ i ] [ 0 ] = _random ( centres [ class ] [ 0 ] - R , centres [ class ] [ 0 ] + R ) ; data [ i ] [ 1 ] = _random ( centres [ class ] [ 1 ] - R , centres [ class ] [ 1 ] + R ) ; /* The follosing can also be used\n        for (int j = 0; j < 2; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */ } }",
    "resources/C/machine_learning/kohonen_som_topology.c@test1": "void test1 ( ) { int j , N = 300 ; int features = 2 ; int num_out = 30 ; // image size - N x N // 2D space, hence size = number of rows * 2 double * * X = ( double * * ) malloc ( N * sizeof ( double * ) ) ; // cluster nodex in 'x' * cluster nodes in 'y' * 2 struct kohonen_array_3d W ; W . dim1 = num_out ; W . dim2 = num_out ; W . dim3 = features ; W . data = ( double * ) malloc ( num_out * num_out * features * sizeof ( double ) ) ; // assign rows for ( int i = 0 ; i < max ( num_out , N ) ; i ++ ) // loop till max(N, num_out) { if ( i < N ) // only add new arrays if i < N X [ i ] = ( double * ) malloc ( features * sizeof ( double ) ) ; if ( i < num_out ) // only add new arrays if i < num_out { for ( int k = 0 ; k < num_out ; k ++ ) { # ifdef _OPENMP # pragma omp for # endif // preallocate with random initial weights for ( j = 0 ; j < features ; j ++ ) { double * w = kohonen_data_3d ( & W , i , k , j ) ; w [ 0 ] = _random ( - 5 , 5 ) ; } } } } test_2d_classes ( X , N ) ; // create test data around circumference of a circle save_2d_data ( \"test1.csv\" , X , N , features ) ; // save test data points save_u_matrix ( \"w11.csv\" , & W ) ; // save initial random weights kohonen_som ( X , & W , N , features , num_out , 1e-4 ) ; // train the SOM save_u_matrix ( \"w12.csv\" , & W ) ; // save the resultant weights for ( int i = 0 ; i < N ; i ++ ) free ( X [ i ] ) ; free ( X ) ; free ( W . data ) ; }",
    "resources/C/machine_learning/kohonen_som_topology.c@test_3d_classes1": "void test_3d_classes1 ( double * const * data , int N ) { const double R = 0.2 ; // radius of cluster int i ; const int num_classes = 4 ; const double centres [ ] [ 3 ] = { // centres of each class cluster { .5 , .5 , .5 } , // centre of class 1 { .5 , - .5 , - .5 } , // centre of class 2 { - .5 , .5 , .5 } , // centre of class 3 { - .5 , - .5 - .5 } // centre of class 4 } ; # ifdef _OPENMP # pragma omp for # endif for ( i = 0 ; i < N ; i ++ ) { int class = rand ( ) % num_classes ; // select a random class for the point // create random coordinates (x,y,z) around the centre of the class data [ i ] [ 0 ] = _random ( centres [ class ] [ 0 ] - R , centres [ class ] [ 0 ] + R ) ; data [ i ] [ 1 ] = _random ( centres [ class ] [ 1 ] - R , centres [ class ] [ 1 ] + R ) ; data [ i ] [ 2 ] = _random ( centres [ class ] [ 2 ] - R , centres [ class ] [ 2 ] + R ) ; /* The follosing can also be used\n        for (int j = 0; j < 3; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */ } }",
    "resources/C/machine_learning/kohonen_som_topology.c@test2": "void test2 ( ) { int j , N = 500 ; int features = 3 ; int num_out = 30 ; // image size - N x N // 3D space, hence size = number of rows * 3 double * * X = ( double * * ) malloc ( N * sizeof ( double * ) ) ; // cluster nodex in 'x' * cluster nodes in 'y' * 2 struct kohonen_array_3d W ; W . dim1 = num_out ; W . dim2 = num_out ; W . dim3 = features ; W . data = ( double * ) malloc ( num_out * num_out * features * sizeof ( double ) ) ; // assign rows for ( int i = 0 ; i < max ( num_out , N ) ; i ++ ) // loop till max(N, num_out) { if ( i < N ) // only add new arrays if i < N X [ i ] = ( double * ) malloc ( features * sizeof ( double ) ) ; if ( i < num_out ) // only add new arrays if i < num_out { for ( int k = 0 ; k < num_out ; k ++ ) { # ifdef _OPENMP # pragma omp for # endif for ( j = 0 ; j < features ; j ++ ) { // preallocate with random initial weights double * w = kohonen_data_3d ( & W , i , k , j ) ; w [ 0 ] = _random ( - 5 , 5 ) ; } } } } test_3d_classes1 ( X , N ) ; // create test data save_2d_data ( \"test2.csv\" , X , N , features ) ; // save test data points save_u_matrix ( \"w21.csv\" , & W ) ; // save initial random weights kohonen_som ( X , & W , N , features , num_out , 1e-4 ) ; // train the SOM save_u_matrix ( \"w22.csv\" , & W ) ; // save the resultant weights for ( int i = 0 ; i < N ; i ++ ) free ( X [ i ] ) ; free ( X ) ; free ( W . data ) ; }",
    "resources/C/machine_learning/kohonen_som_topology.c@test_3d_classes2": "void test_3d_classes2 ( double * const * data , int N ) { const double R = 0.2 ; // radius of cluster int i ; const int num_classes = 8 ; const double centres [ ] [ 3 ] = { // centres of each class cluster { .5 , .5 , .5 } , // centre of class 1 { .5 , .5 , - .5 } , // centre of class 2 { .5 , - .5 , .5 } , // centre of class 3 { .5 , - .5 , - .5 } , // centre of class 4 { - .5 , .5 , .5 } , // centre of class 5 { - .5 , .5 , - .5 } , // centre of class 6 { - .5 , - .5 , .5 } , // centre of class 7 { - .5 , - .5 , - .5 } // centre of class 8 } ; # ifdef _OPENMP # pragma omp for # endif for ( i = 0 ; i < N ; i ++ ) { int class = rand ( ) % num_classes ; // select a random class for the point // create random coordinates (x,y,z) around the centre of the class data [ i ] [ 0 ] = _random ( centres [ class ] [ 0 ] - R , centres [ class ] [ 0 ] + R ) ; data [ i ] [ 1 ] = _random ( centres [ class ] [ 1 ] - R , centres [ class ] [ 1 ] + R ) ; data [ i ] [ 2 ] = _random ( centres [ class ] [ 2 ] - R , centres [ class ] [ 2 ] + R ) ; /* The follosing can also be used\n        for (int j = 0; j < 3; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */ } }",
    "resources/C/machine_learning/kohonen_som_topology.c@test3": "void test3 ( ) { int j , N = 500 ; int features = 3 ; int num_out = 30 ; double * * X = ( double * * ) malloc ( N * sizeof ( double * ) ) ; // cluster nodex in 'x' * cluster nodes in 'y' * 2 struct kohonen_array_3d W ; W . dim1 = num_out ; W . dim2 = num_out ; W . dim3 = features ; W . data = ( double * ) malloc ( num_out * num_out * features * sizeof ( double ) ) ; // assign rows for ( int i = 0 ; i < max ( num_out , N ) ; i ++ ) // loop till max(N, num_out) { if ( i < N ) // only add new arrays if i < N X [ i ] = ( double * ) malloc ( features * sizeof ( double ) ) ; if ( i < num_out ) // only add new arrays if i < num_out { for ( int k = 0 ; k < num_out ; k ++ ) { # ifdef _OPENMP # pragma omp for # endif // preallocate with random initial weights for ( j = 0 ; j < features ; j ++ ) { double * w = kohonen_data_3d ( & W , i , k , j ) ; w [ 0 ] = _random ( - 5 , 5 ) ; } } } } test_3d_classes2 ( X , N ) ; // create test data around the lamniscate save_2d_data ( \"test3.csv\" , X , N , features ) ; // save test data points save_u_matrix ( \"w31.csv\" , & W ) ; // save initial random weights kohonen_som ( X , & W , N , features , num_out , 0.01 ) ; // train the SOM save_u_matrix ( \"w32.csv\" , & W ) ; // save the resultant weights for ( int i = 0 ; i < N ; i ++ ) free ( X [ i ] ) ; free ( X ) ; free ( W . data ) ; }",
    "resources/C/machine_learning/kohonen_som_topology.c@get_clock_diff": "double get_clock_diff ( clock_t start_t , clock_t end_t ) { return ( double ) ( end_t - start_t ) / ( double ) CLOCKS_PER_SEC ; }",
    "resources/C/machine_learning/kohonen_som_topology.c@main": "int main ( int argc , char * * argv ) { # ifdef _OPENMP printf ( \"Using OpenMP based parallelization\\n\" ) ; # else printf ( \"NOT using OpenMP based parallelization\\n\" ) ; # endif clock_t start_clk , end_clk ; start_clk = clock ( ) ; test1 ( ) ; end_clk = clock ( ) ; printf ( \"Test 1 completed in %.4g sec\\n\" , get_clock_diff ( start_clk , end_clk ) ) ; start_clk = clock ( ) ; test2 ( ) ; end_clk = clock ( ) ; printf ( \"Test 2 completed in %.4g sec\\n\" , get_clock_diff ( start_clk , end_clk ) ) ; start_clk = clock ( ) ; test3 ( ) ; end_clk = clock ( ) ; printf ( \"Test 3 completed in %.4g sec\\n\" , get_clock_diff ( start_clk , end_clk ) ) ; printf ( \"(Note: Calculated times include: writing files to disk.)\\n\\n\" ) ; return 0 ; }",
    "resources/C/machine_learning/adaline_learning.c@new_adaline": "struct adaline new_adaline ( const int num_features , const double eta ) { if ( eta <= 0.f || eta >= 1.f ) { fprintf ( stderr , \"learning rate should be > 0 and < 1\\n\" ) ; exit ( EXIT_FAILURE ) ; } // additional weight is for the constant bias term int num_weights = num_features + 1 ; struct adaline ada ; ada . eta = eta ; ada . num_weights = num_weights ; ada . weights = ( double * ) malloc ( num_weights * sizeof ( double ) ) ; if ( ! ada . weights ) { perror ( \"Unable to allocate error for weights!\" ) ; return ada ; } // initialize with random weights in the range [-50, 49] for ( int i = 0 ; i < num_weights ; i ++ ) ada . weights [ i ] = 1.f ; // ada.weights[i] = (double)(rand() % 100) - 50); return ada ; }",
    "resources/C/machine_learning/adaline_learning.c@delete_adaline": "void delete_adaline ( struct adaline * ada ) { if ( ada == NULL ) return ; free ( ada -> weights ) ; }",
    "resources/C/machine_learning/adaline_learning.c@adaline_activation": "int adaline_activation ( double x ) { return x > 0 ? 1 : - 1 ; }",
    "resources/C/machine_learning/adaline_learning.c@adaline_get_weights_str": "char * adaline_get_weights_str ( const struct adaline * ada ) { static char out [ 100 ] ; // static so the value is persistent sprintf ( out , \"<\" ) ; for ( int i = 0 ; i < ada -> num_weights ; i ++ ) { sprintf ( out , \"%s%.4g\" , out , ada -> weights [ i ] ) ; if ( i < ada -> num_weights - 1 ) sprintf ( out , \"%s, \" , out ) ; } sprintf ( out , \"%s>\" , out ) ; return out ; }",
    "resources/C/machine_learning/adaline_learning.c@adaline_predict": "int adaline_predict ( struct adaline * ada , const double * x , double * out ) { double y = ada -> weights [ ada -> num_weights - 1 ] ; // assign bias value for ( int i = 0 ; i < ada -> num_weights - 1 ; i ++ ) y += x [ i ] * ada -> weights [ i ] ; if ( out ) // if out variable is not NULL * out = y ; // quantizer: apply ADALINE threshold function return adaline_activation ( y ) ; }",
    "resources/C/machine_learning/adaline_learning.c@adaline_fit_sample": "double adaline_fit_sample ( struct adaline * ada , const double * x , const int y ) { /* output of the model with current weights */ int p = adaline_predict ( ada , x , NULL ) ; int prediction_error = y - p ; // error in estimation double correction_factor = ada -> eta * prediction_error ; /* update each weight, the last weight is the bias term */ for ( int i = 0 ; i < ada -> num_weights - 1 ; i ++ ) { ada -> weights [ i ] += correction_factor * x [ i ] ; } ada -> weights [ ada -> num_weights - 1 ] += correction_factor ; // update bias return correction_factor ; }",
    "resources/C/machine_learning/adaline_learning.c@adaline_fit": "void adaline_fit ( struct adaline * ada , double * * X , const int * y , const int N ) { double avg_pred_error = 1.f ; int iter ; for ( iter = 0 ; ( iter < MAX_ADALINE_ITER ) && ( avg_pred_error > ADALINE_ACCURACY ) ; iter ++ ) { avg_pred_error = 0.f ; // perform fit for each sample for ( int i = 0 ; i < N ; i ++ ) { double err = adaline_fit_sample ( ada , X [ i ] , y [ i ] ) ; avg_pred_error += fabs ( err ) ; } avg_pred_error /= N ; // Print updates every 200th iteration // if (iter % 100 == 0) printf ( \"\\tIter %3d: Training weights: %s\\tAvg error: %.4f\\n\" , iter , adaline_get_weights_str ( ada ) , avg_pred_error ) ; } if ( iter < MAX_ADALINE_ITER ) printf ( \"Converged after %d iterations.\\n\" , iter ) ; else printf ( \"Did not converged after %d iterations.\\n\" , iter ) ; }",
    "resources/C/machine_learning/adaline_learning.c@test1": "void test1 ( double eta ) { struct adaline ada = new_adaline ( 2 , eta ) ; // 2 features const int N = 10 ; // number of sample points const double saved_X [ 10 ] [ 2 ] = { { 0 , 1 } , { 1 , - 2 } , { 2 , 3 } , { 3 , - 1 } , { 4 , 1 } , { 6 , - 5 } , { - 7 , - 3 } , { - 8 , 5 } , { - 9 , 2 } , { - 10 , - 15 } } ; double * * X = ( double * * ) malloc ( N * sizeof ( double * ) ) ; const int Y [ 10 ] = { 1 , - 1 , 1 , - 1 , - 1 , - 1 , 1 , 1 , 1 , - 1 } ; // corresponding y-values for ( int i = 0 ; i < N ; i ++ ) { X [ i ] = ( double * ) saved_X [ i ] ; } printf ( \"------- Test 1 -------\\n\" ) ; printf ( \"Model before fit: %s\\n\" , adaline_get_weights_str ( & ada ) ) ; adaline_fit ( & ada , X , Y , N ) ; printf ( \"Model after fit: %s\\n\" , adaline_get_weights_str ( & ada ) ) ; double test_x [ ] = { 5 , - 3 } ; int pred = adaline_predict ( & ada , test_x , NULL ) ; printf ( \"Predict for x=(5,-3): % d\\n\" , pred ) ; assert ( pred == - 1 ) ; printf ( \" ...passed\\n\" ) ; double test_x2 [ ] = { 5 , 8 } ; pred = adaline_predict ( & ada , test_x2 , NULL ) ; printf ( \"Predict for x=(5, 8): % d\\n\" , pred ) ; assert ( pred == 1 ) ; printf ( \" ...passed\\n\" ) ; // for (int i = 0; i < N; i++) //     free(X[i]); free ( X ) ; delete_adaline ( & ada ) ; }",
    "resources/C/machine_learning/adaline_learning.c@test2": "void test2 ( double eta ) { struct adaline ada = new_adaline ( 2 , eta ) ; // 2 features const int N = 50 ; // number of sample points double * * X = ( double * * ) malloc ( N * sizeof ( double * ) ) ; int * Y = ( int * ) malloc ( N * sizeof ( int ) ) ; // corresponding y-values for ( int i = 0 ; i < N ; i ++ ) X [ i ] = ( double * ) malloc ( 2 * sizeof ( double ) ) ; // generate sample points in the interval // [-range2/100 , (range2-1)/100] int range = 500 ; // sample points full-range int range2 = range >> 1 ; // sample points half-range for ( int i = 0 ; i < N ; i ++ ) { double x0 = ( ( rand ( ) % range ) - range2 ) / 100.f ; double x1 = ( ( rand ( ) % range ) - range2 ) / 100.f ; X [ i ] [ 0 ] = x0 ; X [ i ] [ 1 ] = x1 ; Y [ i ] = ( x0 + 3. * x1 ) > - 1 ? 1 : - 1 ; } printf ( \"------- Test 2 -------\\n\" ) ; printf ( \"Model before fit: %s\\n\" , adaline_get_weights_str ( & ada ) ) ; adaline_fit ( & ada , X , Y , N ) ; printf ( \"Model after fit: %s\\n\" , adaline_get_weights_str ( & ada ) ) ; int N_test_cases = 5 ; double test_x [ 2 ] ; for ( int i = 0 ; i < N_test_cases ; i ++ ) { double x0 = ( ( rand ( ) % range ) - range2 ) / 100.f ; double x1 = ( ( rand ( ) % range ) - range2 ) / 100.f ; test_x [ 0 ] = x0 ; test_x [ 1 ] = x1 ; int pred = adaline_predict ( & ada , test_x , NULL ) ; printf ( \"Predict for x=(% 3.2f,% 3.2f): % d\\n\" , x0 , x1 , pred ) ; int expected_val = ( x0 + 3. * x1 ) > - 1 ? 1 : - 1 ; assert ( pred == expected_val ) ; printf ( \" ...passed\\n\" ) ; } for ( int i = 0 ; i < N ; i ++ ) free ( X [ i ] ) ; free ( X ) ; free ( Y ) ; delete_adaline ( & ada ) ; }",
    "resources/C/machine_learning/adaline_learning.c@test3": "void test3 ( double eta ) { struct adaline ada = new_adaline ( 6 , eta ) ; // 2 features const int N = 50 ; // number of sample points double * * X = ( double * * ) malloc ( N * sizeof ( double * ) ) ; int * Y = ( int * ) malloc ( N * sizeof ( int ) ) ; // corresponding y-values for ( int i = 0 ; i < N ; i ++ ) X [ i ] = ( double * ) malloc ( 6 * sizeof ( double ) ) ; // generate sample points in the interval // [-range2/100 , (range2-1)/100] int range = 200 ; // sample points full-range int range2 = range >> 1 ; // sample points half-range for ( int i = 0 ; i < N ; i ++ ) { double x0 = ( ( rand ( ) % range ) - range2 ) / 100.f ; double x1 = ( ( rand ( ) % range ) - range2 ) / 100.f ; double x2 = ( ( rand ( ) % range ) - range2 ) / 100.f ; X [ i ] [ 0 ] = x0 ; X [ i ] [ 1 ] = x1 ; X [ i ] [ 2 ] = x2 ; X [ i ] [ 3 ] = x0 * x0 ; X [ i ] [ 4 ] = x1 * x1 ; X [ i ] [ 5 ] = x2 * x2 ; Y [ i ] = ( x0 * x0 + x1 * x1 + x2 * x2 ) <= 1 ? 1 : - 1 ; } printf ( \"------- Test 3 -------\\n\" ) ; printf ( \"Model before fit: %s\\n\" , adaline_get_weights_str ( & ada ) ) ; adaline_fit ( & ada , X , Y , N ) ; printf ( \"Model after fit: %s\\n\" , adaline_get_weights_str ( & ada ) ) ; int N_test_cases = 5 ; double test_x [ 6 ] ; for ( int i = 0 ; i < N_test_cases ; i ++ ) { double x0 = ( ( rand ( ) % range ) - range2 ) / 100.f ; double x1 = ( ( rand ( ) % range ) - range2 ) / 100.f ; double x2 = ( ( rand ( ) % range ) - range2 ) / 100.f ; test_x [ 0 ] = x0 ; test_x [ 1 ] = x1 ; test_x [ 2 ] = x2 ; test_x [ 3 ] = x0 * x0 ; test_x [ 4 ] = x1 * x1 ; test_x [ 5 ] = x2 * x2 ; int pred = adaline_predict ( & ada , test_x , NULL ) ; printf ( \"Predict for x=(% 3.2f,% 3.2f): % d\\n\" , x0 , x1 , pred ) ; int expected_val = ( x0 * x0 + x1 * x1 + x2 * x2 ) <= 1 ? 1 : - 1 ; assert ( pred == expected_val ) ; printf ( \" ...passed\\n\" ) ; } for ( int i = 0 ; i < N ; i ++ ) free ( X [ i ] ) ; free ( X ) ; free ( Y ) ; delete_adaline ( & ada ) ; }",
    "resources/C/machine_learning/adaline_learning.c@main": "int main ( int argc , char * * argv ) { srand ( time ( NULL ) ) ; // initialize random number generator double eta = 0.1 ; // default value of eta if ( argc == 2 ) // read eta value from commandline argument if present eta = strtof ( argv [ 1 ] , NULL ) ; test1 ( eta ) ; printf ( \"Press ENTER to continue...\\n\" ) ; getchar ( ) ; test2 ( eta ) ; printf ( \"Press ENTER to continue...\\n\" ) ; getchar ( ) ; test3 ( eta ) ; return 0 ; }",
    "resources/C/numerical_methods/qr_decomposition.c@print_matrix": "void print_matrix ( double * * A , /**< matrix to print */ int M , /**< number of rows of matrix */ int N ) /**< number of columns of matrix */ { for ( int row = 0 ; row < M ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) printf ( \"% 9.3g\\t\" , A [ row ] [ col ] ) ; putchar ( '\\n' ) ; } putchar ( '\\n' ) ; }",
    "resources/C/numerical_methods/qr_decomposition.c@vector_dot": "double vector_dot ( double * a , double * b , int L ) { double mag = 0.f ; int i ; # ifdef _OPENMP // parallelize on threads # pragma omp parallel for reduction ( + : mag ) # endif for ( i = 0 ; i < L ; i ++ ) mag += a [ i ] * b [ i ] ; return mag ; }",
    "resources/C/numerical_methods/qr_decomposition.c@vector_mag": "double vector_mag ( double * vector , int L ) { double dot = vector_dot ( vector , vector , L ) ; return sqrt ( dot ) ; }",
    "resources/C/numerical_methods/qr_decomposition.c@vector_proj": "double * vector_proj ( double * a , double * b , double * out , int L ) { const double num = vector_dot ( a , b , L ) ; const double deno = vector_dot ( b , b , L ) ; if ( deno == 0 ) /*! check for division by zero */ return NULL ; const double scalar = num / deno ; int i ; # ifdef _OPENMP // parallelize on threads # pragma omp for # endif for ( i = 0 ; i < L ; i ++ ) out [ i ] = scalar * b [ i ] ; return out ; }",
    "resources/C/numerical_methods/qr_decomposition.c@vector_sub": "double * vector_sub ( double * a , /**< minuend */ double * b , /**< subtrahend */ double * out , /**< resultant vector */ int L /**< length of vectors */ ) { int i ; # ifdef _OPENMP // parallelize on threads # pragma omp for # endif for ( i = 0 ; i < L ; i ++ ) out [ i ] = a [ i ] - b [ i ] ; return out ; }",
    "resources/C/numerical_methods/qr_decomposition.c@qr_decompose": "void qr_decompose ( double * * A , /**< input matrix to decompose */ double * * Q , /**< output decomposed matrix */ double * * R , /**< output decomposed matrix */ int M , /**< number of rows of matrix A */ int N /**< number of columns of matrix A */ ) { double * col_vector = ( double * ) malloc ( M * sizeof ( double ) ) ; double * col_vector2 = ( double * ) malloc ( M * sizeof ( double ) ) ; double * tmp_vector = ( double * ) malloc ( M * sizeof ( double ) ) ; for ( int i = 0 ; i < N ; i ++ ) /* for each column => R is a square matrix of NxN */ { int j ; # ifdef _OPENMP // parallelize on threads # pragma omp for # endif for ( j = 0 ; j < i ; j ++ ) /* second dimension of column */ R [ i ] [ j ] = 0. ; /* make R upper triangular */ /* get corresponding Q vector */ # ifdef _OPENMP // parallelize on threads # pragma omp for # endif for ( j = 0 ; j < M ; j ++ ) { tmp_vector [ j ] = A [ j ] [ i ] ; /* accumulator for uk */ col_vector [ j ] = A [ j ] [ i ] ; } for ( j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < M ; k ++ ) col_vector2 [ k ] = Q [ k ] [ j ] ; vector_proj ( col_vector , col_vector2 , col_vector2 , M ) ; vector_sub ( tmp_vector , col_vector2 , tmp_vector , M ) ; } double mag = vector_mag ( tmp_vector , M ) ; # ifdef _OPENMP // parallelize on threads # pragma omp for # endif for ( j = 0 ; j < M ; j ++ ) Q [ j ] [ i ] = tmp_vector [ j ] / mag ; /* compute upper triangular values of R */ for ( int kk = 0 ; kk < M ; kk ++ ) col_vector [ kk ] = Q [ kk ] [ i ] ; for ( int k = i ; k < N ; k ++ ) { for ( int kk = 0 ; kk < M ; kk ++ ) col_vector2 [ kk ] = A [ kk ] [ k ] ; R [ i ] [ k ] = vector_dot ( col_vector , col_vector2 , M ) ; } } free ( col_vector ) ; free ( col_vector2 ) ; free ( tmp_vector ) ; }",
    "resources/C/numerical_methods/qr_decomposition.c@main": "int main ( void ) { double * * A ; unsigned int ROWS , COLUMNS ; printf ( \"Enter the number of rows and columns: \" ) ; scanf ( \"%u %u\" , & ROWS , & COLUMNS ) ; if ( ROWS < COLUMNS ) { fprintf ( stderr , \"Number of rows must be greater than or equal to \" \"number of columns.\\n\" ) ; return - 1 ; } printf ( \"Enter matrix elements row-wise:\\n\" ) ; A = ( double * * ) malloc ( ROWS * sizeof ( double * ) ) ; for ( int i = 0 ; i < ROWS ; i ++ ) A [ i ] = ( double * ) malloc ( COLUMNS * sizeof ( double ) ) ; for ( int i = 0 ; i < ROWS ; i ++ ) for ( int j = 0 ; j < COLUMNS ; j ++ ) scanf ( \"%lf\" , & A [ i ] [ j ] ) ; print_matrix ( A , ROWS , COLUMNS ) ; double * * R = ( double * * ) malloc ( sizeof ( double * ) * ROWS ) ; double * * Q = ( double * * ) malloc ( sizeof ( double * ) * ROWS ) ; if ( ! Q || ! R ) { perror ( \"Unable to allocate memory for Q & R!\" ) ; return - 1 ; } for ( int i = 0 ; i < ROWS ; i ++ ) { R [ i ] = ( double * ) malloc ( sizeof ( double ) * COLUMNS ) ; Q [ i ] = ( double * ) malloc ( sizeof ( double ) * ROWS ) ; if ( ! Q [ i ] || ! R [ i ] ) { perror ( \"Unable to allocate memory for Q & R.\" ) ; return - 1 ; } } clock_t t1 = clock ( ) ; qr_decompose ( A , Q , R , ROWS , COLUMNS ) ; double dtime = ( double ) ( clock ( ) - t1 ) / CLOCKS_PER_SEC ; print_matrix ( R , ROWS , COLUMNS ) ; print_matrix ( Q , ROWS , COLUMNS ) ; printf ( \"Time taken to compute: %.4g sec\\n\" , dtime ) ; for ( int i = 0 ; i < ROWS ; i ++ ) { free ( A [ i ] ) ; free ( R [ i ] ) ; free ( Q [ i ] ) ; } free ( A ) ; free ( R ) ; free ( Q ) ; return 0 ; }",
    "resources/C/numerical_methods/ode_midpoint_euler.c@problem": "void problem ( const double * x , double * y , double * dy ) { const double omega = 1.F ; // some const for the problem dy [ 0 ] = y [ 1 ] ; // x dot dy [ 1 ] = - omega * omega * y [ 0 ] ; // y dot }",
    "resources/C/numerical_methods/ode_midpoint_euler.c@exact_solution": "void exact_solution ( const double * x , double * y ) { y [ 0 ] = cos ( x [ 0 ] ) ; y [ 1 ] = - sin ( x [ 0 ] ) ; }",
    "resources/C/numerical_methods/ode_midpoint_euler.c@midpoint_euler_step": "void midpoint_euler_step ( double dx , double * x , double * y , double * dy ) { problem ( x , y , dy ) ; double tmp_x = ( * x ) + 0.5 * dx ; double tmp_y [ order ] ; int o ; for ( o = 0 ; o < order ; o ++ ) tmp_y [ o ] = y [ o ] + 0.5 * dx * dy [ o ] ; problem ( & tmp_x , tmp_y , dy ) ; for ( o = 0 ; o < order ; o ++ ) y [ o ] += dx * dy [ o ] ; }",
    "resources/C/numerical_methods/ode_midpoint_euler.c@midpoint_euler": "double midpoint_euler ( double dx , double x0 , double x_max , double * y , char save_to_file ) { double dy [ order ] ; FILE * fp = NULL ; if ( save_to_file ) { fp = fopen ( \"midpoint_euler.csv\" , \"w+\" ) ; if ( fp == NULL ) { perror ( \"Error! \" ) ; return - 1 ; } } /* start integration */ clock_t t1 = clock ( ) ; double x = x0 ; do // iterate for each step of independent variable { if ( save_to_file && fp ) fprintf ( fp , \"%.4g,%.4g,%.4g\\n\" , x , y [ 0 ] , y [ 1 ] ) ; // write to file midpoint_euler_step ( dx , & x , y , dy ) ; // perform integration x += dx ; // update step } while ( x <= x_max ) ; // till upper limit of independent variable /* end of integration */ clock_t t2 = clock ( ) ; if ( save_to_file && fp ) fclose ( fp ) ; return ( double ) ( t2 - t1 ) / CLOCKS_PER_SEC ; }",
    "resources/C/numerical_methods/ode_midpoint_euler.c@main": "int main ( int argc , char * argv [ ] ) { double X0 = 0.f ; /* initial value of x0 */ double X_MAX = 10.F ; /* upper limit of integration */ double Y0 [ ] = { 1.f , 0.f } ; /* initial value Y = y(x = x_0) */ double step_size ; if ( argc == 1 ) { printf ( \"\\nEnter the step size: \" ) ; scanf ( \"%lg\" , & step_size ) ; } else // use commandline argument as independent variable step size step_size = atof ( argv [ 1 ] ) ; // get approximate solution double total_time = midpoint_euler ( step_size , X0 , X_MAX , Y0 , 1 ) ; printf ( \"\\tTime = %.6g ms\\n\" , total_time ) ; /* compute exact solution for comparion */ FILE * fp = fopen ( \"exact.csv\" , \"w+\" ) ; if ( fp == NULL ) { perror ( \"Error! \" ) ; return - 1 ; } double x = X0 ; double * y = & ( Y0 [ 0 ] ) ; printf ( \"Finding exact solution\\n\" ) ; clock_t t1 = clock ( ) ; do { fprintf ( fp , \"%.4g,%.4g,%.4g\\n\" , x , y [ 0 ] , y [ 1 ] ) ; // write to file exact_solution ( & x , y ) ; x += step_size ; } while ( x <= X_MAX ) ; clock_t t2 = clock ( ) ; total_time = ( t2 - t1 ) / CLOCKS_PER_SEC ; printf ( \"\\tTime = %.6g ms\\n\" , total_time ) ; fclose ( fp ) ; return 0 ; }",
    "resources/C/numerical_methods/gauss_elimination.c@display": "void display ( float a [ ARRAY_SIZE ] [ ARRAY_SIZE ] , int n ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { printf ( \"%.2f \\t\" , a [ i ] [ j ] ) ; } printf ( \"\\n\" ) ; } }",
    "resources/C/numerical_methods/gauss_elimination.c@interchange": "float interchange ( float m [ ARRAY_SIZE ] [ ARRAY_SIZE ] , int i , int n ) { float tmp [ ARRAY_SIZE ] [ ARRAY_SIZE ] ; float max = fabs ( m [ i ] [ i ] ) ; int j , k = i ; for ( j = i ; j < n ; j ++ ) { if ( max < fabs ( m [ j ] [ i ] ) ) { max = fabs ( m [ j ] [ i ] ) ; k = j ; } } for ( j = 0 ; j <= n ; j ++ ) { tmp [ i ] [ j ] = m [ i ] [ j ] ; m [ i ] [ j ] = m [ k ] [ j ] ; m [ k ] [ j ] = tmp [ i ] [ j ] ; } return m [ ARRAY_SIZE - 1 ] [ ARRAY_SIZE - 1 ] ; }",
    "resources/C/numerical_methods/gauss_elimination.c@eliminate": "float eliminate ( float m [ ARRAY_SIZE ] [ ARRAY_SIZE ] , int i , int n ) { float tmp ; int k = 1 , l , j ; for ( j = i ; j < n - 1 ; j ++ ) { tmp = - ( ( m [ i + k ] [ i ] ) / ( m [ i ] [ i ] ) ) ; for ( l = 0 ; l <= n ; l ++ ) { m [ i + k ] [ l ] = ( m [ i + k ] [ l ] ) + ( m [ i ] [ l ] * tmp ) ; } k ++ ; } return m [ ARRAY_SIZE - 1 ] [ ARRAY_SIZE - 1 ] ; }",
    "resources/C/numerical_methods/gauss_elimination.c@main": "int main ( void ) { int i , j , n , k = 0 , l ; float m [ ARRAY_SIZE ] [ ARRAY_SIZE ] , mul , tmp [ ARRAY_SIZE ] [ ARRAY_SIZE ] , val , ans [ ARRAY_SIZE ] ; printf ( \"Total No.of Equations : \" ) ; scanf ( \"%d\" , & n ) ; printf ( \"\\n\" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"Enter Co-efficient Of Equations %d & Total --->>>\\n\" , i + 1 ) ; for ( j = 0 ; j <= n ; j ++ ) { printf ( \"r%d%d : \" , i , j ) ; scanf ( \"%f\" , & m [ i ] [ j ] ) ; } printf ( \"\\n\" ) ; } printf ( \":::::::::::: Current Matrix ::::::::::::\\n\\n\" ) ; display ( m , n ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { printf ( \"\\n------->>>>>>>>>>>>>>>>>>>>>>>>-------- %d\\n\" , i + 1 ) ; m [ ARRAY_SIZE - 1 ] [ ARRAY_SIZE - 1 ] = interchange ( m , i , n ) ; display ( m , n ) ; printf ( \"\\n_______________________________________\\n\" ) ; m [ ARRAY_SIZE - 1 ] [ ARRAY_SIZE - 1 ] = eliminate ( m , i , n ) ; display ( m , n ) ; } printf ( \"\\n\\n Values are : \\n\" ) ; for ( i = n - 1 ; i >= 0 ; i -- ) { l = n - 1 ; mul = 0 ; for ( j = 0 ; j < k ; j ++ ) { mul = mul + m [ i ] [ l ] * ans [ l ] ; l -- ; } k ++ ; ans [ i ] = ( m [ i ] [ n ] - mul ) / m [ i ] [ i ] ; printf ( \"X%d = %.2f\\n\" , i + 1 , ans [ i ] ) ; } return 0 ; }",
    "resources/C/numerical_methods/realtime_stats.c@stats_computer1": "void stats_computer1 ( float x , float * mean , float * variance , float * std ) { /* following variables declared static becuase they need to be remembered\n     * when updating for next sample, when received.\n     */ static unsigned int n = 0 ; static float Ex = 0.f , Ex2 = 0.f ; static float K = 0.f ; if ( n == 0 ) K = x ; n ++ ; float tmp = x - K ; Ex += tmp ; Ex2 += tmp * tmp ; /* return sample mean computed till last sample */ if ( mean != NULL ) * mean = K + Ex / n ; /* return data variance computed till last sample */ if ( variance != NULL ) * variance = ( Ex2 - ( Ex * Ex ) / n ) / ( n - 1 ) ; /* return sample standard deviation computed till last sample */ if ( std != NULL ) * std = sqrtf ( * variance ) ; }",
    "resources/C/numerical_methods/realtime_stats.c@stats_computer2": "void stats_computer2 ( float x , float * mean , float * variance , float * std ) { /* following variables declared static becuase they need to be remembered\n     * when updating for next sample, when received.\n     */ static unsigned int n = 0 ; static float mu = 0 , M = 0 ; n ++ ; float delta = x - mu ; mu += delta / n ; float delta2 = x - mu ; M += delta * delta2 ; /* return sample mean computed till last sample */ if ( mean != NULL ) * mean = mu ; /* return data variance computed till last sample */ if ( variance != NULL ) * variance = M / n ; /* return sample standard deviation computed till last sample */ if ( std != NULL ) * std = sqrtf ( * variance ) ; }",
    "resources/C/numerical_methods/realtime_stats.c@test_function": "void test_function ( const float * test_data , const int number_of_samples ) { float ref_mean = 0.f , ref_variance = 0.f ; float s1_mean = 0.f , s1_variance = 0.f , s1_std = 0.f ; float s2_mean = 0.f , s2_variance = 0.f , s2_std = 0.f ; for ( int i = 0 ; i < number_of_samples ; i ++ ) { stats_computer1 ( test_data [ i ] , & s1_mean , & s1_variance , & s1_std ) ; stats_computer2 ( test_data [ i ] , & s2_mean , & s2_variance , & s2_std ) ; ref_mean += test_data [ i ] ; } ref_mean /= number_of_samples ; for ( int i = 0 ; i < number_of_samples ; i ++ ) { float temp = test_data [ i ] - ref_mean ; ref_variance += temp * temp ; } ref_variance /= number_of_samples ; printf ( \"<<<<<<<< Test Function >>>>>>>>\\n\" ) ; printf ( \"Expected: Mean: %.4f\\t Variance: %.4f\\n\" , ref_mean , ref_variance ) ; printf ( \"\\tMethod 1:\\tMean: %.4f\\t Variance: %.4f\\t Std: %.4f\\n\" , s1_mean , s1_variance , s1_std ) ; printf ( \"\\tMethod 2:\\tMean: %.4f\\t Variance: %.4f\\t Std: %.4f\\n\" , s2_mean , s2_variance , s2_std ) ; assert ( fabs ( s1_mean - ref_mean ) < 0.01 ) ; assert ( fabs ( s2_mean - ref_mean ) < 0.01 ) ; assert ( fabs ( s2_variance - ref_variance ) < 0.01 ) ; printf ( \"(Tests passed)\\n\\n\" ) ; }",
    "resources/C/numerical_methods/realtime_stats.c@main": "int main ( int argc , char * * argv ) { const float test_data1 [ ] = { 3 , 4 , 5 , - 1.4 , - 3.6 , 1.9 , 1. } ; test_function ( test_data1 , sizeof ( test_data1 ) / sizeof ( test_data1 [ 0 ] ) ) ; float s1_mean = 0.f , s1_variance = 0.f , s1_std = 0.f ; float s2_mean = 0.f , s2_variance = 0.f , s2_std = 0.f ; printf ( \"Enter data. Any non-numeric data will terminate the data input.\\n\" ) ; while ( 1 ) { float val ; printf ( \"Enter number: \" ) ; // check for failure to read input. Happens for // non-numeric data if ( ! scanf ( \"%f\" , & val ) ) break ; stats_computer1 ( val , & s1_mean , & s1_variance , & s1_std ) ; stats_computer2 ( val , & s2_mean , & s2_variance , & s2_std ) ; printf ( \"\\tMethod 1:\\tMean: %.4f\\t Variance: %.4f\\t Std: %.4f\\n\" , s1_mean , s1_variance , s1_std ) ; printf ( \"\\tMethod 2:\\tMean: %.4f\\t Variance: %.4f\\t Std: %.4f\\n\" , s2_mean , s2_variance , s2_std ) ; } return 0 ; }",
    "resources/C/numerical_methods/ode_forward_euler.c@problem": "void problem ( const double * x , double * y , double * dy ) { const double omega = 1.F ; // some const for the problem dy [ 0 ] = y [ 1 ] ; // x dot dy [ 1 ] = - omega * omega * y [ 0 ] ; // y dot }",
    "resources/C/numerical_methods/ode_forward_euler.c@exact_solution": "void exact_solution ( const double * x , double * y ) { y [ 0 ] = cos ( x [ 0 ] ) ; y [ 1 ] = - sin ( x [ 0 ] ) ; }",
    "resources/C/numerical_methods/ode_forward_euler.c@forward_euler_step": "void forward_euler_step ( const double dx , const double * x , double * y , double * dy ) { int o ; problem ( x , y , dy ) ; for ( o = 0 ; o < order ; o ++ ) y [ o ] += dx * dy [ o ] ; }",
    "resources/C/numerical_methods/ode_forward_euler.c@forward_euler": "double forward_euler ( double dx , double x0 , double x_max , double * y , char save_to_file ) { double dy [ order ] ; FILE * fp = NULL ; if ( save_to_file ) { fp = fopen ( \"forward_euler.csv\" , \"w+\" ) ; if ( fp == NULL ) { perror ( \"Error! \" ) ; return - 1 ; } } /* start integration */ clock_t t1 = clock ( ) ; double x = x0 ; do // iterate for each step of independent variable { if ( save_to_file && fp ) fprintf ( fp , \"%.4g,%.4g,%.4g\\n\" , x , y [ 0 ] , y [ 1 ] ) ; // write to file forward_euler_step ( dx , & x , y , dy ) ; // perform integration x += dx ; // update step } while ( x <= x_max ) ; // till upper limit of independent variable /* end of integration */ clock_t t2 = clock ( ) ; if ( save_to_file && fp ) fclose ( fp ) ; return ( double ) ( t2 - t1 ) / CLOCKS_PER_SEC ; }",
    "resources/C/numerical_methods/ode_forward_euler.c@main": "int main ( int argc , char * argv [ ] ) { double X0 = 0.f ; /* initial value of x0 */ double X_MAX = 10.F ; /* upper limit of integration */ double Y0 [ ] = { 1.f , 0.f } ; /* initial value Y = y(x = x_0) */ double step_size ; if ( argc == 1 ) { printf ( \"\\nEnter the step size: \" ) ; scanf ( \"%lg\" , & step_size ) ; } else // use commandline argument as independent variable step size step_size = atof ( argv [ 1 ] ) ; // get approximate solution double total_time = forward_euler ( step_size , X0 , X_MAX , Y0 , 1 ) ; printf ( \"\\tTime = %.6g ms\\n\" , total_time ) ; /* compute exact solution for comparion */ FILE * fp = fopen ( \"exact.csv\" , \"w+\" ) ; if ( fp == NULL ) { perror ( \"Error! \" ) ; return - 1 ; } double x = X0 ; double * y = & ( Y0 [ 0 ] ) ; printf ( \"Finding exact solution\\n\" ) ; clock_t t1 = clock ( ) ; do { fprintf ( fp , \"%.4g,%.4g,%.4g\\n\" , x , y [ 0 ] , y [ 1 ] ) ; // write to file exact_solution ( & x , y ) ; x += step_size ; } while ( x <= X_MAX ) ; clock_t t2 = clock ( ) ; total_time = ( t2 - t1 ) / CLOCKS_PER_SEC ; printf ( \"\\tTime = %.6g ms\\n\" , total_time ) ; fclose ( fp ) ; return 0 ; }",
    "resources/C/numerical_methods/mean.c@main": "int main ( int argc , char * * argv ) { int * a , n = 10 , i , j , temp , sum = 0 ; float mean ; if ( argc == 2 ) { n = atoi ( argv [ 1 ] ) ; if ( n >= MAX_LEN ) { fprintf ( stderr , \"Maximum %d!\\n\" , MAX_LEN ) ; return 1 ; } } a = ( int * ) malloc ( n * sizeof ( int ) ) ; printf ( \"Random Numbers Generated are: \" ) ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = rand ( ) % 100 ; printf ( \"%2d, \" , a [ i ] ) ; } putchar ( '\\n' ) ; for ( i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; mean = sum / ( float ) n ; printf ( \"\\nMean: \" ) ; printf ( \"%f\\n\" , mean ) ; free ( a ) ; return 0 ; }",
    "resources/C/numerical_methods/bisection_method.c@sign": "double sign ( double a , double b ) { return ( a > 0 && b > 0 ) + ( a < 0 && b < 0 ) - ( a > 0 && b < 0 ) - ( a < 0 && b > 0 ) ; }",
    "resources/C/numerical_methods/bisection_method.c@func": "double func ( double x ) { return x * x * x + 2.0 * x - 10.0 ; // f(x) = x**3 + 2x - 10 }",
    "resources/C/numerical_methods/bisection_method.c@bisection": "double bisection ( double x_left , double x_right , double tolerance ) { int n = 1 ; // step counter double middle ; // midpoint while ( n <= NMAX ) { middle = ( x_left + x_right ) / 2 ; // bisect the interval double error = middle - x_left ; if ( fabs ( func ( middle ) ) < EPSILON || error < tolerance ) { return middle ; } if ( sign ( func ( middle ) , func ( x_left ) ) > 0.0 ) { x_left = middle ; // new lower endpoint } else { x_right = middle ; // new upper endpoint } n ++ ; // increase step counter } return - 1 ; // method failed (maximum number of steps exceeded) }",
    "resources/C/numerical_methods/bisection_method.c@test": "static void test ( ) { /* Compares root value that is found by the bisection method within a given\n     * floating point error*/ assert ( fabs ( bisection ( 1.0 , 2.0 , 0.0001 ) - 1.847473 ) < EPSILON ) ; // the algorithm works as expected assert ( fabs ( bisection ( 100.0 , 250.0 , 0.0001 ) - 249.999928 ) < EPSILON ) ; // the algorithm works as expected printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/numerical_methods/bisection_method.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/numerical_methods/median.c@main": "int main ( ) { int a [ 10 ] , n , i , j , temp ; float mean , median ; printf ( \"Enter no. for Random Numbers :\" ) ; scanf ( \"%d\" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = rand ( ) % 100 ; } printf ( \"Random Numbers Generated are :\\n\" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"\\n%d\" , a [ i ] ) ; } printf ( \"\\n\" ) ; printf ( \"\\nSorted Data:\" ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( a [ i ] < a [ j ] ) { temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; } } } for ( i = 0 ; i < n ; i ++ ) { printf ( \"\\n%d\" , a [ i ] ) ; } if ( n % 2 == 0 ) { median = ( a [ n / 2 ] + a [ ( n / 2 ) - 1 ] ) / 2 ; } else { median = a [ n / 2 ] ; } printf ( \"\\nMedian is : %f\" , median ) ; return 0 ; }",
    "resources/C/numerical_methods/variance.c@main": "int main ( ) { int * ARRAY = NULL , ARRAY_LENGTH , i , TEMPORARY_ELEMENT , isSorted = 0 ; float MEAN = 0 , VARIANCE = 0 , STAND ; printf ( \"Enter no. for Random Numbers :\" ) ; scanf ( \"%d\" , & ARRAY_LENGTH ) ; ARRAY = ( int * ) realloc ( ARRAY , ARRAY_LENGTH * ( sizeof ( int ) ) ) ; // We allocate the dedicated memory for ( i = 0 ; i < ARRAY_LENGTH ; i ++ ) // We generate the random numbers ARRAY [ i ] = rand ( ) % 100 ; printf ( \"Random Numbers Generated are :\\n\" ) ; // We display them for ( i = 0 ; i < ARRAY_LENGTH ; i ++ ) printf ( \"%d \" , ARRAY [ i ] ) ; printf ( \"\\nSorted Data: \" ) ; // Then we sort it using Bubble Sort.. while ( ! isSorted ) { // While our array's not sorted isSorted = 1 ; // we suppose that it's sorted for ( i = 0 ; i < ARRAY_LENGTH - 1 ; i ++ ) { // then for each element of the array if ( ARRAY [ i ] > ARRAY [ i + 1 ] ) { // if the two elements aren't sorted isSorted = 0 ; // it means that the array is not sorted TEMPORARY_ELEMENT = ARRAY [ i ] ; // and we switch these elements // using TEMPORARY_ELEMENT ARRAY [ i ] = ARRAY [ i + 1 ] ; ARRAY [ i + 1 ] = TEMPORARY_ELEMENT ; } } } for ( i = 0 ; i < ARRAY_LENGTH ; i ++ ) { printf ( \"%d \" , ARRAY [ i ] ) ; MEAN = MEAN + ARRAY [ i ] ; } MEAN = MEAN / ( float ) ARRAY_LENGTH ; for ( i = 0 ; i < ARRAY_LENGTH ; i ++ ) VARIANCE = VARIANCE + ( pow ( ( ARRAY [ i ] - MEAN ) , 2 ) ) ; VARIANCE = VARIANCE / ( float ) ARRAY_LENGTH ; STAND = sqrt ( VARIANCE ) ; printf ( \"\\n\\n- Mean is: %f\\n\" , MEAN ) ; printf ( \"- Variance is: %f\\n\" , VARIANCE ) ; printf ( \"- Standard Deviation is: %f\\n\" , STAND ) ; }",
    "resources/C/numerical_methods/qr_eigen_values.c@print_matrix": "void print_matrix ( double * * A , /**< matrix to print */ int M , /**< number of rows of matrix */ int N ) /**< number of columns of matrix */ { for ( int row = 0 ; row < M ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) printf ( \"% 9.3g\\t\" , A [ row ] [ col ] ) ; putchar ( '\\n' ) ; } putchar ( '\\n' ) ; }",
    "resources/C/numerical_methods/qr_eigen_values.c@vector_dot": "double vector_dot ( double * a , double * b , int L ) { double mag = 0.f ; int i ; # ifdef _OPENMP // parallelize on threads # pragma omp parallel for reduction ( + : mag ) # endif for ( i = 0 ; i < L ; i ++ ) mag += a [ i ] * b [ i ] ; return mag ; }",
    "resources/C/numerical_methods/qr_eigen_values.c@vector_mag": "double vector_mag ( double * vector , int L ) { double dot = vector_dot ( vector , vector , L ) ; return sqrt ( dot ) ; }",
    "resources/C/numerical_methods/qr_eigen_values.c@vector_proj": "double * vector_proj ( double * a , double * b , double * out , int L ) { const double num = vector_dot ( a , b , L ) ; const double deno = vector_dot ( b , b , L ) ; if ( deno == 0 ) /*! check for division by zero */ return NULL ; const double scalar = num / deno ; int i ; # ifdef _OPENMP // parallelize on threads # pragma omp for # endif for ( i = 0 ; i < L ; i ++ ) out [ i ] = scalar * b [ i ] ; return out ; }",
    "resources/C/numerical_methods/qr_eigen_values.c@vector_sub": "double * vector_sub ( double * a , /**< minuend */ double * b , /**< subtrahend */ double * out , /**< resultant vector */ int L /**< length of vectors */ ) { int i ; # ifdef _OPENMP // parallelize on threads # pragma omp for # endif for ( i = 0 ; i < L ; i ++ ) out [ i ] = a [ i ] - b [ i ] ; return out ; }",
    "resources/C/numerical_methods/qr_eigen_values.c@qr_decompose": "void qr_decompose ( double * * A , /**< input matrix to decompose */ double * * Q , /**< output decomposed matrix */ double * * R , /**< output decomposed matrix */ int M , /**< number of rows of matrix A */ int N /**< number of columns of matrix A */ ) { double * col_vector = ( double * ) malloc ( M * sizeof ( double ) ) ; double * col_vector2 = ( double * ) malloc ( M * sizeof ( double ) ) ; double * tmp_vector = ( double * ) malloc ( M * sizeof ( double ) ) ; for ( int i = 0 ; i < N ; i ++ ) /* for each column => R is a square matrix of NxN */ { int j ; # ifdef _OPENMP // parallelize on threads # pragma omp for # endif for ( j = 0 ; j < i ; j ++ ) /* second dimension of column */ R [ i ] [ j ] = 0. ; /* make R upper triangular */ /* get corresponding Q vector */ # ifdef _OPENMP // parallelize on threads # pragma omp for # endif for ( j = 0 ; j < M ; j ++ ) { tmp_vector [ j ] = A [ j ] [ i ] ; /* accumulator for uk */ col_vector [ j ] = A [ j ] [ i ] ; } for ( j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < M ; k ++ ) col_vector2 [ k ] = Q [ k ] [ j ] ; vector_proj ( col_vector , col_vector2 , col_vector2 , M ) ; vector_sub ( tmp_vector , col_vector2 , tmp_vector , M ) ; } double mag = vector_mag ( tmp_vector , M ) ; # ifdef _OPENMP // parallelize on threads # pragma omp for # endif for ( j = 0 ; j < M ; j ++ ) Q [ j ] [ i ] = tmp_vector [ j ] / mag ; /* compute upper triangular values of R */ for ( int kk = 0 ; kk < M ; kk ++ ) col_vector [ kk ] = Q [ kk ] [ i ] ; for ( int k = i ; k < N ; k ++ ) { for ( int kk = 0 ; kk < M ; kk ++ ) col_vector2 [ kk ] = A [ kk ] [ k ] ; R [ i ] [ k ] = vector_dot ( col_vector , col_vector2 , M ) ; } } free ( col_vector ) ; free ( col_vector2 ) ; free ( tmp_vector ) ; }",
    "resources/C/numerical_methods/qr_eigen_values.c@create_matrix": "void create_matrix ( double * * A , int N ) { int i , j , tmp , lim2 = LIMS >> 1 ; # ifdef _OPENMP # pragma omp for # endif for ( i = 0 ; i < N ; i ++ ) { A [ i ] [ i ] = ( rand ( ) % LIMS ) - lim2 ; for ( j = i + 1 ; j < N ; j ++ ) { tmp = ( rand ( ) % LIMS ) - lim2 ; A [ i ] [ j ] = tmp ; A [ j ] [ i ] = tmp ; } } }",
    "resources/C/numerical_methods/qr_eigen_values.c@mat_mul": "double * * mat_mul ( double * * A , double * * B , double * * OUT , int R1 , int C1 , int R2 , int C2 ) { if ( C1 != R2 ) { perror ( \"Matrix dimensions mismatch!\" ) ; return OUT ; } int i ; # ifdef _OPENMP # pragma omp for # endif for ( i = 0 ; i < R1 ; i ++ ) { for ( int j = 0 ; j < C2 ; j ++ ) { OUT [ i ] [ j ] = 0.f ; for ( int k = 0 ; k < C1 ; k ++ ) OUT [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] ; } } return OUT ; }",
    "resources/C/numerical_methods/qr_eigen_values.c@eigen_values": "double eigen_values ( double * * A , double * eigen_vals , int mat_size , char debug_print ) { if ( ! eigen_vals ) { perror ( \"Output eigen value vector cannot be NULL!\" ) ; return - 1 ; } double * * R = ( double * * ) malloc ( sizeof ( double * ) * mat_size ) ; double * * Q = ( double * * ) malloc ( sizeof ( double * ) * mat_size ) ; if ( ! Q || ! R ) { perror ( \"Unable to allocate memory for Q & R!\" ) ; if ( Q ) { free ( Q ) ; } if ( R ) { free ( R ) ; } return - 1 ; } /* allocate dynamic memory for matrices */ for ( int i = 0 ; i < mat_size ; i ++ ) { R [ i ] = ( double * ) malloc ( sizeof ( double ) * mat_size ) ; Q [ i ] = ( double * ) malloc ( sizeof ( double ) * mat_size ) ; if ( ! Q [ i ] || ! R [ i ] ) { perror ( \"Unable to allocate memory for Q & R.\" ) ; for ( ; i >= 0 ; i -- ) { free ( R [ i ] ) ; free ( Q [ i ] ) ; } free ( Q ) ; free ( R ) ; return - 1 ; } } if ( debug_print ) { print_matrix ( A , mat_size , mat_size ) ; } int rows = mat_size , columns = mat_size ; int counter = 0 , num_eigs = rows - 1 ; double last_eig = 0 ; clock_t t1 = clock ( ) ; while ( num_eigs > 0 ) /* continue till all eigen values are found */ { /* iterate with QR decomposition */ while ( fabs ( A [ num_eigs ] [ num_eigs - 1 ] ) > EPSILON ) { last_eig = A [ num_eigs ] [ num_eigs ] ; for ( int i = 0 ; i < rows ; i ++ ) A [ i ] [ i ] -= last_eig ; /* A - cI */ qr_decompose ( A , Q , R , rows , columns ) ; if ( debug_print ) { print_matrix ( A , rows , columns ) ; print_matrix ( Q , rows , columns ) ; print_matrix ( R , columns , columns ) ; printf ( \"-------------------- %d ---------------------\\n\" , ++ counter ) ; } mat_mul ( R , Q , A , columns , columns , rows , columns ) ; for ( int i = 0 ; i < rows ; i ++ ) A [ i ] [ i ] += last_eig ; /* A + cI */ } /* store the converged eigen value */ eigen_vals [ num_eigs ] = last_eig ; if ( debug_print ) { printf ( \"========================\\n\" ) ; printf ( \"Eigen value: % g,\\n\" , last_eig ) ; printf ( \"========================\\n\" ) ; } num_eigs -- ; rows -- ; columns -- ; } eigen_vals [ 0 ] = A [ 0 ] [ 0 ] ; double dtime = ( double ) ( clock ( ) - t1 ) / CLOCKS_PER_SEC ; if ( debug_print ) { print_matrix ( R , mat_size , mat_size ) ; print_matrix ( Q , mat_size , mat_size ) ; } /* cleanup dynamic memory */ for ( int i = 0 ; i < mat_size ; i ++ ) { free ( R [ i ] ) ; free ( Q [ i ] ) ; } free ( R ) ; free ( Q ) ; return dtime ; }",
    "resources/C/numerical_methods/qr_eigen_values.c@test1": "void test1 ( ) { int mat_size = 2 ; double X [ ] [ 2 ] = { { 5 , 7 } , { 7 , 11 } } ; double y [ ] = { 15.56158 , 0.384227 } ; // corresponding y-values double eig_vals [ 2 ] = { 0 , 0 } ; // The following steps are to convert a \"double[][]\" to \"double **\" double * * A = ( double * * ) malloc ( mat_size * sizeof ( double * ) ) ; for ( int i = 0 ; i < mat_size ; i ++ ) A [ i ] = X [ i ] ; printf ( \"------- Test 1 -------\\n\" ) ; double dtime = eigen_values ( A , eig_vals , mat_size , 0 ) ; for ( int i = 0 ; i < mat_size ; i ++ ) { printf ( \"%d/5 Checking for %.3g --> \" , i + 1 , y [ i ] ) ; char result = 0 ; for ( int j = 0 ; j < mat_size && ! result ; j ++ ) { if ( fabs ( y [ i ] - eig_vals [ j ] ) < 0.1 ) { result = 1 ; printf ( \"(%.3g) \" , eig_vals [ j ] ) ; } } // ensure that i^th expected eigen value was computed assert ( result != 0 ) ; printf ( \"found\\n\" ) ; } printf ( \"Test 1 Passed in %.3g sec\\n\\n\" , dtime ) ; free ( A ) ; }",
    "resources/C/numerical_methods/qr_eigen_values.c@test2": "void test2 ( ) { int mat_size = 5 ; double X [ ] [ 5 ] = { { - 4 , 4 , 2 , 0 , - 3 } , { 4 , - 4 , 4 , - 3 , - 1 } , { 2 , 4 , 4 , 3 , - 3 } , { 0 , - 3 , 3 , - 1 , - 3 } , { - 3 , - 1 , - 3 , - 3 , 0 } } ; double y [ ] = { 9.27648 , - 9.26948 , 2.0181 , - 1.03516 , - 5.98994 } ; // corresponding y-values double eig_vals [ 5 ] ; // The following steps are to convert a \"double[][]\" to \"double **\" double * * A = ( double * * ) malloc ( mat_size * sizeof ( double * ) ) ; for ( int i = 0 ; i < mat_size ; i ++ ) A [ i ] = X [ i ] ; printf ( \"------- Test 2 -------\\n\" ) ; double dtime = eigen_values ( A , eig_vals , mat_size , 0 ) ; for ( int i = 0 ; i < mat_size ; i ++ ) { printf ( \"%d/5 Checking for %.3g --> \" , i + 1 , y [ i ] ) ; char result = 0 ; for ( int j = 0 ; j < mat_size && ! result ; j ++ ) { if ( fabs ( y [ i ] - eig_vals [ j ] ) < 0.1 ) { result = 1 ; printf ( \"(%.3g) \" , eig_vals [ j ] ) ; } } // ensure that i^th expected eigen value was computed assert ( result != 0 ) ; printf ( \"found\\n\" ) ; } printf ( \"Test 2 Passed in %.3g sec\\n\\n\" , dtime ) ; free ( A ) ; }",
    "resources/C/numerical_methods/qr_eigen_values.c@main": "int main ( int argc , char * * argv ) { srand ( time ( NULL ) ) ; int mat_size = 5 ; if ( argc == 2 ) { mat_size = atoi ( argv [ 1 ] ) ; } else { // if invalid input argument is given run tests test1 ( ) ; test2 ( ) ; printf ( \"Usage: ./qr_eigen_values [mat_size]\\n\" ) ; return 0 ; } if ( mat_size < 2 ) { fprintf ( stderr , \"Matrix size should be > 2\\n\" ) ; return - 1 ; } int i ; double * * A = ( double * * ) malloc ( sizeof ( double * ) * mat_size ) ; /* number of eigen values = matrix size */ double * eigen_vals = ( double * ) malloc ( sizeof ( double ) * mat_size ) ; if ( ! eigen_vals ) { perror ( \"Unable to allocate memory for eigen values!\" ) ; free ( A ) ; return - 1 ; } for ( i = 0 ; i < mat_size ; i ++ ) { A [ i ] = ( double * ) malloc ( sizeof ( double ) * mat_size ) ; eigen_vals [ i ] = 0.f ; } /* create a random matrix */ create_matrix ( A , mat_size ) ; print_matrix ( A , mat_size , mat_size ) ; double dtime = eigen_values ( A , eigen_vals , mat_size , 0 ) ; printf ( \"Eigen vals: \" ) ; for ( i = 0 ; i < mat_size ; i ++ ) printf ( \"% 9.4g\\t\" , eigen_vals [ i ] ) ; printf ( \"\\nTime taken to compute: % .4g sec\\n\" , dtime ) ; for ( int i = 0 ; i < mat_size ; i ++ ) free ( A [ i ] ) ; free ( A ) ; free ( eigen_vals ) ; return 0 ; }",
    "resources/C/numerical_methods/gauss_seidel_method.c@main": "int main ( ) { float a , b , c , a1 , a2 , a3 , b1 , b2 , b3 , c1 , c2 , c3 , d1 , d2 , d3 , x1 , x2 , x3 ; printf ( \"Enter values of eq1:\" ) ; scanf ( \"%f%f%f%f\" , & a1 , & a2 , & a3 , & d1 ) ; printf ( \"Enter values of eq2:\" ) ; scanf ( \"%f%f%f%f\" , & b1 , & b2 , & b3 , & d2 ) ; printf ( \"Enter values of eq3:\" ) ; scanf ( \"%f%f%f%f\" , & c1 , & c2 , & c3 , & d3 ) ; x1 = x2 = x3 = 0.0 ; do { a = x1 ; b = x2 ; c = x3 ; x1 = ( 1 / a1 ) * ( d1 - ( a2 * x2 ) - ( a3 * x3 ) ) ; x2 = ( 1 / b2 ) * ( d2 - ( b1 * x1 ) - ( b3 * x3 ) ) ; x3 = ( 1 / c3 ) * ( d3 - ( c1 * x1 ) - ( c2 * x2 ) ) ; } while ( fabs ( x1 - a ) > 0.0001 && fabs ( x2 - b ) > 0.0001 && fabs ( x3 - c ) > 0.0001 ) ; printf ( \"x1=%f\\nx2=%f\\nx3=%f\" , x1 , x2 , x3 ) ; return 0 ; }",
    "resources/C/numerical_methods/simpsons_1_3rd_rule.c@f": "float f ( float x ) { return 1.0 + x * x * x ; // This is the expresion of the function to integrate? }",
    "resources/C/numerical_methods/simpsons_1_3rd_rule.c@main": "int main ( ) { int i , n ; float a , b , h , x , s2 , s3 , sum , integral ; printf ( \"enter the lower limit of the integration:\" ) ; scanf ( \"%f\" , & a ) ; printf ( \"enter the upper limit of the integration:\" ) ; scanf ( \"%f\" , & b ) ; printf ( \"enter the number of intervals:\" ) ; scanf ( \"%d\" , & n ) ; h = ( b - a ) / n ; sum = f ( a ) + f ( b ) ; s2 = s3 = 0.0 ; for ( i = 1 ; i < n ; i += 3 ) { x = a + i * h ; s3 = s3 + f ( x ) + f ( x + h ) ; } for ( i = 3 ; i < n ; i += 3 ) { x = a + i * h ; s2 = s2 + f ( x ) ; } integral = ( h / 3.0 ) * ( sum + 2 * s2 + 4 * s3 ) ; printf ( \"\\nValue of the integral = %9.4f\\n\" , integral ) ; return 0 ; }",
    "resources/C/numerical_methods/lu_decompose.c@lu_decomposition": "int lu_decomposition ( double * * A , double * * L , double * * U , int mat_size ) { int row , col , j ; // regularize each row for ( row = 0 ; row < mat_size ; row ++ ) { // Upper triangular matrix # ifdef _OPENMP # pragma omp for # endif for ( col = row ; col < mat_size ; col ++ ) { // Summation of L[i,j] * U[j,k] double lu_sum = 0. ; for ( j = 0 ; j < row ; j ++ ) lu_sum += L [ row ] [ j ] * U [ j ] [ col ] ; // Evaluate U[i,k] U [ row ] [ col ] = A [ row ] [ col ] - lu_sum ; } // Lower triangular matrix # ifdef _OPENMP # pragma omp for # endif for ( col = row ; col < mat_size ; col ++ ) { if ( row == col ) { L [ row ] [ col ] = 1. ; continue ; } // Summation of L[i,j] * U[j,k] double lu_sum = 0. ; for ( j = 0 ; j < row ; j ++ ) lu_sum += L [ col ] [ j ] * U [ j ] [ row ] ; // Evaluate U[i,k] L [ col ] [ row ] = ( A [ col ] [ row ] - lu_sum ) / U [ row ] [ row ] ; } } return 0 ; }",
    "resources/C/numerical_methods/lu_decompose.c@display": "void display ( double * * A , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { printf ( \"% 3.3g \\t\" , A [ i ] [ j ] ) ; } putchar ( '\\n' ) ; } }",
    "resources/C/numerical_methods/lu_decompose.c@main": "int main ( int argc , char * * argv ) { int mat_size = 3 ; // default matrix size const int range = 10 ; const int range2 = range >> 1 ; if ( argc == 2 ) mat_size = atoi ( argv [ 1 ] ) ; srand ( time ( NULL ) ) ; // random number initializer /* Create a square matrix with random values */ double * * A = ( double * * ) malloc ( mat_size * sizeof ( double * ) ) ; double * * L = ( double * * ) malloc ( mat_size * sizeof ( double * ) ) ; // output double * * U = ( double * * ) malloc ( mat_size * sizeof ( double * ) ) ; // output for ( int i = 0 ; i < mat_size ; i ++ ) { // calloc so that all valeus are '0' by default A [ i ] = ( double * ) calloc ( mat_size , sizeof ( double ) ) ; L [ i ] = ( double * ) calloc ( mat_size , sizeof ( double ) ) ; U [ i ] = ( double * ) calloc ( mat_size , sizeof ( double ) ) ; for ( int j = 0 ; j < mat_size ; j ++ ) /* create random values in the limits [-range2, range-1] */ A [ i ] [ j ] = ( double ) ( rand ( ) % range - range2 ) ; } lu_decomposition ( A , L , U , mat_size ) ; printf ( \"A = \\n\" ) ; display ( A , mat_size ) ; printf ( \"\\nL = \\n\" ) ; display ( L , mat_size ) ; printf ( \"\\nU = \\n\" ) ; display ( U , mat_size ) ; /* Free dynamically allocated memory */ for ( int i = 0 ; i < mat_size ; i ++ ) { free ( A [ i ] ) ; free ( L [ i ] ) ; free ( U [ i ] ) ; } free ( A ) ; free ( L ) ; free ( U ) ; return 0 ; }",
    "resources/C/numerical_methods/ode_semi_implicit_euler.c@problem": "void problem ( const double * x , double * y , double * dy ) { const double omega = 1.F ; // some const for the problem dy [ 0 ] = y [ 1 ] ; // x dot dy [ 1 ] = - omega * omega * y [ 0 ] ; // y dot }",
    "resources/C/numerical_methods/ode_semi_implicit_euler.c@exact_solution": "void exact_solution ( const double * x , double * y ) { y [ 0 ] = cos ( x [ 0 ] ) ; y [ 1 ] = - sin ( x [ 0 ] ) ; }",
    "resources/C/numerical_methods/ode_semi_implicit_euler.c@semi_implicit_euler_step": "void semi_implicit_euler_step ( double dx , double * x , double * y , double * dy ) { int o ; problem ( x , y , dy ) ; // update dy once y [ 0 ] += dx * dy [ 0 ] ; // update y0 problem ( x , y , dy ) ; // update dy once more for ( o = 1 ; o < order ; o ++ ) y [ o ] += dx * dy [ o ] ; // update remaining using new dy * x += dx ; }",
    "resources/C/numerical_methods/ode_semi_implicit_euler.c@semi_implicit_euler": "double semi_implicit_euler ( double dx , double x0 , double x_max , double * y , char save_to_file ) { double dy [ order ] ; FILE * fp = NULL ; if ( save_to_file ) { fp = fopen ( \"semi_implicit_euler.csv\" , \"w+\" ) ; if ( fp == NULL ) { perror ( \"Error! \" ) ; return - 1 ; } } /* start integration */ clock_t t1 = clock ( ) ; double x = x0 ; do // iterate for each step of independent variable { if ( save_to_file && fp ) fprintf ( fp , \"%.4g,%.4g,%.4g\\n\" , x , y [ 0 ] , y [ 1 ] ) ; // write to file semi_implicit_euler_step ( dx , & x , y , dy ) ; // perform integration x += dx ; // update step } while ( x <= x_max ) ; // till upper limit of independent variable /* end of integration */ clock_t t2 = clock ( ) ; if ( save_to_file && fp ) fclose ( fp ) ; return ( double ) ( t2 - t1 ) / CLOCKS_PER_SEC ; }",
    "resources/C/numerical_methods/ode_semi_implicit_euler.c@main": "int main ( int argc , char * argv [ ] ) { double X0 = 0.f ; /* initial value of x0 */ double X_MAX = 10.F ; /* upper limit of integration */ double Y0 [ ] = { 1.f , 0.f } ; /* initial value Y = y(x = x_0) */ double step_size ; if ( argc == 1 ) { printf ( \"\\nEnter the step size: \" ) ; scanf ( \"%lg\" , & step_size ) ; } else // use commandline argument as independent variable step size step_size = atof ( argv [ 1 ] ) ; // get approximate solution double total_time = semi_implicit_euler ( step_size , X0 , X_MAX , Y0 , 1 ) ; printf ( \"\\tTime = %.6g ms\\n\" , total_time ) ; /* compute exact solution for comparion */ FILE * fp = fopen ( \"exact.csv\" , \"w+\" ) ; if ( fp == NULL ) { perror ( \"Error! \" ) ; return - 1 ; } double x = X0 ; double * y = & ( Y0 [ 0 ] ) ; printf ( \"Finding exact solution\\n\" ) ; clock_t t1 = clock ( ) ; do { fprintf ( fp , \"%.4g,%.4g,%.4g\\n\" , x , y [ 0 ] , y [ 1 ] ) ; // write to file exact_solution ( & x , y ) ; x += step_size ; } while ( x <= X_MAX ) ; clock_t t2 = clock ( ) ; total_time = ( t2 - t1 ) / CLOCKS_PER_SEC ; printf ( \"\\tTime = %.6g ms\\n\" , total_time ) ; fclose ( fp ) ; return 0 ; }",
    "resources/C/numerical_methods/lagrange_theorem.c@main": "int main ( ) { float x [ 20 ] , y [ 20 ] , a , sum , p ; int n , i , j ; printf ( \"Enter the no of entry to insert->\" ) ; scanf ( \"%d\" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"enter the value of x%d->\" , i ) ; scanf ( \"%f\" , & x [ i ] ) ; printf ( \"enter the value of y%d->\" , i ) ; scanf ( \"%f\" , & y [ i ] ) ; } printf ( \"\\n X \\t\\t Y \\n\" ) ; printf ( \"----------------------------\\n\" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"%f\\t\" , x [ i ] ) ; printf ( \"%f\\n\" , y [ i ] ) ; } printf ( \"\\nenter the value of x for interpolation:\" ) ; scanf ( \"%f\" , & a ) ; sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { p = 1.0 ; for ( j = 0 ; j < n ; j ++ ) { if ( i != j ) { p = p * ( a - x [ j ] ) / ( x [ i ] - x [ j ] ) ; } sum = sum + y [ i ] * p ; } printf ( \"ans is->%f\" , sum ) ; return 0 ; } }",
    "resources/C/numerical_methods/secant_method.c@func": "double func ( double x ) { return x * x - 3. ; // x^2 = 3 - solution is sqrt(3) }",
    "resources/C/numerical_methods/secant_method.c@secant_method": "double secant_method ( double x0 , double x1 , double tolerance ) { int n = 1 ; // step counter while ( n ++ < NMAX ) { // calculate secant line root double x2 = x1 - func ( x1 ) * ( x1 - x0 ) / ( func ( x1 ) - func ( x0 ) ) ; // update values x0 = x1 ; x1 = x2 ; // return value if it meets tolerance if ( fabs ( x1 - x0 ) < tolerance ) return x2 ; } return - 1 ; // method failed (maximum number of steps exceeded) }",
    "resources/C/numerical_methods/secant_method.c@test": "static void test ( ) { // compares root values found by the secant method within the tolerance assert ( secant_method ( 0.2 , 0.5 , TOLERANCE ) - sqrt ( 3 ) < TOLERANCE ) ; assert ( fabs ( secant_method ( - 2 , - 5 , TOLERANCE ) ) - sqrt ( 3 ) < TOLERANCE ) ; assert ( secant_method ( - 3 , 2 , TOLERANCE ) - sqrt ( 3 ) < TOLERANCE ) ; assert ( fabs ( secant_method ( 1 , - 1.5 , TOLERANCE ) ) - sqrt ( 3 ) < TOLERANCE ) ; printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/numerical_methods/secant_method.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/process_scheduling_algorithms/non_preemptive_priority_scheduling.c@insert": "void insert ( node * * root , int id , int at , int bt , int prior ) { // create a new node and initialize it node * new = ( node * ) malloc ( sizeof ( node ) ) ; node * ptr = * root ; new -> ID = id ; new -> AT = at ; new -> BT = bt ; new -> priority = prior ; new -> next = NULL ; new -> CT = 0 ; new -> WT = 0 ; new -> TAT = 0 ; // if the root is null, make the new node the root if ( * root == NULL ) { * root = new ; return ; } // else traverse to the end of the queue and insert the new node there while ( ptr -> next != NULL ) { ptr = ptr -> next ; } ptr -> next = new ; return ; }",
    "resources/C/process_scheduling_algorithms/non_preemptive_priority_scheduling.c@delete": "void delete ( node * * root , int id ) { node * ptr = * root , * prev ; // if the root is null, return if ( ptr == NULL ) { return ; } // if the root is the process to be deleted, make the next node the root if ( ptr -> ID == id ) { * root = ptr -> next ; free ( ptr ) ; return ; } // else traverse the queue and delete the process while ( ptr != NULL && ptr -> ID != id ) { prev = ptr ; ptr = ptr -> next ; } if ( ptr == NULL ) { return ; } prev -> next = ptr -> next ; free ( ptr ) ; }",
    "resources/C/process_scheduling_algorithms/non_preemptive_priority_scheduling.c@show_list": "void show_list ( node * head ) { printf ( \"Process Priority AT BT CT TAT WT \\n\" ) ; while ( head != NULL ) { printf ( \"P%d. %d %d %d %d %d %d \\n\" , head -> ID , head -> priority , head -> AT , head -> BT , head -> CT , head -> TAT , head -> WT ) ; head = head -> next ; } }",
    "resources/C/process_scheduling_algorithms/non_preemptive_priority_scheduling.c@l_length": "int l_length ( node * * root ) { int count = 0 ; node * ptr = * root ; while ( ptr != NULL ) { count ++ ; ptr = ptr -> next ; } return count ; }",
    "resources/C/process_scheduling_algorithms/non_preemptive_priority_scheduling.c@update": "void update ( node * * root , int id , int ct , int wt , int tat ) { node * ptr = * root ; // If process to be updated is head node if ( ptr != NULL && ptr -> ID == id ) { if ( ct != 0 ) { ptr -> CT = ct ; } if ( wt != 0 ) { ptr -> WT = wt ; } if ( tat != 0 ) { ptr -> TAT = tat ; } return ; } // else traverse the queue and update the values while ( ptr != NULL && ptr -> ID != id ) { ptr = ptr -> next ; } if ( ct != 0 ) { ptr -> CT = ct ; } if ( wt != 0 ) { ptr -> WT = wt ; } if ( tat != 0 ) { ptr -> TAT = tat ; } return ; }",
    "resources/C/process_scheduling_algorithms/non_preemptive_priority_scheduling.c@compare": "",
    "resources/C/process_scheduling_algorithms/non_preemptive_priority_scheduling.c@calculate_ct": "float calculate_ct ( node * * root ) { // calculate the total completion time of all the processes node * ptr = * root , * prior , * rpt ; int ct = 0 , i , time = 0 ; int n = l_length ( root ) ; float avg , sum = 0 ; node * duproot = NULL ; // create a duplicate queue while ( ptr != NULL ) { insert ( & duproot , ptr -> ID , ptr -> AT , ptr -> BT , ptr -> priority ) ; ptr = ptr -> next ; } ptr = duproot ; rpt = ptr -> next ; // sort the queue based on the arrival time and priority while ( rpt != NULL ) { if ( ! compare ( ptr , rpt ) ) { ptr = rpt ; } rpt = rpt -> next ; } // ptr is the process to be executed first. ct = ptr -> AT + ptr -> BT ; time = ct ; sum += ct ; // update the completion time, turn around time and waiting time of the // process update ( root , ptr -> ID , ct , 0 , 0 ) ; delete ( & duproot , ptr -> ID ) ; // repeat the process until all the processes are executed for ( i = 0 ; i < n - 1 ; i ++ ) { ptr = duproot ; while ( ptr != NULL && ptr -> AT > time ) { ptr = ptr -> next ; } rpt = ptr -> next ; while ( rpt != NULL ) { if ( rpt -> AT <= time ) { if ( rpt -> priority < ptr -> priority ) { ptr = rpt ; } } rpt = rpt -> next ; } ct += ptr -> BT ; time += ptr -> BT ; sum += ct ; update ( root , ptr -> ID , ct , 0 , 0 ) ; delete ( & duproot , ptr -> ID ) ; } avg = sum / n ; return avg ; }",
    "resources/C/process_scheduling_algorithms/non_preemptive_priority_scheduling.c@calculate_tat": "float calculate_tat ( node * * root ) { float avg , sum = 0 ; int n = l_length ( root ) ; node * ptr = * root ; // calculate the completion time if not already calculated if ( ptr -> CT == 0 ) { calculate_ct ( root ) ; } // calculate the total turn around time of all the processes while ( ptr != NULL ) { ptr -> TAT = ptr -> CT - ptr -> AT ; sum += ptr -> TAT ; ptr = ptr -> next ; } avg = sum / n ; return avg ; }",
    "resources/C/process_scheduling_algorithms/non_preemptive_priority_scheduling.c@calculate_wt": "float calculate_wt ( node * * root ) { float avg , sum = 0 ; int n = l_length ( root ) ; node * ptr = * root ; // calculate the completion if not already calculated if ( ptr -> CT == 0 ) { calculate_ct ( root ) ; } // calculate the total waiting time of all the processes while ( ptr != NULL ) { ptr -> WT = ( ptr -> TAT - ptr -> BT ) ; sum += ptr -> WT ; ptr = ptr -> next ; } avg = sum / n ; return avg ; }",
    "resources/C/process_scheduling_algorithms/non_preemptive_priority_scheduling.c@test": "static void test ( ) { // Entered processes // printf(\"ID Priority Arrival Time Burst Time \\n\"); // printf(\"1 0 5 1 \\n\"); // printf(\"2 1 4 2 \\n\"); // printf(\"3 2 3 3 \\n\"); // printf(\"4 3 2 4 \\n\"); // printf(\"5 4 1 5 \\n\"); node * root = NULL ; insert ( & root , 1 , 0 , 5 , 1 ) ; insert ( & root , 2 , 1 , 4 , 2 ) ; insert ( & root , 3 , 2 , 3 , 3 ) ; insert ( & root , 4 , 3 , 2 , 4 ) ; insert ( & root , 5 , 4 , 1 , 5 ) ; float avgCT = calculate_ct ( & root ) ; float avgTAT = calculate_tat ( & root ) ; float avgWT = calculate_wt ( & root ) ; assert ( avgCT == 11 ) ; assert ( avgTAT == 9 ) ; assert ( avgWT == 6 ) ; printf ( \"[+] All tests have successfully passed!\\n\" ) ; // printf(\"Average Completion Time is : %f \\n\", calculate_ct(&root)); // printf(\"Average Turn Around Time is : %f \\n\", calculate_tat(&root)); // printf(\"Average Waiting Time is : %f \\n\", calculate_wt(&root)); }",
    "resources/C/process_scheduling_algorithms/non_preemptive_priority_scheduling.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/cipher/affine.c@modular_multiplicative_inverse": "int modular_multiplicative_inverse ( unsigned int a , unsigned int m ) { int x [ 2 ] = { 1 , 0 } ; div_t div_result ; if ( m == 0 ) { return 0 ; } a %= m ; if ( a == 0 ) { return 0 ; } div_result . rem = a ; while ( div_result . rem > 0 ) { div_result = div ( m , a ) ; m = a ; a = div_result . rem ; // Calculate value of x for this iteration int next = x [ 1 ] - ( x [ 0 ] * div_result . quot ) ; x [ 1 ] = x [ 0 ] ; x [ 0 ] = next ; } return x [ 1 ] ; }",
    "resources/C/cipher/affine.c@inverse_key": "affine_key_t inverse_key ( affine_key_t key ) { affine_key_t inverse ; inverse . a = modular_multiplicative_inverse ( key . a , ALPHABET_SIZE ) ; // Turn negative results positive inverse . a += ALPHABET_SIZE ; inverse . a %= ALPHABET_SIZE ; inverse . b = - ( key . b % ALPHABET_SIZE ) + ALPHABET_SIZE ; return inverse ; }",
    "resources/C/cipher/affine.c@affine_encrypt": "void affine_encrypt ( char * s , affine_key_t key ) { for ( int i = 0 ; s [ i ] != '\\0' ; i ++ ) { int c = ( int ) s [ i ] - Z95_CONVERSION_CONSTANT ; c *= key . a ; c += key . b ; c %= ALPHABET_SIZE ; s [ i ] = ( char ) ( c + Z95_CONVERSION_CONSTANT ) ; } }",
    "resources/C/cipher/affine.c@affine_decrypt": "void affine_decrypt ( char * s , affine_key_t key ) { affine_key_t inverse = inverse_key ( key ) ; for ( int i = 0 ; s [ i ] != '\\0' ; i ++ ) { int c = ( int ) s [ i ] - Z95_CONVERSION_CONSTANT ; c += inverse . b ; c *= inverse . a ; c %= ALPHABET_SIZE ; s [ i ] = ( char ) ( c + Z95_CONVERSION_CONSTANT ) ; } }",
    "resources/C/cipher/affine.c@test_string": "void test_string ( const char * s , const char * ciphertext , int a , int b ) { char * copy = malloc ( ( strlen ( s ) + 1 ) * sizeof ( char ) ) ; strcpy ( copy , s ) ; affine_key_t key = { a , b } ; affine_encrypt ( copy , key ) ; assert ( strcmp ( copy , ciphertext ) == 0 ) ; // assert that the encryption worked affine_decrypt ( copy , key ) ; assert ( strcmp ( copy , s ) == 0 ) ; // assert that we got the same string we started with free ( copy ) ; }",
    "resources/C/cipher/affine.c@tests": "static void tests ( ) { test_string ( \"Hello!\" , \"&3ddy2\" , 7 , 11 ) ; test_string ( \"TheAlgorithms/C\" , \"DNC}=jHS2zN!7;E\" , 67 , 67 ) ; test_string ( \"0123456789\" , \"840,($ {ws\" , 91 , 88 ) ; test_string ( \"7W@;cdeRT9uL\" , \"JDfa*we?z&bL\" , 77 , 76 ) ; test_string ( \"~Qr%^-+++$leM\" , \"r'qC0$sss;Ahf\" , 8 , 90 ) ; test_string ( \"The quick brown fox jumps over the lazy dog\" , \"K7: .*6<4 =-0(1 90' 5*2/, 0):- +7: 3>%& ;08\" , 94 , 0 ) ; test_string ( \"One-1, Two-2, Three-3, Four-4, Five-5, Six-6, Seven-7, Eight-8, \" \"Nine-9, Ten-10\" , \"H&60>\\\\2*uY0q\\\\2*p4660E\\\\2XYn40x\\\\2XDB60L\\\\2VDI0 \" \"\\\\2V6B6&0S\\\\2%D=p;0'\\\\2tD&60Z\\\\2*6&0>j\" , 51 , 18 ) ; printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/cipher/affine.c@main": "int main ( ) { tests ( ) ; return 0 ; }",
    "resources/C/cipher/rot13.c@rot13": "void rot13 ( char * s ) { for ( int i = 0 ; s [ i ] ; i ++ ) { if ( s [ i ] >= 'A' && s [ i ] <= 'Z' ) { s [ i ] = 'A' + ( ( s [ i ] - 'A' + 13 ) % 26 ) ; } else if ( s [ i ] >= 'a' && s [ i ] <= 'z' ) { s [ i ] = 'a' + ( ( s [ i ] - 'a' + 13 ) % 26 ) ; } } }",
    "resources/C/cipher/rot13.c@test": "static void test ( ) { char test_01 [ ] = \"The more I C, the less I see.\" ; rot13 ( test_01 ) ; assert ( strcmp ( test_01 , \"Gur zber V P, gur yrff V frr.\" ) == 0 ) ; char test_02 [ ] = \"Which witch switched the Swiss wristwatches?\" ; rot13 ( test_02 ) ; assert ( strcmp ( test_02 , \"Juvpu jvgpu fjvgpurq gur Fjvff jevfgjngpurf?\" ) == 0 ) ; char test_03 [ ] = \"Juvpu jvgpu fjvgpurq gur Fjvff jevfgjngpurf?\" ; rot13 ( test_03 ) ; assert ( strcmp ( test_03 , \"Which witch switched the Swiss wristwatches?\" ) == 0 ) ; printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/cipher/rot13.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/dynamic_programming/matrix_chain_order.c@matrixChainOrder": "int matrixChainOrder ( int l , const int * p , int * s ) { // mat stores the cost for a chain that starts at i and ends on j (inclusive // on both ends) int * * mat = malloc ( l * sizeof ( int * ) ) ; for ( int i = 0 ; i < l ; ++ i ) { mat [ i ] = malloc ( l * sizeof ( int ) ) ; } for ( int i = 0 ; i < l ; ++ i ) { mat [ i ] [ i ] = 0 ; } // cl denotes the difference between start / end indices, cl + 1 would be // chain length. for ( int cl = 1 ; cl < l ; ++ cl ) { for ( int i = 0 ; i < l - cl ; ++ i ) { int j = i + cl ; mat [ i ] [ j ] = INT_MAX ; for ( int div = i ; div < j ; ++ div ) { int q = mat [ i ] [ div ] + mat [ div + 1 ] [ j ] + p [ i ] * p [ div ] * p [ j ] ; if ( q < mat [ i ] [ j ] ) { mat [ i ] [ j ] = q ; s [ i * l + j ] = div ; } } } } int result = mat [ 0 ] [ l - 1 ] ; // Free dynamically allocated memory for ( int i = 0 ; i < l ; ++ i ) { free ( mat [ i ] ) ; } free ( mat ) ; return result ; }",
    "resources/C/dynamic_programming/matrix_chain_order.c@printSolution": "void printSolution ( int l , int * s , int i , int j ) { if ( i == j ) { printf ( \"A%d\" , i ) ; return ; } putchar ( '(' ) ; printSolution ( l , s , i , s [ i * l + j ] ) ; printSolution ( l , s , s [ i * l + j ] + 1 , j ) ; putchar ( ')' ) ; }",
    "resources/C/dynamic_programming/matrix_chain_order.c@test": "static void test ( ) { int sizes [ ] = { 35 , 15 , 5 , 10 , 20 , 25 } ; int len = 6 ; int * sol = malloc ( len * len * sizeof ( int ) ) ; int r = matrixChainOrder ( len , sizes , sol ) ; assert ( r == 18625 ) ; printf ( \"Result : %d\\n\" , r ) ; printf ( \"Optimal ordering : \" ) ; printSolution ( len , sol , 0 , 5 ) ; free ( sol ) ; printf ( \"\\n\" ) ; }",
    "resources/C/dynamic_programming/matrix_chain_order.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/dynamic_programming/lcs.c@lcslen": "void lcslen ( const char * s1 , const char * s2 , int l1 , int l2 , int * * L , int * * B ) { /* B is the directions matrix\n\t   L is the LCS matrix */ int i , j ; /* loop over the simbols in my sequences\n\t   save the directions according to the LCS */ for ( i = 1 ; i <= l1 ; ++ i ) { for ( j = 1 ; j <= l2 ; ++ j ) { if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) { L [ i ] [ j ] = 1 + L [ i - 1 ] [ j - 1 ] ; B [ i ] [ j ] = DIAG ; } else if ( L [ i - 1 ] [ j ] < L [ i ] [ j - 1 ] ) { L [ i ] [ j ] = L [ i ] [ j - 1 ] ; B [ i ] [ j ] = LEFT ; } else { L [ i ] [ j ] = L [ i - 1 ] [ j ] ; B [ i ] [ j ] = UP ; } } } }",
    "resources/C/dynamic_programming/lcs.c@lcsbuild": "char * lcsbuild ( const char * s1 , int l1 , int l2 , int * * L , int * * B ) { int i , j , lcsl ; char * lcs ; lcsl = L [ l1 ] [ l2 ] ; /* my lcs is at least the empty symbol */ lcs = ( char * ) calloc ( lcsl + 1 , sizeof ( char ) ) ; /* null-terminated \\0 */ if ( ! lcs ) { perror ( \"calloc: \" ) ; return NULL ; } i = l1 , j = l2 ; while ( i > 0 && j > 0 ) { /* walk the matrix backwards */ if ( B [ i ] [ j ] == DIAG ) { lcs [ -- lcsl ] = s1 [ i - 1 ] ; i = i - 1 ; j = j - 1 ; } else if ( B [ i ] [ j ] == LEFT ) { j = j - 1 ; } else { i = i - 1 ; } } return lcs ; }",
    "resources/C/dynamic_programming/lcs.c@test": "static void test ( ) { /* https://en.wikipedia.org/wiki/Subsequence#Applications */ int * * L , * * B , j , l1 , l2 ; char * s1 = \"ACGGTGTCGTGCTATGCTGATGCTGACTTATATGCTA\" ; char * s2 = \"CGTTCGGCTATCGTACGTTCTATTCTATGATTTCTAA\" ; char * lcs ; l1 = strlen ( s1 ) ; l2 = strlen ( s2 ) ; L = ( int * * ) calloc ( l1 + 1 , sizeof ( int * ) ) ; B = ( int * * ) calloc ( l1 + 1 , sizeof ( int * ) ) ; if ( ! L ) { perror ( \"calloc: \" ) ; exit ( 1 ) ; } if ( ! B ) { perror ( \"calloc: \" ) ; exit ( 1 ) ; } for ( j = 0 ; j <= l1 ; j ++ ) { L [ j ] = ( int * ) calloc ( l2 + 1 , sizeof ( int ) ) ; if ( ! L [ j ] ) { perror ( \"calloc: \" ) ; exit ( 1 ) ; } B [ j ] = ( int * ) calloc ( l2 + 1 , sizeof ( int ) ) ; if ( ! L [ j ] ) { perror ( \"calloc: \" ) ; exit ( 1 ) ; } } lcslen ( s1 , s2 , l1 , l2 , L , B ) ; lcs = lcsbuild ( s1 , l1 , l2 , L , B ) ; assert ( L [ l1 ] [ l2 ] == 27 ) ; assert ( strcmp ( lcs , \"CGTTCGGCTATGCTTCTACTTATTCTA\" ) == 0 ) ; printf ( \"S1: %s\\tS2: %s\\n\" , s1 , s2 ) ; printf ( \"LCS len:%3d\\n\" , L [ l1 ] [ l2 ] ) ; printf ( \"LCS: %s\\n\" , lcs ) ; free ( lcs ) ; for ( j = 0 ; j <= l1 ; j ++ ) { free ( L [ j ] ) , free ( B [ j ] ) ; } free ( L ) ; free ( B ) ; printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/dynamic_programming/lcs.c@main": "int main ( int argc , char * argv [ ] ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/math/gcd.c@GCD": "int GCD ( int x , int y ) { if ( y == 0 ) return x ; return GCD ( y , x % y ) ; }",
    "resources/C/math/gcd.c@main": "int main ( ) { int a , b ; printf ( \"Input two numbers:\\n\" ) ; scanf ( \"%d %d\" , & a , & b ) ; printf ( \"Greatest common divisor: %d\\n\" , GCD ( a , b ) ) ; }",
    "resources/C/math/large_factorials.c@main": "int main ( ) { int a [ 16500 ] , T ; long long int i , j ; printf ( \"Enter number of test cases : \" ) ; scanf ( \"%d\" , & T ) ; while ( T -- ) { for ( i = 0 ; i < 16500 ; i ++ ) { a [ i ] = 0 ; } a [ 1 ] = 1 ; int N , carry = 0 , count = 0 ; printf ( \"Enter a number : \" ) ; scanf ( \"%d\" , & N ) ; for ( i = 1 ; i <= N ; i ++ ) { carry = 0 ; for ( j = 0 ; j < 16500 ; j ++ ) { a [ j ] = a [ j ] * i + carry ; carry = a [ j ] / 10 ; a [ j ] = a [ j ] % 10 ; } } for ( i = 0 ; i < 16500 ; i ++ ) { if ( a [ i ] != 0 ) { count = i ; } } for ( i = count ; i > 0 ; i -- ) { printf ( \"%d\" , a [ i ] ) ; } printf ( \"\\n\" ) ; } return 0 ; }",
    "resources/C/math/cartesian_to_polar.c@to_polar": "void to_polar ( double x , double y , double * r , double * theta ) { double thetaFinal = 0.f ; * r = sqrt ( x * x + y * y ) ; if ( x != 0 ) { if ( y != 0 ) { * theta = atan ( y / x ) ; if ( ( x > 0 && y > 0 ) || ( x == - y ) ) { // Q1 thetaFinal = * theta ; } else if ( x < 0 && y > 0 ) { // Q2 thetaFinal = * theta + M_PI ; } else if ( x < 0 && y < 0 ) { // Q3 thetaFinal = * theta - M_PI ; } else if ( x > 0 && y < 0 ) { // Q4 thetaFinal = 2 * M_PI - * theta ; } else { fprintf ( stderr , \"Should not reach here!\\n\" ) ; } } } else { // exceptions when no actual angle is present if ( y > 0 ) { thetaFinal = M_PI / 2 ; } else { thetaFinal = - ( M_PI / 2 ) ; } } if ( y == 0 ) { if ( x > 0 ) { thetaFinal = 0 ; } else { thetaFinal = - M_PI ; } } * theta = thetaFinal ; }",
    "resources/C/math/cartesian_to_polar.c@get_rand": "double get_rand ( double lim1 , double lim2 ) { double r = ( double ) rand ( ) / RAND_MAX ; // value in [0,1) return ( lim2 - lim1 ) * r + lim1 ; // scale to range }",
    "resources/C/math/cartesian_to_polar.c@test": "void test ( ) { srand ( 10 ) ; int NUM_TESTS = 5 ; for ( int i = 0 ; i < NUM_TESTS ; i ++ ) { double r , theta ; printf ( \"Test %d.... \" , i ) ; double x = get_rand ( - 5 , 5 ) ; double y = get_rand ( - 5 , 5 ) ; printf ( \"(%.2g, %.2g).... \" , x , y ) ; to_polar ( x , y , & r , & theta ) ; assert ( fabs ( r - hypot ( x , y ) ) < 0.01 ) ; assert ( fabs ( theta - atan2 ( y , x ) ) < 0.01 ) ; printf ( \"passed\\n\" ) ; } }",
    "resources/C/math/cartesian_to_polar.c@main": "int main ( ) { test ( ) ; return 0 ; }",
    "resources/C/math/prime_factoriziation.c@main": "int main ( ) { int n = 0 ; /* for user input */ printf ( \"\\t\\tPrim factoriziation\\n\\n\" ) ; printf ( \"positive integer (> 1) ? \" ) ; scanf ( \"%d\" , & n ) ; Range r = int_fact ( n ) ; printf ( \"\\nThe factoriziation are: \" ) ; print_arr ( r ) ; destroy ( r ) ; return 0 ; }",
    "resources/C/math/prime_factoriziation.c@int_fact": "Range int_fact ( int n ) { assert ( n > 1 ) ; /* precondition : n must be greater then 1*/ int len = LEN ; int count = 0 ; int i = 0 ; int * range = ( int * ) malloc ( sizeof ( int ) * len ) ; assert ( range ) ; Range pstr = ( Range ) malloc ( sizeof ( range ) ) ; assert ( pstr ) ; while ( n % 2 == 0 ) { n /= 2 ; if ( i < len ) { range [ i ] = 2 ; i ++ ; } else { range = increase ( range , len ) ; len += STEP ; range [ i ] = 2 ; i ++ ; } count ++ ; } int j = 3 ; while ( j * j <= n ) { while ( n % j == 0 ) { n /= j ; if ( i < len ) { range [ i ] = j ; i ++ ; } else { range = increase ( range , len ) ; len += STEP ; range [ i ] = j ; i ++ ; } count ++ ; } j += 2 ; } if ( n > 1 ) { if ( i < len ) { range [ i ] = n ; i ++ ; } else { range = increase ( range , len ) ; len += STEP ; range [ i ] = n ; i ++ ; } count ++ ; } pstr -> range = range ; pstr -> length = count ; return pstr ; }",
    "resources/C/math/prime_factoriziation.c@print_arr": "void print_arr ( Range pStr ) { assert ( pStr ) ; /* checks whether pStr is a null-pointer */ int i = 0 ; printf ( \"\\n\" ) ; for ( i ; i < pStr -> length ; i ++ ) { if ( i == 0 ) printf ( \"%d\" , pStr -> range [ 0 ] ) ; else printf ( \"-%d\" , pStr -> range [ i ] ) ; } printf ( \"\\n\" ) ; }",
    "resources/C/math/prime_factoriziation.c@increase": "int * increase ( int * arr , int len ) { assert ( arr ) ; /* checks whether arr is a null-pointer */ int * tmp = ( int * ) realloc ( arr , sizeof ( int ) * ( len + STEP ) ) ; assert ( tmp ) ; return tmp ; //    assert(arr); }",
    "resources/C/math/prime_factoriziation.c@destroy": "void destroy ( Range r ) { free ( r -> range ) ; free ( r ) ; }",
    "resources/C/math/collatz.c@main": "int main ( int argc , char * argv [ ] ) { unsigned long long n , curr_no , num_steps = 0 ; if ( argc == 2 ) n = strtoull ( argv [ 1 ] , NULL , 10 ) ; else { printf ( \"Enter starting number: \" ) ; scanf ( \"%lu\" , & n ) ; // input number } curr_no = n ; // curr_no stores input number n while ( curr_no != 1 ) // loop till series reaches 1 { num_steps ++ ; printf ( \"%llu->\" , curr_no ) ; if ( curr_no % 2 == 0 ) // condition   for even number curr_no = curr_no / 2 ; else curr_no = ( curr_no * 3 ) + 1 ; // condition for odd number } printf ( \"1\\nNumber of steps: %llu\\n\" , num_steps ) ; return 0 ; }",
    "resources/C/math/armstrong_number.c@power": "int power ( int x , unsigned int y ) { if ( y == 0 ) return 1 ; if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; }",
    "resources/C/math/armstrong_number.c@order": "int order ( int x ) { int n = 0 ; while ( x ) { n ++ ; x = x / 10 ; } return n ; }",
    "resources/C/math/armstrong_number.c@isArmstrong": "int isArmstrong ( int x ) { // Calling order function int n = order ( x ) ; int temp = x , sum = 0 ; while ( temp ) { int r = temp % 10 ; sum += power ( r , n ) ; temp = temp / 10 ; } // If satisfies Armstrong condition if ( sum == x ) return 1 ; else return 0 ; }",
    "resources/C/math/armstrong_number.c@main": "int main ( ) { int x = 153 ; if ( isArmstrong ( x ) == 1 ) printf ( \"True\\n\" ) ; else printf ( \"False\\n\" ) ; x = 1253 ; if ( isArmstrong ( x ) == 1 ) printf ( \"True\\n\" ) ; else printf ( \"False\\n\" ) ; return 0 ; }",
    "resources/C/math/fibonacci.c@fib": "unsigned int fib ( int number ) { // Check for negative integers if ( number <= 0 ) { fprintf ( stderr , \"Illegal Argument Is Passed!\\n\" ) ; exit ( EXIT_FAILURE ) ; } // Base conditions if ( number == 1 ) return 0 ; if ( number == 2 ) return 1 ; // Recursive call to the function return fib ( number - 1 ) + fib ( number - 2 ) ; }",
    "resources/C/math/fibonacci.c@getInput": "int getInput ( void ) { int num , excess_len ; char buffer [ 3 ] , * endPtr ; while ( 1 ) { // Repeat until a valid number is entered printf ( \"Please enter a valid number:\" ) ; fgets ( buffer , 3 , stdin ) ; // Inputs the value from user excess_len = 0 ; if ( ! ( buffer [ 0 ] == '\\n' || buffer [ 1 ] == '\\n' || buffer [ 2 ] == '\\n' ) ) { while ( getchar ( ) != '\\n' ) excess_len ++ ; } num = strtol ( buffer , & endPtr , 10 ) ; // Attempts to convert the string to integer // Checking the input if ( // The number is too large ( excess_len > 0 || num > 48 ) || // Characters other than digits are included in the input ( * endPtr != '\\0' && * endPtr != '\\n' ) || // No characters are entered endPtr == buffer ) { continue ; } break ; } printf ( \"\\nEntered digit: %d (it might take sometime)\\n\" , num ) ; return num ; }",
    "resources/C/math/fibonacci.c@test": "static void test ( ) { assert ( fib ( 5 ) == 3 ) ; assert ( fib ( 2 ) == 1 ) ; assert ( fib ( 9 ) == 21 ) ; }",
    "resources/C/math/fibonacci.c@main": "int main ( ) { // Performing the test test ( ) ; printf ( \"Tests passed...\\n\" ) ; // Getting n printf ( \"Enter n to find nth fibonacci element...\\n\" \"Note: You would be asked to enter input until valid number ( less \" \"than or equal to 48 ) is entered.\\n\" ) ; int number = getInput ( ) ; clock_t start , end ; start = clock ( ) ; printf ( \"Fibonacci element %d is %u \" , number , fib ( number ) ) ; end = clock ( ) ; printf ( \"in %.3f seconds.\\n\" , ( ( double ) ( end - start ) ) / CLOCKS_PER_SEC ) ; return 0 ; }",
    "resources/C/math/factorial_large_number.c@new_number": "large_num * new_number ( void ) { large_num * new_num = ( large_num * ) malloc ( sizeof ( large_num ) ) ; new_num -> num_digits = 1 ; new_num -> digits = ( char * ) malloc ( 1 * sizeof ( char ) ) ; new_num -> digits [ 0 ] = 1 ; return new_num ; }",
    "resources/C/math/factorial_large_number.c@delete_number": "void delete_number ( large_num * num ) { free ( num -> digits ) ; free ( num ) ; }",
    "resources/C/math/factorial_large_number.c@add_digit": "void add_digit ( large_num * num , unsigned int value ) { if ( value > 9 ) { fprintf ( stderr , \"digit > 9!!\\n\" ) ; delete_number ( num ) ; exit ( EXIT_FAILURE ) ; } num -> num_digits ++ ; num -> digits = ( char * ) realloc ( num -> digits , num -> num_digits * sizeof ( char ) ) ; num -> digits [ num -> num_digits - 1 ] = value ; }",
    "resources/C/math/factorial_large_number.c@multiply": "void multiply ( large_num * num , unsigned long n ) { int i ; unsigned long carry = 0 , temp ; for ( i = 0 ; i < num -> num_digits ; i ++ ) { temp = num -> digits [ i ] * n ; temp += carry ; if ( temp < 10 ) carry = 0 ; else { carry = temp / 10 ; temp = temp % 10 ; } num -> digits [ i ] = temp ; } while ( carry != 0 ) { add_digit ( num , carry % 10 ) ; carry /= 10 ; } }",
    "resources/C/math/factorial_large_number.c@main": "int main ( int argc , char * argv [ ] ) { int number , i ; // Asks for the number/position of term in Fibonnacci sequence if ( argc == 2 ) number = atoi ( argv [ 1 ] ) ; else { printf ( \"Enter the value of n(n starts from 0 ): \" ) ; scanf ( \"%d\" , & number ) ; } large_num * result = new_number ( ) ; clock_t start_time = clock ( ) ; for ( i = 2 ; i <= number ; i ++ ) /* Multiply every number from 2 thru N */ multiply ( result , i ) ; double time_taken = ( clock ( ) - start_time ) * ( double ) 1e3 / CLOCKS_PER_SEC ; // time_taken = (clock() - start_time) / (double) CLOCKS_PER_SEC; printf ( \"%d! = \" , number ) ; for ( i = result -> num_digits ; i > 0 ; i -- ) putchar ( result -> digits [ i - 1 ] + '0' ) ; printf ( \"\\nTime taken: %.4g ms\\n\" , time_taken ) ; delete_number ( result ) ; return 0 ; }",
    "resources/C/math/factorial_trailing_zeroes.c@main": "int main ( ) { int i , n , test = 0 , count = 0 ; // taking input number n scanf ( \"%d\" , & n ) ; // looping from 1 till loop break for ( i = 1 ; ; i ++ ) { test = n / pow ( 5 , i ) ; // division of n by ith power of 5(storing in integer form) if ( test != 0 ) // condition for zeroes at end corresponding individual ith case { count = count + test ; } else break ; // break the loop for if test=0 } printf ( \"%d\\n\" , count ) ; return 0 ; }",
    "resources/C/math/lcm.c@gcd": "int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }",
    "resources/C/math/lcm.c@lcm": "int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; }",
    "resources/C/math/lcm.c@main": "int main ( ) { int a , b ; printf ( \"Enter two numbers to find their LCM \\n\" ) ; scanf ( \"%d%d\" , & a , & b ) ; printf ( \"LCM of %d and %d is %d \" , a , b , lcm ( a , b ) ) ; return 0 ; }",
    "resources/C/math/strong_number.c@isStrong": "",
    "resources/C/math/strong_number.c@test": "void test ( ) { assert ( isStrong ( 145 ) ) ; /* 145 = 1! + 4! + 5! */ assert ( ! isStrong ( 543 ) ) ; /* 543 != 5!+ 4! + 3! */ }",
    "resources/C/math/strong_number.c@main": "int main ( ) { test ( ) ; return 0 ; }",
    "resources/C/math/factorial.c@main": "int main ( ) { int a [ 200 ] , n , counter , temp , i ; a [ 0 ] = 1 ; counter = 0 ; printf ( \"Enter a whole number to Find its Factorial: \" ) ; scanf ( \"%d\" , & n ) ; if ( n < 0 ) printf ( \"Cannot Calculate factorials for negative numbers.\" ) ; else { for ( ; n >= 2 ; n -- ) { temp = 0 ; for ( i = 0 ; i <= counter ; i ++ ) { temp = ( a [ i ] * n ) + temp ; a [ i ] = temp % 10 ; temp = temp / 10 ; } while ( temp > 0 ) { a [ ++ counter ] = temp % 10 ; temp = temp / 10 ; } } for ( i = counter ; i >= 0 ; i -- ) printf ( \"%d\" , a [ i ] ) ; } return 0 ; }",
    "resources/C/math/fibonacci_fast.c@fib": "void fib ( unsigned long n , unsigned long * C , unsigned long * D ) { // Out of Range checking // commented out since `n` is unsigned integer // if (n < 0) // { //     printf(\"\\nNo Such term !\\n\"); //     exit(0); // } unsigned long a , b , c , d ; if ( n == 0 ) { C [ 0 ] = 0 ; if ( D ) /* if D is not NULL */ D [ 0 ] = 1 ; return ; } fib ( n >> 1 , & c , & d ) ; /* Compute F(n/2) */ a = c * ( ( d << 1 ) - c ) ; b = c * c + d * d ; if ( n % 2 == 0 ) /* If n is even */ { C [ 0 ] = a ; if ( D ) D [ 0 ] = b ; return ; } /**< If n is odd */ C [ 0 ] = b ; if ( D ) /* if D is not NULL */ D [ 0 ] = a + b ; return ; }",
    "resources/C/math/fibonacci_fast.c@main": "int main ( int argc , char * argv [ ] ) { unsigned long number , result ; setlocale ( LC_NUMERIC , \"\" ) ; // format the printf output // Asks for the number/position of term in Fibonnacci sequence if ( argc == 2 ) number = atoi ( argv [ 1 ] ) ; else { printf ( \"Enter the value of n(n starts from 0 ): \" ) ; scanf ( \"%lu\" , & number ) ; } fib ( number , & result , NULL ) ; printf ( \"The nth term is : %'lu \\n\" , result ) ; return 0 ; }",
    "resources/C/math/palindrome.c@main": "int main ( ) { assert ( isPalindrome ( 0 ) ) ; assert ( isPalindrome ( 1 ) ) ; assert ( isPalindrome ( 12321 ) ) ; assert ( ! isPalindrome ( 1234 ) ) ; return 0 ; }",
    "resources/C/math/palindrome.c@isPalindrome": "",
    "resources/C/math/prime.c@isPrime": "",
    "resources/C/math/prime.c@test": "void test ( ) { /* all the prime numbers less than 100 */ int primers [ ] = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 } ; for ( size_t i = 0 , size = sizeof ( primers ) / sizeof ( primers [ 0 ] ) ; i < size ; ++ i ) { assert ( isPrime ( primers [ i ] ) ) ; } /* Example Non-prime numbers */ int NonPrimers [ ] = { - 1 , 0 , 1 , 4 , 6 , 8 , 9 , 10 } ; for ( size_t i = 0 , size = sizeof ( NonPrimers ) / sizeof ( NonPrimers [ 0 ] ) ; i < size ; ++ i ) { assert ( ! isPrime ( NonPrimers [ i ] ) ) ; } }",
    "resources/C/math/prime.c@main": "int main ( ) { test ( ) ; return 0 ; }",
    "resources/C/math/euclidean_algorithm_extended.c@xy_push": "static inline void xy_push ( int arr [ 2 ] , int newval ) { arr [ 1 ] = arr [ 0 ] ; arr [ 0 ] = newval ; }",
    "resources/C/math/euclidean_algorithm_extended.c@calculate_next_xy": "static inline void calculate_next_xy ( int quotient , int prev [ 2 ] ) { int next = prev [ 1 ] - ( prev [ 0 ] * quotient ) ; xy_push ( prev , next ) ; }",
    "resources/C/math/euclidean_algorithm_extended.c@extended_euclidean_algorithm": "euclidean_result_t extended_euclidean_algorithm ( int a , int b ) { int previous_remainder = 1 ; int previous_x_values [ 2 ] = { 0 , 1 } ; int previous_y_values [ 2 ] = { 1 , 0 } ; div_t div_result ; euclidean_result_t result ; /* swap values of a and b */ if ( abs ( a ) < abs ( b ) ) { a ^= b ; b ^= a ; a ^= b ; } div_result . rem = b ; while ( div_result . rem > 0 ) { div_result = div ( a , b ) ; previous_remainder = b ; a = b ; b = div_result . rem ; calculate_next_xy ( div_result . quot , previous_x_values ) ; calculate_next_xy ( div_result . quot , previous_y_values ) ; } result . gcd = previous_remainder ; result . x = previous_x_values [ 1 ] ; result . y = previous_y_values [ 1 ] ; return result ; }",
    "resources/C/math/euclidean_algorithm_extended.c@single_test": "static inline void single_test ( int a , int b , int gcd , int x , int y ) { euclidean_result_t result ; result = extended_euclidean_algorithm ( a , b ) ; assert ( result . gcd == gcd ) ; assert ( result . x == x ) ; assert ( result . y == y ) ; }",
    "resources/C/math/euclidean_algorithm_extended.c@test": "static void test ( ) { single_test ( 40 , 27 , 1 , - 2 , 3 ) ; single_test ( 71 , 41 , 1 , - 15 , 26 ) ; single_test ( 48 , 18 , 6 , - 1 , 3 ) ; single_test ( 99 , 303 , 3 , - 16 , 49 ) ; single_test ( 14005 , 3507 , 1 , - 305 , 1218 ) ; printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/math/euclidean_algorithm_extended.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/math/lerp.c@lerp": "float lerp ( float k0 , float k1 , float t ) { return k0 + t * ( k1 - k0 ) ; }",
    "resources/C/math/lerp.c@lerp_precise": "float lerp_precise ( int k0 , int k1 , float t ) { return ( 1 - t ) * k0 + t * k1 ; }",
    "resources/C/math/lerp.c@main": "int main ( ) { float start = 0 ; float finish = 5 ; float steps = 0 ; printf ( \"Input a number, this is the bigger bound of the lerp:\\n\" ) ; scanf ( \"%f\" , & finish ) ; printf ( \"Input a number, this is in how many steps you want to divide the \" \"lerp:\\n\" ) ; scanf ( \"%f\" , & steps ) ; for ( int i = 0 ; i < steps + 1 ; i ++ ) { printf ( \"%f\\n\" , lerp ( start , finish , i / steps ) ) ; } return 0 ; }",
    "resources/C/math/prime_sieve.c@prime": "void prime ( int * p ) { for ( long long int i = 3 ; i <= MAX_SIZE ; i += 2 ) { p [ i ] = 1 ; } for ( long long int i = 3 ; i <= MAX_SIZE ; i += 2 ) { if ( p [ i ] == 1 ) { for ( long long int j = i * i ; j <= MAX_SIZE ; j += i ) { p [ j ] = 0 ; } } } p [ 2 ] = 1 ; p [ 0 ] = p [ 1 ] = 0 ; }",
    "resources/C/math/prime_sieve.c@count": "int count ( int * arr , const int size ) { int k = 0 ; for ( int i = 0 ; i <= size ; i ++ ) { if ( arr [ i ] == 1 ) { k ++ ; } } return k ; }",
    "resources/C/math/prime_sieve.c@test": "static void test ( ) { // Test Case 1 const int size = 10 ; /* array size */ printf ( \"Test Case 1...\" ) ; int arr [ 1000005 ] = { 0 } ; /* array to store prime numbers */ prime ( arr ) ; assert ( count ( arr , size ) == 4 ) ; printf ( \"Passed\\n\" ) ; }",
    "resources/C/math/prime_sieve.c@main": "int main ( int argc , const char * argv [ ] ) { test ( ) ; // execute the tests return 0 ; }",
    "resources/C/math/fibonacci_dp.c@fib": "int fib ( int n ) { // Out of Range checking if ( n < 0 ) { printf ( \"\\nNo Such term !\\n\" ) ; exit ( 0 ) ; } // declaring array to store fibonacci numbers -- memoization int * f = ( int * ) malloc ( ( n + 2 ) * sizeof ( int ) ) ; //  one extra to handle edge case, n = 0 int i ; /* let 0th and 1st number of the series be 0 and 1*/ f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( i = 2 ; i <= n ; i ++ ) { // Adding the previous 2 terms to make the 3rd term f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; } int out = f [ n ] ; free ( f ) ; return out ; }",
    "resources/C/math/fibonacci_dp.c@main": "int main ( int argc , char * argv [ ] ) { int number ; // Asks for the number/position of term in Fibonnacci sequence if ( argc == 2 ) number = atoi ( argv [ 1 ] ) ; else { printf ( \"Enter the value of n(n starts from 0 ): \" ) ; scanf ( \"%d\" , & number ) ; } printf ( \"The nth term is : %d \\n\" , fib ( number ) ) ; return 0 ; }",
    "resources/C/math/fibonacci_formula.c@fib": "int fib ( unsigned int n ) { float seq = ( 1 / sqrt ( 5 ) * pow ( ( ( 1 + sqrt ( 5 ) ) / 2 ) , n + 1 ) ) - ( 1 / sqrt ( 5 ) * pow ( ( ( 1 - sqrt ( 5 ) ) / 2 ) , n + 1 ) ) ; // removing unnecessary fractional part by implicitly converting float to int return seq ; }",
    "resources/C/math/fibonacci_formula.c@test": "static void test ( ) { /* this ensures that the first 10 number of fibonacci sequence\n     * (1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89)\n     * matches with algorithm\n    */ assert ( fib ( 0 ) == 1 ) ; assert ( fib ( 1 ) == 1 ) ; assert ( fib ( 2 ) == 2 ) ; assert ( fib ( 3 ) == 3 ) ; assert ( fib ( 4 ) == 5 ) ; assert ( fib ( 5 ) == 8 ) ; assert ( fib ( 6 ) == 13 ) ; assert ( fib ( 7 ) == 21 ) ; assert ( fib ( 8 ) == 34 ) ; assert ( fib ( 9 ) == 55 ) ; assert ( fib ( 10 ) == 89 ) ; printf ( \"All tests have successfully passed!\\n\" ) ; }",
    "resources/C/math/fibonacci_formula.c@main": "int main ( ) { test ( ) ; // run self-test implementations for ( int i = 0 ; i <= 10 ; i ++ ) { printf ( \"%d. fibonacci number is: %d\\n\" , i , fib ( i ) ) ; } return 0 ; }",
    "resources/C/math/catalan.c@factorial": "long int factorial ( int x ) // long int for more than 10 factorial { int i ; long int fac ; // fac stores x factorial fac = x ; for ( i = 1 ; i < x ; i ++ ) // loop to calculate x factorial { fac = fac * ( x - i ) ; } return fac ; // returning x factorial }",
    "resources/C/math/catalan.c@main": "int main ( ) { long int f1 , f2 , f3 ; // long int for more than 10 factorial int n ; float C ; // C is catalan number for n; scanf ( \"%d\" , & n ) ; f1 = factorial ( 2 * n ) ; f2 = factorial ( n + 1 ) ; f3 = factorial ( n ) ; C = f1 / ( f2 * f3 ) ; // formula for catalan number for n printf ( \"%0.2f\" , C ) ; return 0 ; }",
    "resources/C/math/cantor_set.c@propagate": "void propagate ( CantorSet * head ) { // if input is NULL, ignore the process if ( head == NULL ) return ; CantorSet * temp = head ; // local pointer to track propagation // create new node for the new set CantorSet * newNode = ( CantorSet * ) malloc ( sizeof ( CantorSet ) ) ; // get 1/3rd of interval double diff = ( ( ( temp -> end ) - ( temp -> start ) ) / 3 ) ; // update interval ranges newNode -> end = temp -> end ; temp -> end = ( ( temp -> start ) + diff ) ; newNode -> start = ( newNode -> end ) - diff ; // update pointer to next set in this level newNode -> next = temp -> next ; // point to next set temp -> next = newNode ; // create next set propagate ( temp -> next -> next ) ; }",
    "resources/C/math/cantor_set.c@print": "void print ( CantorSet * head ) { CantorSet * temp = head ; while ( temp != NULL ) // print while a valid set is found { printf ( \"\\t\" ) ; printf ( \"[%lf] -- \" , temp -> start ) ; printf ( \"[%lf]\" , temp -> end ) ; temp = temp -> next ; } printf ( \"\\n\" ) ; }",
    "resources/C/math/cantor_set.c@free_memory": "void free_memory ( CantorSet * head ) { if ( ! head ) return ; if ( head -> next ) free_memory ( head -> next ) ; free ( head ) ; }",
    "resources/C/math/cantor_set.c@main": "int main ( int argc , char const * argv [ ] ) { int start_num , end_num , levels ; if ( argc < 2 ) { printf ( \"Enter 3 arguments: start_num \\t end_num \\t levels\\n\" ) ; scanf ( \"%d %d %d\" , & start_num , & end_num , & levels ) ; } else { start_num = atoi ( argv [ 1 ] ) ; end_num = atoi ( argv [ 2 ] ) ; levels = atoi ( argv [ 3 ] ) ; } if ( start_num < 0 || end_num < 0 || levels < 0 ) { fprintf ( stderr , \"All numbers must be positive\\n\" ) ; return - 1 ; } CantorSet head = { . start = start_num , . end = end_num , . next = NULL } ; // loop to propagate each level from top to bottom for ( int i = 0 ; i < levels ; i ++ ) { printf ( \"Level %d\\t\" , i ) ; print ( & head ) ; propagate ( & head ) ; printf ( \"\\n\" ) ; } printf ( \"Level %d\\t\" , levels ) ; print ( & head ) ; // delete all memory allocated free_memory ( head . next ) ; return 0 ; }",
    "resources/C/math/is_armstrong.c@main": "int main ( ) { int n , sum = 0 , i , num ; printf ( \"Enter number: \" ) ; scanf ( \"%d\" , & n ) ; num = n ; while ( n != 0 ) { i = n % 10 ; sum = sum + ( i * i * i ) ; n = n / 10 ; } if ( sum == num ) { printf ( \"%d is an armstrong number!\\n\" , num ) ; } else { printf ( \"%d is not an armstrong number!\\n\" , num ) ; } return 0 ; }",
    "resources/C/developer_tools/test_malloc_dbg.c@main": "int main ( int argc , char * argv [ ] ) { int * iptr = malloc ( 10 * sizeof ( int ) ) ; char * cptr = calloc ( 256 , sizeof ( char ) ) ; free ( iptr ) ; // free(cptr); return 0 ; }",
    "resources/C/developer_tools/test_min_printf.c@power_of_ten": "int power_of_ten ( int a ) { int n = 1 ; ///< This number will be returned as ten to power of a for ( int i = 1 ; i <= a ; ++ i ) n *= 10 ; return n ; }",
    "resources/C/developer_tools/test_min_printf.c@is_number": "int is_number ( char * c ) { return ( * c >= '0' && * c <= '9' ) ? 1 : 0 ; }",
    "resources/C/developer_tools/test_min_printf.c@get_ch": "char get_ch ( char * p , Buffer * buffer ) { if ( buffer -> buf_size ) { buffer -> buf_size = 0 ; ///< Since character is used, this sets `buffer->buf_size` to zero return buffer -> buffr_char ; // Returns character inside buffer->buffr_char } return * p ++ ; }",
    "resources/C/developer_tools/test_min_printf.c@unget_ch": "void unget_ch ( char * c , Buffer * buffer ) { buffer -> buffr_char = * c ; // Character initializes inside buffer->buffr_char buffer -> buf_size = 1 ; // Sets bufsize to one as new character is stored in buffr_char }",
    "resources/C/developer_tools/test_min_printf.c@get_number_of_digits": "int get_number_of_digits ( int n ) { int digits = 0 ; // Stores encountered number of digits while ( n > 0 ) { ++ digits ; // Since number still contains a digit, so increment digit variable n /= 10 ; // Removes last digit from number } return digits ; }",
    "resources/C/developer_tools/test_min_printf.c@put_char": "void put_char ( char s ) { /* buf used for storing character to be printed in an array (+1 for '\\0')*/ char * buf = ( char * ) malloc ( sizeof ( char ) + 1 ) ; * buf = s ; * ( buf + 1 ) = '\\0' ; write ( 1 , buf , 1 ) ; free ( buf ) ; }",
    "resources/C/developer_tools/test_min_printf.c@reverse_str": "void reverse_str ( char * p ) { char * l = p ; // Points to first character of p char * h = p ; // Will be used to point to last character of p char temp ; // Temporarily stores a character, Used in swapping while ( * h != '\\0' ) ++ h ; -- h ; // Now h point to last valid character of string  /* Swap character which lower and higher are pointing until lower < higher. At that point string will be reversed.*/ while ( l < h ) { temp = * l ; * l = * h ; * h = temp ; ++ l ; // Increment lower to next character -- h ; // Decrement higher to previous character from current character } }",
    "resources/C/developer_tools/test_min_printf.c@print_int_value": "void print_int_value ( int n , int width , int precision ) { char * p = ( char * ) malloc ( INT_MAX_LENGTH * sizeof ( char ) + 1 ) ; /* +1 for '\\0' */ char * s = p ; // Temporary pointer int size = 0 ; //!< Used to store number of digits in number while ( n > 0 ) { * s ++ = n % 10 + '0' ; // Converts last digit of number to character and store it in p ++ size ; // Increment size variable as one more digit is occurred n /= 10 ; // Removes the last digit from the number n as we have successfully stored it in p } * s = '\\0' ; s = p ; // Again point back s to starting of p reverse_str ( p ) ; /*!\n\t * The next two conditions check weather it is required to \n\t * add blanks before printing the number (ie: width)and is it specified how many\n\t * zeros to be printed before the number is printed (ie: precision)\n\t*/ if ( width > 0 && size < width ) for ( int i = 0 ; i < ( width - precision ) ; ++ i ) put_char ( ' ' ) ; if ( precision > 0 && precision > size ) for ( int i = 0 ; i < ( precision - size ) ; ++ i ) put_char ( '0' ) ; /* Prints the number.*/ while ( * s != '\\0' ) put_char ( * s ++ ) ; free ( p ) ; }",
    "resources/C/developer_tools/test_min_printf.c@print_double_value": "void print_double_value ( double dval , int width , int precision ) { int ndigits = get_number_of_digits ( ( int ) dval ) ; // Store number of digits before decimal in dval int reqd_blanks = width - ( precision + 1 ) - ndigits ; // Blanks to be printed before printing dval, just to cover the width print_int_value ( ( int ) dval , reqd_blanks , 0 ) ; // Prints the part before decimal put_char ( '.' ) ; // Print decimal /*Deletes digits before decimal and makes them zero. For example:\n\t\tif dval = 1923.79022, them this will make dval = 0.79022\n\t*/ dval = dval - ( int ) dval ; dval *= power_of_ten ( precision ) ; // Brings precision number of digits after decimal to before decimal print_int_value ( ( int ) dval , 0 , precision ) ; // Prints the remaining number }",
    "resources/C/developer_tools/test_min_printf.c@print_string": "void print_string ( char * p , int width , int precision ) { int size = 0 ; // Stores number of character in string char * s = p ; // Temporary pointer /* Calculates size of string p*/ while ( * s != '\\0' ) { ++ size ; ++ s ; } s = p ; // Point s to starting of p /* Checks how many characters to be printed.\n\t\tif precision is defined then size variable is changed to precision so that only precision\n\t\tnumber of characters were printed.\n\t*/ if ( precision != 0 && precision < size ) size = precision ; /* Prints blanks to cover the width if required*/ for ( int i = 0 ; i < ( width - size ) ; ++ i ) put_char ( ' ' ) ; /* Print the string.*/ for ( int i = 0 ; i < size ; ++ i ) put_char ( * s ++ ) ; }",
    "resources/C/developer_tools/test_min_printf.c@get_width_and_precision": "char * get_width_and_precision ( char * p , Buffer * buffer , int * width , int * precision ) { /* Skip % if p is pointing to it.*/ if ( * p == '%' ) ++ p ; /* Calculates the width specified. */ while ( * p != '.' && is_number ( p ) ) * width = * width * 10 + ( * p ++ - '0' ) ; /* Calculates the precision specified.*/ if ( * p == '.' /* Since a precision is always specified after a '.'. */ ) { while ( is_number ( ++ p ) ) * precision = * precision * 10 + ( * p - '0' ) ; unget_ch ( p , buffer ) ; // The non number will be stored in `buffer->buffr` } return p ; }",
    "resources/C/developer_tools/test_min_printf.c@min_printf": "void min_printf ( char * fmt , ... ) { va_list ap ; // Points to each unnamed arg in turn char * p , * sval ; // p will be used to point to fmt and sval will store string value char cval ; // Stores character value int ival ; // For integer values double dval ; // For double or float values va_start ( ap , fmt ) ; // Makes ap points to first unnames argument /* Initializing the buffer for storing character. */ Buffer * buffer = ( Buffer * ) malloc ( sizeof ( Buffer ) ) ; buffer -> buf_size = 0 ; // Initially set buffer size to zero as no character is inserted for ( p = fmt ; * p != '\\0' ; ++ p ) { /* If p != '%' then the character is printed to screen. */ if ( * p != '%' ) { put_char ( * p ) ; continue ; } int width = 0 ; // Stores width specified int precision = 0 ; // Stores precision specified /* Updates values of width, precision and p. */ p = get_width_and_precision ( p , buffer , & width , & precision ) ; /* Checks format of next argument.*/ switch ( get_ch ( p , buffer ) ) { case 'd' : // Integer ival = va_arg ( ap , int ) ; print_int_value ( ival , width , precision ) ; break ; case 'c' : // Character cval = va_arg ( ap , int ) ; put_char ( cval ) ; break ; case 'f' : // Float or Double dval = va_arg ( ap , double ) ; // If precision is not specified then default value is applied if ( precision == 0 ) precision = PRECISION_FOR_FLOAT ; print_double_value ( dval , width , precision ) ; break ; case 's' : // String pointer sval = va_arg ( ap , char * ) ; print_string ( sval , width , precision ) ; break ; default : put_char ( * p ) ; break ; } } va_end ( ap ) ; }",
    "resources/C/developer_tools/test_min_printf.c@main": "int main ( ) { // print strings using `printf` and `min_printf` min_printf ( \":%d: :%1.6d:\\n\" , 12 , 56 ) ; printf ( \":%d: :%1.6d:\\n\" , 12 , 56 ) ; printf ( \"\\n\" ) ; /// Printing an empty new line // print floats or doubles using `printf` and `min_printf` min_printf ( \":%f: :%3.6f:\\n\" , 104.5654 , 43.766443332 ) ; printf ( \":%f: :%3.6f:\\n\" , 104.5654 , 43.766443332 ) ; printf ( \"\\n\" ) ; // print integers `printf` and `min_printf` min_printf ( \":%s: :%4.3s:\\n\" , \"Hello, World!\" , \"Hello, World!\" ) ; printf ( \":%s: :%4.3s:\\n\" , \"Hello, World!\" , \"Hello, World!\" ) ; }",
    "resources/C/developer_tools/malloc_dbg.c@addMemInfo": "mem_info * addMemInfo ( mem_info * memoryInfo , void * ptrToReturn , size_t bytes , int line , const char * filename , const char * functionName ) { mem_info * newMemInfo = ( mem_info * ) malloc ( sizeof ( mem_info ) ) ; if ( ! newMemInfo ) { return NULL ; } newMemInfo -> ptr = ptrToReturn ; newMemInfo -> bytes = bytes ; newMemInfo -> line = line ; newMemInfo -> fileName = filename ; newMemInfo -> functionName = functionName ; newMemInfo -> next = memoryInfo ; newMemInfo -> previous = NULL ; if ( memoryInformation ) memoryInformation -> previous = newMemInfo ; return newMemInfo ; }",
    "resources/C/developer_tools/malloc_dbg.c@inList": "int inList ( const char * filename , int line ) { mem_info * tmp = memoryInformation ; int counter = 0 ; int len = strlen ( filename ) ; while ( tmp ) { if ( len == strlen ( tmp -> fileName ) ) { if ( ! memcmp ( filename , tmp -> fileName , len ) && tmp -> line == line ) { return counter ; } } tmp = tmp -> next ; counter ++ ; } return - 1 ; }",
    "resources/C/developer_tools/malloc_dbg.c@editInfo": "void editInfo ( int elemPos , size_t bytes ) { int counter = 0 ; mem_info * tmp = memoryInformation ; while ( counter != elemPos ) { tmp = tmp -> next ; counter ++ ; } tmp -> bytes += bytes ; }",
    "resources/C/developer_tools/malloc_dbg.c@malloc_dbg": "void * malloc_dbg ( size_t bytes , int line , const char * filename , const char * functionName ) { void * ptrToReturn = malloc ( bytes ) ; int pos = 0 ; if ( ! ptrToReturn ) { return NULL ; } // We must check atexitCalled value to know if we already called the function if ( ! atexitCalled ) { atexit ( printLeaks ) ; // Used to call printLeaks when the program exit atexitCalled = 1 ; } pos = inList ( filename , line ) ; if ( pos == - 1 ) { // Add a new element in the mem_info list memoryInformation = addMemInfo ( memoryInformation , ptrToReturn , bytes , line , filename , functionName ) ; if ( ! memoryInformation ) { free ( ptrToReturn ) ; return NULL ; } } else { editInfo ( pos , bytes ) ; } return ptrToReturn ; }",
    "resources/C/developer_tools/malloc_dbg.c@calloc_dbg": "void * calloc_dbg ( size_t elementCount , size_t elementSize , int line , const char * filename , const char * functionName ) { void * ptrToReturn = calloc ( elementCount , elementSize ) ; if ( ! ptrToReturn ) { return NULL ; } // We must check atexitCalled value to know if we already called the function if ( ! atexitCalled ) { atexit ( printLeaks ) ; // Used to call printLeaks when the program exit atexitCalled = 1 ; } // Add a new element in the mem_info list memoryInformation = addMemInfo ( memoryInformation , ptrToReturn , elementCount * elementSize , line , filename , functionName ) ; if ( ! memoryInformation ) { free ( ptrToReturn ) ; return NULL ; } return ptrToReturn ; }",
    "resources/C/developer_tools/malloc_dbg.c@free_dbg": "void free_dbg ( void * ptrToFree ) { mem_info * tmp = memoryInformation ; mem_info * toFree = NULL ; mem_info * previous = NULL ; // Check if the head contains the pointer to free if ( tmp -> ptr == ptrToFree ) { toFree = tmp ; memoryInformation = tmp -> next ; free ( toFree -> ptr ) ; free ( toFree ) ; if ( memoryInformation ) { memoryInformation -> previous = NULL ; } return ; } // We can loop through the list without any problems, the head is not the pointer while ( tmp ) { if ( tmp -> ptr == ptrToFree ) // If we found the pointer that must be freed { toFree = tmp ; tmp = tmp -> next ; previous = toFree -> previous ; if ( previous ) { previous -> next = tmp ; } if ( tmp ) { tmp -> previous = previous ; } free ( toFree -> ptr ) ; if ( toFree == memoryInformation ) { memoryInformation = NULL ; } free ( toFree ) ; return ; } tmp = tmp -> next ; } }",
    "resources/C/developer_tools/malloc_dbg.c@printLeaks": "void printLeaks ( ) { mem_info * tmp = memoryInformation ; mem_info * previous = NULL ; size_t sum = 0 ; int nbBlocks = 0 ; if ( tmp ) { printf ( \"Memory Leaks detected.\\n\" ) ; } while ( tmp ) { previous = tmp ; printf ( \"\\n%ld bytes lost\\n\" , tmp -> bytes ) ; printf ( \"address : 0x%p in %s\\t%s:%d\\n\" , tmp -> ptr , tmp -> functionName , tmp -> fileName , tmp -> line ) ; printf ( \"\\n====================================\\n\" ) ; sum += tmp -> bytes ; tmp = tmp -> next ; free ( previous ) ; nbBlocks ++ ; } printf ( \"SUMMARY :\\n%ld bytes lost in %d blocks\\n\" , sum , nbBlocks ) ; }",
    "resources/C/exercism/rna_transcription/rna_transcription.c@to_rna": "char * to_rna ( const char s [ ] ) { /* determines the length of the given string */ int len = strlen ( s ) ; /* creates a return string */ char * ans = malloc ( sizeof ( char ) * len ) ; /* for the loop */ int i = 0 ; /* actual compile process */ for ( i = 0 ; i < len ; i ++ ) { switch ( s [ i ] ) { case 'G' : ans [ i ] = 'C' ; break ; case 'C' : ans [ i ] = 'G' ; break ; case 'T' : ans [ i ] = 'A' ; break ; case 'A' : ans [ i ] = 'U' ; break ; } } return ans ; }",
    "resources/C/exercism/hello_world/hello_world.c@hello": "const char * hello ( void ) { char * ans = strdup ( \"Hello, World!\" ) ; /* string is pointer of the first character */ return ans ; }",
    "resources/C/exercism/isogram/isogram.c@is_isogram": "",
    "resources/C/exercism/word_count/word_count.c@word_count": "int word_count ( const char * input_text , word_count_word_t * words ) { char word_list [ MAX_WORDS ] [ MAX_WORD_LENGTH ] ; char input [ 1000 ] ; strcpy ( input , input_text ) ; char * p_str = input ; /* index for iteration over input string */ int index = 0 ; /* index for word_list */ int index_list = 0 ; /* counts all words */ int count_all = 0 ; /* for controlling the while loop */ int loop = 1 ; /* for the for-loop */ int i = 0 ; /* collects all words in the word_list */ while ( input [ index ] && loop ) { if ( input [ index ] == ' ' ) { input [ index ] = '\\0' ; if ( strlen ( p_str ) <= MAX_WORD_LENGTH ) { if ( index_list <= MAX_WORDS ) { strcpy ( word_list [ index_list ] , p_str ) ; /* sets pointer to the next position */ p_str = input + index + 1 ; index_list ++ ; /* counts the word */ count_all ++ ; } else /* error case too many words */ { count_all = EXCESSIVE_NUMBER_OF_WORDS ; loop = 0 ; } } else /* error case: word is too long */ { count_all = EXCESSIVE_LENGTH_WORD ; loop = 0 ; } } index ++ ; } words -> count = 0 ; /* make sure none error is occurred */ if ( loop ) { /* collects the last word up to the \\0-character. and counts it.*/ strcpy ( word_list [ index_list ] , p_str ) ; count_all ++ ; for ( i = 0 ; i <= index_list ; i ++ ) { if ( strcmp ( word_list [ i ] , words -> text ) == 0 ) { words -> count ++ ; } } } /* returns the number of words or an error code */ return count_all ; }",
    "resources/C/exercism/acronym/acronym.c@abbreviate": "char * abbreviate ( const char * phrase ) { char str [ 80 ] ; strcpy ( str , phrase ) ; char * p_str = str ; static char acr [ 80 ] ; strcpy ( acr , \"\" ) ; /* for counting the words */ int counter = 0 ; /* for position the words */ int index = 0 ; /* for -loop variable */ int i = 0 ; /*\n        counts the empty-characters.\n        for determine the number of words\n    */ while ( p_str && ( i < 80 ) ) { if ( * p_str == ' ' ) { counter ++ ; } if ( i < 80 ) { p_str ++ ; i ++ ; } } i = 0 ; counter ++ ; char * * words = ( char * * ) malloc ( counter * sizeof ( char * ) ) ; /* initalizes words-array with empty strings */ for ( i = 0 ; i < counter ; i ++ ) { words [ i ] = ( char * ) malloc ( 80 * sizeof ( char ) ) ; strcpy ( words [ i ] , \"\" ) ; } /* rewind string */ p_str = str ; char * p_start = p_str ; /* collects each word in array 'words' */ while ( p_str && ( i <= 80 ) ) { if ( * p_str == ' ' ) { * p_str = '\\0' ; strncat ( words [ index ] , p_start , 80 ) ; index ++ ; p_start = p_str + 1 ; } if ( i <= 80 ) { p_str ++ ; i ++ ; } } /* adds the last word */ * p_str = '\\0' ; strncat ( words [ index ] , p_start , 80 ) ; index ++ ; /* builds the actual acronym */ for ( i = 0 ; i < index ; i ++ ) { /* capitalize the first character */ words [ i ] [ 0 ] = toupper ( words [ i ] [ 0 ] ) ; words [ i ] [ 1 ] = '\\0' ; strcat ( acr , words [ i ] ) ; } for ( i = 0 ; i < counter ; i ++ ) free ( words [ i ] ) ; free ( words ) ; return acr ; }",
    "resources/C/audio/alaw.c@encode": "void encode ( uint8_t * out , int16_t * in , size_t len ) { uint8_t alaw = 0 ; int16_t pcm = 0 ; int32_t sign = 0 ; int32_t abcd = 0 ; int32_t eee = 0 ; int32_t mask = 0 ; for ( size_t i = 0 ; i < len ; i ++ ) { pcm = * in ++ ; /* 0-7 kinds of quantization level from the table above */ eee = 7 ; mask = 0x4000 ; /* 0x4000: '0b0100 0000 0000 0000' */ /* Get sign bit */ sign = ( pcm & 0x8000 ) >> 8 ; /* Turn negative pcm to positive */ /* The absolute value of a negative number may be larger than the size\n         * of the corresponding positive number, so here needs `-pcm -1` after\n         * taking the opposite number. */ pcm = sign ? ( - pcm - 1 ) : pcm ; /* Get eee and abcd bit */ /* Use mask to locate the first `1` bit and quantization level at the\n         * same time */ while ( ( pcm & mask ) == 0 && eee > 0 ) { eee -- ; mask >>= 1 ; } /* The location of abcd bits is related with quantization level. Check\n         * the table above to determine how many bits to `>>` to get abcd */ abcd = ( pcm >> ( eee ? ( eee + 3 ) : 4 ) ) & 0x0f ; /* Put the quantization level number at right bit location to get eee\n         * bits */ eee <<= 4 ; /* Splice results */ alaw = ( sign | eee | abcd ) ; /* The standard specifies that all resulting even bits (LSB\n         * is even) are inverted before the octet is transmitted. This is to\n         * provide plenty of 0/1 transitions to facilitate the clock recovery\n         * process in the PCM receivers. Thus, a silent A-law encoded PCM\n         * channel has the 8 bit samples coded 0xD5 instead of 0x80 in the\n         * octets. (Reference from wiki above) */ * out ++ = alaw ^ 0xD5 ; } }",
    "resources/C/audio/alaw.c@decode": "void decode ( int16_t * out , uint8_t * in , size_t len ) { uint8_t alaw = 0 ; int32_t pcm = 0 ; int32_t sign = 0 ; int32_t eee = 0 ; for ( size_t i = 0 ; i < len ; i ++ ) { alaw = * in ++ ; /* Re-toggle toggled bits */ alaw ^= 0xD5 ; /* Get sign bit */ sign = alaw & 0x80 ; /* Get eee bits */ eee = ( alaw & 0x70 ) >> 4 ; /* Get abcd bits and add 1/2 quantization step */ pcm = ( alaw & 0x0f ) << 4 | 8 ; /* If quantization level > 0, there need `1` bit before abcd bits */ pcm += eee ? 0x100 : 0x0 ; /* Left shift according quantization level */ pcm <<= eee > 1 ? ( eee - 1 ) : 0 ; /* Use the right sign */ * out ++ = sign ? - pcm : pcm ; } }",
    "resources/C/audio/alaw.c@test": "static void test ( int16_t * pcm , uint8_t * coded , int16_t * decoded , size_t len ) { /* run encode */ encode ( coded , pcm , len ) ; /* check encode result */ for ( size_t i = 0 ; i < len ; i ++ ) { assert ( coded [ i ] == r_coded [ i ] ) ; } /* run decode */ decode ( decoded , coded , len ) ; /* check decode result */ for ( size_t i = 0 ; i < len ; i ++ ) { assert ( decoded [ i ] == r_decoded [ i ] ) ; } }",
    "resources/C/audio/alaw.c@main": "int main ( int argc , char * argv [ ] ) { /* output alaw encoded by encode() */ uint8_t coded [ LEN ] ; /* output pcm decoded by decode() from coded[LEN] */ int16_t decoded [ LEN ] ; test ( pcm , coded , decoded , LEN ) ; // run self-test implementations /* print test pcm inputs */ printf ( \"inputs: \" ) ; for ( size_t i = 0 ; i < LEN ; i ++ ) { printf ( \"%d \" , pcm [ i ] ) ; } printf ( \"\\n\" ) ; /* print encoded alaw */ printf ( \"encode: \" ) ; for ( size_t i = 0 ; i < LEN ; i ++ ) { printf ( \"%u \" , coded [ i ] ) ; } printf ( \"\\n\" ) ; /* print decoded pcm */ printf ( \"decode: \" ) ; for ( size_t i = 0 ; i < LEN ; i ++ ) { printf ( \"%d \" , decoded [ i ] ) ; } printf ( \"\\n\" ) ; /* It can be seen that the encoded alaw is smaller than the input PCM, so\n     * the purpose of compression is achieved. And the decoded PCM is almost the\n     * same as the original input PCM, which verifies the correctness of the\n     * decoding. The reason why it is not exactly the same is that there is\n     * precision loss during encode / decode.  */ return 0 ; }",
    "resources/C/sorting/partition_sort.c@swap": "void swap ( int * a , int * b ) { int tmp = * a ; * a = * b ; * b = tmp ; }",
    "resources/C/sorting/partition_sort.c@partition": "int partition ( int arr [ ] , int low , int high ) { int pivot = arr [ low ] ; int i = low - 1 , j = high + 1 ; while ( 1 ) { /* Find leftmost element >= pivot */ do { i ++ ; } while ( arr [ i ] < pivot ) ; /* Find rightmost element <= pivot */ do { j -- ; } while ( arr [ j ] > pivot ) ; /* if two pointers met */ if ( i >= j ) return j ; swap ( & arr [ i ] , & arr [ j ] ) ; } }",
    "resources/C/sorting/partition_sort.c@partitionSort": "void partitionSort ( int arr [ ] , int low , int high ) { if ( low < high ) { int value = partition ( arr , low , high ) ; partitionSort ( arr , low , value ) ; partitionSort ( arr , value + 1 , high ) ; } }",
    "resources/C/sorting/partition_sort.c@printArray": "void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) printf ( \"%d \" , arr [ i ] ) ; printf ( \"\\n\" ) ; }",
    "resources/C/sorting/partition_sort.c@main": "int main ( ) { int arr [ 20 ] ; int i , range = 100 ; for ( i = 0 ; i < 20 ; i ++ ) { arr [ i ] = rand ( ) % range + 1 ; } int size = sizeof arr / sizeof arr [ 0 ] ; printf ( \"Array: \\n\" ) ; printArray ( arr , size ) ; partitionSort ( arr , 0 , size - 1 ) ; printf ( \"Sorted Array: \\n\" ) ; printArray ( arr , size ) ; return 0 ; }",
    "resources/C/sorting/cocktail_sort.c@cocktailSort": "void cocktailSort ( int arr [ ] , int size ) { int i , changed = TRUE , temp , start = 0 , end = size - 1 ; while ( changed ) { changed = FALSE ; for ( i = start ; i < end ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; changed = TRUE ; } } end -- ; if ( changed == FALSE ) { break ; } changed = FALSE ; for ( i = end - 1 ; i >= start ; i -- ) { if ( arr [ i + 1 ] < arr [ i ] ) { temp = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ i ] ; arr [ i ] = temp ; changed = TRUE ; } } start ++ ; } }",
    "resources/C/sorting/cocktail_sort.c@main": "int main ( ) { int i , n ; printf ( \"Enter the size of the array: \" ) ; scanf ( \"%d\" , & n ) ; int * arr = ( int * ) malloc ( sizeof ( int ) * n ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"Number #%d: \" , i + 1 ) ; scanf ( \"%d\" , & arr [ i ] ) ; } printf ( \"You entered:  \" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"%d \" , arr [ i ] ) ; } cocktailSort ( arr , n ) ; printf ( \"\\nSorted array: \" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"%d \" , arr [ i ] ) ; } printf ( \"\\n\" ) ; free ( arr ) ; return 0 ; }",
    "resources/C/sorting/bubble_sort.c@display": "void display ( const int * arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { printf ( \"%d \" , arr [ i ] ) ; } printf ( \"\\n\" ) ; }",
    "resources/C/sorting/bubble_sort.c@swap": "void swap ( int * first , int * second ) { int temp = * first ; * first = * second ; * second = temp ; }",
    "resources/C/sorting/bubble_sort.c@bubbleSort": "void bubbleSort ( int * arr , int size ) { for ( int i = 0 ; i < size - 1 ; i ++ ) { /* for each array index */ bool swapped = false ; /* flag to check if any changes had to be made */ /* perform iterations until no more changes were made or outer loop\n            executed for all array indices */ for ( int j = 0 ; j < size - 1 - i ; j ++ ) { /* for each element in the array */ if ( arr [ j ] > arr [ j + 1 ] ) { /* if the order of successive elements needs update */ swap ( & arr [ j ] , & arr [ j + 1 ] ) ; swapped = true ; /* set flag */ } } if ( ! swapped ) { /* since no more updates we made, the array is already sorted\n                this is an optimization for early termination */ break ; } } }",
    "resources/C/sorting/bubble_sort.c@test": "void test ( ) { const int size = 10 ; int * arr = ( int * ) calloc ( size , sizeof ( int ) ) ; /* generate size random numbers from 0 to 100 */ for ( int i = 0 ; i < size ; i ++ ) { arr [ i ] = rand ( ) % 100 ; } bubbleSort ( arr , size ) ; for ( int i = 0 ; i < size - 1 ; ++ i ) { assert ( arr [ i ] <= arr [ i + 1 ] ) ; } free ( arr ) ; }",
    "resources/C/sorting/bubble_sort.c@main": "int main ( int argc , const char * argv [ ] ) { /* Intializes random number generator */ srand ( time ( NULL ) ) ; test ( ) ; return 0 ; }",
    "resources/C/sorting/merge_sort.c@swap": "void swap ( int * a , int * b ) { int t ; t = * a ; * a = * b ; * b = t ; }",
    "resources/C/sorting/merge_sort.c@merge": "void merge ( int * a , int l , int r , int n ) { int * b = ( int * ) malloc ( n * sizeof ( int ) ) ; /* dynamic memory must be freed */ if ( b == NULL ) { printf ( \"Can't Malloc! Please try again.\" ) ; exit ( EXIT_FAILURE ) ; } int c = l ; int p1 , p2 ; p1 = l ; p2 = ( ( l + r ) / 2 ) + 1 ; while ( ( p1 < ( ( l + r ) / 2 ) + 1 ) && ( p2 < r + 1 ) ) { if ( a [ p1 ] <= a [ p2 ] ) { b [ c ++ ] = a [ p1 ] ; p1 ++ ; } else { b [ c ++ ] = a [ p2 ] ; p2 ++ ; } } if ( p2 == r + 1 ) { while ( ( p1 < ( ( l + r ) / 2 ) + 1 ) ) { b [ c ++ ] = a [ p1 ] ; p1 ++ ; } } else { while ( ( p2 < r + 1 ) ) { b [ c ++ ] = a [ p2 ] ; p2 ++ ; } } for ( c = l ; c < r + 1 ; c ++ ) a [ c ] = b [ c ] ; free ( b ) ; }",
    "resources/C/sorting/merge_sort.c@merge_sort": "void merge_sort ( int * a , int n , int l , int r ) { if ( r - l == 1 ) { if ( a [ l ] > a [ r ] ) swap ( & a [ l ] , & a [ r ] ) ; } else if ( l != r ) { merge_sort ( a , n , l , ( l + r ) / 2 ) ; merge_sort ( a , n , ( ( l + r ) / 2 ) + 1 , r ) ; merge ( a , l , r , n ) ; } /* no change if l == r */ }",
    "resources/C/sorting/merge_sort.c@main": "int main ( void ) { int * a , n , i ; printf ( \"Enter Array size: \" ) ; scanf ( \"%d\" , & n ) ; if ( n <= 0 ) /* exit program if arraysize is not greater than 0 */ { printf ( \"Array size must be Greater than 0!\\n\" ) ; return 1 ; } a = ( int * ) malloc ( n * sizeof ( int ) ) ; if ( a == NULL ) /* exit program if can't malloc memory */ { printf ( \"Can't Malloc! Please try again.\" ) ; return 1 ; } for ( i = 0 ; i < n ; i ++ ) { printf ( \"Enter number[%d]: \" , i ) ; scanf ( \"%d\" , & a [ i ] ) ; } merge_sort ( a , n , 0 , n - 1 ) ; printf ( \"Sorted Array: \" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"%d \" , a [ i ] ) ; } printf ( \"\\n\" ) ; free ( a ) ; return 0 ; }",
    "resources/C/sorting/bucket_sort.c@BucketSort": "void BucketSort ( int arr [ ] ) { int i , j ; struct Node * * buckets ; /* allocate memory for array of pointers to the buckets */ buckets = ( struct Node * * ) malloc ( sizeof ( struct Node * ) * NBUCKET ) ; /* initialize pointers to the buckets */ for ( i = 0 ; i < NBUCKET ; ++ i ) { buckets [ i ] = NULL ; } /* put items into the buckets */ /* creates a link list in each bucket slot */ for ( i = 0 ; i < NARRAY ; ++ i ) { struct Node * current ; int pos = getBucketIndex ( arr [ i ] ) ; current = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; current -> data = arr [ i ] ; current -> next = buckets [ pos ] ; buckets [ pos ] = current ; } /* check what's in each bucket */ for ( i = 0 ; i < NBUCKET ; i ++ ) { printf ( \"Bucket[\\\"%d\\\"] : \" , i ) ; printBuckets ( buckets [ i ] ) ; printf ( \"\\n\" ) ; } /* sorting bucket using Insertion Sort */ for ( i = 0 ; i < NBUCKET ; ++ i ) { buckets [ i ] = InsertionSort ( buckets [ i ] ) ; } /* check what's in each bucket */ printf ( \"--------------\\n\" ) ; printf ( \"Buckets after sorted\\n\" ) ; for ( i = 0 ; i < NBUCKET ; i ++ ) { printf ( \"Bucket[\\\"%d\\\"] : \" , i ) ; printBuckets ( buckets [ i ] ) ; printf ( \"\\n\" ) ; } /* put items back to original array */ for ( j = 0 , i = 0 ; i < NBUCKET ; ++ i ) { struct Node * node ; node = buckets [ i ] ; while ( node ) { // precondition for avoiding out of bounds by the array assert ( j < NARRAY ) ; arr [ j ++ ] = node -> data ; node = node -> next ; } } /* free memory */ for ( i = 0 ; i < NBUCKET ; ++ i ) { struct Node * node ; node = buckets [ i ] ; while ( node ) { struct Node * tmp ; tmp = node ; node = node -> next ; free ( tmp ) ; } } free ( buckets ) ; return ; }",
    "resources/C/sorting/bucket_sort.c@InsertionSort": "struct Node * InsertionSort ( struct Node * list ) { struct Node * k , * nodeList ; /* need at least two items to sort */ if ( list == NULL || list -> next == NULL ) { return list ; } nodeList = list ; k = list -> next ; nodeList -> next = NULL ; /* 1st node is new list */ while ( k != NULL ) { struct Node * ptr ; /* check if insert before first */ if ( nodeList -> data > k -> data ) { struct Node * tmp ; tmp = k ; k = k -> next ; // important for the while tmp -> next = nodeList ; nodeList = tmp ; continue ; } // from begin up to end // finds [i] > [i+1] for ( ptr = nodeList ; ptr -> next != NULL ; ptr = ptr -> next ) { if ( ptr -> next -> data > k -> data ) break ; } // if found (above) if ( ptr -> next != NULL ) { struct Node * tmp ; tmp = k ; k = k -> next ; // important for the while tmp -> next = ptr -> next ; ptr -> next = tmp ; continue ; } else { ptr -> next = k ; k = k -> next ; // important for the while ptr -> next -> next = NULL ; continue ; } } return nodeList ; }",
    "resources/C/sorting/bucket_sort.c@getBucketIndex": "int getBucketIndex ( int value ) { return value / INTERVAL ; }",
    "resources/C/sorting/bucket_sort.c@print": "void print ( int ar [ ] ) { int i ; for ( i = 0 ; i < NARRAY ; ++ i ) { printf ( \"%d \" , ar [ i ] ) ; } printf ( \"\\n\" ) ; }",
    "resources/C/sorting/bucket_sort.c@printBuckets": "void printBuckets ( struct Node * list ) { struct Node * cur = list ; while ( cur ) { printf ( \"%d \" , cur -> data ) ; cur = cur -> next ; } }",
    "resources/C/sorting/bucket_sort.c@main": "int main ( void ) { int array [ NARRAY ] = { 29 , 25 , - 1 , 49 , 9 , 37 , 21 , 43 } ; printf ( \"Initial array\\n\" ) ; print ( array ) ; printf ( \"------------\\n\" ) ; BucketSort ( array ) ; printf ( \"------------\\n\" ) ; printf ( \"Sorted array\\n\" ) ; print ( array ) ; return 0 ; }",
    "resources/C/sorting/shell_sort.c@show_data": "void show_data ( int arr [ ] , int len ) { int i ; for ( i = 0 ; i < len ; i ++ ) printf ( \"%3d \" , arr [ i ] ) ; printf ( \"\\n\" ) ; }",
    "resources/C/sorting/shell_sort.c@swap": "void swap ( int * a , int * b ) { int tmp ; tmp = * a ; * a = * b ; * b = tmp ; }",
    "resources/C/sorting/shell_sort.c@shellSort": "void shellSort ( int array [ ] , int len ) { int i , j , gap ; for ( gap = len / 2 ; gap > 0 ; gap = gap / 2 ) for ( i = gap ; i < len ; i ++ ) for ( j = i - gap ; j >= 0 && array [ j ] > array [ j + gap ] ; j = j - gap ) swap ( & array [ j ] , & array [ j + gap ] ) ; }",
    "resources/C/sorting/shell_sort.c@main": "int main ( int argc , char * argv [ ] ) { int i ; int array [ ELEMENT_NR ] ; int range = 500 ; int size ; clock_t start , end ; double time_spent ; srand ( time ( NULL ) ) ; for ( i = 0 ; i < ELEMENT_NR ; i ++ ) array [ i ] = rand ( ) % range + 1 ; size = ARRAY_LEN ( array ) ; show_data ( array , size ) ; start = clock ( ) ; shellSort ( array , size ) ; end = clock ( ) ; time_spent = ( double ) ( end - start ) / CLOCKS_PER_SEC ; printf ( \"Data Sorted\\n\" ) ; show_data ( array , size ) ; printf ( \"%s\\n\" , notation ) ; printf ( \"Time spent sorting: %.4g ms\\n\" , time_spent * 1e3 ) ; return 0 ; }",
    "resources/C/sorting/bead_sort.c@display": "void display ( const int * arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { printf ( \"%d \" , arr [ i ] ) ; } printf ( \"\\n\" ) ; }",
    "resources/C/sorting/bead_sort.c@bead_sort": "void bead_sort ( int * a , size_t len ) { int i , j , max , sum ; unsigned char * beads ; for ( i = 1 , max = a [ 0 ] ; i < len ; i ++ ) if ( a [ i ] > max ) max = a [ i ] ; beads = calloc ( 1 , max * len ) ; /* mark the beads */ for ( i = 0 ; i < len ; i ++ ) for ( j = 0 ; j < a [ i ] ; j ++ ) BEAD ( i , j ) = 1 ; for ( j = 0 ; j < max ; j ++ ) { /* count how many beads are on each post */ for ( sum = i = 0 ; i < len ; i ++ ) { sum += BEAD ( i , j ) ; BEAD ( i , j ) = 0 ; } /* mark bottom sum beads */ for ( i = len - sum ; i < len ; i ++ ) BEAD ( i , j ) = 1 ; } for ( i = 0 ; i < len ; i ++ ) { for ( j = 0 ; j < max && BEAD ( i , j ) ; j ++ ) ; a [ i ] = j ; } free ( beads ) ; }",
    "resources/C/sorting/bead_sort.c@main": "int main ( int argc , const char * argv [ ] ) { int n ; printf ( \"Enter size of array:\\n\" ) ; scanf ( \"%d\" , & n ) ; // E.g. 8 1 2 3 printf ( \"Enter the elements of the array\\n\" ) ; int i ; int * arr = ( int * ) malloc ( n * sizeof ( int ) ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & arr [ i ] ) ; } printf ( \"Original array: \" ) ; display ( arr , n ) ; bead_sort ( arr , n ) ; printf ( \"Sorted array: \" ) ; display ( arr , n ) ; free ( arr ) ; return 0 ; }",
    "resources/C/sorting/heap_sort.c@max_heapify": "void max_heapify ( int * a , int i , int n ) { int j , temp ; temp = a [ i ] ; j = 2 * i ; while ( j <= n ) { if ( j < n && a [ j + 1 ] > a [ j ] ) j = j + 1 ; if ( temp > a [ j ] ) { break ; } else if ( temp <= a [ j ] ) { a [ j / 2 ] = a [ j ] ; j = 2 * j ; } } a [ j / 2 ] = temp ; return ; }",
    "resources/C/sorting/heap_sort.c@heapsort": "void heapsort ( int * a , int n ) { int i , temp ; for ( i = n ; i >= 2 ; i -- ) { temp = a [ i ] ; a [ i ] = a [ 1 ] ; a [ 1 ] = temp ; max_heapify ( a , 1 , i - 1 ) ; } }",
    "resources/C/sorting/heap_sort.c@build_maxheap": "void build_maxheap ( int * a , int n ) { int i ; for ( i = n / 2 ; i >= 1 ; i -- ) { max_heapify ( a , i , n ) ; } }",
    "resources/C/sorting/heap_sort.c@main": "int main ( ) { int n , i ; printf ( \"Enter number of elements of array\\n\" ) ; scanf ( \"%d\" , & n ) ; int a [ 20 ] ; for ( i = 1 ; i <= n ; i ++ ) { printf ( \"Enter Element %d\\n\" , i ) ; scanf ( \"%d\" , a + i ) ; } build_maxheap ( a , n ) ; heapsort ( a , n ) ; printf ( \"Sorted Output\\n\" ) ; for ( i = 1 ; i <= n ; i ++ ) { printf ( \"%d\\n\" , a [ i ] ) ; } getchar ( ) ; }",
    "resources/C/sorting/bubble_sort_2.c@bubble_sort": "void bubble_sort ( int * array_sort ) { bool is_sorted = false ; /* keep iterating over entire array\n     * and swaping elements out of order\n     * until it is sorted */ while ( ! is_sorted ) { is_sorted = true ; /* iterate over all elements */ for ( int i = 0 ; i < MAX - 1 ; i ++ ) { /* check if adjacent elements are out of order */ if ( array_sort [ i ] > array_sort [ i + 1 ] ) { /* swap elements */ int change_place = array_sort [ i ] ; array_sort [ i ] = array_sort [ i + 1 ] ; array_sort [ i + 1 ] = change_place ; /* elements out of order were found\n                 * so we reset the flag to keep ordering\n                 * until no swap operations are executed */ is_sorted = false ; } } } }",
    "resources/C/sorting/bubble_sort_2.c@test": "static void test ( ) { /* simple int array for testing */ int array_sort [ MAX ] = { 0 } ; /* populate our test array with \n     * random integer numbers */ for ( int i = 0 ; i < MAX ; i ++ ) { array_sort [ i ] = rand ( ) % 101 ; } /* sort array */ bubble_sort ( array_sort ) ; /* check if array ir correctly ordered */ for ( int i = 0 ; i < MAX - 1 ; i ++ ) { assert ( array_sort [ i ] <= array_sort [ i + 1 ] ) ; } }",
    "resources/C/sorting/bubble_sort_2.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/sorting/bogo_sort.c@check_sorted": "",
    "resources/C/sorting/bogo_sort.c@shuffle": "void shuffle ( int * a , int n ) { int i , t , r ; for ( i = 0 ; i < n ; i ++ ) { t = a [ i ] ; r = rand ( ) % n ; a [ i ] = a [ r ] ; a [ r ] = t ; } }",
    "resources/C/sorting/bogo_sort.c@sort": "void sort ( int * a , int n ) { while ( ! check_sorted ( a , n ) ) shuffle ( a , n ) ; }",
    "resources/C/sorting/bogo_sort.c@main": "int main ( ) { int numbers [ 6 ] ; int i ; printf ( \"Enter 6 numbers unsorted \\n\\n\" ) ; for ( i = 0 ; i < 6 ; i ++ ) { scanf ( \"%d\" , & numbers [ i ] ) ; } sort ( numbers , 6 ) ; for ( i = 0 ; i < 6 ; i ++ ) printf ( \"%d \" , numbers [ i ] ) ; printf ( \"\\n\" ) ; }",
    "resources/C/sorting/patience_sort.c@patienceSort": "void patienceSort ( int * array , int length ) { // An array of pointers used to store each pile int * * piles = ( int * * ) malloc ( sizeof ( int * ) * length ) ; for ( int i = 0 ; i < length ; ++ i ) { piles [ i ] = malloc ( sizeof ( int ) * length ) ; } // pileSizes keep track of the indices of each pile's topmost element, hence 0 means only one element // Note how calloc() is used to initialize the sizes of all piles to zero int * pileSizes = ( int * ) calloc ( length , sizeof ( int ) ) ; // This initializes the first pile, note how using an array of pointers allowed us to access elements through two subscripts // The first subscript indicates which pile we are accessing, the second subscript indicates the location being accessed in that pile piles [ 0 ] [ 0 ] = array [ 0 ] ; int pileCount = 1 ; for ( int i = 1 ; i < length ; ++ i ) { // This will be used to keep track whether an element has been added to an existing pile int flag = 1 ; for ( int j = 0 ; j < pileCount ; ++ j ) { if ( piles [ j ] [ pileSizes [ j ] ] > array [ i ] ) { // We have found a pile this element can be added to piles [ j ] [ pileSizes [ j ] + 1 ] = array [ i ] ; pileSizes [ j ] ++ ; flag -- ; break ; } } if ( flag ) { // The element in question can not be added to any existing piles, creating a new pile piles [ pileCount ] [ 0 ] = array [ i ] ; pileCount ++ ; } } // This will keep track of the minimum value of all 'exposed' elements and which pile that value is from int min , minLocation ; for ( int i = 0 ; i < length ; ++ i ) { // Since there's no guarantee the first pile will be depleted slower than other piles, // Example: when all elements are equal, in that case the first pile will be depleted immediately // We can't simply initialize min to the top most element of the first pile, // this loop finds a value to initialize min to. for ( int j = 0 ; j < pileCount ; ++ j ) { if ( pileSizes [ j ] < 0 ) { continue ; } min = piles [ j ] [ pileSizes [ j ] ] ; minLocation = j ; break ; } for ( int j = 0 ; j < pileCount ; ++ j ) { if ( pileSizes [ j ] < 0 ) { continue ; } if ( piles [ j ] [ pileSizes [ j ] ] < min ) { min = piles [ j ] [ pileSizes [ j ] ] ; minLocation = j ; } } array [ i ] = min ; pileSizes [ minLocation ] -- ; } // Deallocate memory free ( pileSizes ) ; for ( int i = 0 ; i < length ; ++ i ) { free ( piles [ i ] ) ; } free ( piles ) ; }",
    "resources/C/sorting/patience_sort.c@printArray": "void printArray ( int * array , int length ) { printf ( \"Array:\" ) ; for ( int i = 0 ; i < length ; ++ i ) { printf ( \"%d\" , array [ i ] ) ; if ( i != length - 1 ) putchar ( ',' ) ; } putchar ( '\\n' ) ; }",
    "resources/C/sorting/patience_sort.c@testArray": "void testArray ( int * array , int length ) { printf ( \"Before sorting:\\n\" ) ; printArray ( array , length ) ; patienceSort ( array , length ) ; printf ( \"After sorting:\\n\" ) ; printArray ( array , length ) ; for ( int i = 0 ; i < length - 1 ; ++ i ) { assert ( array [ i ] <= array [ i + 1 ] ) ; } printf ( \"All assertions have passed!\\n\\n\" ) ; }",
    "resources/C/sorting/patience_sort.c@test": "static void test ( ) { int testArray1 [ ] = { 2 , 8 , 7 , 1 , 3 , 5 , 6 , 4 } ; int testArray2 [ ] = { 2 , 2 , 5 , 1 , 3 , 5 , 6 , 4 } ; int testArray3 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int testArray4 [ ] = { 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 } ; testArray ( testArray1 , 8 ) ; testArray ( testArray2 , 8 ) ; testArray ( testArray3 , 8 ) ; testArray ( testArray4 , 8 ) ; printf ( \"Testing successfully completed!\\n\" ) ; }",
    "resources/C/sorting/patience_sort.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/sorting/pancake_sort.c@flip": "void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } }",
    "resources/C/sorting/pancake_sort.c@findMax": "int findMax ( int arr [ ] , int n ) { int maxElementIdx , i ; for ( maxElementIdx = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ maxElementIdx ] ) maxElementIdx = i ; return maxElementIdx ; }",
    "resources/C/sorting/pancake_sort.c@pancakeSort": "void pancakeSort ( int * arr , int n ) { // Start from the complete array and one by one reduce current size by one for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) { // Find index of the maximum element in arr[0..curr_size-1] int maxElementIdx = findMax ( arr , curr_size ) ; // Move the maximum element to end of current array if it's not already // at the end if ( maxElementIdx != curr_size - 1 ) { // To move at the end, first move maximum number to beginning flip ( arr , maxElementIdx ) ; // Now move the maximum number to end by reversing current array flip ( arr , curr_size - 1 ) ; } } }",
    "resources/C/sorting/pancake_sort.c@display": "void display ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { printf ( \"%d \" , arr [ i ] ) ; } printf ( \"\\n\" ) ; }",
    "resources/C/sorting/pancake_sort.c@main": "int main ( ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = rand ( ) % ( N << 1 ) ; /* random numbers from 0 to 2N */ printf ( \"Original array: \" ) ; display ( arr , N ) ; pancakeSort ( arr , N ) ; printf ( \"Sorted array: \" ) ; display ( arr , N ) ; return 0 ; }",
    "resources/C/sorting/binary_insertion_sort.c@display": "void display ( int * arr , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"%d \" , arr [ i ] ) ; } printf ( \"\\n\" ) ; }",
    "resources/C/sorting/binary_insertion_sort.c@binarySearch": "int binarySearch ( int * arr , int key , int low , int high ) { if ( low >= high ) return ( key > arr [ low ] ) ? ( low + 1 ) : low ; int mid = low + ( high - 1 ) / 2 ; if ( arr [ mid ] == key ) return mid + 1 ; else if ( arr [ mid ] > key ) return binarySearch ( arr , key , low , mid - 1 ) ; else return binarySearch ( arr , key , mid + 1 , high ) ; }",
    "resources/C/sorting/binary_insertion_sort.c@insertionSort": "void insertionSort ( int * arr , int size ) { int i , j , key , index ; for ( i = 0 ; i < size ; i ++ ) { j = i - 1 ; key = arr [ i ] ; /* Use binrary search to find exact key's index */ index = binarySearch ( arr , key , 0 , j ) ; /* Move all elements greater than key from [index...j]\n         * to one position */ while ( j >= index ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } /* Insert key value in right place */ arr [ j + 1 ] = key ; } }",
    "resources/C/sorting/binary_insertion_sort.c@main": "int main ( int argc , const char * argv [ ] ) { int n ; printf ( \"Enter size of array:\\n\" ) ; scanf ( \"%d\" , & n ) ; // E.g. 8 printf ( \"Enter the elements of the array\\n\" ) ; int i ; int * arr = ( int * ) malloc ( n * sizeof ( int ) ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & arr [ i ] ) ; } printf ( \"Original array: \" ) ; display ( arr , n ) ; insertionSort ( arr , n ) ; printf ( \"Sorted array: \" ) ; display ( arr , n ) ; free ( arr ) ; return 0 ; }",
    "resources/C/sorting/multikey_quick_sort.c@vecswap": "void vecswap ( int i , int j , int n , char * x [ ] ) { while ( n -- > 0 ) { swap ( i , j ) ; i ++ ; j ++ ; } }",
    "resources/C/sorting/multikey_quick_sort.c@ssort1": "void ssort1 ( char * x [ ] , int n , int depth ) { int a , b , c , d , r , v ; if ( n <= 1 ) return ; a = rand ( ) % n ; swap ( 0 , a ) ; v = i2c ( 0 ) ; a = b = 1 ; c = d = n - 1 ; for ( ; ; ) { while ( b <= c && ( r = i2c ( b ) - v ) <= 0 ) { if ( r == 0 ) { swap ( a , b ) ; a ++ ; } b ++ ; } while ( b <= c && ( r = i2c ( c ) - v ) >= 0 ) { if ( r == 0 ) { swap ( c , d ) ; d -- ; } c -- ; } if ( b > c ) break ; swap ( b , c ) ; b ++ ; c -- ; } r = min ( a , b - a ) ; vecswap ( 0 , b - r , r , x ) ; r = min ( d - c , n - d - 1 ) ; vecswap ( b , n - r , r , x ) ; r = b - a ; ssort1 ( x , r , depth ) ; if ( i2c ( r ) != 0 ) ssort1 ( x + r , a + n - d - 1 , depth + 1 ) ; r = d - c ; ssort1 ( x + n - r , r , depth ) ; }",
    "resources/C/sorting/multikey_quick_sort.c@ssort1main": "void ssort1main ( char * x [ ] , int n ) { ssort1 ( x , n , 0 ) ; }",
    "resources/C/sorting/multikey_quick_sort.c@vecswap2": "void vecswap2 ( char * * a , char * * b , int n ) { while ( n -- > 0 ) { char * t = * a ; * a ++ = * b ; * b ++ = t ; } }",
    "resources/C/sorting/multikey_quick_sort.c@med3func": "char * * med3func ( char * * a , char * * b , char * * c , int depth ) { int va , vb , vc ; if ( ( va = ptr2char ( a ) ) == ( vb = ptr2char ( b ) ) ) return a ; if ( ( vc = ptr2char ( c ) ) == va || vc == vb ) return c ; return va < vb ? ( vb < vc ? b : ( va < vc ? c : a ) ) : ( vb > vc ? b : ( va < vc ? a : c ) ) ; }",
    "resources/C/sorting/multikey_quick_sort.c@inssort": "void inssort ( char * * a , int n , int d ) { char * * pi , * * pj , * s , * t ; for ( pi = a + 1 ; -- n > 0 ; pi ++ ) for ( pj = pi ; pj > a ; pj -- ) { // Inline strcmp: break if *(pj-1) <= *pj for ( s = * ( pj - 1 ) + d , t = * pj + d ; * s == * t && * s != 0 ; s ++ , t ++ ) ; if ( * s <= * t ) break ; swap2 ( pj , pj - 1 ) ; } }",
    "resources/C/sorting/multikey_quick_sort.c@ssort2": "void ssort2 ( char * * a , int n , int depth ) { int d , r , partval ; char * * pa , * * pb , * * pc , * * pd , * * pl , * * pm , * * pn , * t ; if ( n < 10 ) { inssort ( a , n , depth ) ; return ; } pl = a ; pm = a + ( n / 2 ) ; pn = a + ( n - 1 ) ; if ( n > 30 ) { // On big arrays, pseudomedian of 9 d = ( n / 8 ) ; pl = med3 ( pl , pl + d , pl + 2 * d ) ; pm = med3 ( pm - d , pm , pm + d ) ; pn = med3 ( pn - 2 * d , pn - d , pn ) ; } pm = med3 ( pl , pm , pn ) ; swap2 ( a , pm ) ; partval = ptr2char ( a ) ; pa = pb = a + 1 ; pc = pd = a + n - 1 ; for ( ; ; ) { while ( pb <= pc && ( r = ptr2char ( pb ) - partval ) <= 0 ) { if ( r == 0 ) { swap2 ( pa , pb ) ; pa ++ ; } pb ++ ; } while ( pb <= pc && ( r = ptr2char ( pc ) - partval ) >= 0 ) { if ( r == 0 ) { swap2 ( pc , pd ) ; pd -- ; } pc -- ; } if ( pb > pc ) break ; swap2 ( pb , pc ) ; pb ++ ; pc -- ; } pn = a + n ; r = min ( pa - a , pb - pa ) ; vecswap2 ( a , pb - r , r ) ; r = min ( pd - pc , pn - pd - 1 ) ; vecswap2 ( pb , pn - r , r ) ; if ( ( r = pb - pa ) > 1 ) ssort2 ( a , r , depth ) ; if ( ptr2char ( a + r ) != 0 ) ssort2 ( a + r , pa - a + pn - pd - 1 , depth + 1 ) ; if ( ( r = pd - pc ) > 1 ) ssort2 ( a + n - r , r , depth ) ; }",
    "resources/C/sorting/multikey_quick_sort.c@ssort2main": "void ssort2main ( char * * a , int n ) { ssort2 ( a , n , 0 ) ; }",
    "resources/C/sorting/multikey_quick_sort.c@insert1": "Tptr insert1 ( Tptr p , char * s ) { if ( p == 0 ) { p = ( Tptr ) malloc ( sizeof ( Tnode ) ) ; p -> splitchar = * s ; p -> lokid = p -> eqkid = p -> hikid = 0 ; } if ( * s < p -> splitchar ) p -> lokid = insert1 ( p -> lokid , s ) ; else if ( * s == p -> splitchar ) { if ( * s != 0 ) p -> eqkid = insert1 ( p -> eqkid , ++ s ) ; } else p -> hikid = insert1 ( p -> hikid , s ) ; return p ; }",
    "resources/C/sorting/multikey_quick_sort.c@cleanup1": "void cleanup1 ( Tptr p ) { if ( p ) { cleanup1 ( p -> lokid ) ; cleanup1 ( p -> eqkid ) ; cleanup1 ( p -> hikid ) ; free ( p ) ; } }",
    "resources/C/sorting/multikey_quick_sort.c@insert2": "void insert2 ( char * s ) { int d ; char * instr = s ; Tptr pp , * p ; p = & root ; pp = * p ; while ( pp == * p ) { if ( ( d = * s - pp -> splitchar ) == 0 ) { if ( * s ++ == 0 ) return ; p = & ( pp -> eqkid ) ; } else if ( d < 0 ) p = & ( pp -> lokid ) ; else p = & ( pp -> hikid ) ; } for ( ; ; ) { // *p = (Tptr) malloc(sizeof(Tnode)); if ( bufn -- == 0 ) { buffer = ( Tptr ) malloc ( BUFSIZE * sizeof ( Tnode ) ) ; freearr [ freen ++ ] = ( void * ) buffer ; bufn = BUFSIZE - 1 ; } * p = buffer ++ ; pp = * p ; pp -> splitchar = * s ; pp -> lokid = pp -> eqkid = pp -> hikid = 0 ; if ( * s ++ == 0 ) { if ( storestring ) pp -> eqkid = ( Tptr ) instr ; return ; } p = & ( pp -> eqkid ) ; } }",
    "resources/C/sorting/multikey_quick_sort.c@cleanup2": "void cleanup2 ( ) { int i ; for ( i = 0 ; i < freen ; i ++ ) free ( freearr [ i ] ) ; }",
    "resources/C/sorting/multikey_quick_sort.c@search1": "int search1 ( char * s ) { Tptr p ; p = root ; while ( p ) { if ( * s < p -> splitchar ) p = p -> lokid ; else if ( * s == p -> splitchar ) { if ( * s ++ == 0 ) return 1 ; p = p -> eqkid ; } else p = p -> hikid ; } return 0 ; }",
    "resources/C/sorting/multikey_quick_sort.c@search2": "int search2 ( char * s ) { int d , sc ; Tptr p ; sc = * s ; p = root ; while ( p ) { if ( ( d = sc - p -> splitchar ) == 0 ) { if ( sc == 0 ) return 1 ; sc = * ++ s ; p = p -> eqkid ; } else if ( d < 0 ) p = p -> lokid ; else p = p -> hikid ; } return 0 ; }",
    "resources/C/sorting/multikey_quick_sort.c@pmsearch": "void pmsearch ( Tptr p , char * s ) { if ( ! p ) return ; nodecnt ++ ; if ( * s == '.' || * s < p -> splitchar ) pmsearch ( p -> lokid , s ) ; if ( * s == '.' || * s == p -> splitchar ) if ( p -> splitchar && * s ) pmsearch ( p -> eqkid , s + 1 ) ; if ( * s == 0 && p -> splitchar == 0 ) srcharr [ srchtop ++ ] = ( char * ) p -> eqkid ; if ( * s == '.' || * s > p -> splitchar ) pmsearch ( p -> hikid , s ) ; }",
    "resources/C/sorting/multikey_quick_sort.c@nearsearch": "void nearsearch ( Tptr p , char * s , int d ) { if ( ! p || d < 0 ) return ; nodecnt ++ ; if ( d > 0 || * s < p -> splitchar ) nearsearch ( p -> lokid , s , d ) ; if ( p -> splitchar == 0 ) { if ( ( int ) strlen ( s ) <= d ) srcharr [ srchtop ++ ] = ( char * ) p -> eqkid ; } else nearsearch ( p -> eqkid , * s ? s + 1 : s , ( * s == p -> splitchar ) ? d : d - 1 ) ; if ( d > 0 || * s > p -> splitchar ) nearsearch ( p -> hikid , s , d ) ; }",
    "resources/C/sorting/multikey_quick_sort.c@main": "int main ( int argc , char * argv [ ] ) { char * arr [ NUMBER_OF_STRING ] = { \"apple\" , \"cat\" , \"boy\" } ; ssort1main ( arr , NUMBER_OF_STRING ) ; for ( int i = 0 ; i < NUMBER_OF_STRING ; i ++ ) { printf ( \"%s \" , arr [ i ] ) ; } }",
    "resources/C/sorting/stooge_sort.c@main": "int main ( ) { int arr [ 100 ] , i , n ; printf ( \"How many elements do you want to sort: \" ) ; scanf ( \"%d\" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( \" %d\" , & arr [ i ] ) ; stoogesort ( arr , 0 , n - 1 ) ; printf ( \"Sorted array : \\n\" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"%d \" , arr [ i ] ) ; } printf ( \"\\n\" ) ; return 0 ; }",
    "resources/C/sorting/stooge_sort.c@stoogesort": "void stoogesort ( int arr [ ] , int i , int j ) { int temp , k ; if ( arr [ i ] > arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } if ( ( i + 1 ) >= j ) return ; k = ( int ) ( ( j - i + 1 ) / 3 ) ; stoogesort ( arr , i , j - k ) ; stoogesort ( arr , i + k , j ) ; stoogesort ( arr , i , j - k ) ; }",
    "resources/C/sorting/shell_sort2.c@show_data": "void show_data ( int * arr , long len ) { for ( long i = 0 ; i < len ; i ++ ) printf ( \"%3d \" , arr [ i ] ) ; printf ( \"\\n\" ) ; }",
    "resources/C/sorting/shell_sort2.c@swap": "inline void swap ( int * a , int * b ) { int tmp ; tmp = * a ; * a = * b ; * b = tmp ; }",
    "resources/C/sorting/shell_sort2.c@shell_sort": "void shell_sort ( int * array , long LEN ) { const int gaps [ ] = { 701 , 301 , 132 , 57 , 23 , 10 , 4 , 1 } ; const int gap_len = 8 ; long i , j , g ; for ( g = 0 ; g < gap_len ; g ++ ) { // for each gap int gap = gaps [ g ] ; for ( i = gap ; i < LEN ; i ++ ) { // from gap position to the end int tmp = array [ i ] ; for ( j = i ; j >= gap && ( array [ j - gap ] - tmp ) > 0 ; j -= gap ) array [ j ] = array [ j - gap ] ; array [ j ] = tmp ; } } # ifdef DEBUG for ( i = 0 ; i < LEN ; i ++ ) printf ( \"%s\\t\" , data [ i ] ) ; # endif }",
    "resources/C/sorting/shell_sort2.c@main": "int main ( int argc , char * argv [ ] ) { int i ; long size = 500 ; if ( argc == 2 ) size = atol ( argv [ 1 ] ) ; else if ( argc > 2 ) fprintf ( stderr , \"Usage: ./shell_sort [number of values]\\n\" ) ; int * array = ( int * ) malloc ( size * sizeof ( int ) ) ; int range = 500 ; // range of array values double time_spent ; srand ( time ( NULL ) ) ; // initialize random number generator for ( i = 0 ; i < size ; i ++ ) // fill array with random integers array [ i ] = rand ( ) % range + 1 ; show_data ( array , size ) ; // show array before sorting clock_t t1 = clock ( ) ; // start timer shell_sort ( array , size ) ; // sort the array clock_t t2 = clock ( ) ; // end timer printf ( \"Data Sorted\\n\" ) ; show_data ( array , size ) ; // display array after sorting printf ( \"Time spent sorting: %.4g s\\n\" , ( t2 - t1 ) / CLOCKS_PER_SEC ) ; free ( array ) ; return 0 ; }",
    "resources/C/sorting/heap_sort_2.c@swap": "void swap ( int8_t * first , int8_t * second ) { int8_t temp = * first ; * first = * second ; * second = temp ; }",
    "resources/C/sorting/heap_sort_2.c@heapifyDown": "void heapifyDown ( int8_t * arr , const uint8_t size ) { uint8_t i = 0 ; while ( 2 * i + 1 < size ) { uint8_t maxChild = 2 * i + 1 ; if ( 2 * i + 2 < size && arr [ 2 * i + 2 ] > arr [ maxChild ] ) { maxChild = 2 * i + 2 ; } if ( arr [ maxChild ] > arr [ i ] ) { swap ( & arr [ i ] , & arr [ maxChild ] ) ; i = maxChild ; } else { break ; } } }",
    "resources/C/sorting/heap_sort_2.c@heapifyUp": "void heapifyUp ( int8_t * arr , uint8_t i ) { while ( i > 0 && arr [ ( i - 1 ) / 2 ] < arr [ i ] ) { swap ( & arr [ ( i - 1 ) / 2 ] , & arr [ i ] ) ; i = ( i - 1 ) / 2 ; } }",
    "resources/C/sorting/heap_sort_2.c@heapSort": "void heapSort ( int8_t * arr , const uint8_t size ) { if ( size <= 1 ) { return ; } for ( uint8_t i = 0 ; i < size ; i ++ ) { // Pushing `arr[i]` to the heap /*heapifyUp Adjusts arr[i] to the correct position in the heap*/ heapifyUp ( arr , i ) ; } for ( uint8_t i = size - 1 ; i >= 1 ; i -- ) { // Moving current root to the end swap ( & arr [ 0 ] , & arr [ i ] ) ; // `heapifyDown` adjusts new root to the correct position in the heap heapifyDown ( arr , i ) ; } }",
    "resources/C/sorting/heap_sort_2.c@test": "static void test ( ) { const uint8_t size = 10 ; int8_t * arr = ( int8_t * ) calloc ( size , sizeof ( int8_t ) ) ; /* generate size random numbers from 0 to 100 */ for ( uint8_t i = 0 ; i < size ; i ++ ) { arr [ i ] = rand ( ) % 100 ; } heapSort ( arr , size ) ; for ( uint8_t i = 0 ; i < size - 1 ; ++ i ) { assert ( arr [ i ] <= arr [ i + 1 ] ) ; } free ( arr ) ; }",
    "resources/C/sorting/heap_sort_2.c@main": "int main ( ) { // Intializes random number generator srand ( time ( NULL ) ) ; test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/sorting/selection_sort_recursive.c@swap": "void swap ( int8_t * first , int8_t * second ) { int8_t temp = * first ; * first = * second ; * second = temp ; }",
    "resources/C/sorting/selection_sort_recursive.c@findIndex": "uint8_t findIndex ( const int8_t * arr , const uint8_t size ) { if ( size == 1 ) { return 0 ; } // marking recursive call to reach starting element uint8_t min_index = findIndex ( arr , size - 1 ) ; if ( arr [ size - 1 ] < arr [ min_index ] ) { min_index = size - 1 ; } return min_index ; }",
    "resources/C/sorting/selection_sort_recursive.c@selectionSort": "void selectionSort ( int8_t * arr , const uint8_t size ) { if ( size <= 1 ) { return ; } /* findIndex(arr, size) returned the index having min value*/ uint8_t min_index = findIndex ( arr , size ) ; /* arr[min_index] is the minimum value in the array*/ if ( min_index != 0 ) { swap ( & arr [ 0 ] , & arr [ min_index ] ) ; } /*sorted the remaining array recursively*/ selectionSort ( arr + 1 , size - 1 ) ; }",
    "resources/C/sorting/selection_sort_recursive.c@test": "static void test ( ) { const uint8_t size = 10 ; int8_t * arr = ( int8_t * ) calloc ( size , sizeof ( int8_t ) ) ; /* generate size random numbers from 0 to 100 */ for ( uint8_t i = 0 ; i < size ; i ++ ) { arr [ i ] = rand ( ) % 100 ; } selectionSort ( arr , size ) ; for ( uint8_t i = 0 ; i < size - 1 ; ++ i ) { assert ( arr [ i ] <= arr [ i + 1 ] ) ; } free ( arr ) ; }",
    "resources/C/sorting/selection_sort_recursive.c@main": "int main ( ) { /* Intializes random number generator */ srand ( time ( NULL ) ) ; test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/sorting/quick_sort.c@display": "void display ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"%d \" , arr [ i ] ) ; } printf ( \"\\n\" ) ; }",
    "resources/C/sorting/quick_sort.c@swap": "void swap ( int * first , int * second ) { int temp = * first ; * first = * second ; * second = temp ; }",
    "resources/C/sorting/quick_sort.c@partition": "int partition ( int arr [ ] , int lower , int upper ) { int i = ( lower - 1 ) ; int pivot = arr [ upper ] ; // Selects last element as the pivot value int j ; for ( j = lower ; j < upper ; j ++ ) { if ( arr [ j ] <= pivot ) { // if current element is smaller than the pivot i ++ ; // increment the index of smaller element swap ( & arr [ i ] , & arr [ j ] ) ; } } swap ( & arr [ i + 1 ] , & arr [ upper ] ) ; // places the last element i.e, the pivot // to its correct position return ( i + 1 ) ; }",
    "resources/C/sorting/quick_sort.c@quickSort": "void quickSort ( int arr [ ] , int lower , int upper ) { if ( upper > lower ) { // partitioning index is returned by the partition method , partition // element is at its correct poition int partitionIndex = partition ( arr , lower , upper ) ; // Sorting elements before and after the partition index quickSort ( arr , lower , partitionIndex - 1 ) ; quickSort ( arr , partitionIndex + 1 , upper ) ; } }",
    "resources/C/sorting/quick_sort.c@main": "int main ( ) { int n ; printf ( \"Enter size of array:\\n\" ) ; scanf ( \"%d\" , & n ) ; // E.g. 8 printf ( \"Enter the elements of the array\\n\" ) ; int i ; int * arr = ( int * ) malloc ( sizeof ( int ) * n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & arr [ i ] ) ; } printf ( \"Original array: \" ) ; display ( arr , n ) ; // Original array : 10 11 9 8 4 7 3 8 quickSort ( arr , 0 , n - 1 ) ; printf ( \"Sorted array: \" ) ; display ( arr , n ) ; // Sorted array : 3 4 7 8 8 9 10 11 getchar ( ) ; free ( arr ) ; return 0 ; }",
    "resources/C/sorting/merge_sort_nr.c@mergesort": "void mergesort ( int x [ ] , int n ) { int temp [ 50 ] , i , j , k , lb1 , lb2 , ub1 , ub2 , size ; size = 1 ; while ( size < n ) { lb1 = 0 ; k = 0 ; while ( lb1 + size < n ) { lb2 = lb1 + size ; ub1 = lb2 - 1 ; if ( ub1 + size < n ) ub2 = ub1 + size ; else ub2 = n - 1 ; i = lb1 ; j = lb2 ; while ( i <= ub1 && j <= ub2 ) if ( x [ i ] < x [ j ] ) temp [ k ++ ] = x [ i ++ ] ; else temp [ k ++ ] = x [ j ++ ] ; while ( i <= ub1 ) temp [ k ++ ] = x [ i ++ ] ; while ( j <= ub2 ) temp [ k ++ ] = x [ j ++ ] ; lb1 = ub2 + 1 ; } for ( i = 0 ; i <= ub2 ; i ++ ) x [ i ] = temp [ i ] ; size = size * 2 ; show ( x , n ) ; } }",
    "resources/C/sorting/merge_sort_nr.c@show": "void show ( int x [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) printf ( \"%d \" , x [ i ] ) ; printf ( \"\\n\\n\" ) ; }",
    "resources/C/sorting/merge_sort_nr.c@main": "int main ( ) // main function { int i , n , x [ 20 ] ; printf ( \"Enter the number of elements: \" ) ; scanf ( \"%d\" , & n ) ; printf ( \"Enter the elements:\\n\" ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( \"%d\" , & x [ i ] ) ; mergesort ( x , n ) ; printf ( \"Sorted array is as shown:\\n\" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \"%d \" , x [ i ] ) ; return 0 ; }",
    "resources/C/sorting/insertion_sort_recursive.c@RecursionInsertionSort": "void RecursionInsertionSort ( int * arr , int size ) { if ( size <= 0 ) { return ; } // marking recursive call to reach starting element RecursionInsertionSort ( arr , size - 1 ) ; int key = arr [ size - 1 ] ; int j = size - 2 ; // swapping logic for insertion sort while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = key ; }",
    "resources/C/sorting/insertion_sort_recursive.c@test": "static void test ( ) { const int size = rand ( ) % 500 ; /* random array size */ int * arr = ( int * ) calloc ( size , sizeof ( int ) ) ; /* generate size random numbers from -50 to 49 */ for ( int i = 0 ; i < size ; i ++ ) { arr [ i ] = ( rand ( ) % 100 ) - 50 ; /* signed random numbers */ } RecursionInsertionSort ( arr , size ) ; for ( int i = 0 ; i < size ; ++ i ) { assert ( arr [ i ] <= arr [ i + 1 ] ) ; } free ( arr ) ; }",
    "resources/C/sorting/insertion_sort_recursive.c@main": "int main ( int argc , const char * argv [ ] ) { /* Intializes random number generator */ srand ( time ( NULL ) ) ; test ( ) ; return 0 ; }",
    "resources/C/sorting/gnome_sort.c@sort": "void sort ( int * numbers , int size ) { int pos = 0 ; while ( pos < size ) { if ( numbers [ pos ] >= numbers [ pos - 1 ] ) pos ++ ; else { int tmp = numbers [ pos - 1 ] ; numbers [ pos - 1 ] = numbers [ pos ] ; numbers [ pos ] = tmp ; pos -- ; if ( pos == 0 ) pos = 1 ; } } }",
    "resources/C/sorting/gnome_sort.c@display": "void display ( int * array , int n ) { int i ; for ( i = 0 ; i < n ; ++ i ) printf ( \"%d \" , array [ i ] ) ; printf ( \"\\n\" ) ; }",
    "resources/C/sorting/gnome_sort.c@main": "int main ( ) { int size = 6 ; int i ; int * numbers = malloc ( size * sizeof ( int ) ) ; printf ( \"Insert %d unsorted numbers: \\n\" , size ) ; for ( i = 0 ; i < size ; ++ i ) scanf ( \"%d\" , & numbers [ i ] ) ; printf ( \"Initial array: \" ) ; display ( numbers , size ) ; sort ( numbers , size ) ; printf ( \"Sorted array: \" ) ; display ( numbers , size ) ; free ( numbers ) ; return 0 ; }",
    "resources/C/sorting/odd_even_sort.c@swap": "void swap ( int32_t * first , int32_t * second ) { int32_t temp = * first ; * first = * second ; * second = temp ; }",
    "resources/C/sorting/odd_even_sort.c@oddEvenSort": "void oddEvenSort ( int * arr , int size ) { bool isSorted = false ; while ( ! isSorted ) { isSorted = true ; int32_t i ; // Even phase for ( i = 0 ; i <= size - 2 ; i += 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { swap ( & arr [ i ] , & arr [ i + 1 ] ) ; isSorted = false ; } } // Odd phase for ( i = 1 ; i <= size - 2 ; i += 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { swap ( & arr [ i ] , & arr [ i + 1 ] ) ; isSorted = false ; } } } }",
    "resources/C/sorting/odd_even_sort.c@test": "static void test ( ) { int32_t arr1 [ ] = { - 9 , 2 , 3 , 1 } ; int32_t arr1Soln [ ] = { - 9 , 1 , 2 , 3 } ; int32_t arr2 [ ] = { 9 , 7 , 5 , 3 , 8 , 2 , 1 , 4 , 0 , 6 } ; int32_t arr2Soln [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; oddEvenSort ( arr1 , 4 ) ; oddEvenSort ( arr2 , 10 ) ; for ( int32_t i = 0 ; i < 4 ; i ++ ) { assert ( arr1 [ i ] == arr1Soln [ i ] ) ; } for ( int32_t i = 0 ; i < 10 ; i ++ ) { assert ( arr2 [ i ] == arr2Soln [ i ] ) ; } printf ( \"All tests have passed!\\n\" ) ; }",
    "resources/C/sorting/odd_even_sort.c@main": "int main ( ) { test ( ) ; // run self-test implementations return 0 ; }",
    "resources/C/sorting/radix_sort.c@largest": "int largest ( int a [ ] , int n ) { int large = a [ 0 ] , i ; for ( i = 1 ; i < n ; i ++ ) { if ( large < a [ i ] ) large = a [ i ] ; } return large ; }",
    "resources/C/sorting/radix_sort.c@RadixSort": "void RadixSort ( int a [ ] , int n ) { int bucket [ 10 ] [ 10 ] , bucket_count [ 10 ] ; int i , j , k , remainder , NOP = 0 , divisor = 1 , large , pass ; large = largest ( a , n ) ; printf ( \"The large element %d\\n\" , large ) ; while ( large > 0 ) { NOP ++ ; large /= 10 ; } for ( pass = 0 ; pass < NOP ; pass ++ ) { for ( i = 0 ; i < 10 ; i ++ ) { bucket_count [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { remainder = ( a [ i ] / divisor ) % 10 ; bucket [ remainder ] [ bucket_count [ remainder ] ] = a [ i ] ; bucket_count [ remainder ] += 1 ; } i = 0 ; for ( k = 0 ; k < 10 ; k ++ ) { for ( j = 0 ; j < bucket_count [ k ] ; j ++ ) { a [ i ] = bucket [ k ] [ j ] ; i ++ ; } } divisor *= 10 ; for ( i = 0 ; i < n ; i ++ ) printf ( \"%d  \" , a [ i ] ) ; printf ( \"\\n\" ) ; } }",
    "resources/C/sorting/radix_sort.c@main": "int main ( ) { int i , n , a [ 10 ] ; printf ( \"Enter the number of elements :: \" ) ; scanf ( \"%d\" , & n ) ; printf ( \"Enter the elements :: \" ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & a [ i ] ) ; } RadixSort ( a , n ) ; printf ( \"The sorted elements are ::  \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \"%d  \" , a [ i ] ) ; printf ( \"\\n\" ) ; return 0 ; }",
    "resources/C/sorting/counting_sort.c@main": "int main ( ) { int i , n , l = 0 ; printf ( \"Enter size of array = \" ) ; scanf ( \"%d\" , & n ) ; int * a = ( int * ) malloc ( n * sizeof ( int ) ) ; printf ( \"Enter %d elements in array :\\n\" , n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & a [ i ] ) ; if ( a [ i ] > l ) l = a [ i ] ; } int * b = ( int * ) malloc ( ( l + 1 ) * sizeof ( int ) ) ; memset ( b , 0 , ( l + 1 ) * sizeof ( b [ 0 ] ) ) ; for ( i = 0 ; i < n ; i ++ ) b [ a [ i ] ] ++ ; // hashing number to array index for ( i = 0 ; i < ( l + 1 ) ; i ++ ) // unstable , stabilized by prefix sum array { if ( b [ i ] > 0 ) { while ( b [ i ] != 0 ) // for case when number exists more than once { printf ( \"%d \" , i ) ; b [ i ] -- ; } } } free ( a ) ; free ( b ) ; return 0 ; }",
    "resources/C/sorting/comb_sort.c@sort": "void sort ( int * numbers , int size ) { int gap = size ; while ( gap > 1 ) // gap = 1 means that the array is sorted { gap = gap / SHRINK ; int i = 0 ; while ( ( i + gap ) < size ) { // similiar to the Shell Sort if ( numbers [ i ] > numbers [ i + gap ] ) { int tmp = numbers [ i ] ; numbers [ i ] = numbers [ i + gap ] ; numbers [ i + gap ] = tmp ; } i ++ ; } } }",
    "resources/C/sorting/comb_sort.c@display": "void display ( int * array , int n ) { int i ; for ( i = 0 ; i < n ; ++ i ) printf ( \"%d \" , array [ i ] ) ; printf ( \"\\n\" ) ; }",
    "resources/C/sorting/comb_sort.c@main": "int main ( ) { int size = 6 ; int * numbers = malloc ( size * sizeof ( int ) ) ; printf ( \"Insert %d unsorted numbers: \\n\" , size ) ; int i ; for ( i = 0 ; i < size ; ++ i ) scanf ( \"%d\" , & numbers [ i ] ) ; printf ( \"Initial array: \" ) ; display ( numbers , size ) ; sort ( numbers , size ) ; printf ( \"Sorted array: \" ) ; display ( numbers , size ) ; free ( numbers ) ; return 0 ; }",
    "resources/C/sorting/radix_sort_2.c@MAX": "int MAX ( int * ar , int size ) { int i , max = ar [ 0 ] ; for ( i = 0 ; i < size ; i ++ ) { if ( ar [ i ] > max ) max = ar [ i ] ; } return max ; }",
    "resources/C/sorting/radix_sort_2.c@countSort": "void countSort ( int * arr , int n , int place ) { int i , freq [ range ] = { 0 } ; int * output = ( int * ) malloc ( n * sizeof ( int ) ) ; // Store count of occurrences in freq[] for ( i = 0 ; i < n ; i ++ ) freq [ ( arr [ i ] / place ) % range ] ++ ; // Change freq[i] so that it contains the actual position of the digit in // output[] for ( i = 1 ; i < range ; i ++ ) freq [ i ] += freq [ i - 1 ] ; // Build the output array for ( i = n - 1 ; i >= 0 ; i -- ) { output [ freq [ ( arr [ i ] / place ) % range ] - 1 ] = arr [ i ] ; freq [ ( arr [ i ] / place ) % range ] -- ; } // Copy the output array to arr[], so it contains numbers according to the // current digit for ( i = 0 ; i < n ; i ++ ) arr [ i ] = output [ i ] ; free ( output ) ; }",
    "resources/C/sorting/radix_sort_2.c@radixsort2": "void radixsort2 ( int * arr , int n , int max ) // max is the maximum element in the array { int mul = 1 ; while ( max ) { countSort ( arr , n , mul ) ; mul *= 10 ; max /= 10 ; } }",
    "resources/C/sorting/radix_sort_2.c@display": "void display ( int * arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) printf ( \"%d, \" , arr [ i ] ) ; putchar ( '\\n' ) ; }",
    "resources/C/sorting/radix_sort_2.c@main": "int main ( int argc , const char * argv [ ] ) { int n ; printf ( \"Enter size of array:\\n\" ) ; scanf ( \"%d\" , & n ) ; // E.g. 8 printf ( \"Enter the elements of the array\\n\" ) ; int i ; int * arr = ( int * ) malloc ( n * sizeof ( int ) ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & arr [ i ] ) ; } printf ( \"Original array: \" ) ; display ( arr , n ) ; // Original array : 10 11 9 8 4 7 3 8 int max ; max = MAX ( arr , n ) ; radixsort2 ( arr , n , max ) ; printf ( \"Sorted array: \" ) ; display ( arr , n ) ; // Sorted array : 3 4 7 8 8 9 10 11 free ( arr ) ; return 0 ; }",
    "resources/C/sorting/cycle_sort.c@display": "void display ( int * arr , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"%d \" , arr [ i ] ) ; } printf ( \"\\n\" ) ; }",
    "resources/C/sorting/cycle_sort.c@swap": "void swap ( int * first , int * second ) { int temp = * first ; * first = * second ; * second = temp ; }",
    "resources/C/sorting/cycle_sort.c@cycleSort": "void cycleSort ( int * arr , int n ) { // count number of memory writes int writes = 0 ; // traverse array elements and put it to on // the right place for ( int cycle_start = 0 ; cycle_start <= n - 2 ; cycle_start ++ ) { // initialize item as starting point int item = arr [ cycle_start ] ; // Find position where we put the item. We basically // count all smaller elements on right side of item. int pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos ++ ; // If item is already in correct position if ( pos == cycle_start ) continue ; // ignore all duplicate elements while ( item == arr [ pos ] ) pos += 1 ; // put the item to it's right position if ( pos != cycle_start ) { swap ( & item , & arr [ pos ] ) ; writes ++ ; } // Rotate rest of the cycle while ( pos != cycle_start ) { pos = cycle_start ; // Find position where we put the element for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos += 1 ; // ignore all duplicate elements while ( item == arr [ pos ] ) pos += 1 ; // put the item to it's right position if ( item != arr [ pos ] ) { swap ( & item , & arr [ pos ] ) ; writes ++ ; } } } }",
    "resources/C/sorting/cycle_sort.c@main": "int main ( ) { int n ; // Size of array elements printf ( \"Enter size of array:\\n\" ) ; scanf ( \"%d\" , & n ) ; // E.g. 8 printf ( \"Enter the elements of the array\\n\" ) ; int i ; int * arr = ( int * ) malloc ( n * sizeof ( int ) ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & arr [ i ] ) ; } printf ( \"Original array: \" ) ; display ( arr , n ) ; cycleSort ( arr , n ) ; printf ( \"Sorted array: \" ) ; display ( arr , n ) ; free ( arr ) ; return 0 ; }",
    "resources/C/sorting/random_quick_sort.c@getBig": "int getBig ( int * a , int i , int right , int pivot ) { for ( int k = i ; k <= right ; k ++ ) { if ( a [ k ] > pivot ) return k ; } return right + 1 ; }",
    "resources/C/sorting/random_quick_sort.c@getSmall": "int getSmall ( int * a , int j , int left , int pivot ) { for ( int k = j ; k >= left ; k -- ) { if ( a [ k ] < pivot ) return k ; } return - 1 ; }",
    "resources/C/sorting/random_quick_sort.c@swap": "void swap ( int * a , int * b ) { int t = * a ; * a = * b ; * b = t ; }",
    "resources/C/sorting/random_quick_sort.c@random_quick": "void random_quick ( int * a , int left , int right ) { if ( left >= right ) return ; int index = left + ( rand ( ) % ( right - left ) ) , i = left , j = right ; int pivot_index = index ; int pivot = a [ index ] ; // storing index of element greater than pivot i = getBig ( a , i , right , pivot ) ; // storing index of element smaller than pivot j = getSmall ( a , j , left , pivot ) ; while ( i <= j ) { swap ( & a [ i ] , & a [ j ] ) ; i = getBig ( a , i , right , pivot ) ; j = getSmall ( a , j , left , pivot ) ; } // after separating the smaller and greater elements, there are 3 cases // possible if ( pivot_index > j && pivot_index > i ) { // case 1. When the pivot element index is greater than both i and j swap ( & a [ i ] , & a [ pivot_index ] ) ; random_quick ( a , left , i - 1 ) ; random_quick ( a , i + 1 , right ) ; } else if ( pivot_index < j && pivot_index < i ) { // case 2. When the pivot element index is smaller than both i and j swap ( & a [ j ] , & a [ pivot_index ] ) ; random_quick ( a , left , j - 1 ) ; random_quick ( a , j + 1 , right ) ; } else { // the pivot element is at its origin position. random_quick ( a , left , pivot_index - 1 ) ; random_quick ( a , pivot_index + 1 , right ) ; } }",
    "resources/C/sorting/random_quick_sort.c@main": "int main ( ) { srand ( time ( 0 ) ) ; int num ; scanf ( \"%d\" , & num ) ; int * arr = ( int * ) malloc ( num * sizeof ( int ) ) ; for ( int i = 0 ; i < num ; i ++ ) { scanf ( \"%d\" , & arr [ i ] ) ; } random_quick ( arr , 0 , num - 1 ) ; for ( int i = 0 ; i < num ; i ++ ) { printf ( \"%d \" , arr [ i ] ) ; } free ( arr ) ; printf ( \"\\n\" ) ; }",
    "resources/C/sorting/selection_sort.c@swap": "void swap ( int * first , int * second ) { int temp = * first ; * first = * second ; * second = temp ; }",
    "resources/C/sorting/selection_sort.c@selectionSort": "void selectionSort ( int * arr , int size ) { for ( int i = 0 ; i < size - 1 ; i ++ ) { int min_index = i ; for ( int j = i + 1 ; j < size ; j ++ ) { if ( arr [ min_index ] > arr [ j ] ) { min_index = j ; } } if ( min_index != i ) { swap ( arr + i , arr + min_index ) ; } } }",
    "resources/C/sorting/selection_sort.c@test": "static void test ( ) { const int size = rand ( ) % 500 ; /* random array size */ int * arr = ( int * ) calloc ( size , sizeof ( int ) ) ; /* generate size random numbers from -50 to 49 */ for ( int i = 0 ; i < size ; i ++ ) { arr [ i ] = ( rand ( ) % 100 ) - 50 ; /* signed random numbers */ } selectionSort ( arr , size ) ; for ( int i = 0 ; i < size - 1 ; ++ i ) { assert ( arr [ i ] <= arr [ i + 1 ] ) ; } free ( arr ) ; }",
    "resources/C/sorting/selection_sort.c@main": "int main ( int argc , const char * argv [ ] ) { /* Intializes random number generator */ srand ( time ( NULL ) ) ; test ( ) ; return 0 ; }",
    "resources/C/sorting/insertion_sort.c@insertionSort": "void insertionSort ( int * arr , int size ) { for ( int i = 1 ; i < size ; i ++ ) { int j = i - 1 ; int key = arr [ i ] ; /* Move all elements greater than key to one position */ while ( j >= 0 && key < arr [ j ] ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } /* Find a correct position for key */ arr [ j + 1 ] = key ; } }",
    "resources/C/sorting/insertion_sort.c@test": "static void test ( ) { const int size = rand ( ) % 500 ; /* random array size */ int * arr = ( int * ) calloc ( size , sizeof ( int ) ) ; /* generate size random numbers from -50 to 49 */ for ( int i = 0 ; i < size ; i ++ ) { arr [ i ] = ( rand ( ) % 100 ) - 50 ; /* signed random numbers */ } insertionSort ( arr , size ) ; for ( int i = 0 ; i < size - 1 ; ++ i ) { assert ( arr [ i ] <= arr [ i + 1 ] ) ; } free ( arr ) ; }",
    "resources/C/sorting/insertion_sort.c@main": "int main ( int argc , const char * argv [ ] ) { /* Intializes random number generator */ srand ( time ( NULL ) ) ; test ( ) ; return 0 ; }",
    "resources/C/sorting/bubble_sort_recursion.c@swap": "void swap ( int * first , int * second ) { int temp = * first ; * first = * second ; * second = temp ; }",
    "resources/C/sorting/bubble_sort_recursion.c@bubbleSort": "void bubbleSort ( int * arr , int size ) { if ( size == 1 ) { return ; } bool swapped = false ; for ( int i = 0 ; i < size - 1 ; ++ i ) { if ( arr [ i ] > arr [ i + 1 ] ) { swap ( arr + i , arr + i + 1 ) ; swapped = true ; } } if ( swapped ) { bubbleSort ( arr , size - 1 ) ; } }",
    "resources/C/sorting/bubble_sort_recursion.c@test": "void test ( ) { const int size = 10 ; int * arr = ( int * ) calloc ( size , sizeof ( int ) ) ; /* generate size random numbers from 0 to 100 */ for ( int i = 0 ; i < size ; i ++ ) { arr [ i ] = rand ( ) % 100 ; } bubbleSort ( arr , size ) ; for ( int i = 0 ; i < size - 1 ; ++ i ) { assert ( arr [ i ] <= arr [ i + 1 ] ) ; } free ( arr ) ; }",
    "resources/C/sorting/bubble_sort_recursion.c@main": "int main ( ) { /* Intializes random number generator */ srand ( time ( NULL ) ) ; test ( ) ; return 0 ; }",
    "resources/C/sorting/shaker_sort.c@swap": "void swap ( int * a , int * b ) { int temp ; temp = * a ; * a = * b ; * b = temp ; }",
    "resources/C/sorting/shaker_sort.c@shakersort": "void shakersort ( int * a , int n ) { int p , i ; for ( p = 1 ; p <= n / 2 ; p ++ ) { for ( i = p - 1 ; i < n - p ; i ++ ) if ( a [ i ] > a [ i + 1 ] ) { swap ( & a [ i ] , & a [ i + 1 ] ) ; } for ( i = n - p - 1 ; i >= p ; i -- ) if ( a [ i ] < a [ i - 1 ] ) { swap ( & a [ i ] , & a [ i - 1 ] ) ; } } }",
    "resources/C/sorting/shaker_sort.c@main": "int main ( ) { int n ; scanf ( \"%d\" , & n ) ; int * arr = ( int * ) malloc ( n * sizeof ( int ) ) ; int i ; for ( i = 0 ; i < n ; i ++ ) scanf ( \"%d \" , & arr [ i ] ) ; shakersort ( arr , n ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \"%d \" , arr [ i ] ) ; free ( arr ) ; return 0 ; }",
    "resources/C/sorting/pigeonhole_sort.c@pigeonholeSort": "void pigeonholeSort ( int arr [ ] , int size ) { int i , j , min = arr [ 0 ] , max = arr [ 0 ] , range ; // Getting range of the array using max and min for ( i = 1 ; i < size ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; if ( arr [ i ] > max ) max = arr [ i ] ; } range = max - min + 1 ; // Make 'holes' and put array's numbers in holes int * holes = ( int * ) malloc ( sizeof ( int ) * range ) ; for ( i = 0 ; i < range ; i ++ ) { holes [ i ] = 0 ; } for ( i = 0 ; i < size ; i ++ ) { holes [ arr [ i ] - min ] ++ ; } // Copy the numbers back to the original array j = 0 ; for ( i = 0 ; i < range ; i ++ ) { while ( holes [ i ] > 0 ) { arr [ j ] = i + min ; holes [ i ] -- ; j ++ ; } } free ( holes ) ; }",
    "resources/C/sorting/pigeonhole_sort.c@main": "int main ( ) { int i , n ; printf ( \"Enter the size of the array: \" ) ; scanf ( \"%d\" , & n ) ; int * arr = ( int * ) malloc ( sizeof ( int ) * n ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"Number #%d: \" , i + 1 ) ; scanf ( \"%d\" , & arr [ i ] ) ; } printf ( \"You entered:  \" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"%d \" , arr [ i ] ) ; } pigeonholeSort ( arr , n ) ; printf ( \"\\nSorted array: \" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( \"%d \" , arr [ i ] ) ; } printf ( \"\\n\" ) ; free ( arr ) ; return 0 ; }",
    "resources/C/geometry/vectors_3d.c@vector_sub": "vec_3d vector_sub ( const vec_3d * a , const vec_3d * b ) { vec_3d out ; # ifdef LIBQUAT_ARM arm_sub_f32 ( ( float * ) a , ( float * ) b , ( float * ) & out ) ; # else out . x = a -> x - b -> x ; out . y = a -> y - b -> y ; out . z = a -> z - b -> z ; # endif return out ; }",
    "resources/C/geometry/vectors_3d.c@vector_add": "vec_3d vector_add ( const vec_3d * a , const vec_3d * b ) { vec_3d out ; # ifdef LIBQUAT_ARM arm_add_f32 ( ( float * ) a , ( float * ) b , ( float * ) & out ) ; # else out . x = a -> x + b -> x ; out . y = a -> y + b -> y ; out . z = a -> z + b -> z ; # endif return out ; }",
    "resources/C/geometry/vectors_3d.c@dot_prod": "float dot_prod ( const vec_3d * a , const vec_3d * b ) { float dot ; # ifdef LIBQUAT_ARM arm_dot_prod_f32 ( ( float * ) a , ( float * ) b , & dot ) ; # else dot = a -> x * b -> x ; dot += a -> y * b -> y ; dot += a -> z * b -> z ; # endif return dot ; }",
    "resources/C/geometry/vectors_3d.c@vector_prod": "vec_3d vector_prod ( const vec_3d * a , const vec_3d * b ) { vec_3d out ; // better this way to avoid copying results to input // vectors themselves out . x = a -> y * b -> z - a -> z * b -> y ; out . y = - a -> x * b -> z + a -> z * b -> x ; out . z = a -> x * b -> y - a -> y * b -> x ; return out ; }",
    "resources/C/geometry/vectors_3d.c@print_vector": "const char * print_vector ( const vec_3d * a , const char * name ) { static char vec_str [ 100 ] ; // static to ensure the string life extends the // life of function snprintf ( vec_str , 99 , \"vec(%s) = (%.3g)i + (%.3g)j + (%.3g)k\\n\" , name , a -> x , a -> y , a -> z ) ; return vec_str ; }",
    "resources/C/geometry/vectors_3d.c@vector_norm": "float vector_norm ( const vec_3d * a ) { float n = dot_prod ( a , a ) ; # ifdef LIBQUAT_ARM arm_sqrt_f32 ( * n , n ) ; # else n = sqrtf ( n ) ; # endif return n ; }",
    "resources/C/geometry/vectors_3d.c@unit_vec": "vec_3d unit_vec ( const vec_3d * a ) { vec_3d n = { 0 } ; float norm = vector_norm ( a ) ; if ( fabsf ( norm ) < EPSILON ) { // detect possible divide by 0 return n ; } if ( norm != 1.F ) // perform division only if needed { n . x = a -> x / norm ; n . y = a -> y / norm ; n . z = a -> z / norm ; } return n ; }",
    "resources/C/geometry/vectors_3d.c@get_cross_matrix": "mat_3x3 get_cross_matrix ( const vec_3d * a ) { mat_3x3 A = { 0. , - a -> z , a -> y , a -> z , 0. , - a -> x , - a -> y , a -> x , 0. } ; return A ; }",
    "resources/C/geometry/vectors_3d.c@get_angle": "double get_angle ( const vec_3d * a , const vec_3d * b ) { double alpha , cos_alpha ; float norm_a = vector_norm ( a ) ; ///< The norm of vector a float norm_b = vector_norm ( b ) ; ///< The norm of vector b if ( fabsf ( norm_a ) < EPSILON || fabsf ( norm_b ) < EPSILON ) /// detect possible division by 0 - the angle is not defined in this case { return NAN ; } cos_alpha = dot_prod ( a , b ) / ( norm_a * norm_b ) ; alpha = acos ( cos_alpha ) ; // delivers the radian return alpha ; // in range from -1 to 1 }",
    "resources/C/geometry/vectors_3d.c@test": "static void test ( ) { vec_3d a = { 1. , 2. , 3. } ; vec_3d b = { 1. , 1. , 1. } ; float d ; // printf(\"%s\", print_vector(&a, \"a\")); // printf(\"%s\", print_vector(&b, \"b\")); d = vector_norm ( & a ) ; // printf(\"|a| = %.4g\\n\", d); assert ( fabsf ( d - 3.742f ) < 0.01 ) ; d = vector_norm ( & b ) ; // printf(\"|b| = %.4g\\n\", d); assert ( fabsf ( d - 1.732f ) < 0.01 ) ; d = dot_prod ( & a , & b ) ; // printf(\"Dot product: %f\\n\", d); assert ( fabsf ( d - 6.f ) < 0.01 ) ; vec_3d c = vector_prod ( & a , & b ) ; // printf(\"Vector product \"); // printf(\"%s\", print_vector(&c, \"c\")); assert ( fabsf ( c . x - ( - 1.f ) ) < 0.01 ) ; assert ( fabsf ( c . y - ( 2.f ) ) < 0.01 ) ; assert ( fabsf ( c . z - ( - 1.f ) ) < 0.01 ) ; double alpha = get_angle ( & a , & b ) ; // printf(\"The angle is %f\\n\", alpha); assert ( fabsf ( alpha - 0.387597 ) < 0.01 ) ; }",
    "resources/C/geometry/vectors_3d.c@main": "int main ( void ) { test ( ) ; return 0 ; }",
    "resources/C/geometry/quaternions.c@quat_from_euler": "quaternion quat_from_euler ( const euler * in_euler ) { quaternion out_quat ; if ( ! in_euler ) // if null { fprintf ( stderr , \"%s: Invalid input.\" , __func__ ) ; return out_quat ; } quaternion temp ; float cy = cosf ( in_euler -> yaw * 0.5f ) ; float sy = sinf ( in_euler -> yaw * 0.5f ) ; float cp = cosf ( in_euler -> pitch * 0.5f ) ; float sp = sinf ( in_euler -> pitch * 0.5f ) ; float cr = cosf ( in_euler -> roll * 0.5f ) ; float sr = sinf ( in_euler -> roll * 0.5f ) ; temp . w = cr * cp * cy + sr * sp * sy ; temp . q1 = sr * cp * cy - cr * sp * sy ; temp . q2 = cr * sp * cy + sr * cp * sy ; temp . q3 = cr * cp * sy - sr * sp * cy ; return temp ; }",
    "resources/C/geometry/quaternions.c@euler_from_quat": "euler euler_from_quat ( const quaternion * in_quat ) { euler out_euler ; if ( ! in_quat ) // if null { fprintf ( stderr , \"%s: Invalid input.\" , __func__ ) ; return out_euler ; } out_euler . roll = atan2f ( 2.f * ( in_quat -> w * in_quat -> q1 + in_quat -> q2 * in_quat -> q3 ) , 1.f - 2.f * ( in_quat -> q1 * in_quat -> q1 + in_quat -> q2 * in_quat -> q2 ) ) ; out_euler . pitch = asinf ( 2.f * ( in_quat -> w * in_quat -> q2 + in_quat -> q1 * in_quat -> q3 ) ) ; out_euler . yaw = atan2f ( 2.f * ( in_quat -> w * in_quat -> q3 + in_quat -> q1 * in_quat -> q2 ) , 1.f - 2.f * ( in_quat -> q2 * in_quat -> q2 + in_quat -> q3 * in_quat -> q3 ) ) ; return out_euler ; }",
    "resources/C/geometry/quaternions.c@quaternion_multiply": "quaternion quaternion_multiply ( const quaternion * in_quat1 , const quaternion * in_quat2 ) { quaternion out_quat ; if ( ! in_quat1 || ! in_quat2 ) // if null { fprintf ( stderr , \"%s: Invalid input.\" , __func__ ) ; return out_quat ; } out_quat . w = in_quat1 -> w * in_quat2 -> w - in_quat1 -> q1 * in_quat2 -> q1 - in_quat1 -> q2 * in_quat2 -> q2 - in_quat1 -> q3 * in_quat2 -> q3 ; out_quat . q1 = in_quat1 -> w * in_quat2 -> q1 + in_quat1 -> q1 * in_quat2 -> w + in_quat1 -> q2 * in_quat2 -> q3 - in_quat1 -> q3 * in_quat2 -> q2 ; out_quat . q2 = in_quat1 -> w * in_quat2 -> q2 - in_quat1 -> q1 * in_quat2 -> q3 + in_quat1 -> q2 * in_quat2 -> w + in_quat1 -> q3 * in_quat2 -> q1 ; out_quat . q3 = in_quat1 -> w * in_quat2 -> q3 + in_quat1 -> q1 * in_quat2 -> q2 - in_quat1 -> q2 * in_quat2 -> q1 + in_quat1 -> q3 * in_quat2 -> w ; return out_quat ; }",
    "resources/C/geometry/quaternions.c@test": "static void test ( ) { quaternion quat = { 0.7071f , 0.7071f , 0.f , 0.f } ; euler eul = euler_from_quat ( & quat ) ; printf ( \"Euler: %.4g, %.4g, %.4g\\n\" , eul . pitch , eul . roll , eul . yaw ) ; quaternion test_quat = quat_from_euler ( & eul ) ; printf ( \"Quaternion: %.4g %+.4g %+.4g %+.4g\\n\" , test_quat . w , test_quat . dual . x , test_quat . dual . y , test_quat . dual . z ) ; assert ( fabsf ( test_quat . w - quat . w ) < .01 ) ; assert ( fabsf ( test_quat . q1 - quat . q1 ) < .01 ) ; assert ( fabsf ( test_quat . q2 - quat . q2 ) < .01 ) ; assert ( fabsf ( test_quat . q3 - quat . q3 ) < .01 ) ; }",
    "resources/C/geometry/quaternions.c@main": "int main ( ) { test ( ) ; return 0 ; }",
    "resources/C/graphics/spirograph.c@spirograph": "void spirograph ( double * x , double * y , double l , double k , size_t N , double rot ) { double dt = rot * 2.f * M_PI / N ; double t = 0.f , R = 1.f ; const double k1 = 1.f - k ; for ( size_t dk = 0 ; dk < N ; dk ++ , t += dt ) { x [ dk ] = R * ( k1 * cos ( t ) + l * k * cos ( k1 * t / k ) ) ; y [ dk ] = R * ( k1 * sin ( t ) - l * k * sin ( k1 * t / k ) ) ; } }",
    "resources/C/graphics/spirograph.c@test": "void test ( void ) { size_t N = 500 ; double l = 0.3 , k = 0.75 , rot = 10. ; char fname [ 50 ] ; snprintf ( fname , 50 , \"spirograph_%.2f_%.2f_%.2f.csv\" , l , k , rot ) ; FILE * fp = fopen ( fname , \"wt\" ) ; if ( ! fp ) { perror ( fname ) ; exit ( EXIT_FAILURE ) ; } double * x = ( double * ) malloc ( N * sizeof ( double ) ) ; double * y = ( double * ) malloc ( N * sizeof ( double ) ) ; spirograph ( x , y , l , k , N , rot ) ; for ( size_t i = 0 ; i < N ; i ++ ) { fprintf ( fp , \"%.5g, %.5g\" , x [ i ] , y [ i ] ) ; if ( i < N - 1 ) { fputc ( '\\n' , fp ) ; } } fclose ( fp ) ; free ( x ) ; free ( y ) ; }",
    "resources/C/graphics/spirograph.c@main": "int main ( int argc , char * * argv ) { test ( ) ; # ifdef USE_GLUT glutInit ( & argc , argv ) ; glutInitDisplayMode ( GLUT_RGB | GLUT_DOUBLE ) ; glutCreateWindow ( \"Spirograph\" ) ; glutInitWindowSize ( 400 , 400 ) ; // glutIdleFunc(glutPostRedisplay); glutTimerFunc ( animation_speed , timer_cb , 0 ) ; glutKeyboardFunc ( keyboard_cb ) ; glutDisplayFunc ( test2 ) ; glutMainLoop ( ) ; # endif return 0 ; }",
    "resources/C/games/naval_battle.c@validEntryLineColumn": "int validEntryLineColumn ( int line , char column ) { if ( ( line >= 1 && line <= 10 ) && ( column >= 65 && column <= 74 ) ) { return 1 ; } return 0 ; }",
    "resources/C/games/naval_battle.c@validatePosition": "int validatePosition ( int mat [ 10 ] [ 10 ] , int boat , int line , int column , char guide ) { int cont = 0 ; int i , j ; if ( line < 0 || line > 9 || column < 0 || column > 9 || ( guide != 'H' && guide != 'V' ) || boat < 1 || boat > 3 ) { return 0 ; } if ( guide == 'H' ) { if ( ( 10 - column ) < boat ) { return 0 ; } else { for ( j = column ; j < ( column + boat ) ; j ++ ) { if ( mat [ line ] [ j ] == 0 ) { cont ++ ; } } } } if ( guide == 'V' ) { if ( ( 10 - line ) < boat ) { return 0 ; } else { for ( i = line ; i < ( line + boat ) ; i ++ ) { if ( mat [ i ] [ column ] == 0 ) { cont ++ ; } } } } if ( cont == boat ) { return 1 ; } return 0 ; }",
    "resources/C/games/naval_battle.c@canShoot": "int canShoot ( int mat [ 10 ] [ 10 ] , int line , int column ) { if ( mat [ line ] [ column ] == - 2 || mat [ line ] [ column ] == 10 || mat [ line ] [ column ] == 20 || mat [ line ] [ column ] == 30 || mat [ line ] [ column ] == 50 ) { return 0 ; } return 1 ; }",
    "resources/C/games/naval_battle.c@positionBoat": "void positionBoat ( int mat [ 10 ] [ 10 ] , int boat ) { int line , j ; char column , guide ; if ( boat == 1 ) { scanf ( \"%d %c\" , & line , & column ) ; while ( validEntryLineColumn ( line , column ) != 1 || validatePosition ( mat , boat , ( line - 1 ) , ( column - 65 ) , 'H' ) != 1 ) { printf ( \"Position unavailable!\\n\" ) ; scanf ( \"%d %c\" , & line , & column ) ; } } else { scanf ( \"%d %c %c\" , & line , & column , & guide ) ; while ( validEntryLineColumn ( line , column ) == 0 || validatePosition ( mat , boat , ( line - 1 ) , ( column - 65 ) , guide ) == 0 ) { printf ( \"Position unavailable!\\n\" ) ; scanf ( \"%d %c %c\" , & line , & column , & guide ) ; } } int aux = column - 'A' ; line -= 1 ; if ( boat == 1 ) { for ( j = aux ; j < ( aux + boat ) ; j ++ ) { mat [ line ] [ j ] = boat ; } for ( int a = line - 1 ; a < ( line + boat + 1 ) ; a ++ ) { for ( int b = aux - 1 ; b < ( aux + boat + 1 ) ; b ++ ) { if ( a >= 0 && a <= 9 && b >= 0 && b <= 9 ) { if ( mat [ a ] [ b ] != boat ) { mat [ a ] [ b ] = - 1 ; } } } } } if ( guide == 'H' ) { for ( j = aux ; j < ( aux + boat ) ; j ++ ) { mat [ line ] [ j ] = boat ; } if ( boat == 3 ) { for ( int a = line - 1 ; a < ( line + boat - 1 ) ; a ++ ) { for ( int b = aux - 1 ; b < ( aux + boat + 1 ) ; b ++ ) { if ( a >= 0 && a <= 9 && b >= 0 && b <= 9 ) { if ( mat [ a ] [ b ] != boat ) { mat [ a ] [ b ] = - 1 ; } } } } } else { for ( int a = line - 1 ; a < ( line + boat ) ; a ++ ) { for ( int b = aux - 1 ; b < ( aux + boat + 1 ) ; b ++ ) { if ( a >= 0 && a <= 9 && b >= 0 && b <= 9 ) { if ( mat [ a ] [ b ] != boat ) { mat [ a ] [ b ] = - 1 ; } } } } } } if ( guide == 'V' ) { for ( j = line ; j < ( line + boat ) ; j ++ ) { mat [ j ] [ aux ] = boat ; } if ( boat == 3 ) { for ( int a = line - 1 ; a < ( line + boat + 1 ) ; a ++ ) { for ( int b = aux - 1 ; b < ( aux + boat - 1 ) ; b ++ ) { if ( a >= 0 && a <= 9 && b >= 0 && b <= 9 ) { if ( mat [ a ] [ b ] != boat ) { mat [ a ] [ b ] = - 1 ; } } } } } else { for ( int a = line - 1 ; a < ( line + boat + 1 ) ; a ++ ) { for ( int b = aux - 1 ; b < ( aux + boat ) ; b ++ ) { if ( a >= 0 && a <= 9 && b >= 0 && b <= 9 ) { if ( mat [ a ] [ b ] != boat ) { mat [ a ] [ b ] = - 1 ; } } } } } } }",
    "resources/C/games/naval_battle.c@printMessage": "void printMessage ( char * msg ) { printf ( \"************************\\n\" ) ; printf ( \"*\\n\" ) ; printf ( \"* %s\\n\" , msg ) ; printf ( \"*\\n\" ) ; printf ( \"************************\\n\" ) ; }",
    "resources/C/games/naval_battle.c@printMessageScore": "void printMessageScore ( int pts1 , int pts2 ) { printf ( \"************************\\n\" ) ; printf ( \"*\\n\" ) ; printf ( \"* Player'S SCORE 1: %02d\\n\" , pts1 ) ; printf ( \"* Player'S SCORE 2: %02d\\n\" , pts2 ) ; printf ( \"*\\n\" ) ; printf ( \"************************\\n\" ) ; }",
    "resources/C/games/naval_battle.c@printTable": "char printTable ( int logic , int stage ) { if ( stage == 0 ) { if ( logic == 0 ) { return '.' ; } else if ( logic == - 1 ) { return '*' ; } else if ( logic == 1 ) { return '1' ; } else if ( logic == 2 ) { return '2' ; } else { return '3' ; } } else { if ( logic == 0 || logic == - 1 || logic == 1 || logic == 2 || logic == 3 ) { return '.' ; } else if ( logic == - 2 ) { return 'x' ; } else if ( logic == 10 || logic == 20 || logic == 30 ) { return 'N' ; } else { return 'A' ; } } }",
    "resources/C/games/naval_battle.c@printsTray": "void printsTray ( int mat [ 10 ] [ 10 ] , int stage ) { int logic ; char imp ; printf ( \"     \" ) ; for ( int i = 65 ; i < 75 ; i ++ ) { printf ( \"%c\" , i ) ; if ( i < 74 ) { printf ( \" \" ) ; } } printf ( \"\\n\" ) ; for ( int i = 0 ; i < 12 ; i ++ ) { if ( i > 0 && i < 11 ) { printf ( \"%02d \" , i ) ; } else { printf ( \"   \" ) ; } for ( int j = 0 ; j < 12 ; j ++ ) { if ( ( i > 0 && i < 11 ) && ( j > 0 && j < 11 ) ) { logic = mat [ i - 1 ] [ j - 1 ] ; imp = printTable ( logic , stage ) ; printf ( \"%c\" , imp ) ; } else { printf ( \"#\" ) ; } if ( j < 11 ) { printf ( \" \" ) ; } } printf ( \"\\n\" ) ; } }",
    "resources/C/games/naval_battle.c@shoot": "void shoot ( int mat [ 10 ] [ 10 ] , int line , int column ) { if ( mat [ line ] [ column ] == 0 || mat [ line ] [ column ] == - 1 ) { mat [ line ] [ column ] = - 2 ; } else if ( mat [ line ] [ column ] == 1 ) { mat [ line ] [ column ] = 10 ; } else if ( mat [ line ] [ column ] == 2 ) { mat [ line ] [ column ] = 20 ; } else if ( mat [ line ] [ column ] == 3 ) { mat [ line ] [ column ] = 30 ; } }",
    "resources/C/games/naval_battle.c@calculateScore": "int calculateScore ( int mat [ 10 ] [ 10 ] , int line , int column ) { int c = 0 , b = 0 , e = 0 , d = 0 ; if ( mat [ line ] [ column ] == 10 ) { mat [ line ] [ column ] = 50 ; return 2 ; } else if ( mat [ line ] [ column ] == 20 ) { if ( mat [ line + 1 ] [ column ] == 20 ) { b = 1 ; } if ( mat [ line - 1 ] [ column ] == 20 ) { c = 1 ; } if ( mat [ line ] [ column + 1 ] == 20 ) { d = 1 ; } if ( mat [ line ] [ column - 1 ] == 20 ) { e = 1 ; } if ( b == 1 ) { if ( mat [ line + 1 ] [ column ] == 20 ) { mat [ line ] [ column ] = 50 ; mat [ line + 1 ] [ column ] = 50 ; return 4 ; } else { return 0 ; } } if ( c == 1 ) { if ( mat [ line - 1 ] [ column ] == 20 ) { mat [ line ] [ column ] = 50 ; mat [ line - 1 ] [ column ] = 50 ; return 4 ; } else { return 0 ; } } if ( d == 1 ) { if ( mat [ line ] [ column + 1 ] == 20 ) { mat [ line ] [ column ] = 50 ; mat [ line ] [ column + 1 ] = 50 ; return 4 ; } else { return 0 ; } } if ( e == 1 ) { if ( mat [ line ] [ column - 1 ] == 20 ) { mat [ line ] [ column ] = 50 ; mat [ line ] [ column - 1 ] = 50 ; return 4 ; } else { return 0 ; } } } else if ( mat [ line ] [ column ] == 30 ) { if ( mat [ line + 1 ] [ column ] == 30 ) { b = 1 ; } if ( mat [ line - 1 ] [ column ] == 30 ) { c = 1 ; } if ( mat [ line ] [ column + 1 ] == 30 ) { d = 1 ; } if ( mat [ line ] [ column - 1 ] == 30 ) { e = 1 ; } if ( b == 1 && c == 1 ) { if ( mat [ line + 1 ] [ column ] == 30 && mat [ line - 1 ] [ column ] == 30 ) { mat [ line ] [ column ] = 50 ; mat [ line + 1 ] [ column ] = 50 ; mat [ line - 1 ] [ column ] = 50 ; return 7 ; } else { return 0 ; } } else if ( d == 1 && e == 1 ) { if ( mat [ line ] [ column + 1 ] == 30 && mat [ line ] [ column - 1 ] == 30 ) { mat [ line ] [ column ] = 50 ; mat [ line ] [ column - 1 ] = 50 ; mat [ line ] [ column + 1 ] = 50 ; return 7 ; } else { return 0 ; } } else if ( d == 1 ) { if ( mat [ line ] [ column + 1 ] == 30 && mat [ line ] [ column + 2 ] == 30 ) { mat [ line ] [ column ] = 50 ; mat [ line ] [ column + 1 ] = 50 ; mat [ line ] [ column + 2 ] = 50 ; return 7 ; } else { return 0 ; } } else if ( e == 1 ) { if ( mat [ line ] [ column - 1 ] == 30 && mat [ line ] [ column - 2 ] == 30 ) { mat [ line ] [ column ] = 50 ; mat [ line ] [ column - 1 ] = 50 ; mat [ line ] [ column - 2 ] = 50 ; return 7 ; } else { return 0 ; } } else if ( c == 1 ) { if ( mat [ line - 1 ] [ column ] == 30 && mat [ line - 2 ] [ column ] == 30 ) { mat [ line ] [ column ] = 50 ; mat [ line - 1 ] [ column ] = 50 ; mat [ line - 2 ] [ column ] = 50 ; return 7 ; } else { return 0 ; } } else if ( b == 1 ) { if ( mat [ line + 1 ] [ column ] == 30 && mat [ line + 2 ] [ column ] == 30 ) { mat [ line ] [ column ] = 50 ; mat [ line + 1 ] [ column ] = 50 ; mat [ line + 2 ] [ column ] = 50 ; return 7 ; } else { return 0 ; } } } return 0 ; }",
    "resources/C/games/naval_battle.c@printPositioning": "void printPositioning ( int Player , int boat , int nm ) { if ( Player == 1 ) { char msg1 [ 60 ] = \"Player 1 - Position the size boat 1 (1/6)\" ; char msg2 [ 60 ] = \"Player 1 - Position the size boat 1 (2/6)\" ; char msg3 [ 60 ] = \"Player 1 - Position the size boat 1 (3/6)\" ; char msg4 [ 60 ] = \"Player 1 - Position the size boat 1 (4/6)\" ; char msg5 [ 60 ] = \"Player 1 - Position the size boat 1 (5/6)\" ; char msg6 [ 60 ] = \"Player 1 - Position the size boat 1 (6/6)\" ; char msg7 [ 60 ] = \"Player 1 - Position the size boat 2 (1/4)\" ; char msg8 [ 60 ] = \"Player 1 - Position the size boat 2 (2/4)\" ; char msg9 [ 60 ] = \"Player 1 - Position the size boat 2 (3/4)\" ; char msg10 [ 60 ] = \"Player 1 - Position the size boat 2 (4/4)\" ; char msg11 [ 60 ] = \"Player 1 - Position the size boat 3 (1/2)\" ; char msg12 [ 60 ] = \"Player 1 - Position the size boat 3 (2/2)\" ; if ( boat == 1 ) { if ( nm == 1 ) { printMessage ( msg1 ) ; } else if ( nm == 2 ) { printMessage ( msg2 ) ; } else if ( nm == 3 ) { printMessage ( msg3 ) ; } else if ( nm == 4 ) { printMessage ( msg4 ) ; } else if ( nm == 5 ) { printMessage ( msg5 ) ; } else if ( nm == 6 ) { printMessage ( msg6 ) ; } } else if ( boat == 2 ) { if ( nm == 1 ) { printMessage ( msg7 ) ; } else if ( nm == 2 ) { printMessage ( msg8 ) ; } else if ( nm == 3 ) { printMessage ( msg9 ) ; } else if ( nm == 4 ) { printMessage ( msg10 ) ; } } else if ( boat == 3 ) { if ( nm == 1 ) { printMessage ( msg11 ) ; } if ( nm == 2 ) { printMessage ( msg12 ) ; } } } if ( Player == 2 ) { char msg1 [ 60 ] = \"Player 2 - Position the size boat 1 (1/6)\" ; char msg2 [ 60 ] = \"Player 2 - Position the size boat 1 (2/6)\" ; char msg3 [ 60 ] = \"Player 2 - Position the size boat 1 (3/6)\" ; char msg4 [ 60 ] = \"Player 2 - Position the size boat 1 (4/6)\" ; char msg5 [ 60 ] = \"Player 2 - Position the size boat 1 (5/6)\" ; char msg6 [ 60 ] = \"Player 2 - Position the size boat 1 (6/6)\" ; char msg7 [ 60 ] = \"Player 2 - Position the size boat 2 (1/4)\" ; char msg8 [ 60 ] = \"Player 2 - Position the size boat 2 (2/4)\" ; char msg9 [ 60 ] = \"Player 2 - Position the size boat 2 (3/4)\" ; char msg10 [ 60 ] = \"Player 2 - Position the size boat 2 (4/4)\" ; char msg11 [ 60 ] = \"Player 2 - Position the size boat 3 (1/2)\" ; char msg12 [ 60 ] = \"Player 2 - Position the size boat 3 (2/2)\" ; if ( boat == 1 ) { if ( nm == 1 ) { printMessage ( msg1 ) ; } else if ( nm == 2 ) { printMessage ( msg2 ) ; } else if ( nm == 3 ) { printMessage ( msg3 ) ; } else if ( nm == 4 ) { printMessage ( msg4 ) ; } else if ( nm == 5 ) { printMessage ( msg5 ) ; } else if ( nm == 6 ) { printMessage ( msg6 ) ; } } else if ( boat == 2 ) { if ( nm == 1 ) { printMessage ( msg7 ) ; } else if ( nm == 2 ) { printMessage ( msg8 ) ; } else if ( nm == 3 ) { printMessage ( msg9 ) ; } else if ( nm == 4 ) { printMessage ( msg10 ) ; } } else if ( boat == 3 ) { if ( nm == 1 ) { printMessage ( msg11 ) ; } else if ( nm == 2 ) { printMessage ( msg12 ) ; } } } }",
    "resources/C/games/naval_battle.c@main": "int main ( ) { int Player1 [ 10 ] [ 10 ] ; int Player2 [ 10 ] [ 10 ] ; int plays = 1 ; int pts1 = 0 , pts2 = 0 , a1 = 0 , a2 = 0 ; int line , col = 0 , lin = 0 ; char column ; // filling matrix with 0 for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { Player1 [ i ] [ j ] = 0 ; Player2 [ i ] [ j ] = 0 ; } } // positioning boats for ( int i = 1 ; i <= 2 ; i ++ ) { for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i == 1 ) { printPositioning ( i , 1 , j ) ; printsTray ( Player1 , 0 ) ; positionBoat ( Player1 , 1 ) ; } else if ( i == 2 ) { printPositioning ( i , 1 , j ) ; printsTray ( Player2 , 0 ) ; positionBoat ( Player2 , 1 ) ; } } for ( int j = 1 ; j <= 4 ; j ++ ) { if ( i == 1 ) { printPositioning ( i , 2 , j ) ; printsTray ( Player1 , 0 ) ; positionBoat ( Player1 , 2 ) ; } else if ( i == 2 ) { printPositioning ( i , 2 , j ) ; printsTray ( Player2 , 0 ) ; positionBoat ( Player2 , 2 ) ; } } for ( int j = 1 ; j <= 2 ; j ++ ) { if ( i == 1 ) { printPositioning ( i , 3 , j ) ; printsTray ( Player1 , 0 ) ; positionBoat ( Player1 , 3 ) ; } else if ( i == 2 ) { printPositioning ( i , 3 , j ) ; printsTray ( Player2 , 0 ) ; positionBoat ( Player2 , 3 ) ; } } } // starting the game while ( plays <= 40 ) { if ( plays % 2 != 0 ) { printMessageScore ( pts1 , pts2 ) ; printMessage ( \"Player 1's turn\" ) ; printsTray ( Player2 , 1 ) ; scanf ( \"%d %c\" , & line , & column ) ; while ( validEntryLineColumn ( line , column ) != 1 || canShoot ( Player2 , line - 1 , column - 65 ) != 1 ) { line = 0 ; column = 'a' ; printf ( \"Position unavailable!\\n\" ) ; scanf ( \"%d %c\" , & line , & column ) ; } lin = line - 1 ; col = column - 65 ; shoot ( Player2 , lin , col ) ; a1 = pts1 ; pts1 += calculateScore ( Player2 , lin , col ) ; if ( a1 != pts1 ) { printMessage ( \"Player 1 DROPPED A BOAT!\" ) ; } } else { printMessageScore ( pts1 , pts2 ) ; printMessage ( \"Player 2's turn\" ) ; printsTray ( Player1 , 1 ) ; scanf ( \"%d %c\" , & line , & column ) ; while ( validEntryLineColumn ( line , column ) != 1 || canShoot ( Player1 , line - 1 , column - 65 ) != 1 ) { printf ( \"Position unavailable!\\n\" ) ; scanf ( \"%d %c\" , & line , & column ) ; } lin = line - 1 ; col = column - 65 ; shoot ( Player1 , lin , col ) ; a2 = pts2 ; pts2 += calculateScore ( Player1 , lin , col ) ; if ( a2 != pts2 ) { printMessage ( \"Player 2 DROPPED A BOAT!\" ) ; } } plays ++ ; } /**\n     * the one with the most points wins, or the one who knocks down all boats\n     * first.\n     */ printMessage ( \"END GAME\\n\" ) ; printMessageScore ( pts1 , pts2 ) ; return 0 ; }",
    "resources/C/games/tic_tac_toe.c@main": "int main ( ) { srand ( ( unsigned int ) time ( NULL ) ) ; int l = 0 ; do { int n = 0 ; // filling the table with multiple asterisks for ( int i = 0 ; i < 9 ; i ++ ) game_table [ i ] = '*' ; // displaying the main menu printf ( \"***************************************\\n\" ) ; printf ( \"*************TIC TAC TOE***************\\n\" ) ; printf ( \"***************************************\\n\" ) ; printf ( \"***********1. YOU vs COMPUTER ***********\\n\" ) ; printf ( \"***********2. YOU vs PLAYER ***********\\n\" ) ; printf ( \"***********3.EXIT *********************\\n\" ) ; printf ( \"Enter your choice : \" ) ; scanf ( \"%d\" , & n ) ; switch ( n ) // switch case to select between single player mode or // double player mode { case 1 : singlemode ( ) ; break ; case 2 : doublemode ( ) ; break ; default : printf ( \"THANK YOU and EXIT!\" ) ; } printf ( \"Next game ? : \" ) ; printf ( \"Enter 1 \u2013 YES and 0 - NO \" ) ; scanf ( \"%d\" , & l ) ; } while ( l == 1 ) ; return 0 ; }",
    "resources/C/games/tic_tac_toe.c@singlemode": "void singlemode ( ) { int m ; int k = 0 ; int table_fill_count = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { printf ( \"%c \" , game_table [ k ] ) ; k ++ ; } printf ( \"\\n\" ) ; } for ( int x = 1 ; x < 10 ; x ++ ) { k = 0 ; printf ( \"Where would you like to place 'x' \" ) ; scanf ( \"%d\" , & m ) ; placex ( m ) ; if ( table_fill_count < 4 ) { place ( ) ; } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { printf ( \"%c \" , game_table [ k ] ) ; k ++ ; } printf ( \"\\n\" ) ; } table_fill_count ++ ; int o = checkwin ( ) ; if ( o == - 1 || o == - 2 ) { if ( o == - 1 ) { printf ( \"YOU WIN\\n\" ) ; } if ( o == - 2 ) { printf ( \"YOU LOSE\\n\" ) ; } break ; } if ( table_fill_count == 4 ) { printf ( \"\\nDRAW \" ) ; break ; } } }",
    "resources/C/games/tic_tac_toe.c@doublemode": "void doublemode ( ) { int m ; int e1 ; int k = 0 ; int doublemode_table_count = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { printf ( \"%c \" , game_table [ k ] ) ; k ++ ; } printf ( \"\\n\" ) ; } for ( int x = 1 ; x < 10 ; x ++ ) { k = 0 ; printf ( \"PLAYER1 - where would you like to place 'x' : \" ) ; scanf ( \"%d\" , & m ) ; placex ( m ) ; if ( doublemode_table_count < 4 ) { printf ( \"PLAYER2 - where would you like to place 'o' : \" ) ; scanf ( \"%d\" , & e1 ) ; placey ( e1 ) ; } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { printf ( \"%c \" , game_table [ k ] ) ; k ++ ; } printf ( \"\\n\" ) ; } doublemode_table_count ++ ; int o = checkwin ( ) ; if ( o == - 1 || o == - 2 ) { if ( o == - 1 ) { printf ( \"Player 1 WIN\\n\" ) ; } if ( o == - 2 ) { printf ( \"Player 2 WIN\\n\" ) ; } break ; } if ( doublemode_table_count == 4 ) { printf ( \"\\nDRAW \" ) ; break ; } } }",
    "resources/C/games/tic_tac_toe.c@check_placex": "int check_placex ( ) { char input [ 50 ] ; int n1 ; while ( 1 ) { fgets ( input , 49 , stdin ) ; if ( strlen ( input ) > 2 || strlen ( input ) == 0 ) { fprintf ( stderr , \"Invalid move, Enter number 1 - 9: \" ) ; continue ; } if ( sscanf ( input , \"%d\" , & n1 ) != 1 ) { fprintf ( stderr , \"Invalid move, Enter number 1 - 9: \" ) ; continue ; } if ( ( game_table [ n1 - 1 ] == 'x' ) || ( game_table [ n1 - 1 ] ) == 'o' || ( n1 == 0 ) ) { fprintf ( stderr , \"Already allocated, Enter number: \" ) ; continue ; } return n1 ; } }",
    "resources/C/games/tic_tac_toe.c@placex": "void placex ( int m ) { int n1 = 0 ; if ( m >= 1 && m <= 9 ) { if ( game_table [ m - 1 ] != 'x' && game_table [ m - 1 ] != 'o' ) { game_table [ m - 1 ] = 'x' ; } else { int n = check_placex ( ) ; placex ( n ) ; } } else { int n = check_placex ( ) ; placex ( n ) ; } }",
    "resources/C/games/tic_tac_toe.c@place": "void place ( ) { int e = rand ( ) % 9 ; if ( e >= 0 ) { if ( game_table [ e ] != 'x' && game_table [ e ] != 'o' ) { game_table [ e ] = 'o' ; printf ( \"\\n Computer placed at %d position\\n\" , e + 1 ) ; } else { place ( ) ; } } }",
    "resources/C/games/tic_tac_toe.c@placey": "void placey ( int e1 ) { int n1 = 0 ; if ( e1 >= 1 && e1 <= 9 ) { if ( game_table [ e1 - 1 ] != 'x' && game_table [ e1 - 1 ] != 'o' ) { game_table [ e1 - 1 ] = 'o' ; } else { int n = check_placex ( ) ; placex ( n ) ; } } else { int n = check_placex ( ) ; placex ( n ) ; } }",
    "resources/C/games/tic_tac_toe.c@checkwin": "int checkwin ( ) { if ( game_table [ 0 ] == game_table [ 1 ] && game_table [ 1 ] == game_table [ 2 ] ) { if ( game_table [ 0 ] == 'x' && game_table [ 1 ] == 'x' && game_table [ 2 ] == 'x' ) { return - 1 ; } if ( game_table [ 0 ] == 'o' && game_table [ 1 ] == 'o' && game_table [ 2 ] == 'o' ) { return - 2 ; } } else if ( game_table [ 0 ] == game_table [ 4 ] && game_table [ 4 ] == game_table [ 8 ] ) { if ( game_table [ 0 ] == 'x' && game_table [ 4 ] == 'x' && game_table [ 8 ] == 'x' ) { return - 1 ; } if ( game_table [ 0 ] == 'o' && game_table [ 4 ] == 'o' && game_table [ 8 ] == 'o' ) { return - 2 ; } } else if ( game_table [ 0 ] == game_table [ 3 ] && game_table [ 3 ] == game_table [ 6 ] ) { if ( game_table [ 0 ] == 'x' && game_table [ 3 ] == 'x' && game_table [ 6 ] == 'x' ) { return - 1 ; } if ( game_table [ 0 ] == 'o' && game_table [ 3 ] == 'o' && game_table [ 6 ] == 'o' ) { return - 2 ; } } else if ( game_table [ 3 ] == game_table [ 4 ] && game_table [ 4 ] == game_table [ 5 ] ) { if ( game_table [ 3 ] == 'x' && game_table [ 4 ] == 'x' && game_table [ 5 ] == 'x' ) { return - 1 ; } if ( game_table [ 3 ] == 'o' && game_table [ 4 ] == 'o' && game_table [ 5 ] == 'o' ) { return - 2 ; } } else if ( game_table [ 6 ] == game_table [ 7 ] && game_table [ 7 ] == game_table [ 8 ] ) { if ( game_table [ 6 ] == 'x' && game_table [ 7 ] == 'x' && game_table [ 8 ] == 'x' ) { return - 1 ; } if ( game_table [ 6 ] == 'o' && game_table [ 7 ] == 'o' && game_table [ 8 ] == 'o' ) { return - 2 ; } } else if ( game_table [ 1 ] == game_table [ 4 ] && game_table [ 4 ] == game_table [ 7 ] ) { if ( game_table [ 1 ] == 'x' && game_table [ 4 ] == 'x' && game_table [ 7 ] == 'x' ) { return - 1 ; } if ( game_table [ 1 ] == 'o' && game_table [ 4 ] == 'o' && game_table [ 7 ] == 'o' ) { return - 2 ; } } else if ( game_table [ 2 ] == game_table [ 5 ] && game_table [ 5 ] == game_table [ 8 ] ) { if ( game_table [ 2 ] == 'x' && game_table [ 5 ] == 'x' && game_table [ 8 ] == 'x' ) { return - 1 ; } if ( game_table [ 2 ] == 'o' && game_table [ 5 ] == 'o' && game_table [ 8 ] == 'o' ) { return - 2 ; } } else if ( game_table [ 2 ] == game_table [ 4 ] && game_table [ 4 ] == game_table [ 6 ] ) { if ( game_table [ 2 ] == 'x' && game_table [ 4 ] == 'x' && game_table [ 6 ] == 'x' ) { return - 1 ; } if ( game_table [ 2 ] == 'o' && game_table [ 4 ] == 'o' && game_table [ 6 ] == 'o' ) { return - 2 ; } } return 0 ; }",
    "resources/C/games/hangman.c@main": "int main ( ) { struct game_instance game = new_game ( ) ; // new game created char guess ; // current letter guessed by player // main loop - asks player for guesses while ( ( strchr ( game . hidden , '_' ) != NULL ) && game . incorrect <= 12 ) { do { printf ( \"\\n****************************\\n\" ) ; printf ( \"Your word: \" ) ; for ( int i = 0 ; i < game . size ; i ++ ) { printf ( \"%c \" , game . hidden [ i ] ) ; } if ( game . guesses_size > 0 ) { printf ( \"\\nSo far, you have guessed: \" ) ; for ( int i = 0 ; i < game . guesses_size ; i ++ ) { printf ( \"%c \" , game . guesses [ i ] ) ; } } printf ( \"\\nYou have %d guesses left.\" , ( 12 - game . incorrect ) ) ; printf ( \"\\nPlease enter a letter: \" ) ; scanf ( \" %c\" , & guess ) ; guess = tolower ( guess ) ; } while ( new_guess ( guess , game . guesses , game . guesses_size ) != - 1 ) ; game . guesses [ game . guesses_size ] = guess ; // adds new letter to guesses array game . guesses_size ++ ; // updates size of guesses array if ( in_word ( guess , game . current_word , game . size ) == 1 ) { printf ( \"That letter is in the word!\" ) ; for ( int i = 0 ; i < game . size ; i ++ ) { if ( ( game . current_word [ i ] ) == guess ) { game . hidden [ i ] = guess ; } } } else { printf ( \"That letter is not in the word.\\n\" ) ; ( game . incorrect ) ++ ; } picture ( game . incorrect ) ; } won ( game . current_word , game . incorrect ) ; return 0 ; }",
    "resources/C/games/hangman.c@new_guess": "int new_guess ( char new_guess , const char guesses [ ] , int size ) { for ( int j = 0 ; j < size ; j ++ ) { if ( guesses [ j ] == new_guess ) { printf ( \"\\nYou have already guessed that letter.\" ) ; return 1 ; } } return - 1 ; }",
    "resources/C/games/hangman.c@in_word": "int in_word ( char letter , const char word [ ] , unsigned int size ) { for ( int i = 0 ; i < size ; i ++ ) { if ( ( word [ i ] ) == letter ) { return 1 ; } } return - 1 ; }",
    "resources/C/games/hangman.c@new_game": "struct game_instance new_game ( ) { char word [ 30 ] ; // used throughout function FILE * fptr ; fptr = fopen ( \"games/words.txt\" , \"r\" ) ; if ( fptr == NULL ) { fprintf ( stderr , \"File not found.\\n\" ) ; exit ( EXIT_FAILURE ) ; } // counts number of words in file - assumes each word on new line int line_number = 0 ; while ( fgets ( word , 30 , fptr ) != NULL ) { line_number ++ ; } rewind ( fptr ) ; // generates random number int random_num ; srand ( time ( NULL ) ) ; random_num = rand ( ) % line_number ; // selects randomly generated word int s = 0 ; while ( s <= random_num ) { fgets ( word , 30 , fptr ) ; s ++ ; } // formats string correctly if ( strchr ( word , '\\n' ) != NULL ) { word [ strlen ( word ) - 1 ] = '\\0' ; } fclose ( fptr ) ; // creates new game instance struct game_instance current_game ; strcpy ( current_game . current_word , word ) ; current_game . size = strlen ( word ) ; for ( int i = 0 ; i < ( strlen ( word ) ) ; i ++ ) { current_game . hidden [ i ] = '_' ; } current_game . incorrect = 0 ; current_game . guesses_size = 0 ; return current_game ; }",
    "resources/C/games/hangman.c@won": "void won ( const char word [ ] , int score ) { if ( score > 12 ) { printf ( \"\\nYou lost! The word was: %s.\\n\" , word ) ; } else { printf ( \"\\nYou won! You had %d guesses left.\\n\" , ( 12 - score ) ) ; } }",
    "resources/C/games/hangman.c@picture": "void picture ( int score ) { switch ( score ) { case 12 : printf ( \"\\n      _\\n\" \"  __( ' )> \\n\" \" \\\\_ < _ ) \" ) ; break ; case 11 : printf ( \"\\n      _\\n\" \"  __( ' )\\n\" \" \\\\_ < _ ) \" ) ; break ; case 10 : printf ( \"\\n      _\\n\" \"  __(   )\\n\" \" \\\\_ < _ ) \" ) ; break ; case 9 : printf ( \"\\n        \\n\" \"  __(   )\\n\" \" \\\\_ < _ ) \" ) ; break ; case 8 : printf ( \"\\n        \\n\" \"  __(    \\n\" \" \\\\_ < _ ) \" ) ; break ; case 7 : printf ( \"\\n        \\n\" \"  __     \\n\" \" \\\\_ < _ ) \" ) ; break ; case 6 : printf ( \"\\n        \\n\" \"  _      \\n\" \" \\\\_ < _ ) \" ) ; break ; case 5 : printf ( \"\\n        \\n\" \"  _      \\n\" \"   _ < _ ) \" ) ; break ; case 4 : printf ( \"\\n        \\n\" \"         \\n\" \"   _ < _ ) \" ) ; break ; case 3 : printf ( \"\\n        \\n\" \"         \\n\" \"     < _ ) \" ) ; break ; case 2 : printf ( \"\\n        \\n\" \"         \\n\" \"       _ ) \" ) ; break ; case 1 : printf ( \"\\n        \\n\" \"         \\n\" \"         ) \" ) ; break ; case 0 : break ; default : printf ( \"\\n      _\\n\" \"  __( ' )> QUACK!\\n\" \" \\\\_ < _ ) \" ) ; break ; } }",
    "resources/C/greedy_approach/dijkstra.c@enqueue": "void enqueue ( int v ) { q [ qp ++ ] = v ; }",
    "resources/C/greedy_approach/dijkstra.c@cf": "int cf ( void * a , void * b ) { int * x = ( int * ) a ; int * y = ( int * ) b ; return * y - * x ; }",
    "resources/C/greedy_approach/dijkstra.c@dequeue": "int dequeue ( ) { qsort ( q , qp , sizeof ( int ) , cf ) ; return q [ -- qp ] ; }",
    "resources/C/greedy_approach/dijkstra.c@queue_has_something": "int queue_has_something ( ) { return ( qp > 0 ) ; }",
    "resources/C/greedy_approach/dijkstra.c@dijkstra": "void dijkstra ( int s ) { dist [ s ] = 0 ; int i ; for ( i = 0 ; i < V ; ++ i ) { if ( i != s ) { dist [ i ] = INF ; } enqueue ( i ) ; } while ( queue_has_something ( ) ) { int u = dequeue ( ) ; visited [ vp ++ ] = u ; for ( i = 0 ; i < V ; ++ i ) { if ( mat [ u ] [ i ] ) { if ( dist [ i ] > dist [ u ] + mat [ u ] [ i ] ) { dist [ i ] = dist [ u ] + mat [ u ] [ i ] ; } } } } }",
    "resources/C/greedy_approach/dijkstra.c@main": "int main ( int argc , char const * argv [ ] ) { printf ( \"Enter the number of vertices: \" ) ; scanf ( \" %d\" , & V ) ; printf ( \"Enter the adj matrix: \" ) ; int i , j ; for ( i = 0 ; i < V ; ++ i ) { for ( j = 0 ; j < V ; ++ j ) { scanf ( \" %d\" , & mat [ i ] [ j ] ) ; } } dijkstra ( 0 ) ; printf ( \"\\nNode\\tDist\\n\" ) ; for ( i = 0 ; i < V ; ++ i ) { printf ( \"%d\\t%d\\n\" , i , dist [ i ] ) ; } return 0 ; }",
    "resources/C/greedy_approach/prim.c@minimum": "uint16_t minimum ( uint16_t arr [ ] , uint16_t N ) { uint16_t index = 0 ; uint16_t min = INF ; for ( uint16_t i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < min ) { min = arr [ i ] ; index = i ; } } return index ; }",
    "resources/C/greedy_approach/prim.c@prim": "void prim ( uint16_t G [ ] [ MAX ] , uint16_t MST [ ] [ MAX ] , uint16_t V ) { uint16_t u , v ; uint16_t E_t [ MAX ] , path [ MAX ] ; uint16_t V_t [ MAX ] , no_of_edges ; E_t [ 0 ] = 0 ; // edges for current vertex V_t [ 0 ] = 1 ; // list of visited vertices for ( uint16_t i = 1 ; i < V ; i ++ ) { E_t [ i ] = G [ i ] [ 0 ] ; path [ i ] = 0 ; V_t [ i ] = 0 ; } no_of_edges = V - 1 ; while ( no_of_edges > 0 ) { u = minimum ( E_t , V ) ; while ( V_t [ u ] == 1 ) { E_t [ u ] = INF ; u = minimum ( E_t , V ) ; } v = path [ u ] ; MST [ v ] [ u ] = E_t [ u ] ; MST [ u ] [ v ] = E_t [ u ] ; no_of_edges -- ; V_t [ u ] = 1 ; for ( uint16_t i = 1 ; i < V ; i ++ ) { if ( V_t [ i ] == 0 && G [ u ] [ i ] < E_t [ i ] ) { E_t [ i ] = G [ u ] [ i ] ; path [ i ] = v ; } } } }",
    "resources/C/greedy_approach/prim.c@test": "static void test ( uint16_t G [ ] [ MAX ] , uint16_t MST [ ] [ MAX ] , uint16_t V ) { uint16_t test [ 4 ] [ 4 ] = { { 0 , 1 , 2 , 3 } , { 1 , 0 , 4 , 6 } , { 2 , 4 , 0 , 5 } , { 3 , 6 , 5 , 0 } } ; uint16_t solution [ 4 ] [ 4 ] = { { 0 , 1 , 2 , 3 } , { 1 , 0 , 0 , 0 } , { 2 , 0 , 0 , 0 } , { 3 , 0 , 0 , 0 } } ; V = 4 ; for ( uint16_t i = 0 ; i < V ; ++ i ) { for ( uint16_t j = 0 ; j < V ; ++ j ) { G [ i ] [ j ] = test [ i ] [ j ] ; } } prim ( & ( * G ) , & ( * MST ) , V ) ; for ( uint16_t i = 0 ; i < V ; ++ i ) { for ( uint16_t j = 0 ; j < V ; ++ j ) { assert ( MST [ i ] [ j ] == solution [ i ] [ j ] ) ; } } }",
    "resources/C/greedy_approach/prim.c@user_graph": "void user_graph ( uint16_t G [ ] [ MAX ] , uint16_t MST [ ] [ MAX ] , uint16_t V ) { printf ( \"Enter the number of vertices: \" ) ; scanf ( \" %hd\" , & V ) ; assert ( V <= MAX ) ; printf ( \"Enter the adj matrix\\n\" ) ; uint16_t i , j ; for ( i = 0 ; i < V ; ++ i ) { for ( j = 0 ; j < V ; ++ j ) { printf ( \"G[%d][%d]: \" , i , j ) ; scanf ( \" %hd\" , & G [ i ] [ j ] ) ; if ( G [ i ] [ j ] == 0 ) G [ i ] [ j ] = INF ; } } prim ( & ( * G ) , & ( * MST ) , V ) ; printf ( \"minimum spanning tree:\\n\" ) ; for ( i = 0 ; i < V ; ++ i ) { printf ( \"\\n\" ) ; for ( j = 0 ; j < V ; ++ j ) { printf ( \"%d\\t\" , MST [ i ] [ j ] ) ; } } }",
    "resources/C/greedy_approach/prim.c@main": "int main ( int argc , char const * argv [ ] ) { uint16_t G [ MAX ] [ MAX ] ; ///< weighted, connected graph G uint16_t MST [ MAX ] [ MAX ] ; ///< adj matrix to hold minimum spanning tree of G uint16_t V ; ///< number of vertices in V in G if ( argc == 2 && strcmp ( argv [ 1 ] , \"-test\" ) == 0 ) { test ( & ( * G ) , & ( * MST ) , V ) ; } else { user_graph ( & ( * G ) , & ( * MST ) , V ) ; } return 0 ; }"
}