{
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@fopen_utf8": "static inline FILE * fopen_utf8 ( const char * path , const char * mode ) { return fopen ( path , mode ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@uninit_opts": "void uninit_opts ( void ) { av_dict_free ( & swr_opts ) ; av_dict_free ( & sws_dict ) ; av_dict_free ( & format_opts ) ; av_dict_free ( & codec_opts ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@init_dynload": "void init_dynload ( void ) { # if HAVE_SETDLLDIRECTORY && defined ( _WIN32 ) /* Calling SetDllDirectory with the empty string (but not NULL) removes the\n     * current working directory from the DLL search path as a security pre-caution. */ SetDllDirectory ( \"\" ) ; # endif }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@register_exit": "void register_exit ( void ( * cb ) ( int ret ) ) { program_exit = cb ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@report_and_exit": "void report_and_exit ( int ret ) { av_log ( NULL , AV_LOG_FATAL , \"%s\\n\" , av_err2str ( ret ) ) ; exit_program ( AVUNERROR ( ret ) ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@exit_program": "void exit_program ( int ret ) { if ( program_exit ) program_exit ( ret ) ; // FFmpegKit // exit disabled and replaced with longjmp, exit value stored in longjmp_value // exit(ret); longjmp_value = ret ; longjmp ( ex_buf__ , ret ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@parse_number_or_die": "double parse_number_or_die ( const char * context , const char * numstr , int type , double min , double max ) { char * tail ; const char * error ; double d = av_strtod ( numstr , & tail ) ; if ( * tail ) error = \"Expected number for %s but found: %s\\n\" ; else if ( d < min || d > max ) error = \"The value for %s was %s which is not within %f - %f\\n\" ; else if ( type == OPT_INT64 && ( int64_t ) d != d ) error = \"Expected int64 for %s but found %s\\n\" ; else if ( type == OPT_INT && ( int ) d != d ) error = \"Expected int for %s but found %s\\n\" ; else return d ; av_log ( NULL , AV_LOG_FATAL , error , context , numstr , min , max ) ; exit_program ( 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@parse_time_or_die": "int64_t parse_time_or_die ( const char * context , const char * timestr , int is_duration ) { int64_t us ; if ( av_parse_time ( & us , timestr , is_duration ) < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid %s specification for %s: %s\\n\" , is_duration ? \"duration\" : \"date\" , context , timestr ) ; exit_program ( 1 ) ; } return us ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@show_help_options": "void show_help_options ( const OptionDef * options , const char * msg , int req_flags , int rej_flags , int alt_flags ) { const OptionDef * po ; int first ; first = 1 ; for ( po = options ; po -> name ; po ++ ) { char buf [ 128 ] ; if ( ( ( po -> flags & req_flags ) != req_flags ) || ( alt_flags && ! ( po -> flags & alt_flags ) ) || ( po -> flags & rej_flags ) ) continue ; if ( first ) { av_log ( NULL , AV_LOG_STDERR , \"%s\\n\" , msg ) ; first = 0 ; } av_strlcpy ( buf , po -> name , sizeof ( buf ) ) ; if ( po -> argname ) { av_strlcat ( buf , \" \" , sizeof ( buf ) ) ; av_strlcat ( buf , po -> argname , sizeof ( buf ) ) ; } av_log ( NULL , AV_LOG_STDERR , \"-%-17s  %s\\n\" , buf , po -> help ) ; } av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@show_help_children": "void show_help_children ( const AVClass * class , int flags ) { void * iter = NULL ; const AVClass * child ; if ( class -> option ) { av_opt_show2 ( & class , NULL , flags , 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; } while ( ( child = av_opt_child_class_iterate ( class , & iter ) ) ) show_help_children ( child , flags ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@find_option": "static const OptionDef * find_option ( const OptionDef * po , const char * name ) { while ( po -> name ) { const char * end ; if ( av_strstart ( name , po -> name , & end ) && ( ! * end || * end == ':' ) ) break ; po ++ ; } return po ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@prepare_app_arguments": "static inline void prepare_app_arguments ( int * argc_ptr , char * * * argv_ptr ) { /* nothing to do */ }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@write_option": "static int write_option ( void * optctx , const OptionDef * po , const char * opt , const char * arg ) { /* new-style options contain an offset into optctx, old-style address of\n     * a global var*/ void * dst = po -> flags & ( OPT_OFFSET | OPT_SPEC ) ? ( uint8_t * ) optctx + po -> u . off : po -> u . dst_ptr ; int * dstcount ; if ( po -> flags & OPT_SPEC ) { SpecifierOpt * * so = dst ; char * p = strchr ( opt , ':' ) ; char * str ; dstcount = ( int * ) ( so + 1 ) ; * so = grow_array ( * so , sizeof ( * * so ) , dstcount , * dstcount + 1 ) ; str = av_strdup ( p ? p + 1 : \"\" ) ; if ( ! str ) return AVERROR ( ENOMEM ) ; ( * so ) [ * dstcount - 1 ] . specifier = str ; dst = & ( * so ) [ * dstcount - 1 ] . u ; } if ( po -> flags & OPT_STRING ) { char * str ; str = av_strdup ( arg ) ; av_freep ( dst ) ; if ( ! str ) return AVERROR ( ENOMEM ) ; * ( char * * ) dst = str ; } else if ( po -> flags & OPT_BOOL || po -> flags & OPT_INT ) { * ( int * ) dst = parse_number_or_die ( opt , arg , OPT_INT64 , INT_MIN , INT_MAX ) ; } else if ( po -> flags & OPT_INT64 ) { * ( int64_t * ) dst = parse_number_or_die ( opt , arg , OPT_INT64 , INT64_MIN , ( double ) INT64_MAX ) ; } else if ( po -> flags & OPT_TIME ) { * ( int64_t * ) dst = parse_time_or_die ( opt , arg , 1 ) ; } else if ( po -> flags & OPT_FLOAT ) { * ( float * ) dst = parse_number_or_die ( opt , arg , OPT_FLOAT , - INFINITY , INFINITY ) ; } else if ( po -> flags & OPT_DOUBLE ) { * ( double * ) dst = parse_number_or_die ( opt , arg , OPT_DOUBLE , - INFINITY , INFINITY ) ; } else if ( po -> u . func_arg ) { int ret = po -> u . func_arg ( optctx , opt , arg ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Failed to set value '%s' for option '%s': %s\\n\" , arg , opt , av_err2str ( ret ) ) ; return ret ; } } if ( po -> flags & OPT_EXIT ) exit_program ( 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@parse_option": "int parse_option ( void * optctx , const char * opt , const char * arg , const OptionDef * options ) { static const OptionDef opt_avoptions = { . name = \"AVOption passthrough\" , . flags = HAS_ARG , . u . func_arg = opt_default , } ; const OptionDef * po ; int ret ; po = find_option ( options , opt ) ; if ( ! po -> name && opt [ 0 ] == 'n' && opt [ 1 ] == 'o' ) { /* handle 'no' bool option */ po = find_option ( options , opt + 2 ) ; if ( ( po -> name && ( po -> flags & OPT_BOOL ) ) ) arg = \"0\" ; } else if ( po -> flags & OPT_BOOL ) arg = \"1\" ; if ( ! po -> name ) po = & opt_avoptions ; if ( ! po -> name ) { av_log ( NULL , AV_LOG_ERROR , \"Unrecognized option '%s'\\n\" , opt ) ; return AVERROR ( EINVAL ) ; } if ( po -> flags & HAS_ARG && ! arg ) { av_log ( NULL , AV_LOG_ERROR , \"Missing argument for option '%s'\\n\" , opt ) ; return AVERROR ( EINVAL ) ; } ret = write_option ( optctx , po , opt , arg ) ; if ( ret < 0 ) return ret ; return ! ! ( po -> flags & HAS_ARG ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@parse_options": "void parse_options ( void * optctx , int argc , char * * argv , const OptionDef * options , void ( * parse_arg_function ) ( void * , const char * ) ) { const char * opt ; int optindex , handleoptions = 1 , ret ; /* perform system-dependent conversions for arguments list */ prepare_app_arguments ( & argc , & argv ) ; /* parse options */ optindex = 1 ; while ( optindex < argc ) { opt = argv [ optindex ++ ] ; if ( handleoptions && opt [ 0 ] == '-' && opt [ 1 ] != '\\0' ) { if ( opt [ 1 ] == '-' && opt [ 2 ] == '\\0' ) { handleoptions = 0 ; continue ; } opt ++ ; if ( optindex >= argc ) { if ( ( ret = parse_option ( optctx , opt , NULL , options ) ) < 0 ) exit_program ( 1 ) ; } else { if ( ( ret = parse_option ( optctx , opt , argv [ optindex ] , options ) ) < 0 ) exit_program ( 1 ) ; } optindex += ret ; } else { if ( parse_arg_function ) parse_arg_function ( optctx , opt ) ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@parse_optgroup": "int parse_optgroup ( void * optctx , OptionGroup * g ) { int i , ret ; av_log ( NULL , AV_LOG_DEBUG , \"Parsing a group of options: %s %s.\\n\" , g -> group_def -> name , g -> arg ) ; for ( i = 0 ; i < g -> nb_opts ; i ++ ) { Option * o = & g -> opts [ i ] ; if ( g -> group_def -> flags && ! ( g -> group_def -> flags & o -> opt -> flags ) ) { av_log ( NULL , AV_LOG_ERROR , \"Option %s (%s) cannot be applied to \" \"%s %s -- you are trying to apply an input option to an \" \"output file or vice versa. Move this option before the \" \"file it belongs to.\\n\" , o -> key , o -> opt -> help , g -> group_def -> name , g -> arg ) ; return AVERROR ( EINVAL ) ; } av_log ( NULL , AV_LOG_DEBUG , \"Applying option %s (%s) with argument %s.\\n\" , o -> key , o -> opt -> help , o -> val ) ; ret = write_option ( optctx , o -> opt , o -> key , o -> val ) ; if ( ret < 0 ) return ret ; } av_log ( NULL , AV_LOG_DEBUG , \"Successfully parsed a group of options.\\n\" ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@locate_option": "int locate_option ( int argc , char * * argv , const OptionDef * options , const char * optname ) { const OptionDef * po ; int i ; for ( i = 1 ; i < argc ; i ++ ) { const char * cur_opt = argv [ i ] ; if ( * cur_opt ++ != '-' ) continue ; po = find_option ( options , cur_opt ) ; if ( ! po -> name && cur_opt [ 0 ] == 'n' && cur_opt [ 1 ] == 'o' ) po = find_option ( options , cur_opt + 2 ) ; if ( ( ! po -> name && ! strcmp ( cur_opt , optname ) ) || ( po -> name && ! strcmp ( optname , po -> name ) ) ) return i ; if ( ! po -> name || po -> flags & HAS_ARG ) i ++ ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@dump_argument": "static void dump_argument ( FILE * report_file , const char * a ) { const unsigned char * p ; for ( p = a ; * p ; p ++ ) if ( ! ( ( * p >= '+' && * p <= ':' ) || ( * p >= '@' && * p <= 'Z' ) || * p == '_' || ( * p >= 'a' && * p <= 'z' ) ) ) break ; if ( ! * p ) { fputs ( a , report_file ) ; return ; } fputc ( '\"' , report_file ) ; for ( p = a ; * p ; p ++ ) { if ( * p == '\\\\' || * p == '\"' || * p == '$' || * p == '`' ) fprintf ( report_file , \"\\\\%c\" , * p ) ; else if ( * p < ' ' || * p > '~' ) fprintf ( report_file , \"\\\\x%02x\" , * p ) ; else fputc ( * p , report_file ) ; } fputc ( '\"' , report_file ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@check_options": "static void check_options ( const OptionDef * po ) { while ( po -> name ) { if ( po -> flags & OPT_PERFILE ) av_assert0 ( po -> flags & ( OPT_INPUT | OPT_OUTPUT ) ) ; po ++ ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@parse_loglevel": "void parse_loglevel ( int argc , char * * argv , const OptionDef * options ) { int idx = locate_option ( argc , argv , options , \"loglevel\" ) ; char * env ; check_options ( options ) ; if ( ! idx ) idx = locate_option ( argc , argv , options , \"v\" ) ; if ( idx && ( idx + 1 < argc ) && argv [ idx + 1 ] ) opt_loglevel ( NULL , \"loglevel\" , argv [ idx + 1 ] ) ; idx = locate_option ( argc , argv , options , \"report\" ) ; env = getenv_utf8 ( \"FFREPORT\" ) ; if ( env || idx ) { FILE * report_file = NULL ; init_report ( env , & report_file ) ; if ( report_file ) { int i ; fprintf ( report_file , \"Command line:\\n\" ) ; for ( i = 0 ; i < argc ; i ++ ) { dump_argument ( report_file , argv [ i ] ) ; fputc ( i < argc - 1 ? ' ' : '\\n' , report_file ) ; } fflush ( report_file ) ; } } freeenv_utf8 ( env ) ; idx = locate_option ( argc , argv , options , \"hide_banner\" ) ; if ( idx ) hide_banner = 1 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@opt_find": "static const AVOption * opt_find ( void * obj , const char * name , const char * unit , int opt_flags , int search_flags ) { const AVOption * o = av_opt_find ( obj , name , unit , opt_flags , search_flags ) ; if ( o && ! o -> flags ) return NULL ; return o ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@opt_default": "int opt_default ( void * optctx , const char * opt , const char * arg ) { const AVOption * o ; int consumed = 0 ; char opt_stripped [ 128 ] ; const char * p ; const AVClass * cc = avcodec_get_class ( ) , * fc = avformat_get_class ( ) ; # if CONFIG_SWSCALE const AVClass * sc = sws_get_class ( ) ; # endif # if CONFIG_SWRESAMPLE const AVClass * swr_class = swr_get_class ( ) ; # endif if ( ! strcmp ( opt , \"debug\" ) || ! strcmp ( opt , \"fdebug\" ) ) av_log_set_level ( AV_LOG_DEBUG ) ; if ( ! ( p = strchr ( opt , ':' ) ) ) p = opt + strlen ( opt ) ; av_strlcpy ( opt_stripped , opt , FFMIN ( sizeof ( opt_stripped ) , p - opt + 1 ) ) ; if ( ( o = opt_find ( & cc , opt_stripped , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ) || ( ( opt [ 0 ] == 'v' || opt [ 0 ] == 'a' || opt [ 0 ] == 's' ) && ( o = opt_find ( & cc , opt + 1 , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ) ) ) { av_dict_set ( & codec_opts , opt , arg , FLAGS ) ; consumed = 1 ; } if ( ( o = opt_find ( & fc , opt , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ) ) { av_dict_set ( & format_opts , opt , arg , FLAGS ) ; if ( consumed ) av_log ( NULL , AV_LOG_VERBOSE , \"Routing option %s to both codec and muxer layer\\n\" , opt ) ; consumed = 1 ; } # if CONFIG_SWSCALE if ( ! consumed && ( o = opt_find ( & sc , opt , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ) ) { if ( ! strcmp ( opt , \"srcw\" ) || ! strcmp ( opt , \"srch\" ) || ! strcmp ( opt , \"dstw\" ) || ! strcmp ( opt , \"dsth\" ) || ! strcmp ( opt , \"src_format\" ) || ! strcmp ( opt , \"dst_format\" ) ) { av_log ( NULL , AV_LOG_ERROR , \"Directly using swscale dimensions/format options is not supported, please use the -s or -pix_fmt options\\n\" ) ; return AVERROR ( EINVAL ) ; } av_dict_set ( & sws_dict , opt , arg , FLAGS ) ; consumed = 1 ; } # else if ( ! consumed && ! strcmp ( opt , \"sws_flags\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"Ignoring %s %s, due to disabled swscale\\n\" , opt , arg ) ; consumed = 1 ; } # endif # if CONFIG_SWRESAMPLE if ( ! consumed && ( o = opt_find ( & swr_class , opt , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ) ) { av_dict_set ( & swr_opts , opt , arg , FLAGS ) ; consumed = 1 ; } # endif if ( consumed ) return 0 ; return AVERROR_OPTION_NOT_FOUND ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@match_group_separator": "static int match_group_separator ( const OptionGroupDef * groups , int nb_groups , const char * opt ) { int i ; for ( i = 0 ; i < nb_groups ; i ++ ) { const OptionGroupDef * p = & groups [ i ] ; if ( p -> sep && ! strcmp ( p -> sep , opt ) ) return i ; } return - 1 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@finish_group": "static void finish_group ( OptionParseContext * octx , int group_idx , const char * arg ) { OptionGroupList * l = & octx -> groups [ group_idx ] ; OptionGroup * g ; GROW_ARRAY ( l -> groups , l -> nb_groups ) ; g = & l -> groups [ l -> nb_groups - 1 ] ; * g = octx -> cur_group ; g -> arg = arg ; g -> group_def = l -> group_def ; g -> sws_dict = sws_dict ; g -> swr_opts = swr_opts ; g -> codec_opts = codec_opts ; g -> format_opts = format_opts ; codec_opts = NULL ; format_opts = NULL ; sws_dict = NULL ; swr_opts = NULL ; memset ( & octx -> cur_group , 0 , sizeof ( octx -> cur_group ) ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@add_opt": "static void add_opt ( OptionParseContext * octx , const OptionDef * opt , const char * key , const char * val ) { int global = ! ( opt -> flags & ( OPT_PERFILE | OPT_SPEC | OPT_OFFSET ) ) ; OptionGroup * g = global ? & octx -> global_opts : & octx -> cur_group ; GROW_ARRAY ( g -> opts , g -> nb_opts ) ; g -> opts [ g -> nb_opts - 1 ] . opt = opt ; g -> opts [ g -> nb_opts - 1 ] . key = key ; g -> opts [ g -> nb_opts - 1 ] . val = val ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@init_parse_context": "static void init_parse_context ( OptionParseContext * octx , const OptionGroupDef * groups , int nb_groups ) { static const OptionGroupDef global_group = { \"global\" } ; int i ; memset ( octx , 0 , sizeof ( * octx ) ) ; octx -> nb_groups = nb_groups ; octx -> groups = av_calloc ( octx -> nb_groups , sizeof ( * octx -> groups ) ) ; if ( ! octx -> groups ) report_and_exit ( AVERROR ( ENOMEM ) ) ; for ( i = 0 ; i < octx -> nb_groups ; i ++ ) octx -> groups [ i ] . group_def = & groups [ i ] ; octx -> global_opts . group_def = & global_group ; octx -> global_opts . arg = \"\" ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@uninit_parse_context": "void uninit_parse_context ( OptionParseContext * octx ) { int i , j ; for ( i = 0 ; i < octx -> nb_groups ; i ++ ) { OptionGroupList * l = & octx -> groups [ i ] ; for ( j = 0 ; j < l -> nb_groups ; j ++ ) { av_freep ( & l -> groups [ j ] . opts ) ; av_dict_free ( & l -> groups [ j ] . codec_opts ) ; av_dict_free ( & l -> groups [ j ] . format_opts ) ; av_dict_free ( & l -> groups [ j ] . sws_dict ) ; av_dict_free ( & l -> groups [ j ] . swr_opts ) ; } av_freep ( & l -> groups ) ; } av_freep ( & octx -> groups ) ; av_freep ( & octx -> cur_group . opts ) ; av_freep ( & octx -> global_opts . opts ) ; uninit_opts ( ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@split_commandline": "int split_commandline ( OptionParseContext * octx , int argc , char * argv [ ] , const OptionDef * options , const OptionGroupDef * groups , int nb_groups ) { int optindex = 1 ; int dashdash = - 2 ; /* perform system-dependent conversions for arguments list */ prepare_app_arguments ( & argc , & argv ) ; init_parse_context ( octx , groups , nb_groups ) ; av_log ( NULL , AV_LOG_DEBUG , \"Splitting the commandline.\\n\" ) ; while ( optindex < argc ) { const char * opt = argv [ optindex ++ ] , * arg ; const OptionDef * po ; int ret ; av_log ( NULL , AV_LOG_DEBUG , \"Reading option '%s' ...\" , opt ) ; if ( opt [ 0 ] == '-' && opt [ 1 ] == '-' && ! opt [ 2 ] ) { dashdash = optindex ; continue ; } /* unnamed group separators, e.g. output filename */ if ( opt [ 0 ] != '-' || ! opt [ 1 ] || dashdash + 1 == optindex ) { finish_group ( octx , 0 , opt ) ; av_log ( NULL , AV_LOG_DEBUG , \" matched as %s.\\n\" , groups [ 0 ] . name ) ; continue ; } opt ++ ; # define GET_ARG ( arg ) do { if ( optindex < argc ) { arg = argv [ optindex ++ ] ; } else { av_log ( NULL , AV_LOG_ERROR , \"Missing argument for option '%s'.\\n\" , opt ) ; return AVERROR ( EINVAL ) ; } \\\n} while ( 0 ) /* named group separators, e.g. -i */ if ( ( ret = match_group_separator ( groups , nb_groups , opt ) ) >= 0 ) { GET_ARG ( arg ) ; finish_group ( octx , ret , arg ) ; av_log ( NULL , AV_LOG_DEBUG , \" matched as %s with argument '%s'.\\n\" , groups [ ret ] . name , arg ) ; continue ; } /* normal options */ po = find_option ( options , opt ) ; if ( po -> name ) { if ( po -> flags & OPT_EXIT ) { /* optional argument, e.g. -h */ if ( optindex < argc ) { arg = argv [ optindex ++ ] ; } else { arg = NULL ; } } else if ( po -> flags & HAS_ARG ) { GET_ARG ( arg ) ; } else { arg = \"1\" ; } add_opt ( octx , po , opt , arg ) ; av_log ( NULL , AV_LOG_DEBUG , \" matched as option '%s' (%s) with \" \"argument '%s'.\\n\" , po -> name , po -> help , arg ) ; continue ; } /* AVOptions */ if ( ( optindex < argc ) && argv [ optindex ] ) { ret = opt_default ( NULL , opt , argv [ optindex ] ) ; if ( ret >= 0 ) { av_log ( NULL , AV_LOG_DEBUG , \" matched as AVOption '%s' with \" \"argument '%s'.\\n\" , opt , argv [ optindex ] ) ; optindex ++ ; continue ; } else if ( ret != AVERROR_OPTION_NOT_FOUND ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing option '%s' \" \"with argument '%s'.\\n\" , opt , argv [ optindex ] ) ; return ret ; } } /* boolean -nofoo options */ if ( opt [ 0 ] == 'n' && opt [ 1 ] == 'o' && ( po = find_option ( options , opt + 2 ) ) && po -> name && po -> flags & OPT_BOOL ) { add_opt ( octx , po , opt , \"0\" ) ; av_log ( NULL , AV_LOG_DEBUG , \" matched as option '%s' (%s) with \" \"argument 0.\\n\" , po -> name , po -> help ) ; continue ; } av_log ( NULL , AV_LOG_ERROR , \"Unrecognized option '%s'.\\n\" , opt ) ; return AVERROR_OPTION_NOT_FOUND ; } if ( octx -> cur_group . nb_opts || codec_opts || format_opts ) av_log ( NULL , AV_LOG_WARNING , \"Trailing option(s) found in the \" \"command: may be ignored.\\n\" ) ; av_log ( NULL , AV_LOG_DEBUG , \"Finished splitting the commandline.\\n\" ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@print_error": "void print_error ( const char * filename , int err ) { av_log ( NULL , AV_LOG_ERROR , \"%s: %s\\n\" , filename , av_err2str ( err ) ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@read_yesno": "int read_yesno ( void ) { int c = getchar ( ) ; int yesno = ( av_toupper ( c ) == 'Y' ) ; while ( c != '\\n' && c != EOF ) c = getchar ( ) ; return yesno ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@get_preset_file": "FILE * get_preset_file ( char * filename , size_t filename_size , const char * preset_name , int is_path , const char * codec_name ) { FILE * f = NULL ; int i ; # if HAVE_GETMODULEHANDLE && defined ( _WIN32 ) char * datadir = NULL ; # endif char * env_home = getenv_utf8 ( \"HOME\" ) ; char * env_ffmpeg_datadir = getenv_utf8 ( \"FFMPEG_DATADIR\" ) ; const char * base [ 3 ] = { env_ffmpeg_datadir , env_home , /* index=1(HOME) is special: search in a .ffmpeg subfolder */ FFMPEG_DATADIR , } ; if ( is_path ) { av_strlcpy ( filename , preset_name , filename_size ) ; f = fopen_utf8 ( filename , \"r\" ) ; } else { # if HAVE_GETMODULEHANDLE && defined ( _WIN32 ) wchar_t * datadir_w = get_module_filename ( NULL ) ; base [ 2 ] = NULL ; if ( wchartoutf8 ( datadir_w , & datadir ) ) datadir = NULL ; av_free ( datadir_w ) ; if ( datadir ) { char * ls ; for ( ls = datadir ; * ls ; ls ++ ) if ( * ls == '\\\\' ) * ls = '/' ; if ( ls = strrchr ( datadir , '/' ) ) { ptrdiff_t datadir_len = ls - datadir ; size_t desired_size = datadir_len + strlen ( \"/ffpresets\" ) + 1 ; char * new_datadir = av_realloc_array ( datadir , desired_size , sizeof * datadir ) ; if ( new_datadir ) { datadir = new_datadir ; datadir [ datadir_len ] = 0 ; strncat ( datadir , \"/ffpresets\" , desired_size - 1 - datadir_len ) ; base [ 2 ] = datadir ; } } } # endif for ( i = 0 ; i < 3 && ! f ; i ++ ) { if ( ! base [ i ] ) continue ; snprintf ( filename , filename_size , \"%s%s/%s.ffpreset\" , base [ i ] , i != 1 ? \"\" : \"/.ffmpeg\" , preset_name ) ; f = fopen_utf8 ( filename , \"r\" ) ; if ( ! f && codec_name ) { snprintf ( filename , filename_size , \"%s%s/%s-%s.ffpreset\" , base [ i ] , i != 1 ? \"\" : \"/.ffmpeg\" , codec_name , preset_name ) ; f = fopen_utf8 ( filename , \"r\" ) ; } } } # if HAVE_GETMODULEHANDLE && defined ( _WIN32 ) av_free ( datadir ) ; # endif freeenv_utf8 ( env_ffmpeg_datadir ) ; freeenv_utf8 ( env_home ) ; return f ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@check_stream_specifier": "int check_stream_specifier ( AVFormatContext * s , AVStream * st , const char * spec ) { int ret = avformat_match_stream_specifier ( s , st , spec ) ; if ( ret < 0 ) av_log ( s , AV_LOG_ERROR , \"Invalid stream specifier: %s.\\n\" , spec ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@filter_codec_opts": "AVDictionary * filter_codec_opts ( AVDictionary * opts , enum AVCodecID codec_id , AVFormatContext * s , AVStream * st , const AVCodec * codec ) { AVDictionary * ret = NULL ; const AVDictionaryEntry * t = NULL ; int flags = s -> oformat ? AV_OPT_FLAG_ENCODING_PARAM : AV_OPT_FLAG_DECODING_PARAM ; char prefix = 0 ; const AVClass * cc = avcodec_get_class ( ) ; if ( ! codec ) codec = s -> oformat ? avcodec_find_encoder ( codec_id ) : avcodec_find_decoder ( codec_id ) ; switch ( st -> codecpar -> codec_type ) { case AVMEDIA_TYPE_VIDEO : prefix = 'v' ; flags |= AV_OPT_FLAG_VIDEO_PARAM ; break ; case AVMEDIA_TYPE_AUDIO : prefix = 'a' ; flags |= AV_OPT_FLAG_AUDIO_PARAM ; break ; case AVMEDIA_TYPE_SUBTITLE : prefix = 's' ; flags |= AV_OPT_FLAG_SUBTITLE_PARAM ; break ; } while ( ( t = av_dict_iterate ( opts , t ) ) ) { const AVClass * priv_class ; char * p = strchr ( t -> key , ':' ) ; /* check stream specification in opt name */ if ( p ) switch ( check_stream_specifier ( s , st , p + 1 ) ) { case 1 : * p = 0 ; break ; case 0 : continue ; default : exit_program ( 1 ) ; } if ( av_opt_find ( & cc , t -> key , NULL , flags , AV_OPT_SEARCH_FAKE_OBJ ) || ! codec || ( ( priv_class = codec -> priv_class ) && av_opt_find ( & priv_class , t -> key , NULL , flags , AV_OPT_SEARCH_FAKE_OBJ ) ) ) av_dict_set ( & ret , t -> key , t -> value , 0 ) ; else if ( t -> key [ 0 ] == prefix && av_opt_find ( & cc , t -> key + 1 , NULL , flags , AV_OPT_SEARCH_FAKE_OBJ ) ) av_dict_set ( & ret , t -> key + 1 , t -> value , 0 ) ; if ( p ) * p = ':' ; } return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@setup_find_stream_info_opts": "AVDictionary * * setup_find_stream_info_opts ( AVFormatContext * s , AVDictionary * codec_opts ) { int i ; AVDictionary * * opts ; if ( ! s -> nb_streams ) return NULL ; opts = av_calloc ( s -> nb_streams , sizeof ( * opts ) ) ; if ( ! opts ) report_and_exit ( AVERROR ( ENOMEM ) ) ; for ( i = 0 ; i < s -> nb_streams ; i ++ ) opts [ i ] = filter_codec_opts ( codec_opts , s -> streams [ i ] -> codecpar -> codec_id , s , s -> streams [ i ] , NULL ) ; return opts ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@grow_array": "void * grow_array ( void * array , int elem_size , int * size , int new_size ) { if ( new_size >= INT_MAX / elem_size ) { av_log ( NULL , AV_LOG_ERROR , \"Array too big.\\n\" ) ; exit_program ( 1 ) ; } if ( * size < new_size ) { uint8_t * tmp = av_realloc_array ( array , new_size , elem_size ) ; if ( ! tmp ) report_and_exit ( AVERROR ( ENOMEM ) ) ; memset ( tmp + * size * elem_size , 0 , ( new_size - * size ) * elem_size ) ; * size = new_size ; return tmp ; } return array ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@allocate_array_elem": "void * allocate_array_elem ( void * ptr , size_t elem_size , int * nb_elems ) { void * new_elem ; if ( ! ( new_elem = av_mallocz ( elem_size ) ) || av_dynarray_add_nofree ( ptr , nb_elems , new_elem ) < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return new_elem ; }",
    "resources/ffmpeg-kit/apple/src/fftools_cmdutils.c@get_rotation": "double get_rotation ( int32_t * displaymatrix ) { double theta = 0 ; if ( displaymatrix ) theta = - round ( av_display_rotation_get ( ( int32_t * ) displaymatrix ) ) ; theta -= 360 * floor ( theta / 360 + 0.9 / 360 ) ; if ( fabs ( theta - 90 * round ( theta / 90 ) ) > 2 ) av_log ( NULL , AV_LOG_WARNING , \"Odd rotation angle.\\n\" \"If you want to help, upload a sample \" \"of this file to https://streams.videolan.org/upload/ \" \"and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)\" ) ; return theta ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@frame_move": "static void frame_move ( const SyncQueue * sq , SyncQueueFrame dst , SyncQueueFrame src ) { if ( sq -> type == SYNC_QUEUE_PACKETS ) av_packet_move_ref ( dst . p , src . p ) ; else av_frame_move_ref ( dst . f , src . f ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@frame_ts": "static int64_t frame_ts ( const SyncQueue * sq , SyncQueueFrame frame ) { return ( sq -> type == SYNC_QUEUE_PACKETS ) ? frame . p -> pts + frame . p -> duration : frame . f -> pts + frame . f -> duration ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@frame_null": "static int frame_null ( const SyncQueue * sq , SyncQueueFrame frame ) { return ( sq -> type == SYNC_QUEUE_PACKETS ) ? ( frame . p == NULL ) : ( frame . f == NULL ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@finish_stream": "static void finish_stream ( SyncQueue * sq , unsigned int stream_idx ) { SyncQueueStream * st = & sq -> streams [ stream_idx ] ; st -> finished = 1 ; if ( st -> limiting && st -> head_ts != AV_NOPTS_VALUE ) { /* check if this stream is the new finished head */ if ( sq -> head_finished_stream < 0 || av_compare_ts ( st -> head_ts , st -> tb , sq -> streams [ sq -> head_finished_stream ] . head_ts , sq -> streams [ sq -> head_finished_stream ] . tb ) < 0 ) { sq -> head_finished_stream = stream_idx ; } /* mark as finished all streams that should no longer receive new frames,\n         * due to them being ahead of some finished stream */ st = & sq -> streams [ sq -> head_finished_stream ] ; for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueStream * st1 = & sq -> streams [ i ] ; if ( st != st1 && st1 -> head_ts != AV_NOPTS_VALUE && av_compare_ts ( st -> head_ts , st -> tb , st1 -> head_ts , st1 -> tb ) <= 0 ) st1 -> finished = 1 ; } } /* mark the whole queue as finished if all streams are finished */ for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { if ( ! sq -> streams [ i ] . finished ) return ; } sq -> finished = 1 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@queue_head_update": "static void queue_head_update ( SyncQueue * sq ) { if ( sq -> head_stream < 0 ) { /* wait for one timestamp in each stream before determining\n         * the queue head */ for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueStream * st = & sq -> streams [ i ] ; if ( st -> limiting && st -> head_ts == AV_NOPTS_VALUE ) return ; } // placeholder value, correct one will be found below sq -> head_stream = 0 ; } for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueStream * st_head = & sq -> streams [ sq -> head_stream ] ; SyncQueueStream * st_other = & sq -> streams [ i ] ; if ( st_other -> limiting && st_other -> head_ts != AV_NOPTS_VALUE && av_compare_ts ( st_other -> head_ts , st_other -> tb , st_head -> head_ts , st_head -> tb ) < 0 ) sq -> head_stream = i ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@stream_update_ts": "static void stream_update_ts ( SyncQueue * sq , unsigned int stream_idx , int64_t ts ) { SyncQueueStream * st = & sq -> streams [ stream_idx ] ; if ( ts == AV_NOPTS_VALUE || ( st -> head_ts != AV_NOPTS_VALUE && st -> head_ts >= ts ) ) return ; st -> head_ts = ts ; /* if this stream is now ahead of some finished stream, then\n     * this stream is also finished */ if ( sq -> head_finished_stream >= 0 && av_compare_ts ( sq -> streams [ sq -> head_finished_stream ] . head_ts , sq -> streams [ sq -> head_finished_stream ] . tb , ts , st -> tb ) <= 0 ) finish_stream ( sq , stream_idx ) ; /* update the overall head timestamp if it could have changed */ if ( st -> limiting && ( sq -> head_stream < 0 || sq -> head_stream == stream_idx ) ) queue_head_update ( sq ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@overflow_heartbeat": "static int overflow_heartbeat ( SyncQueue * sq , int stream_idx ) { SyncQueueStream * st ; SyncQueueFrame frame ; int64_t tail_ts = AV_NOPTS_VALUE ; /* if no stream specified, pick the one that is most ahead */ if ( stream_idx < 0 ) { int64_t ts = AV_NOPTS_VALUE ; for ( int i = 0 ; i < sq -> nb_streams ; i ++ ) { st = & sq -> streams [ i ] ; if ( st -> head_ts != AV_NOPTS_VALUE && ( ts == AV_NOPTS_VALUE || av_compare_ts ( ts , sq -> streams [ stream_idx ] . tb , st -> head_ts , st -> tb ) < 0 ) ) { ts = st -> head_ts ; stream_idx = i ; } } /* no stream has a timestamp yet -> nothing to do */ if ( stream_idx < 0 ) return 0 ; } st = & sq -> streams [ stream_idx ] ; /* get the chosen stream's tail timestamp */ for ( size_t i = 0 ; tail_ts == AV_NOPTS_VALUE && av_fifo_peek ( st -> fifo , & frame , 1 , i ) >= 0 ; i ++ ) tail_ts = frame_ts ( sq , frame ) ; /* overflow triggers when the tail is over specified duration behind the head */ if ( tail_ts == AV_NOPTS_VALUE || tail_ts >= st -> head_ts || av_rescale_q ( st -> head_ts - tail_ts , st -> tb , AV_TIME_BASE_Q ) < sq -> buf_size_us ) return 0 ; /* signal a fake timestamp for all streams that prevent tail_ts from being output */ tail_ts ++ ; for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueStream * st1 = & sq -> streams [ i ] ; int64_t ts ; if ( st == st1 || st1 -> finished || ( st1 -> head_ts != AV_NOPTS_VALUE && av_compare_ts ( tail_ts , st -> tb , st1 -> head_ts , st1 -> tb ) <= 0 ) ) continue ; ts = av_rescale_q ( tail_ts , st -> tb , st1 -> tb ) ; if ( st1 -> head_ts != AV_NOPTS_VALUE ) ts = FFMAX ( st1 -> head_ts + 1 , ts ) ; stream_update_ts ( sq , i , ts ) ; } return 1 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@sq_send": "int sq_send ( SyncQueue * sq , unsigned int stream_idx , SyncQueueFrame frame ) { SyncQueueStream * st ; SyncQueueFrame dst ; int64_t ts ; int ret ; av_assert0 ( stream_idx < sq -> nb_streams ) ; st = & sq -> streams [ stream_idx ] ; av_assert0 ( st -> tb . num > 0 && st -> tb . den > 0 ) ; if ( frame_null ( sq , frame ) ) { finish_stream ( sq , stream_idx ) ; return 0 ; } if ( st -> finished ) return AVERROR_EOF ; ret = objpool_get ( sq -> pool , ( void * * ) & dst ) ; if ( ret < 0 ) return ret ; frame_move ( sq , dst , frame ) ; ts = frame_ts ( sq , dst ) ; ret = av_fifo_write ( st -> fifo , & dst , 1 ) ; if ( ret < 0 ) { frame_move ( sq , frame , dst ) ; objpool_release ( sq -> pool , ( void * * ) & dst ) ; return ret ; } stream_update_ts ( sq , stream_idx , ts ) ; st -> frames_sent ++ ; if ( st -> frames_sent >= st -> frames_max ) finish_stream ( sq , stream_idx ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@receive_for_stream": "static int receive_for_stream ( SyncQueue * sq , unsigned int stream_idx , SyncQueueFrame frame ) { SyncQueueStream * st_head = sq -> head_stream >= 0 ? & sq -> streams [ sq -> head_stream ] : NULL ; SyncQueueStream * st ; av_assert0 ( stream_idx < sq -> nb_streams ) ; st = & sq -> streams [ stream_idx ] ; if ( av_fifo_can_read ( st -> fifo ) ) { SyncQueueFrame peek ; int64_t ts ; int cmp = 1 ; av_fifo_peek ( st -> fifo , & peek , 1 , 0 ) ; ts = frame_ts ( sq , peek ) ; /* check if this stream's tail timestamp does not overtake\n         * the overall queue head */ if ( ts != AV_NOPTS_VALUE && st_head ) cmp = av_compare_ts ( ts , st -> tb , st_head -> head_ts , st_head -> tb ) ; /* We can release frames that do not end after the queue head.\n         * Frames with no timestamps are just passed through with no conditions.\n         */ if ( cmp <= 0 || ts == AV_NOPTS_VALUE ) { frame_move ( sq , frame , peek ) ; objpool_release ( sq -> pool , ( void * * ) & peek ) ; av_fifo_drain2 ( st -> fifo , 1 ) ; return 0 ; } } return ( sq -> finished || ( st -> finished && ! av_fifo_can_read ( st -> fifo ) ) ) ? AVERROR_EOF : AVERROR ( EAGAIN ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@receive_internal": "static int receive_internal ( SyncQueue * sq , int stream_idx , SyncQueueFrame frame ) { int nb_eof = 0 ; int ret ; /* read a frame for a specific stream */ if ( stream_idx >= 0 ) { ret = receive_for_stream ( sq , stream_idx , frame ) ; return ( ret < 0 ) ? ret : stream_idx ; } /* read a frame for any stream with available output */ for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { ret = receive_for_stream ( sq , i , frame ) ; if ( ret == AVERROR_EOF || ret == AVERROR ( EAGAIN ) ) { nb_eof += ( ret == AVERROR_EOF ) ; continue ; } return ( ret < 0 ) ? ret : i ; } return ( nb_eof == sq -> nb_streams ) ? AVERROR_EOF : AVERROR ( EAGAIN ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@sq_receive": "int sq_receive ( SyncQueue * sq , int stream_idx , SyncQueueFrame frame ) { int ret = receive_internal ( sq , stream_idx , frame ) ; /* try again if the queue overflowed and triggered a fake heartbeat\n     * for lagging streams */ if ( ret == AVERROR ( EAGAIN ) && overflow_heartbeat ( sq , stream_idx ) ) ret = receive_internal ( sq , stream_idx , frame ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@sq_add_stream": "int sq_add_stream ( SyncQueue * sq , int limiting ) { SyncQueueStream * tmp , * st ; tmp = av_realloc_array ( sq -> streams , sq -> nb_streams + 1 , sizeof ( * sq -> streams ) ) ; if ( ! tmp ) return AVERROR ( ENOMEM ) ; sq -> streams = tmp ; st = & sq -> streams [ sq -> nb_streams ] ; memset ( st , 0 , sizeof ( * st ) ) ; st -> fifo = av_fifo_alloc2 ( 1 , sizeof ( SyncQueueFrame ) , AV_FIFO_FLAG_AUTO_GROW ) ; if ( ! st -> fifo ) return AVERROR ( ENOMEM ) ; /* we set a valid default, so that a pathological stream that never\n     * receives even a real timebase (and no frames) won't stall all other\n     * streams forever; cf. overflow_heartbeat() */ st -> tb = ( AVRational ) { 1 , 1 } ; st -> head_ts = AV_NOPTS_VALUE ; st -> frames_max = UINT64_MAX ; st -> limiting = limiting ; return sq -> nb_streams ++ ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@sq_set_tb": "void sq_set_tb ( SyncQueue * sq , unsigned int stream_idx , AVRational tb ) { SyncQueueStream * st ; av_assert0 ( stream_idx < sq -> nb_streams ) ; st = & sq -> streams [ stream_idx ] ; av_assert0 ( ! av_fifo_can_read ( st -> fifo ) ) ; if ( st -> head_ts != AV_NOPTS_VALUE ) st -> head_ts = av_rescale_q ( st -> head_ts , st -> tb , tb ) ; st -> tb = tb ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@sq_limit_frames": "void sq_limit_frames ( SyncQueue * sq , unsigned int stream_idx , uint64_t frames ) { SyncQueueStream * st ; av_assert0 ( stream_idx < sq -> nb_streams ) ; st = & sq -> streams [ stream_idx ] ; st -> frames_max = frames ; if ( st -> frames_sent >= st -> frames_max ) finish_stream ( sq , stream_idx ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@sq_alloc": "SyncQueue * sq_alloc ( enum SyncQueueType type , int64_t buf_size_us ) { SyncQueue * sq = av_mallocz ( sizeof ( * sq ) ) ; if ( ! sq ) return NULL ; sq -> type = type ; sq -> buf_size_us = buf_size_us ; sq -> head_stream = - 1 ; sq -> head_finished_stream = - 1 ; sq -> pool = ( type == SYNC_QUEUE_PACKETS ) ? objpool_alloc_packets ( ) : objpool_alloc_frames ( ) ; if ( ! sq -> pool ) { av_freep ( & sq ) ; return NULL ; } return sq ; }",
    "resources/ffmpeg-kit/apple/src/fftools_sync_queue.c@sq_free": "void sq_free ( SyncQueue * * psq ) { SyncQueue * sq = * psq ; if ( ! sq ) return ; for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueFrame frame ; while ( av_fifo_read ( sq -> streams [ i ] . fifo , & frame , 1 ) >= 0 ) objpool_release ( sq -> pool , ( void * * ) & frame ) ; av_fifo_freep2 ( & sq -> streams [ i ] . fifo ) ; } av_freep ( & sq -> streams ) ; objpool_free ( & sq -> pool ) ; av_freep ( psq ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@demuxer_from_ifile": "static Demuxer * demuxer_from_ifile ( InputFile * f ) { return ( Demuxer * ) f ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@report_new_stream": "static void report_new_stream ( Demuxer * d , const AVPacket * pkt ) { AVStream * st = d -> f . ctx -> streams [ pkt -> stream_index ] ; if ( pkt -> stream_index < d -> nb_streams_warn ) return ; av_log ( NULL , AV_LOG_WARNING , \"New %s stream %d:%d at pos:%\" PRId64 \" and DTS:%ss\\n\" , av_get_media_type_string ( st -> codecpar -> codec_type ) , d -> f . index , pkt -> stream_index , pkt -> pos , av_ts2timestr ( pkt -> dts , & st -> time_base ) ) ; d -> nb_streams_warn = pkt -> stream_index + 1 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@ifile_duration_update": "static void ifile_duration_update ( Demuxer * d , InputStream * ist , int64_t last_duration ) { /* the total duration of the stream, max_pts - min_pts is\n     * the duration of the stream without the last frame */ if ( ist -> max_pts > ist -> min_pts && ist -> max_pts - ( uint64_t ) ist -> min_pts < INT64_MAX - last_duration ) last_duration += ist -> max_pts - ist -> min_pts ; if ( ! d -> duration || av_compare_ts ( d -> duration , d -> time_base , last_duration , ist -> st -> time_base ) < 0 ) { d -> duration = last_duration ; d -> time_base = ist -> st -> time_base ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@seek_to_start": "static int seek_to_start ( Demuxer * d ) { InputFile * ifile = & d -> f ; AVFormatContext * is = ifile -> ctx ; InputStream * ist ; int ret ; ret = avformat_seek_file ( is , - 1 , INT64_MIN , is -> start_time , is -> start_time , 0 ) ; if ( ret < 0 ) return ret ; if ( ifile -> audio_duration_queue_size ) { /* duration is the length of the last frame in a stream\n         * when audio stream is present we don't care about\n         * last video frame length because it's not defined exactly */ int got_durations = 0 ; while ( got_durations < ifile -> audio_duration_queue_size ) { LastFrameDuration dur ; ret = av_thread_message_queue_recv ( ifile -> audio_duration_queue , & dur , 0 ) ; if ( ret < 0 ) return ret ; got_durations ++ ; ist = ifile -> streams [ dur . stream_idx ] ; ifile_duration_update ( d , ist , dur . duration ) ; } } else { for ( int i = 0 ; i < ifile -> nb_streams ; i ++ ) { int64_t duration = 0 ; ist = ifile -> streams [ i ] ; if ( ist -> framerate . num ) { duration = av_rescale_q ( 1 , av_inv_q ( ist -> framerate ) , ist -> st -> time_base ) ; } else if ( ist -> st -> avg_frame_rate . num ) { duration = av_rescale_q ( 1 , av_inv_q ( ist -> st -> avg_frame_rate ) , ist -> st -> time_base ) ; } else { duration = 1 ; } ifile_duration_update ( d , ist , duration ) ; } } if ( d -> loop > 0 ) d -> loop -- ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@ts_fixup": "static void ts_fixup ( Demuxer * d , AVPacket * pkt , int * repeat_pict ) { InputFile * ifile = & d -> f ; InputStream * ist = ifile -> streams [ pkt -> stream_index ] ; const int64_t start_time = ifile -> start_time_effective ; int64_t duration ; if ( debug_ts ) { av_log ( NULL , AV_LOG_INFO , \"demuxer -> ist_index:%d:%d type:%s \" \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s\\n\" , ifile -> index , pkt -> stream_index , av_get_media_type_string ( ist -> st -> codecpar -> codec_type ) , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & ist -> st -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & ist -> st -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & ist -> st -> time_base ) ) ; } if ( ! ist -> wrap_correction_done && start_time != AV_NOPTS_VALUE && ist -> st -> pts_wrap_bits < 64 ) { int64_t stime , stime2 ; stime = av_rescale_q ( start_time , AV_TIME_BASE_Q , ist -> st -> time_base ) ; stime2 = stime + ( 1ULL << ist -> st -> pts_wrap_bits ) ; ist -> wrap_correction_done = 1 ; if ( stime2 > stime && pkt -> dts != AV_NOPTS_VALUE && pkt -> dts > stime + ( 1LL << ( ist -> st -> pts_wrap_bits - 1 ) ) ) { pkt -> dts -= 1ULL << ist -> st -> pts_wrap_bits ; ist -> wrap_correction_done = 0 ; } if ( stime2 > stime && pkt -> pts != AV_NOPTS_VALUE && pkt -> pts > stime + ( 1LL << ( ist -> st -> pts_wrap_bits - 1 ) ) ) { pkt -> pts -= 1ULL << ist -> st -> pts_wrap_bits ; ist -> wrap_correction_done = 0 ; } } if ( pkt -> dts != AV_NOPTS_VALUE ) pkt -> dts += av_rescale_q ( ifile -> ts_offset , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts += av_rescale_q ( ifile -> ts_offset , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts *= ist -> ts_scale ; if ( pkt -> dts != AV_NOPTS_VALUE ) pkt -> dts *= ist -> ts_scale ; duration = av_rescale_q ( d -> duration , d -> time_base , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) { pkt -> pts += duration ; ist -> max_pts = FFMAX ( pkt -> pts , ist -> max_pts ) ; ist -> min_pts = FFMIN ( pkt -> pts , ist -> min_pts ) ; } if ( pkt -> dts != AV_NOPTS_VALUE ) pkt -> dts += duration ; * repeat_pict = - 1 ; if ( ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && av_stream_get_parser ( ist -> st ) ) * repeat_pict = av_stream_get_parser ( ist -> st ) -> repeat_pict ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@thread_set_name": "static void thread_set_name ( InputFile * f ) { char name [ 16 ] ; snprintf ( name , sizeof ( name ) , \"dmx%d:%s\" , f -> index , f -> ctx -> iformat -> name ) ; ff_thread_setname ( name ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@input_thread": "static void * input_thread ( void * arg ) { Demuxer * d = arg ; InputFile * f = & d -> f ; AVPacket * pkt ; unsigned flags = d -> non_blocking ? AV_THREAD_MESSAGE_NONBLOCK : 0 ; int ret = 0 ; pkt = av_packet_alloc ( ) ; if ( ! pkt ) { ret = AVERROR ( ENOMEM ) ; goto finish ; } thread_set_name ( f ) ; while ( 1 ) { DemuxMsg msg = { NULL } ; ret = av_read_frame ( f -> ctx , pkt ) ; if ( ret == AVERROR ( EAGAIN ) ) { av_usleep ( 10000 ) ; continue ; } if ( ret < 0 ) { if ( d -> loop ) { /* signal looping to the consumer thread */ msg . looping = 1 ; ret = av_thread_message_queue_send ( d -> in_thread_queue , & msg , 0 ) ; if ( ret >= 0 ) ret = seek_to_start ( d ) ; if ( ret >= 0 ) continue ; /* fallthrough to the error path */ } if ( ret == AVERROR_EOF ) av_log ( NULL , AV_LOG_VERBOSE , \"EOF in input file %d\\n\" , f -> index ) ; else av_log ( NULL , AV_LOG_ERROR , \"Error demuxing input file %d: %s\\n\" , f -> index , av_err2str ( ret ) ) ; break ; } if ( do_pkt_dump ) { av_pkt_dump_log2 ( NULL , AV_LOG_INFO , pkt , do_hex_dump , f -> ctx -> streams [ pkt -> stream_index ] ) ; } /* the following test is needed in case new streams appear\n           dynamically in stream : we ignore them */ if ( pkt -> stream_index >= f -> nb_streams ) { report_new_stream ( d , pkt ) ; av_packet_unref ( pkt ) ; continue ; } if ( pkt -> flags & AV_PKT_FLAG_CORRUPT ) { av_log ( NULL , exit_on_error ? AV_LOG_FATAL : AV_LOG_WARNING , \"%s: corrupt input packet in stream %d\\n\" , f -> ctx -> url , pkt -> stream_index ) ; if ( exit_on_error ) { av_packet_unref ( pkt ) ; ret = AVERROR_INVALIDDATA ; break ; } } ts_fixup ( d , pkt , & msg . repeat_pict ) ; msg . pkt = av_packet_alloc ( ) ; if ( ! msg . pkt ) { av_packet_unref ( pkt ) ; ret = AVERROR ( ENOMEM ) ; break ; } av_packet_move_ref ( msg . pkt , pkt ) ; ret = av_thread_message_queue_send ( d -> in_thread_queue , & msg , flags ) ; if ( flags && ret == AVERROR ( EAGAIN ) ) { flags = 0 ; ret = av_thread_message_queue_send ( d -> in_thread_queue , & msg , flags ) ; av_log ( f -> ctx , AV_LOG_WARNING , \"Thread message queue blocking; consider raising the \" \"thread_queue_size option (current value: %d)\\n\" , d -> thread_queue_size ) ; } if ( ret < 0 ) { if ( ret != AVERROR_EOF ) av_log ( f -> ctx , AV_LOG_ERROR , \"Unable to send packet to main thread: %s\\n\" , av_err2str ( ret ) ) ; av_packet_free ( & msg . pkt ) ; break ; } } finish : av_assert0 ( ret < 0 ) ; av_thread_message_queue_set_err_recv ( d -> in_thread_queue , ret ) ; av_packet_free ( & pkt ) ; av_log ( NULL , AV_LOG_VERBOSE , \"Terminating demuxer thread %d\\n\" , f -> index ) ; return NULL ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@thread_stop": "static void thread_stop ( Demuxer * d ) { InputFile * f = & d -> f ; DemuxMsg msg ; if ( ! d -> in_thread_queue ) return ; av_thread_message_queue_set_err_send ( d -> in_thread_queue , AVERROR_EOF ) ; while ( av_thread_message_queue_recv ( d -> in_thread_queue , & msg , 0 ) >= 0 ) av_packet_free ( & msg . pkt ) ; pthread_join ( d -> thread , NULL ) ; av_thread_message_queue_free ( & d -> in_thread_queue ) ; av_thread_message_queue_free ( & f -> audio_duration_queue ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@thread_start": "static int thread_start ( Demuxer * d ) { int ret ; InputFile * f = & d -> f ; if ( d -> thread_queue_size <= 0 ) d -> thread_queue_size = ( nb_input_files > 1 ? 8 : 1 ) ; if ( nb_input_files > 1 && ( f -> ctx -> pb ? ! f -> ctx -> pb -> seekable : strcmp ( f -> ctx -> iformat -> name , \"lavfi\" ) ) ) d -> non_blocking = 1 ; ret = av_thread_message_queue_alloc ( & d -> in_thread_queue , d -> thread_queue_size , sizeof ( DemuxMsg ) ) ; if ( ret < 0 ) return ret ; if ( d -> loop ) { int nb_audio_dec = 0 ; for ( int i = 0 ; i < f -> nb_streams ; i ++ ) { InputStream * ist = f -> streams [ i ] ; nb_audio_dec += ! ! ( ist -> decoding_needed && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) ; } if ( nb_audio_dec ) { ret = av_thread_message_queue_alloc ( & f -> audio_duration_queue , nb_audio_dec , sizeof ( LastFrameDuration ) ) ; if ( ret < 0 ) goto fail ; f -> audio_duration_queue_size = nb_audio_dec ; } } if ( ( ret = pthread_create ( & d -> thread , NULL , input_thread , d ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"pthread_create failed: %s. Try to increase `ulimit -v` or decrease `ulimit -s`.\\n\" , strerror ( ret ) ) ; ret = AVERROR ( ret ) ; goto fail ; } return 0 ; fail : av_thread_message_queue_free ( & d -> in_thread_queue ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@ifile_get_packet": "int ifile_get_packet ( InputFile * f , AVPacket * * pkt ) { Demuxer * d = demuxer_from_ifile ( f ) ; InputStream * ist ; DemuxMsg msg ; int ret ; if ( ! d -> in_thread_queue ) { ret = thread_start ( d ) ; if ( ret < 0 ) return ret ; } if ( f -> readrate || f -> rate_emu ) { int i ; int64_t file_start = copy_ts * ( ( f -> start_time_effective != AV_NOPTS_VALUE ? f -> start_time_effective * ! start_at_zero : 0 ) + ( f -> start_time != AV_NOPTS_VALUE ? f -> start_time : 0 ) ) ; float scale = f -> rate_emu ? 1.0 : f -> readrate ; for ( i = 0 ; i < f -> nb_streams ; i ++ ) { InputStream * ist = f -> streams [ i ] ; int64_t stream_ts_offset , pts , now ; if ( ! ist -> nb_packets || ( ist -> decoding_needed && ! ist -> got_output ) ) continue ; stream_ts_offset = FFMAX ( ist -> first_dts != AV_NOPTS_VALUE ? ist -> first_dts : 0 , file_start ) ; pts = av_rescale ( ist -> dts , 1000000 , AV_TIME_BASE ) ; now = ( av_gettime_relative ( ) - ist -> start ) * scale + stream_ts_offset ; if ( pts > now ) return AVERROR ( EAGAIN ) ; } } ret = av_thread_message_queue_recv ( d -> in_thread_queue , & msg , d -> non_blocking ? AV_THREAD_MESSAGE_NONBLOCK : 0 ) ; if ( ret < 0 ) return ret ; if ( msg . looping ) return 1 ; ist = f -> streams [ msg . pkt -> stream_index ] ; ist -> last_pkt_repeat_pict = msg . repeat_pict ; * pkt = msg . pkt ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@ist_free": "static void ist_free ( InputStream * * pist ) { InputStream * ist = * pist ; if ( ! ist ) return ; av_frame_free ( & ist -> decoded_frame ) ; av_packet_free ( & ist -> pkt ) ; av_dict_free ( & ist -> decoder_opts ) ; avsubtitle_free ( & ist -> prev_sub . subtitle ) ; av_frame_free ( & ist -> sub2video . frame ) ; av_freep ( & ist -> filters ) ; av_freep ( & ist -> hwaccel_device ) ; av_freep ( & ist -> dts_buffer ) ; avcodec_free_context ( & ist -> dec_ctx ) ; avcodec_parameters_free ( & ist -> par ) ; av_freep ( pist ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@ifile_close": "void ifile_close ( InputFile * * pf ) { InputFile * f = * pf ; Demuxer * d = demuxer_from_ifile ( f ) ; if ( ! f ) return ; thread_stop ( d ) ; for ( int i = 0 ; i < f -> nb_streams ; i ++ ) ist_free ( & f -> streams [ i ] ) ; av_freep ( & f -> streams ) ; avformat_close_input ( & f -> ctx ) ; av_freep ( pf ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@choose_decoder": "static const AVCodec * choose_decoder ( const OptionsContext * o , AVFormatContext * s , AVStream * st , enum HWAccelID hwaccel_id , enum AVHWDeviceType hwaccel_device_type ) { char * codec_name = NULL ; MATCH_PER_STREAM_OPT ( codec_names , str , codec_name , s , st ) ; if ( codec_name ) { const AVCodec * codec = find_codec_or_die ( NULL , codec_name , st -> codecpar -> codec_type , 0 ) ; st -> codecpar -> codec_id = codec -> id ; if ( recast_media && st -> codecpar -> codec_type != codec -> type ) st -> codecpar -> codec_type = codec -> type ; return codec ; } else { if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && hwaccel_id == HWACCEL_GENERIC && hwaccel_device_type != AV_HWDEVICE_TYPE_NONE ) { const AVCodec * c ; void * i = NULL ; while ( ( c = av_codec_iterate ( & i ) ) ) { const AVCodecHWConfig * config ; if ( c -> id != st -> codecpar -> codec_id || ! av_codec_is_decoder ( c ) ) continue ; for ( int j = 0 ; ( config = avcodec_get_hw_config ( c , j ) ) ; j ++ ) { if ( config -> device_type == hwaccel_device_type ) { av_log ( NULL , AV_LOG_VERBOSE , \"Selecting decoder '%s' because of requested hwaccel method %s\\n\" , c -> name , av_hwdevice_get_type_name ( hwaccel_device_type ) ) ; return c ; } } } } return avcodec_find_decoder ( st -> codecpar -> codec_id ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@guess_input_channel_layout": "static int guess_input_channel_layout ( InputStream * ist ) { AVCodecContext * dec = ist -> dec_ctx ; if ( dec -> ch_layout . order == AV_CHANNEL_ORDER_UNSPEC ) { char layout_name [ 256 ] ; if ( dec -> ch_layout . nb_channels > ist -> guess_layout_max ) return 0 ; av_channel_layout_default ( & dec -> ch_layout , dec -> ch_layout . nb_channels ) ; if ( dec -> ch_layout . order == AV_CHANNEL_ORDER_UNSPEC ) return 0 ; av_channel_layout_describe ( & dec -> ch_layout , layout_name , sizeof ( layout_name ) ) ; av_log ( NULL , AV_LOG_WARNING , \"Guessed Channel Layout for Input Stream \" \"#%d.%d : %s\\n\" , ist -> file_index , ist -> st -> index , layout_name ) ; } return 1 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@add_display_matrix_to_stream": "static void add_display_matrix_to_stream ( const OptionsContext * o , AVFormatContext * ctx , AVStream * st ) { double rotation = DBL_MAX ; int hflip = - 1 , vflip = - 1 ; int hflip_set = 0 , vflip_set = 0 , rotation_set = 0 ; int32_t * buf ; MATCH_PER_STREAM_OPT ( display_rotations , dbl , rotation , ctx , st ) ; MATCH_PER_STREAM_OPT ( display_hflips , i , hflip , ctx , st ) ; MATCH_PER_STREAM_OPT ( display_vflips , i , vflip , ctx , st ) ; rotation_set = rotation != DBL_MAX ; hflip_set = hflip != - 1 ; vflip_set = vflip != - 1 ; if ( ! rotation_set && ! hflip_set && ! vflip_set ) return ; buf = ( int32_t * ) av_stream_new_side_data ( st , AV_PKT_DATA_DISPLAYMATRIX , sizeof ( int32_t ) * 9 ) ; if ( ! buf ) { av_log ( NULL , AV_LOG_FATAL , \"Failed to generate a display matrix!\\n\" ) ; exit_program ( 1 ) ; } av_display_rotation_set ( buf , rotation_set ? - ( rotation ) : - 0.0f ) ; av_display_matrix_flip ( buf , hflip_set ? hflip : 0 , vflip_set ? vflip : 0 ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@add_input_streams": "static void add_input_streams ( const OptionsContext * o , Demuxer * d ) { InputFile * f = & d -> f ; AVFormatContext * ic = f -> ctx ; int i , ret ; for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { AVStream * st = ic -> streams [ i ] ; AVCodecParameters * par = st -> codecpar ; InputStream * ist ; char * framerate = NULL , * hwaccel_device = NULL ; const char * hwaccel = NULL ; char * hwaccel_output_format = NULL ; char * codec_tag = NULL ; char * next ; char * discard_str = NULL ; const AVClass * cc = avcodec_get_class ( ) ; const AVOption * discard_opt = av_opt_find ( & cc , \"skip_frame\" , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ; ist = ALLOC_ARRAY_ELEM ( f -> streams , f -> nb_streams ) ; ist -> st = st ; ist -> file_index = f -> index ; ist -> discard = 1 ; st -> discard = AVDISCARD_ALL ; ist -> nb_samples = 0 ; ist -> first_dts = AV_NOPTS_VALUE ; ist -> min_pts = INT64_MAX ; ist -> max_pts = INT64_MIN ; ist -> ts_scale = 1.0 ; MATCH_PER_STREAM_OPT ( ts_scale , dbl , ist -> ts_scale , ic , st ) ; ist -> autorotate = 1 ; MATCH_PER_STREAM_OPT ( autorotate , i , ist -> autorotate , ic , st ) ; MATCH_PER_STREAM_OPT ( codec_tags , str , codec_tag , ic , st ) ; if ( codec_tag ) { uint32_t tag = strtol ( codec_tag , & next , 0 ) ; if ( * next ) tag = AV_RL32 ( codec_tag ) ; st -> codecpar -> codec_tag = tag ; } if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { add_display_matrix_to_stream ( o , ic , st ) ; MATCH_PER_STREAM_OPT ( hwaccels , str , hwaccel , ic , st ) ; MATCH_PER_STREAM_OPT ( hwaccel_output_formats , str , hwaccel_output_format , ic , st ) ; if ( ! hwaccel_output_format && hwaccel && ! strcmp ( hwaccel , \"cuvid\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"WARNING: defaulting hwaccel_output_format to cuda for compatibility \" \"with old commandlines. This behaviour is DEPRECATED and will be removed \" \"in the future. Please explicitly set \\\"-hwaccel_output_format cuda\\\".\\n\" ) ; ist -> hwaccel_output_format = AV_PIX_FMT_CUDA ; } else if ( ! hwaccel_output_format && hwaccel && ! strcmp ( hwaccel , \"qsv\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"WARNING: defaulting hwaccel_output_format to qsv for compatibility \" \"with old commandlines. This behaviour is DEPRECATED and will be removed \" \"in the future. Please explicitly set \\\"-hwaccel_output_format qsv\\\".\\n\" ) ; ist -> hwaccel_output_format = AV_PIX_FMT_QSV ; } else if ( ! hwaccel_output_format && hwaccel && ! strcmp ( hwaccel , \"mediacodec\" ) ) { // There is no real AVHWFrameContext implementation. Set // hwaccel_output_format to avoid av_hwframe_transfer_data error. ist -> hwaccel_output_format = AV_PIX_FMT_MEDIACODEC ; } else if ( hwaccel_output_format ) { ist -> hwaccel_output_format = av_get_pix_fmt ( hwaccel_output_format ) ; if ( ist -> hwaccel_output_format == AV_PIX_FMT_NONE ) { av_log ( NULL , AV_LOG_FATAL , \"Unrecognised hwaccel output \" \"format: %s\" , hwaccel_output_format ) ; } } else { ist -> hwaccel_output_format = AV_PIX_FMT_NONE ; } if ( hwaccel ) { // The NVDEC hwaccels use a CUDA device, so remap the name here. if ( ! strcmp ( hwaccel , \"nvdec\" ) || ! strcmp ( hwaccel , \"cuvid\" ) ) hwaccel = \"cuda\" ; if ( ! strcmp ( hwaccel , \"none\" ) ) ist -> hwaccel_id = HWACCEL_NONE ; else if ( ! strcmp ( hwaccel , \"auto\" ) ) ist -> hwaccel_id = HWACCEL_AUTO ; else { enum AVHWDeviceType type = av_hwdevice_find_type_by_name ( hwaccel ) ; if ( type != AV_HWDEVICE_TYPE_NONE ) { ist -> hwaccel_id = HWACCEL_GENERIC ; ist -> hwaccel_device_type = type ; } if ( ! ist -> hwaccel_id ) { av_log ( NULL , AV_LOG_FATAL , \"Unrecognized hwaccel: %s.\\n\" , hwaccel ) ; av_log ( NULL , AV_LOG_FATAL , \"Supported hwaccels: \" ) ; type = AV_HWDEVICE_TYPE_NONE ; while ( ( type = av_hwdevice_iterate_types ( type ) ) != AV_HWDEVICE_TYPE_NONE ) av_log ( NULL , AV_LOG_FATAL , \"%s \" , av_hwdevice_get_type_name ( type ) ) ; av_log ( NULL , AV_LOG_FATAL , \"\\n\" ) ; exit_program ( 1 ) ; } } } MATCH_PER_STREAM_OPT ( hwaccel_devices , str , hwaccel_device , ic , st ) ; if ( hwaccel_device ) { ist -> hwaccel_device = av_strdup ( hwaccel_device ) ; if ( ! ist -> hwaccel_device ) report_and_exit ( AVERROR ( ENOMEM ) ) ; } ist -> hwaccel_pix_fmt = AV_PIX_FMT_NONE ; } ist -> dec = choose_decoder ( o , ic , st , ist -> hwaccel_id , ist -> hwaccel_device_type ) ; ist -> decoder_opts = filter_codec_opts ( o -> g -> codec_opts , ist -> st -> codecpar -> codec_id , ic , st , ist -> dec ) ; ist -> reinit_filters = - 1 ; MATCH_PER_STREAM_OPT ( reinit_filters , i , ist -> reinit_filters , ic , st ) ; MATCH_PER_STREAM_OPT ( discard , str , discard_str , ic , st ) ; ist -> user_set_discard = AVDISCARD_NONE ; if ( ( o -> video_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) || ( o -> audio_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) || ( o -> subtitle_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_SUBTITLE ) || ( o -> data_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) ) ist -> user_set_discard = AVDISCARD_ALL ; if ( discard_str && av_opt_eval_int ( & cc , discard_opt , discard_str , & ist -> user_set_discard ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing discard %s.\\n\" , discard_str ) ; exit_program ( 1 ) ; } ist -> filter_in_rescale_delta_last = AV_NOPTS_VALUE ; ist -> prev_pkt_pts = AV_NOPTS_VALUE ; ist -> dec_ctx = avcodec_alloc_context3 ( ist -> dec ) ; if ( ! ist -> dec_ctx ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ret = avcodec_parameters_to_context ( ist -> dec_ctx , par ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error initializing the decoder context.\\n\" ) ; exit_program ( 1 ) ; } ist -> decoded_frame = av_frame_alloc ( ) ; if ( ! ist -> decoded_frame ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ist -> pkt = av_packet_alloc ( ) ; if ( ! ist -> pkt ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( o -> bitexact ) ist -> dec_ctx -> flags |= AV_CODEC_FLAG_BITEXACT ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : // avformat_find_stream_info() doesn't set this for us anymore. ist -> dec_ctx -> framerate = st -> avg_frame_rate ; MATCH_PER_STREAM_OPT ( frame_rates , str , framerate , ic , st ) ; if ( framerate && av_parse_video_rate ( & ist -> framerate , framerate ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing framerate %s.\\n\" , framerate ) ; exit_program ( 1 ) ; } ist -> top_field_first = - 1 ; MATCH_PER_STREAM_OPT ( top_field_first , i , ist -> top_field_first , ic , st ) ; ist -> framerate_guessed = av_guess_frame_rate ( ic , st , NULL ) ; break ; case AVMEDIA_TYPE_AUDIO : ist -> guess_layout_max = INT_MAX ; MATCH_PER_STREAM_OPT ( guess_layout_max , i , ist -> guess_layout_max , ic , st ) ; guess_input_channel_layout ( ist ) ; break ; case AVMEDIA_TYPE_DATA : case AVMEDIA_TYPE_SUBTITLE : { char * canvas_size = NULL ; MATCH_PER_STREAM_OPT ( fix_sub_duration , i , ist -> fix_sub_duration , ic , st ) ; MATCH_PER_STREAM_OPT ( canvas_sizes , str , canvas_size , ic , st ) ; if ( canvas_size && av_parse_video_size ( & ist -> dec_ctx -> width , & ist -> dec_ctx -> height , canvas_size ) < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid canvas size: %s.\\n\" , canvas_size ) ; exit_program ( 1 ) ; } break ; } case AVMEDIA_TYPE_ATTACHMENT : case AVMEDIA_TYPE_UNKNOWN : break ; default : abort ( ) ; } ist -> par = avcodec_parameters_alloc ( ) ; if ( ! ist -> par ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ret = avcodec_parameters_from_context ( ist -> par , ist -> dec_ctx ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error initializing the decoder context.\\n\" ) ; exit_program ( 1 ) ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@dump_attachment": "static void dump_attachment ( AVStream * st , const char * filename ) { int ret ; AVIOContext * out = NULL ; const AVDictionaryEntry * e ; if ( ! st -> codecpar -> extradata_size ) { av_log ( NULL , AV_LOG_WARNING , \"No extradata to dump in stream #%d:%d.\\n\" , nb_input_files - 1 , st -> index ) ; return ; } if ( ! * filename && ( e = av_dict_get ( st -> metadata , \"filename\" , NULL , 0 ) ) ) filename = e -> value ; if ( ! * filename ) { av_log ( NULL , AV_LOG_FATAL , \"No filename specified and no 'filename' tag\" \"in stream #%d:%d.\\n\" , nb_input_files - 1 , st -> index ) ; exit_program ( 1 ) ; } assert_file_overwrite ( filename ) ; if ( ( ret = avio_open2 ( & out , filename , AVIO_FLAG_WRITE , & int_cb , NULL ) ) < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Could not open file %s for writing.\\n\" , filename ) ; exit_program ( 1 ) ; } avio_write ( out , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ; avio_flush ( out ) ; avio_close ( out ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_demux.c@ifile_open": "int ifile_open ( const OptionsContext * o , const char * filename ) { Demuxer * d ; InputFile * f ; AVFormatContext * ic ; const AVInputFormat * file_iformat = NULL ; int err , i , ret ; int64_t timestamp ; AVDictionary * unused_opts = NULL ; const AVDictionaryEntry * e = NULL ; char * video_codec_name = NULL ; char * audio_codec_name = NULL ; char * subtitle_codec_name = NULL ; char * data_codec_name = NULL ; int scan_all_pmts_set = 0 ; int64_t start_time = o -> start_time ; int64_t start_time_eof = o -> start_time_eof ; int64_t stop_time = o -> stop_time ; int64_t recording_time = o -> recording_time ; if ( stop_time != INT64_MAX && recording_time != INT64_MAX ) { stop_time = INT64_MAX ; av_log ( NULL , AV_LOG_WARNING , \"-t and -to cannot be used together; using -t.\\n\" ) ; } if ( stop_time != INT64_MAX && recording_time == INT64_MAX ) { int64_t start = start_time == AV_NOPTS_VALUE ? 0 : start_time ; if ( stop_time <= start ) { av_log ( NULL , AV_LOG_ERROR , \"-to value smaller than -ss; aborting.\\n\" ) ; exit_program ( 1 ) ; } else { recording_time = stop_time - start ; } } if ( o -> format ) { if ( ! ( file_iformat = av_find_input_format ( o -> format ) ) ) { av_log ( NULL , AV_LOG_FATAL , \"Unknown input format: '%s'\\n\" , o -> format ) ; exit_program ( 1 ) ; } } if ( ! strcmp ( filename , \"-\" ) ) filename = \"fd:\" ; stdin_interaction &= strncmp ( filename , \"pipe:\" , 5 ) && strcmp ( filename , \"fd:\" ) && strcmp ( filename , \"/dev/stdin\" ) ; /* get default parameters from command line */ ic = avformat_alloc_context ( ) ; if ( ! ic ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( o -> nb_audio_sample_rate ) { av_dict_set_int ( & o -> g -> format_opts , \"sample_rate\" , o -> audio_sample_rate [ o -> nb_audio_sample_rate - 1 ] . u . i , 0 ) ; } if ( o -> nb_audio_channels ) { const AVClass * priv_class ; if ( file_iformat && ( priv_class = file_iformat -> priv_class ) && av_opt_find ( & priv_class , \"ch_layout\" , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ) { char buf [ 32 ] ; snprintf ( buf , sizeof ( buf ) , \"%dC\" , o -> audio_channels [ o -> nb_audio_channels - 1 ] . u . i ) ; av_dict_set ( & o -> g -> format_opts , \"ch_layout\" , buf , 0 ) ; } } if ( o -> nb_audio_ch_layouts ) { const AVClass * priv_class ; if ( file_iformat && ( priv_class = file_iformat -> priv_class ) && av_opt_find ( & priv_class , \"ch_layout\" , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ) { av_dict_set ( & o -> g -> format_opts , \"ch_layout\" , o -> audio_ch_layouts [ o -> nb_audio_ch_layouts - 1 ] . u . str , 0 ) ; } } if ( o -> nb_frame_rates ) { const AVClass * priv_class ; /* set the format-level framerate option;\n         * this is important for video grabbers, e.g. x11 */ if ( file_iformat && ( priv_class = file_iformat -> priv_class ) && av_opt_find ( & priv_class , \"framerate\" , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ) { av_dict_set ( & o -> g -> format_opts , \"framerate\" , o -> frame_rates [ o -> nb_frame_rates - 1 ] . u . str , 0 ) ; } } if ( o -> nb_frame_sizes ) { av_dict_set ( & o -> g -> format_opts , \"video_size\" , o -> frame_sizes [ o -> nb_frame_sizes - 1 ] . u . str , 0 ) ; } if ( o -> nb_frame_pix_fmts ) av_dict_set ( & o -> g -> format_opts , \"pixel_format\" , o -> frame_pix_fmts [ o -> nb_frame_pix_fmts - 1 ] . u . str , 0 ) ; MATCH_PER_TYPE_OPT ( codec_names , str , video_codec_name , ic , \"v\" ) ; MATCH_PER_TYPE_OPT ( codec_names , str , audio_codec_name , ic , \"a\" ) ; MATCH_PER_TYPE_OPT ( codec_names , str , subtitle_codec_name , ic , \"s\" ) ; MATCH_PER_TYPE_OPT ( codec_names , str , data_codec_name , ic , \"d\" ) ; if ( video_codec_name ) ic -> video_codec = find_codec_or_die ( NULL , video_codec_name , AVMEDIA_TYPE_VIDEO , 0 ) ; if ( audio_codec_name ) ic -> audio_codec = find_codec_or_die ( NULL , audio_codec_name , AVMEDIA_TYPE_AUDIO , 0 ) ; if ( subtitle_codec_name ) ic -> subtitle_codec = find_codec_or_die ( NULL , subtitle_codec_name , AVMEDIA_TYPE_SUBTITLE , 0 ) ; if ( data_codec_name ) ic -> data_codec = find_codec_or_die ( NULL , data_codec_name , AVMEDIA_TYPE_DATA , 0 ) ; ic -> video_codec_id = video_codec_name ? ic -> video_codec -> id : AV_CODEC_ID_NONE ; ic -> audio_codec_id = audio_codec_name ? ic -> audio_codec -> id : AV_CODEC_ID_NONE ; ic -> subtitle_codec_id = subtitle_codec_name ? ic -> subtitle_codec -> id : AV_CODEC_ID_NONE ; ic -> data_codec_id = data_codec_name ? ic -> data_codec -> id : AV_CODEC_ID_NONE ; ic -> flags |= AVFMT_FLAG_NONBLOCK ; if ( o -> bitexact ) ic -> flags |= AVFMT_FLAG_BITEXACT ; ic -> interrupt_callback = int_cb ; if ( ! av_dict_get ( o -> g -> format_opts , \"scan_all_pmts\" , NULL , AV_DICT_MATCH_CASE ) ) { av_dict_set ( & o -> g -> format_opts , \"scan_all_pmts\" , \"1\" , AV_DICT_DONT_OVERWRITE ) ; scan_all_pmts_set = 1 ; } /* open the input file with generic avformat function */ err = avformat_open_input ( & ic , filename , file_iformat , & o -> g -> format_opts ) ; if ( err < 0 ) { print_error ( filename , err ) ; if ( err == AVERROR_PROTOCOL_NOT_FOUND ) av_log ( NULL , AV_LOG_ERROR , \"Did you mean file:%s?\\n\" , filename ) ; exit_program ( 1 ) ; } if ( scan_all_pmts_set ) av_dict_set ( & o -> g -> format_opts , \"scan_all_pmts\" , NULL , AV_DICT_MATCH_CASE ) ; remove_avoptions ( & o -> g -> format_opts , o -> g -> codec_opts ) ; assert_avoptions ( o -> g -> format_opts ) ; /* apply forced codec ids */ for ( i = 0 ; i < ic -> nb_streams ; i ++ ) choose_decoder ( o , ic , ic -> streams [ i ] , HWACCEL_NONE , AV_HWDEVICE_TYPE_NONE ) ; if ( o -> find_stream_info ) { AVDictionary * * opts = setup_find_stream_info_opts ( ic , o -> g -> codec_opts ) ; int orig_nb_streams = ic -> nb_streams ; /* If not enough info to get the stream parameters, we decode the\n           first frames to get it. (used in mpeg case for example) */ ret = avformat_find_stream_info ( ic , opts ) ; for ( i = 0 ; i < orig_nb_streams ; i ++ ) av_dict_free ( & opts [ i ] ) ; av_freep ( & opts ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"%s: could not find codec parameters\\n\" , filename ) ; if ( ic -> nb_streams == 0 ) { avformat_close_input ( & ic ) ; exit_program ( 1 ) ; } } } if ( start_time != AV_NOPTS_VALUE && start_time_eof != AV_NOPTS_VALUE ) { av_log ( NULL , AV_LOG_WARNING , \"Cannot use -ss and -sseof both, using -ss for %s\\n\" , filename ) ; start_time_eof = AV_NOPTS_VALUE ; } if ( start_time_eof != AV_NOPTS_VALUE ) { if ( start_time_eof >= 0 ) { av_log ( NULL , AV_LOG_ERROR , \"-sseof value must be negative; aborting\\n\" ) ; exit_program ( 1 ) ; } if ( ic -> duration > 0 ) { start_time = start_time_eof + ic -> duration ; if ( start_time < 0 ) { av_log ( NULL , AV_LOG_WARNING , \"-sseof value seeks to before start of file %s; ignored\\n\" , filename ) ; start_time = AV_NOPTS_VALUE ; } } else av_log ( NULL , AV_LOG_WARNING , \"Cannot use -sseof, duration of %s not known\\n\" , filename ) ; } timestamp = ( start_time == AV_NOPTS_VALUE ) ? 0 : start_time ; /* add the stream start time */ if ( ! o -> seek_timestamp && ic -> start_time != AV_NOPTS_VALUE ) timestamp += ic -> start_time ; /* if seeking requested, we execute it */ if ( start_time != AV_NOPTS_VALUE ) { int64_t seek_timestamp = timestamp ; if ( ! ( ic -> iformat -> flags & AVFMT_SEEK_TO_PTS ) ) { int dts_heuristic = 0 ; for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { const AVCodecParameters * par = ic -> streams [ i ] -> codecpar ; if ( par -> video_delay ) { dts_heuristic = 1 ; break ; } } if ( dts_heuristic ) { seek_timestamp -= 3 * AV_TIME_BASE / 23 ; } } ret = avformat_seek_file ( ic , - 1 , INT64_MIN , seek_timestamp , seek_timestamp , 0 ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_WARNING , \"%s: could not seek to position %0.3f\\n\" , filename , ( double ) timestamp / AV_TIME_BASE ) ; } } d = allocate_array_elem ( & input_files , sizeof ( * d ) , & nb_input_files ) ; f = & d -> f ; f -> ctx = ic ; f -> index = nb_input_files - 1 ; f -> start_time = start_time ; f -> recording_time = recording_time ; f -> input_sync_ref = o -> input_sync_ref ; f -> input_ts_offset = o -> input_ts_offset ; f -> ts_offset = o -> input_ts_offset - ( copy_ts ? ( start_at_zero && ic -> start_time != AV_NOPTS_VALUE ? ic -> start_time : 0 ) : timestamp ) ; f -> rate_emu = o -> rate_emu ; f -> accurate_seek = o -> accurate_seek ; d -> loop = o -> loop ; d -> duration = 0 ; d -> time_base = ( AVRational ) { 1 , 1 } ; f -> readrate = o -> readrate ? o -> readrate : 0.0 ; if ( f -> readrate < 0.0f ) { av_log ( NULL , AV_LOG_ERROR , \"Option -readrate for Input #%d is %0.3f; it must be non-negative.\\n\" , f -> index , f -> readrate ) ; exit_program ( 1 ) ; } if ( f -> readrate && f -> rate_emu ) { av_log ( NULL , AV_LOG_WARNING , \"Both -readrate and -re set for Input #%d. Using -readrate %0.3f.\\n\" , f -> index , f -> readrate ) ; f -> rate_emu = 0 ; } d -> thread_queue_size = o -> thread_queue_size ; /* update the current parameters so that they match the one of the input stream */ add_input_streams ( o , d ) ; /* dump the file content */ av_dump_format ( ic , f -> index , filename , 0 ) ; /* check if all codec options have been used */ unused_opts = strip_specifiers ( o -> g -> codec_opts ) ; for ( i = 0 ; i < f -> nb_streams ; i ++ ) { e = NULL ; while ( ( e = av_dict_iterate ( f -> streams [ i ] -> decoder_opts , e ) ) ) av_dict_set ( & unused_opts , e -> key , NULL , 0 ) ; } e = NULL ; while ( ( e = av_dict_iterate ( unused_opts , e ) ) ) { const AVClass * class = avcodec_get_class ( ) ; const AVOption * option = av_opt_find ( & class , e -> key , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ; const AVClass * fclass = avformat_get_class ( ) ; const AVOption * foption = av_opt_find ( & fclass , e -> key , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ; if ( ! option || foption ) continue ; if ( ! ( option -> flags & AV_OPT_FLAG_DECODING_PARAM ) ) { av_log ( NULL , AV_LOG_ERROR , \"Codec AVOption %s (%s) specified for \" \"input file #%d (%s) is not a decoding option.\\n\" , e -> key , option -> help ? option -> help : \"\" , f -> index , filename ) ; exit_program ( 1 ) ; } av_log ( NULL , AV_LOG_WARNING , \"Codec AVOption %s (%s) specified for \" \"input file #%d (%s) has not been used for any stream. The most \" \"likely reason is either wrong type (e.g. a video option with \" \"no video streams) or that it is a private option of some decoder \" \"which was not actually used for any stream.\\n\" , e -> key , option -> help ? option -> help : \"\" , f -> index , filename ) ; } av_dict_free ( & unused_opts ) ; for ( i = 0 ; i < o -> nb_dump_attachment ; i ++ ) { int j ; for ( j = 0 ; j < ic -> nb_streams ; j ++ ) { AVStream * st = ic -> streams [ j ] ; if ( check_stream_specifier ( ic , st , o -> dump_attachment [ i ] . specifier ) == 1 ) dump_attachment ( st , o -> dump_attachment [ i ] . u . str ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_objpool.c@objpool_alloc": "ObjPool * objpool_alloc ( ObjPoolCBAlloc cb_alloc , ObjPoolCBReset cb_reset , ObjPoolCBFree cb_free ) { ObjPool * op = av_mallocz ( sizeof ( * op ) ) ; if ( ! op ) return NULL ; op -> alloc = cb_alloc ; op -> reset = cb_reset ; op -> free = cb_free ; return op ; }",
    "resources/ffmpeg-kit/apple/src/fftools_objpool.c@objpool_free": "void objpool_free ( ObjPool * * pop ) { ObjPool * op = * pop ; if ( ! op ) return ; for ( unsigned int i = 0 ; i < op -> pool_count ; i ++ ) op -> free ( & op -> pool [ i ] ) ; av_freep ( pop ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_objpool.c@objpool_get": "int objpool_get ( ObjPool * op , void * * obj ) { if ( op -> pool_count ) { * obj = op -> pool [ -- op -> pool_count ] ; op -> pool [ op -> pool_count ] = NULL ; } else * obj = op -> alloc ( ) ; return * obj ? 0 : AVERROR ( ENOMEM ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_objpool.c@objpool_release": "void objpool_release ( ObjPool * op , void * * obj ) { if ( ! * obj ) return ; op -> reset ( * obj ) ; if ( op -> pool_count < FF_ARRAY_ELEMS ( op -> pool ) ) op -> pool [ op -> pool_count ++ ] = * obj ; else op -> free ( obj ) ; * obj = NULL ; }",
    "resources/ffmpeg-kit/apple/src/fftools_objpool.c@alloc_packet": "static void * alloc_packet ( void ) { return av_packet_alloc ( ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_objpool.c@alloc_frame": "static void * alloc_frame ( void ) { return av_frame_alloc ( ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_objpool.c@reset_packet": "static void reset_packet ( void * obj ) { av_packet_unref ( obj ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_objpool.c@reset_frame": "static void reset_frame ( void * obj ) { av_frame_unref ( obj ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_objpool.c@free_packet": "static void free_packet ( void * * obj ) { AVPacket * pkt = * obj ; av_packet_free ( & pkt ) ; * obj = NULL ; }",
    "resources/ffmpeg-kit/apple/src/fftools_objpool.c@free_frame": "static void free_frame ( void * * obj ) { AVFrame * frame = * obj ; av_frame_free ( & frame ) ; * obj = NULL ; }",
    "resources/ffmpeg-kit/apple/src/fftools_objpool.c@objpool_alloc_packets": "ObjPool * objpool_alloc_packets ( void ) { return objpool_alloc ( alloc_packet , reset_packet , free_packet ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_objpool.c@objpool_alloc_frames": "ObjPool * objpool_alloc_frames ( void ) { return objpool_alloc ( alloc_frame , reset_frame , free_frame ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@log_callback": "static void log_callback ( void * ptr , int level , const char * fmt , va_list vl ) { AVClass * avc = ptr ? * ( AVClass * * ) ptr : NULL ; va_list vl2 ; char line [ 1024 ] ; static int print_prefix = 1 ; void * new_log_buffer ; va_copy ( vl2 , vl ) ; av_log_default_callback ( ptr , level , fmt , vl ) ; av_log_format_line ( ptr , level , fmt , vl2 , line , sizeof ( line ) , & print_prefix ) ; va_end ( vl2 ) ; # if HAVE_THREADS pthread_mutex_lock ( & log_mutex ) ; new_log_buffer = av_realloc_array ( log_buffer , log_buffer_size + 1 , sizeof ( * log_buffer ) ) ; if ( new_log_buffer ) { char * msg ; int i ; log_buffer = new_log_buffer ; memset ( & log_buffer [ log_buffer_size ] , 0 , sizeof ( log_buffer [ log_buffer_size ] ) ) ; log_buffer [ log_buffer_size ] . context_name = avc ? av_strdup ( avc -> item_name ( ptr ) ) : NULL ; if ( avc ) { if ( avc -> get_category ) log_buffer [ log_buffer_size ] . category = avc -> get_category ( ptr ) ; else log_buffer [ log_buffer_size ] . category = avc -> category ; } log_buffer [ log_buffer_size ] . log_level = level ; msg = log_buffer [ log_buffer_size ] . log_message = av_strdup ( line ) ; for ( i = strlen ( msg ) - 1 ; i >= 0 && msg [ i ] == '\\n' ; i -- ) { msg [ i ] = 0 ; } if ( avc && avc -> parent_log_context_offset ) { AVClass * * parent = * ( AVClass * * * ) ( ( ( uint8_t * ) ptr ) + avc -> parent_log_context_offset ) ; if ( parent && * parent ) { log_buffer [ log_buffer_size ] . parent_name = av_strdup ( ( * parent ) -> item_name ( parent ) ) ; log_buffer [ log_buffer_size ] . parent_category = ( * parent ) -> get_category ? ( * parent ) -> get_category ( parent ) : ( * parent ) -> category ; } } log_buffer_size ++ ; } pthread_mutex_unlock ( & log_mutex ) ; # endif }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@ffprobe_cleanup": "static void ffprobe_cleanup ( int ret ) { int i ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( sections ) ; i ++ ) av_dict_free ( & ( sections [ i ] . entries_to_show ) ) ; # if HAVE_THREADS pthread_mutex_destroy ( & log_mutex ) ; # endif }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@value_string": "static char * value_string ( char * buf , int buf_size , struct unit_value uv ) { double vald ; long long int vali ; int show_float = 0 ; if ( uv . unit == unit_second_str ) { vald = uv . val . d ; show_float = 1 ; } else { vald = vali = uv . val . i ; } if ( uv . unit == unit_second_str && use_value_sexagesimal_format ) { double secs ; int hours , mins ; secs = vald ; mins = ( int ) secs / 60 ; secs = secs - mins * 60 ; hours = mins / 60 ; mins %= 60 ; snprintf ( buf , buf_size , \"%d:%02d:%09.6f\" , hours , mins , secs ) ; } else { const char * prefix_string = \"\" ; if ( use_value_prefix && vald > 1 ) { long long int index ; if ( uv . unit == unit_byte_str && use_byte_value_binary_prefix ) { index = ( long long int ) ( log2 ( vald ) ) / 10 ; index = av_clip ( index , 0 , FF_ARRAY_ELEMS ( si_prefixes ) - 1 ) ; vald /= si_prefixes [ index ] . bin_val ; prefix_string = si_prefixes [ index ] . bin_str ; } else { index = ( long long int ) ( log10 ( vald ) ) / 3 ; index = av_clip ( index , 0 , FF_ARRAY_ELEMS ( si_prefixes ) - 1 ) ; vald /= si_prefixes [ index ] . dec_val ; prefix_string = si_prefixes [ index ] . dec_str ; } vali = vald ; } if ( show_float || ( use_value_prefix && vald != ( long long int ) vald ) ) snprintf ( buf , buf_size , \"%f\" , vald ) ; else snprintf ( buf , buf_size , \"%lld\" , vali ) ; av_strlcatf ( buf , buf_size , \"%s%s%s\" , * prefix_string || show_value_unit ? \" \" : \"\" , prefix_string , show_value_unit ? uv . unit : \"\" ) ; } return buf ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_get_name": "static const char * writer_get_name ( void * p ) { WriterContext * wctx = p ; return wctx -> writer -> name ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_child_next": "static void * writer_child_next ( void * obj , void * prev ) { WriterContext * ctx = obj ; if ( ! prev && ctx -> writer && ctx -> writer -> priv_class && ctx -> priv ) return ctx -> priv ; return NULL ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_close": "static int writer_close ( WriterContext * * wctx ) { int i ; int ret = 0 ; if ( ! * wctx ) return - 1 ; if ( ( * wctx ) -> writer -> uninit ) ( * wctx ) -> writer -> uninit ( * wctx ) ; for ( i = 0 ; i < SECTION_MAX_NB_LEVELS ; i ++ ) av_bprint_finalize ( & ( * wctx ) -> section_pbuf [ i ] , NULL ) ; if ( ( * wctx ) -> writer -> priv_class ) av_opt_free ( ( * wctx ) -> priv ) ; av_freep ( & ( ( * wctx ) -> priv ) ) ; av_opt_free ( * wctx ) ; if ( ( * wctx ) -> avio ) { avio_flush ( ( * wctx ) -> avio ) ; ret = avio_close ( ( * wctx ) -> avio ) ; } av_freep ( wctx ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@bprint_bytes": "static void bprint_bytes ( AVBPrint * bp , const uint8_t * ubuf , size_t ubuf_size ) { int i ; av_bprintf ( bp , \"0X\" ) ; for ( i = 0 ; i < ubuf_size ; i ++ ) av_bprintf ( bp , \"%02X\" , ubuf [ i ] ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_w8_avio": "static inline void writer_w8_avio ( WriterContext * wctx , int b ) { avio_w8 ( wctx -> avio , b ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_put_str_avio": "static inline void writer_put_str_avio ( WriterContext * wctx , const char * str ) { avio_write ( wctx -> avio , str , strlen ( str ) ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_printf_avio": "static inline void writer_printf_avio ( WriterContext * wctx , const char * fmt , ... ) { va_list ap ; va_start ( ap , fmt ) ; avio_vprintf ( wctx -> avio , fmt , ap ) ; va_end ( ap ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_w8_printf": "static inline void writer_w8_printf ( WriterContext * wctx , int b ) { av_log ( NULL , AV_LOG_STDERR , \"%c\" , b ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_put_str_printf": "static inline void writer_put_str_printf ( WriterContext * wctx , const char * str ) { av_log ( NULL , AV_LOG_STDERR , \"%s\" , str ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_printf_printf": "static inline void writer_printf_printf ( WriterContext * wctx , const char * fmt , ... ) { va_list ap ; va_start ( ap , fmt ) ; av_vlog ( NULL , AV_LOG_STDERR , fmt , ap ) ; va_end ( ap ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_open": "static int writer_open ( WriterContext * * wctx , const Writer * writer , const char * args , const struct section * sections , int nb_sections , const char * output ) { int i , ret = 0 ; if ( ! ( * wctx = av_mallocz ( sizeof ( WriterContext ) ) ) ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } if ( ! ( ( * wctx ) -> priv = av_mallocz ( writer -> priv_size ) ) ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } ( * wctx ) -> class = & writer_class ; ( * wctx ) -> writer = writer ; ( * wctx ) -> level = - 1 ; ( * wctx ) -> sections = sections ; ( * wctx ) -> nb_sections = nb_sections ; av_opt_set_defaults ( * wctx ) ; if ( writer -> priv_class ) { void * priv_ctx = ( * wctx ) -> priv ; * ( ( const AVClass * * ) priv_ctx ) = writer -> priv_class ; av_opt_set_defaults ( priv_ctx ) ; } /* convert options to dictionary */ if ( args ) { AVDictionary * opts = NULL ; const AVDictionaryEntry * opt = NULL ; if ( ( ret = av_dict_parse_string ( & opts , args , \"=\" , \":\" , 0 ) ) < 0 ) { av_log ( * wctx , AV_LOG_ERROR , \"Failed to parse option string '%s' provided to writer context\\n\" , args ) ; av_dict_free ( & opts ) ; goto fail ; } while ( ( opt = av_dict_iterate ( opts , opt ) ) ) { if ( ( ret = av_opt_set ( * wctx , opt -> key , opt -> value , AV_OPT_SEARCH_CHILDREN ) ) < 0 ) { av_log ( * wctx , AV_LOG_ERROR , \"Failed to set option '%s' with value '%s' provided to writer context\\n\" , opt -> key , opt -> value ) ; av_dict_free ( & opts ) ; goto fail ; } } av_dict_free ( & opts ) ; } /* validate replace string */ { const uint8_t * p = ( * wctx ) -> string_validation_replacement ; const uint8_t * endp = p + strlen ( p ) ; while ( * p ) { const uint8_t * p0 = p ; int32_t code ; ret = av_utf8_decode ( & code , & p , endp , ( * wctx ) -> string_validation_utf8_flags ) ; if ( ret < 0 ) { AVBPrint bp ; av_bprint_init ( & bp , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; bprint_bytes ( & bp , p0 , p - p0 ) , av_log ( wctx , AV_LOG_ERROR , \"Invalid UTF8 sequence %s found in string validation replace '%s'\\n\" , bp . str , ( * wctx ) -> string_validation_replacement ) ; return ret ; } } } if ( ! output_filename ) { ( * wctx ) -> writer_w8 = writer_w8_printf ; ( * wctx ) -> writer_put_str = writer_put_str_printf ; ( * wctx ) -> writer_printf = writer_printf_printf ; } else { if ( ( ret = avio_open ( & ( * wctx ) -> avio , output , AVIO_FLAG_WRITE ) ) < 0 ) { av_log ( * wctx , AV_LOG_ERROR , \"Failed to open output '%s' with error: %s\\n\" , output , av_err2str ( ret ) ) ; goto fail ; } ( * wctx ) -> writer_w8 = writer_w8_avio ; ( * wctx ) -> writer_put_str = writer_put_str_avio ; ( * wctx ) -> writer_printf = writer_printf_avio ; } for ( i = 0 ; i < SECTION_MAX_NB_LEVELS ; i ++ ) av_bprint_init ( & ( * wctx ) -> section_pbuf [ i ] , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; if ( ( * wctx ) -> writer -> init ) ret = ( * wctx ) -> writer -> init ( * wctx ) ; if ( ret < 0 ) goto fail ; return 0 ; fail : writer_close ( wctx ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_print_section_header": "static inline void writer_print_section_header ( WriterContext * wctx , int section_id ) { int parent_section_id ; wctx -> level ++ ; av_assert0 ( wctx -> level < SECTION_MAX_NB_LEVELS ) ; parent_section_id = wctx -> level ? ( wctx -> section [ wctx -> level - 1 ] ) -> id : SECTION_ID_NONE ; wctx -> nb_item [ wctx -> level ] = 0 ; wctx -> section [ wctx -> level ] = & wctx -> sections [ section_id ] ; if ( section_id == SECTION_ID_PACKETS_AND_FRAMES ) { wctx -> nb_section_packet = wctx -> nb_section_frame = wctx -> nb_section_packet_frame = 0 ; } else if ( parent_section_id == SECTION_ID_PACKETS_AND_FRAMES ) { wctx -> nb_section_packet_frame = section_id == SECTION_ID_PACKET ? wctx -> nb_section_packet : wctx -> nb_section_frame ; } if ( wctx -> writer -> print_section_header ) wctx -> writer -> print_section_header ( wctx ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_print_section_footer": "static inline void writer_print_section_footer ( WriterContext * wctx ) { int section_id = wctx -> section [ wctx -> level ] -> id ; int parent_section_id = wctx -> level ? wctx -> section [ wctx -> level - 1 ] -> id : SECTION_ID_NONE ; if ( parent_section_id != SECTION_ID_NONE ) wctx -> nb_item [ wctx -> level - 1 ] ++ ; if ( parent_section_id == SECTION_ID_PACKETS_AND_FRAMES ) { if ( section_id == SECTION_ID_PACKET ) wctx -> nb_section_packet ++ ; else wctx -> nb_section_frame ++ ; } if ( wctx -> writer -> print_section_footer ) wctx -> writer -> print_section_footer ( wctx ) ; wctx -> level -- ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_print_integer": "static inline void writer_print_integer ( WriterContext * wctx , const char * key , long long int val ) { const struct section * section = wctx -> section [ wctx -> level ] ; if ( section -> show_all_entries || av_dict_get ( section -> entries_to_show , key , NULL , 0 ) ) { wctx -> writer -> print_integer ( wctx , key , val ) ; wctx -> nb_item [ wctx -> level ] ++ ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@validate_string": "static inline int validate_string ( WriterContext * wctx , char * * dstp , const char * src ) { const uint8_t * p , * endp ; AVBPrint dstbuf ; int invalid_chars_nb = 0 , ret = 0 ; av_bprint_init ( & dstbuf , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; endp = src + strlen ( src ) ; for ( p = ( uint8_t * ) src ; * p ; ) { uint32_t code ; int invalid = 0 ; const uint8_t * p0 = p ; if ( av_utf8_decode ( & code , & p , endp , wctx -> string_validation_utf8_flags ) < 0 ) { AVBPrint bp ; av_bprint_init ( & bp , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; bprint_bytes ( & bp , p0 , p - p0 ) ; av_log ( wctx , AV_LOG_DEBUG , \"Invalid UTF-8 sequence %s found in string '%s'\\n\" , bp . str , src ) ; invalid = 1 ; } if ( invalid ) { invalid_chars_nb ++ ; switch ( wctx -> string_validation ) { case WRITER_STRING_VALIDATION_FAIL : av_log ( wctx , AV_LOG_ERROR , \"Invalid UTF-8 sequence found in string '%s'\\n\" , src ) ; ret = AVERROR_INVALIDDATA ; goto end ; break ; case WRITER_STRING_VALIDATION_REPLACE : av_bprintf ( & dstbuf , \"%s\" , wctx -> string_validation_replacement ) ; break ; } } if ( ! invalid || wctx -> string_validation == WRITER_STRING_VALIDATION_IGNORE ) av_bprint_append_data ( & dstbuf , p0 , p - p0 ) ; } if ( invalid_chars_nb && wctx -> string_validation == WRITER_STRING_VALIDATION_REPLACE ) { av_log ( wctx , AV_LOG_WARNING , \"%d invalid UTF-8 sequence(s) found in string '%s', replaced with '%s'\\n\" , invalid_chars_nb , src , wctx -> string_validation_replacement ) ; } end : av_bprint_finalize ( & dstbuf , dstp ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_print_string": "static inline int writer_print_string ( WriterContext * wctx , const char * key , const char * val , int flags ) { const struct section * section = wctx -> section [ wctx -> level ] ; int ret = 0 ; if ( show_optional_fields == SHOW_OPTIONAL_FIELDS_NEVER || ( show_optional_fields == SHOW_OPTIONAL_FIELDS_AUTO && ( flags & PRINT_STRING_OPT ) && ! ( wctx -> writer -> flags & WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS ) ) ) return 0 ; if ( section -> show_all_entries || av_dict_get ( section -> entries_to_show , key , NULL , 0 ) ) { if ( flags & PRINT_STRING_VALIDATE ) { char * key1 = NULL , * val1 = NULL ; ret = validate_string ( wctx , & key1 , key ) ; if ( ret < 0 ) goto end ; ret = validate_string ( wctx , & val1 , val ) ; if ( ret < 0 ) goto end ; wctx -> writer -> print_string ( wctx , key1 , val1 ) ; end : if ( ret < 0 ) { av_log ( wctx , AV_LOG_ERROR , \"Invalid key=value string combination %s=%s in section %s\\n\" , key , val , section -> unique_name ) ; } av_free ( key1 ) ; av_free ( val1 ) ; } else { wctx -> writer -> print_string ( wctx , key , val ) ; } wctx -> nb_item [ wctx -> level ] ++ ; } return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_print_rational": "static inline void writer_print_rational ( WriterContext * wctx , const char * key , AVRational q , char sep ) { AVBPrint buf ; av_bprint_init ( & buf , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; av_bprintf ( & buf , \"%d%c%d\" , q . num , sep , q . den ) ; writer_print_string ( wctx , key , buf . str , 0 ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_print_time": "static void writer_print_time ( WriterContext * wctx , const char * key , int64_t ts , const AVRational * time_base , int is_duration ) { char buf [ 128 ] ; if ( ( ! is_duration && ts == AV_NOPTS_VALUE ) || ( is_duration && ts == 0 ) ) { writer_print_string ( wctx , key , \"N/A\" , PRINT_STRING_OPT ) ; } else { double d = ts * av_q2d ( * time_base ) ; struct unit_value uv ; uv . val . d = d ; uv . unit = unit_second_str ; value_string ( buf , sizeof ( buf ) , uv ) ; writer_print_string ( wctx , key , buf , 0 ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_print_ts": "static void writer_print_ts ( WriterContext * wctx , const char * key , int64_t ts , int is_duration ) { if ( ( ! is_duration && ts == AV_NOPTS_VALUE ) || ( is_duration && ts == 0 ) ) { writer_print_string ( wctx , key , \"N/A\" , PRINT_STRING_OPT ) ; } else { writer_print_integer ( wctx , key , ts ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_print_data": "static void writer_print_data ( WriterContext * wctx , const char * name , const uint8_t * data , int size ) { AVBPrint bp ; int offset = 0 , l , i ; av_bprint_init ( & bp , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; av_bprintf ( & bp , \"\\n\" ) ; while ( size ) { av_bprintf ( & bp , \"%08x: \" , offset ) ; l = FFMIN ( size , 16 ) ; for ( i = 0 ; i < l ; i ++ ) { av_bprintf ( & bp , \"%02x\" , data [ i ] ) ; if ( i & 1 ) av_bprintf ( & bp , \" \" ) ; } av_bprint_chars ( & bp , ' ' , 41 - 2 * i - i / 2 ) ; for ( i = 0 ; i < l ; i ++ ) av_bprint_chars ( & bp , data [ i ] - 32U < 95 ? data [ i ] : '.' , 1 ) ; av_bprintf ( & bp , \"\\n\" ) ; offset += l ; data += l ; size -= l ; } writer_print_string ( wctx , name , bp . str , 0 ) ; av_bprint_finalize ( & bp , NULL ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_print_data_hash": "static void writer_print_data_hash ( WriterContext * wctx , const char * name , const uint8_t * data , int size ) { char * p , buf [ AV_HASH_MAX_SIZE * 2 + 64 ] = { 0 } ; if ( ! hash ) return ; av_hash_init ( hash ) ; av_hash_update ( hash , data , size ) ; snprintf ( buf , sizeof ( buf ) , \"%s:\" , av_hash_get_name ( hash ) ) ; p = buf + strlen ( buf ) ; av_hash_final_hex ( hash , p , buf + sizeof ( buf ) - p ) ; writer_print_string ( wctx , name , buf , 0 ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_print_integers": "static void writer_print_integers ( WriterContext * wctx , const char * name , uint8_t * data , int size , const char * format , int columns , int bytes , int offset_add ) { AVBPrint bp ; int offset = 0 , l , i ; av_bprint_init ( & bp , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; av_bprintf ( & bp , \"\\n\" ) ; while ( size ) { av_bprintf ( & bp , \"%08x: \" , offset ) ; l = FFMIN ( size , columns ) ; for ( i = 0 ; i < l ; i ++ ) { if ( bytes == 1 ) av_bprintf ( & bp , format , * data ) ; else if ( bytes == 2 ) av_bprintf ( & bp , format , AV_RN16 ( data ) ) ; else if ( bytes == 4 ) av_bprintf ( & bp , format , AV_RN32 ( data ) ) ; data += bytes ; size -- ; } av_bprintf ( & bp , \"\\n\" ) ; offset += offset_add ; } writer_print_string ( wctx , name , bp . str , 0 ) ; av_bprint_finalize ( & bp , NULL ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_register": "static int writer_register ( const Writer * writer ) { if ( next_registered_writer_idx == MAX_REGISTERED_WRITERS_NB ) return AVERROR ( ENOMEM ) ; registered_writers [ next_registered_writer_idx ++ ] = writer ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_get_by_name": "static const Writer * writer_get_by_name ( const char * name ) { int i ; for ( i = 0 ; registered_writers [ i ] ; i ++ ) if ( ! strcmp ( registered_writers [ i ] -> name , name ) ) return registered_writers [ i ] ; return NULL ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@default_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@upcase_string": "static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@default_print_section_header": "static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@default_print_section_footer": "static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@default_print_str": "static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@default_print_int": "static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@c_escape_str": "static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@csv_escape_str": "static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@none_escape_str": "static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@compact_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@compact_init": "static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@compact_print_section_header": "static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@compact_print_section_footer": "static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@compact_print_str": "static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@compact_print_int": "static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@csv_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@flat_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv ) ; static const Writer csv_writer = { . name = \"csv\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & csv_class , } ; /* Flat output */ typedef struct FlatContext { const AVClass * class ; const char * sep_str ; char sep ; int hierarchical ; } FlatContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( FlatContext , x ) static const AVOption flat_options [ ] = { { \"sep_char\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"s\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( flat )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@flat_init": "static av_cold int flat_init ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; if ( strlen ( flat -> sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , flat -> sep_str ) ; return AVERROR ( EINVAL ) ; } flat -> sep = flat -> sep_str [ 0 ] ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@flat_escape_key_str": "static const char * flat_escape_key_str ( AVBPrint * dst , const char * src , const char sep ) { const char * p ; for ( p = src ; * p ; p ++ ) { if ( ! ( ( * p >= '0' && * p <= '9' ) || ( * p >= 'a' && * p <= 'z' ) || ( * p >= 'A' && * p <= 'Z' ) ) ) av_bprint_chars ( dst , '_' , 1 ) ; else av_bprint_chars ( dst , * p , 1 ) ; } return dst -> str ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@flat_escape_value_str": "static const char * flat_escape_value_str ( AVBPrint * dst , const char * src ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; case '\"' : av_bprintf ( dst , \"%s\" , \"\\\\\\\"\" ) ; break ; case '`' : av_bprintf ( dst , \"%s\" , \"\\\\`\" ) ; break ; case '$' : av_bprintf ( dst , \"%s\" , \"\\\\$\" ) ; break ; default : av_bprint_chars ( dst , * p , 1 ) ; break ; } } return dst -> str ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@flat_print_section_header": "static void flat_print_section_header ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; /* build section header */ av_bprint_clear ( buf ) ; if ( ! parent_section ) return ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( flat -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , wctx -> section [ wctx -> level ] -> name , flat -> sep_str ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \"%d%s\" , n , flat -> sep_str ) ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@flat_print_int": "static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s%s=%lld\\n\" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@flat_print_str": "static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) { FlatContext * flat = wctx -> priv ; AVBPrint buf ; writer_put_str ( wctx , wctx -> section_pbuf [ wctx -> level ] . str ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"\\\"%s\\\"\\n\" , flat_escape_value_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@ini_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv ) ; static const Writer csv_writer = { . name = \"csv\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & csv_class , } ; /* Flat output */ typedef struct FlatContext { const AVClass * class ; const char * sep_str ; char sep ; int hierarchical ; } FlatContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( FlatContext , x ) static const AVOption flat_options [ ] = { { \"sep_char\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"s\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( flat ) ; static av_cold int flat_init ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; if ( strlen ( flat -> sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , flat -> sep_str ) ; return AVERROR ( EINVAL ) ; } flat -> sep = flat -> sep_str [ 0 ] ; return 0 ; } static const char * flat_escape_key_str ( AVBPrint * dst , const char * src , const char sep ) { const char * p ; for ( p = src ; * p ; p ++ ) { if ( ! ( ( * p >= '0' && * p <= '9' ) || ( * p >= 'a' && * p <= 'z' ) || ( * p >= 'A' && * p <= 'Z' ) ) ) av_bprint_chars ( dst , '_' , 1 ) ; else av_bprint_chars ( dst , * p , 1 ) ; } return dst -> str ; } static const char * flat_escape_value_str ( AVBPrint * dst , const char * src ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; case '\"' : av_bprintf ( dst , \"%s\" , \"\\\\\\\"\" ) ; break ; case '`' : av_bprintf ( dst , \"%s\" , \"\\\\`\" ) ; break ; case '$' : av_bprintf ( dst , \"%s\" , \"\\\\$\" ) ; break ; default : av_bprint_chars ( dst , * p , 1 ) ; break ; } } return dst -> str ; } static void flat_print_section_header ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; /* build section header */ av_bprint_clear ( buf ) ; if ( ! parent_section ) return ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( flat -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , wctx -> section [ wctx -> level ] -> name , flat -> sep_str ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \"%d%s\" , n , flat -> sep_str ) ; } } } static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s%s=%lld\\n\" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ; } static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) { FlatContext * flat = wctx -> priv ; AVBPrint buf ; writer_put_str ( wctx , wctx -> section_pbuf [ wctx -> level ] . str ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"\\\"%s\\\"\\n\" , flat_escape_value_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static const Writer flat_writer = { . name = \"flat\" , . priv_size = sizeof ( FlatContext ) , . init = flat_init , . print_section_header = flat_print_section_header , . print_integer = flat_print_int , . print_string = flat_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & flat_class , } ; /* INI format output */ typedef struct INIContext { const AVClass * class ; int hierarchical ; } INIContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( INIContext , x ) static const AVOption ini_options [ ] = { { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( ini )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@ini_escape_str": "static char * ini_escape_str ( AVBPrint * dst , const char * src ) { int i = 0 ; char c = 0 ; while ( ( c = src [ i ++ ] ) ) { switch ( c ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\t' : av_bprintf ( dst , \"%s\" , \"\\\\t\" ) ; break ; case '\\\\' : case '#' : case '=' : case ':' : av_bprint_chars ( dst , '\\\\' , 1 ) ; default : if ( ( unsigned char ) c < 32 ) av_bprintf ( dst , \"\\\\x00%02x\" , c & 0xff ) ; else av_bprint_chars ( dst , c , 1 ) ; break ; } } return dst -> str ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@ini_print_section_header": "static void ini_print_section_header ( WriterContext * wctx ) { INIContext * ini = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( buf ) ; if ( ! parent_section ) { writer_put_str ( wctx , \"# ffprobe output\\n\\n\" ) ; return ; } if ( wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , '\\n' ) ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( ini -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , buf -> str [ 0 ] ? \".\" : \"\" , wctx -> section [ wctx -> level ] -> name ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \".%d\" , n ) ; } } if ( ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) writer_printf ( wctx , \"[%s]\\n\" , buf -> str ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@ini_print_str": "static void ini_print_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , ini_escape_str ( & buf , key ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"%s\\n\" , ini_escape_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@ini_print_int": "static void ini_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s=%lld\\n\" , key , value ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@json_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv ) ; static const Writer csv_writer = { . name = \"csv\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & csv_class , } ; /* Flat output */ typedef struct FlatContext { const AVClass * class ; const char * sep_str ; char sep ; int hierarchical ; } FlatContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( FlatContext , x ) static const AVOption flat_options [ ] = { { \"sep_char\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"s\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( flat ) ; static av_cold int flat_init ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; if ( strlen ( flat -> sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , flat -> sep_str ) ; return AVERROR ( EINVAL ) ; } flat -> sep = flat -> sep_str [ 0 ] ; return 0 ; } static const char * flat_escape_key_str ( AVBPrint * dst , const char * src , const char sep ) { const char * p ; for ( p = src ; * p ; p ++ ) { if ( ! ( ( * p >= '0' && * p <= '9' ) || ( * p >= 'a' && * p <= 'z' ) || ( * p >= 'A' && * p <= 'Z' ) ) ) av_bprint_chars ( dst , '_' , 1 ) ; else av_bprint_chars ( dst , * p , 1 ) ; } return dst -> str ; } static const char * flat_escape_value_str ( AVBPrint * dst , const char * src ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; case '\"' : av_bprintf ( dst , \"%s\" , \"\\\\\\\"\" ) ; break ; case '`' : av_bprintf ( dst , \"%s\" , \"\\\\`\" ) ; break ; case '$' : av_bprintf ( dst , \"%s\" , \"\\\\$\" ) ; break ; default : av_bprint_chars ( dst , * p , 1 ) ; break ; } } return dst -> str ; } static void flat_print_section_header ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; /* build section header */ av_bprint_clear ( buf ) ; if ( ! parent_section ) return ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( flat -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , wctx -> section [ wctx -> level ] -> name , flat -> sep_str ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \"%d%s\" , n , flat -> sep_str ) ; } } } static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s%s=%lld\\n\" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ; } static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) { FlatContext * flat = wctx -> priv ; AVBPrint buf ; writer_put_str ( wctx , wctx -> section_pbuf [ wctx -> level ] . str ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"\\\"%s\\\"\\n\" , flat_escape_value_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static const Writer flat_writer = { . name = \"flat\" , . priv_size = sizeof ( FlatContext ) , . init = flat_init , . print_section_header = flat_print_section_header , . print_integer = flat_print_int , . print_string = flat_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & flat_class , } ; /* INI format output */ typedef struct INIContext { const AVClass * class ; int hierarchical ; } INIContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( INIContext , x ) static const AVOption ini_options [ ] = { { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( ini ) ; static char * ini_escape_str ( AVBPrint * dst , const char * src ) { int i = 0 ; char c = 0 ; while ( ( c = src [ i ++ ] ) ) { switch ( c ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\t' : av_bprintf ( dst , \"%s\" , \"\\\\t\" ) ; break ; case '\\\\' : case '#' : case '=' : case ':' : av_bprint_chars ( dst , '\\\\' , 1 ) ; default : if ( ( unsigned char ) c < 32 ) av_bprintf ( dst , \"\\\\x00%02x\" , c & 0xff ) ; else av_bprint_chars ( dst , c , 1 ) ; break ; } } return dst -> str ; } static void ini_print_section_header ( WriterContext * wctx ) { INIContext * ini = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( buf ) ; if ( ! parent_section ) { writer_put_str ( wctx , \"# ffprobe output\\n\\n\" ) ; return ; } if ( wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , '\\n' ) ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( ini -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , buf -> str [ 0 ] ? \".\" : \"\" , wctx -> section [ wctx -> level ] -> name ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \".%d\" , n ) ; } } if ( ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) writer_printf ( wctx , \"[%s]\\n\" , buf -> str ) ; } static void ini_print_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , ini_escape_str ( & buf , key ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"%s\\n\" , ini_escape_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void ini_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s=%lld\\n\" , key , value ) ; } static const Writer ini_writer = { . name = \"ini\" , . priv_size = sizeof ( INIContext ) , . print_section_header = ini_print_section_header , . print_integer = ini_print_int , . print_string = ini_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & ini_class , } ; /* JSON output */ typedef struct JSONContext { const AVClass * class ; int indent_level ; int compact ; const char * item_sep , * item_start_end ; } JSONContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( JSONContext , x ) static const AVOption json_options [ ] = { { \"compact\" , \"enable compact output\" , OFFSET ( compact ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"c\" , \"enable compact output\" , OFFSET ( compact ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } } ; DEFINE_WRITER_CLASS ( json )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@json_init": "static av_cold int json_init ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; json -> item_sep = json -> compact ? \", \" : \",\\n\" ; json -> item_start_end = json -> compact ? \" \" : \"\\n\" ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@json_escape_str": "static const char * json_escape_str ( AVBPrint * dst , const char * src , void * log_ctx ) { static const char json_escape [ ] = { '\"' , '\\\\' , '\\b' , '\\f' , '\\n' , '\\r' , '\\t' , 0 } ; static const char json_subst [ ] = { '\"' , '\\\\' , 'b' , 'f' , 'n' , 'r' , 't' , 0 } ; const char * p ; for ( p = src ; * p ; p ++ ) { char * s = strchr ( json_escape , * p ) ; if ( s ) { av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , json_subst [ s - json_escape ] , 1 ) ; } else if ( ( unsigned char ) * p < 32 ) { av_bprintf ( dst , \"\\\\u00%02x\" , * p & 0xff ) ; } else { av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@json_print_section_header": "static void json_print_section_header ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; AVBPrint buf ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_put_str ( wctx , \",\\n\" ) ; if ( section -> flags & SECTION_FLAG_IS_WRAPPER ) { writer_put_str ( wctx , \"{\\n\" ) ; json -> indent_level ++ ; } else { av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; json_escape_str ( & buf , section -> name , wctx ) ; JSON_INDENT ( ) ; json -> indent_level ++ ; if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { writer_printf ( wctx , \"\\\"%s\\\": [\\n\" , buf . str ) ; } else if ( parent_section && ! ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) ) { writer_printf ( wctx , \"\\\"%s\\\": {%s\" , buf . str , json -> item_start_end ) ; } else { writer_printf ( wctx , \"{%s\" , json -> item_start_end ) ; /* this is required so the parser can distinguish between packets and frames */ if ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) { if ( ! json -> compact ) JSON_INDENT ( ) ; writer_printf ( wctx , \"\\\"type\\\": \\\"%s\\\"\" , section -> name ) ; wctx -> nb_item [ wctx -> level ] ++ ; } } av_bprint_finalize ( & buf , NULL ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@json_print_section_footer": "static void json_print_section_footer ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; if ( wctx -> level == 0 ) { json -> indent_level -- ; writer_put_str ( wctx , \"\\n}\\n\" ) ; } else if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { writer_w8 ( wctx , '\\n' ) ; json -> indent_level -- ; JSON_INDENT ( ) ; writer_w8 ( wctx , ']' ) ; } else { writer_put_str ( wctx , json -> item_start_end ) ; json -> indent_level -- ; if ( ! json -> compact ) JSON_INDENT ( ) ; writer_w8 ( wctx , '}' ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@json_print_item_str": "static inline void json_print_item_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"\\\"%s\\\":\" , json_escape_str ( & buf , key , wctx ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \" \\\"%s\\\"\" , json_escape_str ( & buf , value , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@json_print_str": "static void json_print_str ( WriterContext * wctx , const char * key , const char * value ) { JSONContext * json = wctx -> priv ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> nb_item [ wctx -> level ] || ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) ) writer_put_str ( wctx , json -> item_sep ) ; if ( ! json -> compact ) JSON_INDENT ( ) ; json_print_item_str ( wctx , key , value ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@json_print_int": "static void json_print_int ( WriterContext * wctx , const char * key , long long int value ) { JSONContext * json = wctx -> priv ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] || ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) ) writer_put_str ( wctx , json -> item_sep ) ; if ( ! json -> compact ) JSON_INDENT ( ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"\\\"%s\\\": %lld\" , json_escape_str ( & buf , key , wctx ) , value ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@xml_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv ) ; static const Writer csv_writer = { . name = \"csv\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & csv_class , } ; /* Flat output */ typedef struct FlatContext { const AVClass * class ; const char * sep_str ; char sep ; int hierarchical ; } FlatContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( FlatContext , x ) static const AVOption flat_options [ ] = { { \"sep_char\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"s\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( flat ) ; static av_cold int flat_init ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; if ( strlen ( flat -> sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , flat -> sep_str ) ; return AVERROR ( EINVAL ) ; } flat -> sep = flat -> sep_str [ 0 ] ; return 0 ; } static const char * flat_escape_key_str ( AVBPrint * dst , const char * src , const char sep ) { const char * p ; for ( p = src ; * p ; p ++ ) { if ( ! ( ( * p >= '0' && * p <= '9' ) || ( * p >= 'a' && * p <= 'z' ) || ( * p >= 'A' && * p <= 'Z' ) ) ) av_bprint_chars ( dst , '_' , 1 ) ; else av_bprint_chars ( dst , * p , 1 ) ; } return dst -> str ; } static const char * flat_escape_value_str ( AVBPrint * dst , const char * src ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; case '\"' : av_bprintf ( dst , \"%s\" , \"\\\\\\\"\" ) ; break ; case '`' : av_bprintf ( dst , \"%s\" , \"\\\\`\" ) ; break ; case '$' : av_bprintf ( dst , \"%s\" , \"\\\\$\" ) ; break ; default : av_bprint_chars ( dst , * p , 1 ) ; break ; } } return dst -> str ; } static void flat_print_section_header ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; /* build section header */ av_bprint_clear ( buf ) ; if ( ! parent_section ) return ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( flat -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , wctx -> section [ wctx -> level ] -> name , flat -> sep_str ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \"%d%s\" , n , flat -> sep_str ) ; } } } static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s%s=%lld\\n\" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ; } static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) { FlatContext * flat = wctx -> priv ; AVBPrint buf ; writer_put_str ( wctx , wctx -> section_pbuf [ wctx -> level ] . str ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"\\\"%s\\\"\\n\" , flat_escape_value_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static const Writer flat_writer = { . name = \"flat\" , . priv_size = sizeof ( FlatContext ) , . init = flat_init , . print_section_header = flat_print_section_header , . print_integer = flat_print_int , . print_string = flat_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & flat_class , } ; /* INI format output */ typedef struct INIContext { const AVClass * class ; int hierarchical ; } INIContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( INIContext , x ) static const AVOption ini_options [ ] = { { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( ini ) ; static char * ini_escape_str ( AVBPrint * dst , const char * src ) { int i = 0 ; char c = 0 ; while ( ( c = src [ i ++ ] ) ) { switch ( c ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\t' : av_bprintf ( dst , \"%s\" , \"\\\\t\" ) ; break ; case '\\\\' : case '#' : case '=' : case ':' : av_bprint_chars ( dst , '\\\\' , 1 ) ; default : if ( ( unsigned char ) c < 32 ) av_bprintf ( dst , \"\\\\x00%02x\" , c & 0xff ) ; else av_bprint_chars ( dst , c , 1 ) ; break ; } } return dst -> str ; } static void ini_print_section_header ( WriterContext * wctx ) { INIContext * ini = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( buf ) ; if ( ! parent_section ) { writer_put_str ( wctx , \"# ffprobe output\\n\\n\" ) ; return ; } if ( wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , '\\n' ) ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( ini -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , buf -> str [ 0 ] ? \".\" : \"\" , wctx -> section [ wctx -> level ] -> name ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \".%d\" , n ) ; } } if ( ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) writer_printf ( wctx , \"[%s]\\n\" , buf -> str ) ; } static void ini_print_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , ini_escape_str ( & buf , key ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"%s\\n\" , ini_escape_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void ini_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s=%lld\\n\" , key , value ) ; } static const Writer ini_writer = { . name = \"ini\" , . priv_size = sizeof ( INIContext ) , . print_section_header = ini_print_section_header , . print_integer = ini_print_int , . print_string = ini_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & ini_class , } ; /* JSON output */ typedef struct JSONContext { const AVClass * class ; int indent_level ; int compact ; const char * item_sep , * item_start_end ; } JSONContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( JSONContext , x ) static const AVOption json_options [ ] = { { \"compact\" , \"enable compact output\" , OFFSET ( compact ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"c\" , \"enable compact output\" , OFFSET ( compact ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } } ; DEFINE_WRITER_CLASS ( json ) ; static av_cold int json_init ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; json -> item_sep = json -> compact ? \", \" : \",\\n\" ; json -> item_start_end = json -> compact ? \" \" : \"\\n\" ; return 0 ; } static const char * json_escape_str ( AVBPrint * dst , const char * src , void * log_ctx ) { static const char json_escape [ ] = { '\"' , '\\\\' , '\\b' , '\\f' , '\\n' , '\\r' , '\\t' , 0 } ; static const char json_subst [ ] = { '\"' , '\\\\' , 'b' , 'f' , 'n' , 'r' , 't' , 0 } ; const char * p ; for ( p = src ; * p ; p ++ ) { char * s = strchr ( json_escape , * p ) ; if ( s ) { av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , json_subst [ s - json_escape ] , 1 ) ; } else if ( ( unsigned char ) * p < 32 ) { av_bprintf ( dst , \"\\\\u00%02x\" , * p & 0xff ) ; } else { av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } # define JSON_INDENT ( ) writer_printf ( wctx , \"%*c\" , json -> indent_level * 4 , ' ' ) static void json_print_section_header ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; AVBPrint buf ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_put_str ( wctx , \",\\n\" ) ; if ( section -> flags & SECTION_FLAG_IS_WRAPPER ) { writer_put_str ( wctx , \"{\\n\" ) ; json -> indent_level ++ ; } else { av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; json_escape_str ( & buf , section -> name , wctx ) ; JSON_INDENT ( ) ; json -> indent_level ++ ; if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { writer_printf ( wctx , \"\\\"%s\\\": [\\n\" , buf . str ) ; } else if ( parent_section && ! ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) ) { writer_printf ( wctx , \"\\\"%s\\\": {%s\" , buf . str , json -> item_start_end ) ; } else { writer_printf ( wctx , \"{%s\" , json -> item_start_end ) ; /* this is required so the parser can distinguish between packets and frames */ if ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) { if ( ! json -> compact ) JSON_INDENT ( ) ; writer_printf ( wctx , \"\\\"type\\\": \\\"%s\\\"\" , section -> name ) ; wctx -> nb_item [ wctx -> level ] ++ ; } } av_bprint_finalize ( & buf , NULL ) ; } } static void json_print_section_footer ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; if ( wctx -> level == 0 ) { json -> indent_level -- ; writer_put_str ( wctx , \"\\n}\\n\" ) ; } else if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { writer_w8 ( wctx , '\\n' ) ; json -> indent_level -- ; JSON_INDENT ( ) ; writer_w8 ( wctx , ']' ) ; } else { writer_put_str ( wctx , json -> item_start_end ) ; json -> indent_level -- ; if ( ! json -> compact ) JSON_INDENT ( ) ; writer_w8 ( wctx , '}' ) ; } } static inline void json_print_item_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"\\\"%s\\\":\" , json_escape_str ( & buf , key , wctx ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \" \\\"%s\\\"\" , json_escape_str ( & buf , value , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void json_print_str ( WriterContext * wctx , const char * key , const char * value ) { JSONContext * json = wctx -> priv ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> nb_item [ wctx -> level ] || ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) ) writer_put_str ( wctx , json -> item_sep ) ; if ( ! json -> compact ) JSON_INDENT ( ) ; json_print_item_str ( wctx , key , value ) ; } static void json_print_int ( WriterContext * wctx , const char * key , long long int value ) { JSONContext * json = wctx -> priv ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] || ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) ) writer_put_str ( wctx , json -> item_sep ) ; if ( ! json -> compact ) JSON_INDENT ( ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"\\\"%s\\\": %lld\" , json_escape_str ( & buf , key , wctx ) , value ) ; av_bprint_finalize ( & buf , NULL ) ; } static const Writer json_writer = { . name = \"json\" , . priv_size = sizeof ( JSONContext ) , . init = json_init , . print_section_header = json_print_section_header , . print_section_footer = json_print_section_footer , . print_integer = json_print_int , . print_string = json_print_str , . flags = WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & json_class , } ; /* XML output */ typedef struct XMLContext { const AVClass * class ; int within_tag ; int indent_level ; int fully_qualified ; int xsd_strict ; } XMLContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( XMLContext , x ) static const AVOption xml_options [ ] = { { \"fully_qualified\" , \"specify if the output should be fully qualified\" , OFFSET ( fully_qualified ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"q\" , \"specify if the output should be fully qualified\" , OFFSET ( fully_qualified ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"xsd_strict\" , \"ensure that the output is XSD compliant\" , OFFSET ( xsd_strict ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"x\" , \"ensure that the output is XSD compliant\" , OFFSET ( xsd_strict ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( xml )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@xml_init": "static av_cold int xml_init ( WriterContext * wctx ) { XMLContext * xml = wctx -> priv ; if ( xml -> xsd_strict ) { xml -> fully_qualified = 1 ; # define CHECK_COMPLIANCE ( opt , opt_name ) if ( opt ) { av_log ( wctx , AV_LOG_ERROR , \"XSD-compliant output selected but option '%s' was selected, XML output may be non-compliant.\\n\" \"You need to disable such option with '-no%s'\\n\" , opt_name , opt_name ) ; return AVERROR ( EINVAL ) ; } CHECK_COMPLIANCE ( show_private_data , \"private\" ) ; CHECK_COMPLIANCE ( show_value_unit , \"unit\" ) ; CHECK_COMPLIANCE ( use_value_prefix , \"prefix\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@xml_print_section_header": "static void xml_print_section_header ( WriterContext * wctx ) { XMLContext * xml = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> level == 0 ) { const char * qual = \" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" \" \"xmlns:ffprobe=\\\"http://www.ffmpeg.org/schema/ffprobe\\\" \" \"xsi:schemaLocation=\\\"http://www.ffmpeg.org/schema/ffprobe ffprobe.xsd\\\"\" ; writer_put_str ( wctx , \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" ) ; writer_printf ( wctx , \"<%sffprobe%s>\\n\" , xml -> fully_qualified ? \"ffprobe:\" : \"\" , xml -> fully_qualified ? qual : \"\" ) ; return ; } if ( xml -> within_tag ) { xml -> within_tag = 0 ; writer_put_str ( wctx , \">\\n\" ) ; } if ( section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ) { xml -> indent_level ++ ; } else { if ( parent_section && ( parent_section -> flags & SECTION_FLAG_IS_WRAPPER ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , '\\n' ) ; xml -> indent_level ++ ; if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { XML_INDENT ( ) ; writer_printf ( wctx , \"<%s>\\n\" , section -> name ) ; } else { XML_INDENT ( ) ; writer_printf ( wctx , \"<%s \" , section -> name ) ; xml -> within_tag = 1 ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@xml_print_section_footer": "static void xml_print_section_footer ( WriterContext * wctx ) { XMLContext * xml = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; if ( wctx -> level == 0 ) { writer_printf ( wctx , \"</%sffprobe>\\n\" , xml -> fully_qualified ? \"ffprobe:\" : \"\" ) ; } else if ( xml -> within_tag ) { xml -> within_tag = 0 ; writer_put_str ( wctx , \"/>\\n\" ) ; xml -> indent_level -- ; } else if ( section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ) { xml -> indent_level -- ; } else { XML_INDENT ( ) ; writer_printf ( wctx , \"</%s>\\n\" , section -> name ) ; xml -> indent_level -- ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@xml_print_str": "static void xml_print_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; XMLContext * xml = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; if ( section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ) { XML_INDENT ( ) ; av_bprint_escape ( & buf , key , NULL , AV_ESCAPE_MODE_XML , AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES ) ; writer_printf ( wctx , \"<%s key=\\\"%s\\\"\" , section -> element_name , buf . str ) ; av_bprint_clear ( & buf ) ; av_bprint_escape ( & buf , value , NULL , AV_ESCAPE_MODE_XML , AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES ) ; writer_printf ( wctx , \" value=\\\"%s\\\"/>\\n\" , buf . str ) ; } else { if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , ' ' ) ; av_bprint_escape ( & buf , value , NULL , AV_ESCAPE_MODE_XML , AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES ) ; writer_printf ( wctx , \"%s=\\\"%s\\\"\" , key , buf . str ) ; } av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@xml_print_int": "static void xml_print_int ( WriterContext * wctx , const char * key , long long int value ) { if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , ' ' ) ; writer_printf ( wctx , \"%s=\\\"%lld\\\"\" , key , value ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@writer_register_all": "static void writer_register_all ( void ) { writer_register ( & default_writer ) ; writer_register ( & compact_writer ) ; writer_register ( & csv_writer ) ; writer_register ( & flat_writer ) ; writer_register ( & ini_writer ) ; writer_register ( & json_writer ) ; writer_register ( & xml_writer ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_tags": "static inline int show_tags ( WriterContext * w , AVDictionary * tags , int section_id ) { const AVDictionaryEntry * tag = NULL ; int ret = 0 ; if ( ! tags ) return 0 ; writer_print_section_header ( w , section_id ) ; while ( ( tag = av_dict_iterate ( tags , tag ) ) ) { if ( ( ret = print_str_validate ( tag -> key , tag -> value ) ) < 0 ) break ; } writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@print_dovi_metadata": "static void print_dovi_metadata ( WriterContext * w , const AVDOVIMetadata * dovi ) { if ( ! dovi ) return ; { const AVDOVIRpuDataHeader * hdr = av_dovi_get_header ( dovi ) ; const AVDOVIDataMapping * mapping = av_dovi_get_mapping ( dovi ) ; const AVDOVIColorMetadata * color = av_dovi_get_color ( dovi ) ; AVBPrint pbuf ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; // header print_int ( \"rpu_type\" , hdr -> rpu_type ) ; print_int ( \"rpu_format\" , hdr -> rpu_format ) ; print_int ( \"vdr_rpu_profile\" , hdr -> vdr_rpu_profile ) ; print_int ( \"vdr_rpu_level\" , hdr -> vdr_rpu_level ) ; print_int ( \"chroma_resampling_explicit_filter_flag\" , hdr -> chroma_resampling_explicit_filter_flag ) ; print_int ( \"coef_data_type\" , hdr -> coef_data_type ) ; print_int ( \"coef_log2_denom\" , hdr -> coef_log2_denom ) ; print_int ( \"vdr_rpu_normalized_idc\" , hdr -> vdr_rpu_normalized_idc ) ; print_int ( \"bl_video_full_range_flag\" , hdr -> bl_video_full_range_flag ) ; print_int ( \"bl_bit_depth\" , hdr -> bl_bit_depth ) ; print_int ( \"el_bit_depth\" , hdr -> el_bit_depth ) ; print_int ( \"vdr_bit_depth\" , hdr -> vdr_bit_depth ) ; print_int ( \"spatial_resampling_filter_flag\" , hdr -> spatial_resampling_filter_flag ) ; print_int ( \"el_spatial_resampling_filter_flag\" , hdr -> el_spatial_resampling_filter_flag ) ; print_int ( \"disable_residual_flag\" , hdr -> disable_residual_flag ) ; // data mapping values print_int ( \"vdr_rpu_id\" , mapping -> vdr_rpu_id ) ; print_int ( \"mapping_color_space\" , mapping -> mapping_color_space ) ; print_int ( \"mapping_chroma_format_idc\" , mapping -> mapping_chroma_format_idc ) ; print_int ( \"nlq_method_idc\" , mapping -> nlq_method_idc ) ; switch ( mapping -> nlq_method_idc ) { case AV_DOVI_NLQ_NONE : print_str ( \"nlq_method_idc_name\" , \"none\" ) ; break ; case AV_DOVI_NLQ_LINEAR_DZ : print_str ( \"nlq_method_idc_name\" , \"linear_dz\" ) ; break ; default : print_str ( \"nlq_method_idc_name\" , \"unknown\" ) ; break ; } print_int ( \"num_x_partitions\" , mapping -> num_x_partitions ) ; print_int ( \"num_y_partitions\" , mapping -> num_y_partitions ) ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_COMPONENT_LIST ) ; for ( int c = 0 ; c < 3 ; c ++ ) { const AVDOVIReshapingCurve * curve = & mapping -> curves [ c ] ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_COMPONENT ) ; print_list_fmt ( \"pivots\" , \"%\" PRIu16 , curve -> num_pivots , 1 , curve -> pivots [ idx ] ) ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_PIECE_LIST ) ; for ( int i = 0 ; i < curve -> num_pivots - 1 ; i ++ ) { writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_PIECE ) ; print_int ( \"mapping_idc\" , curve -> mapping_idc [ i ] ) ; switch ( curve -> mapping_idc [ i ] ) { case AV_DOVI_MAPPING_POLYNOMIAL : print_str ( \"mapping_idc_name\" , \"polynomial\" ) ; print_int ( \"poly_order\" , curve -> poly_order [ i ] ) ; print_list_fmt ( \"poly_coef\" , \"%\" PRIi64 , curve -> poly_order [ i ] + 1 , 1 , curve -> poly_coef [ i ] [ idx ] ) ; break ; case AV_DOVI_MAPPING_MMR : print_str ( \"mapping_idc_name\" , \"mmr\" ) ; print_int ( \"mmr_order\" , curve -> mmr_order [ i ] ) ; print_int ( \"mmr_constant\" , curve -> mmr_constant [ i ] ) ; print_list_fmt ( \"mmr_coef\" , \"%\" PRIi64 , curve -> mmr_order [ i ] , 7 , curve -> mmr_coef [ i ] [ idx ] [ idx2 ] ) ; break ; default : print_str ( \"mapping_idc_name\" , \"unknown\" ) ; break ; } // SECTION_ID_FRAME_SIDE_DATA_PIECE writer_print_section_footer ( w ) ; } // SECTION_ID_FRAME_SIDE_DATA_PIECE_LIST writer_print_section_footer ( w ) ; if ( mapping -> nlq_method_idc != AV_DOVI_NLQ_NONE ) { const AVDOVINLQParams * nlq = & mapping -> nlq [ c ] ; print_int ( \"nlq_offset\" , nlq -> nlq_offset ) ; print_int ( \"vdr_in_max\" , nlq -> vdr_in_max ) ; switch ( mapping -> nlq_method_idc ) { case AV_DOVI_NLQ_LINEAR_DZ : print_int ( \"linear_deadzone_slope\" , nlq -> linear_deadzone_slope ) ; print_int ( \"linear_deadzone_threshold\" , nlq -> linear_deadzone_threshold ) ; break ; } } // SECTION_ID_FRAME_SIDE_DATA_COMPONENT writer_print_section_footer ( w ) ; } // SECTION_ID_FRAME_SIDE_DATA_COMPONENT_LIST writer_print_section_footer ( w ) ; // color metadata print_int ( \"dm_metadata_id\" , color -> dm_metadata_id ) ; print_int ( \"scene_refresh_flag\" , color -> scene_refresh_flag ) ; print_list_fmt ( \"ycc_to_rgb_matrix\" , \"%d/%d\" , FF_ARRAY_ELEMS ( color -> ycc_to_rgb_matrix ) , 1 , color -> ycc_to_rgb_matrix [ idx ] . num , color -> ycc_to_rgb_matrix [ idx ] . den ) ; print_list_fmt ( \"ycc_to_rgb_offset\" , \"%d/%d\" , FF_ARRAY_ELEMS ( color -> ycc_to_rgb_offset ) , 1 , color -> ycc_to_rgb_offset [ idx ] . num , color -> ycc_to_rgb_offset [ idx ] . den ) ; print_list_fmt ( \"rgb_to_lms_matrix\" , \"%d/%d\" , FF_ARRAY_ELEMS ( color -> rgb_to_lms_matrix ) , 1 , color -> rgb_to_lms_matrix [ idx ] . num , color -> rgb_to_lms_matrix [ idx ] . den ) ; print_int ( \"signal_eotf\" , color -> signal_eotf ) ; print_int ( \"signal_eotf_param0\" , color -> signal_eotf_param0 ) ; print_int ( \"signal_eotf_param1\" , color -> signal_eotf_param1 ) ; print_int ( \"signal_eotf_param2\" , color -> signal_eotf_param2 ) ; print_int ( \"signal_bit_depth\" , color -> signal_bit_depth ) ; print_int ( \"signal_color_space\" , color -> signal_color_space ) ; print_int ( \"signal_chroma_format\" , color -> signal_chroma_format ) ; print_int ( \"signal_full_range_flag\" , color -> signal_full_range_flag ) ; print_int ( \"source_min_pq\" , color -> source_min_pq ) ; print_int ( \"source_max_pq\" , color -> source_max_pq ) ; print_int ( \"source_diagonal\" , color -> source_diagonal ) ; av_bprint_finalize ( & pbuf , NULL ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@print_dynamic_hdr10_plus": "static void print_dynamic_hdr10_plus ( WriterContext * w , const AVDynamicHDRPlus * metadata ) { if ( ! metadata ) return ; print_int ( \"application version\" , metadata -> application_version ) ; print_int ( \"num_windows\" , metadata -> num_windows ) ; for ( int n = 1 ; n < metadata -> num_windows ; n ++ ) { const AVHDRPlusColorTransformParams * params = & metadata -> params [ n ] ; print_q ( \"window_upper_left_corner_x\" , params -> window_upper_left_corner_x , '/' ) ; print_q ( \"window_upper_left_corner_y\" , params -> window_upper_left_corner_y , '/' ) ; print_q ( \"window_lower_right_corner_x\" , params -> window_lower_right_corner_x , '/' ) ; print_q ( \"window_lower_right_corner_y\" , params -> window_lower_right_corner_y , '/' ) ; print_q ( \"window_upper_left_corner_x\" , params -> window_upper_left_corner_x , '/' ) ; print_q ( \"window_upper_left_corner_y\" , params -> window_upper_left_corner_y , '/' ) ; print_int ( \"center_of_ellipse_x\" , params -> center_of_ellipse_x ) ; print_int ( \"center_of_ellipse_y\" , params -> center_of_ellipse_y ) ; print_int ( \"rotation_angle\" , params -> rotation_angle ) ; print_int ( \"semimajor_axis_internal_ellipse\" , params -> semimajor_axis_internal_ellipse ) ; print_int ( \"semimajor_axis_external_ellipse\" , params -> semimajor_axis_external_ellipse ) ; print_int ( \"semiminor_axis_external_ellipse\" , params -> semiminor_axis_external_ellipse ) ; print_int ( \"overlap_process_option\" , params -> overlap_process_option ) ; } print_q ( \"targeted_system_display_maximum_luminance\" , metadata -> targeted_system_display_maximum_luminance , '/' ) ; if ( metadata -> targeted_system_display_actual_peak_luminance_flag ) { print_int ( \"num_rows_targeted_system_display_actual_peak_luminance\" , metadata -> num_rows_targeted_system_display_actual_peak_luminance ) ; print_int ( \"num_cols_targeted_system_display_actual_peak_luminance\" , metadata -> num_cols_targeted_system_display_actual_peak_luminance ) ; for ( int i = 0 ; i < metadata -> num_rows_targeted_system_display_actual_peak_luminance ; i ++ ) { for ( int j = 0 ; j < metadata -> num_cols_targeted_system_display_actual_peak_luminance ; j ++ ) { print_q ( \"targeted_system_display_actual_peak_luminance\" , metadata -> targeted_system_display_actual_peak_luminance [ i ] [ j ] , '/' ) ; } } } for ( int n = 0 ; n < metadata -> num_windows ; n ++ ) { const AVHDRPlusColorTransformParams * params = & metadata -> params [ n ] ; for ( int i = 0 ; i < 3 ; i ++ ) { print_q ( \"maxscl\" , params -> maxscl [ i ] , '/' ) ; } print_q ( \"average_maxrgb\" , params -> average_maxrgb , '/' ) ; print_int ( \"num_distribution_maxrgb_percentiles\" , params -> num_distribution_maxrgb_percentiles ) ; for ( int i = 0 ; i < params -> num_distribution_maxrgb_percentiles ; i ++ ) { print_int ( \"distribution_maxrgb_percentage\" , params -> distribution_maxrgb [ i ] . percentage ) ; print_q ( \"distribution_maxrgb_percentile\" , params -> distribution_maxrgb [ i ] . percentile , '/' ) ; } print_q ( \"fraction_bright_pixels\" , params -> fraction_bright_pixels , '/' ) ; } if ( metadata -> mastering_display_actual_peak_luminance_flag ) { print_int ( \"num_rows_mastering_display_actual_peak_luminance\" , metadata -> num_rows_mastering_display_actual_peak_luminance ) ; print_int ( \"num_cols_mastering_display_actual_peak_luminance\" , metadata -> num_cols_mastering_display_actual_peak_luminance ) ; for ( int i = 0 ; i < metadata -> num_rows_mastering_display_actual_peak_luminance ; i ++ ) { for ( int j = 0 ; j < metadata -> num_cols_mastering_display_actual_peak_luminance ; j ++ ) { print_q ( \"mastering_display_actual_peak_luminance\" , metadata -> mastering_display_actual_peak_luminance [ i ] [ j ] , '/' ) ; } } } for ( int n = 0 ; n < metadata -> num_windows ; n ++ ) { const AVHDRPlusColorTransformParams * params = & metadata -> params [ n ] ; if ( params -> tone_mapping_flag ) { print_q ( \"knee_point_x\" , params -> knee_point_x , '/' ) ; print_q ( \"knee_point_y\" , params -> knee_point_y , '/' ) ; print_int ( \"num_bezier_curve_anchors\" , params -> num_bezier_curve_anchors ) ; for ( int i = 0 ; i < params -> num_bezier_curve_anchors ; i ++ ) { print_q ( \"bezier_curve_anchors\" , params -> bezier_curve_anchors [ i ] , '/' ) ; } } if ( params -> color_saturation_mapping_flag ) { print_q ( \"color_saturation_weight\" , params -> color_saturation_weight , '/' ) ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@print_dynamic_hdr_vivid": "static void print_dynamic_hdr_vivid ( WriterContext * w , const AVDynamicHDRVivid * metadata ) { if ( ! metadata ) return ; print_int ( \"system_start_code\" , metadata -> system_start_code ) ; print_int ( \"num_windows\" , metadata -> num_windows ) ; for ( int n = 0 ; n < metadata -> num_windows ; n ++ ) { const AVHDRVividColorTransformParams * params = & metadata -> params [ n ] ; print_q ( \"minimum_maxrgb\" , params -> minimum_maxrgb , '/' ) ; print_q ( \"average_maxrgb\" , params -> average_maxrgb , '/' ) ; print_q ( \"variance_maxrgb\" , params -> variance_maxrgb , '/' ) ; print_q ( \"maximum_maxrgb\" , params -> maximum_maxrgb , '/' ) ; } for ( int n = 0 ; n < metadata -> num_windows ; n ++ ) { const AVHDRVividColorTransformParams * params = & metadata -> params [ n ] ; print_int ( \"tone_mapping_mode_flag\" , params -> tone_mapping_mode_flag ) ; print_int ( \"tone_mapping_param_num\" , params -> tone_mapping_param_num ) ; if ( params -> tone_mapping_mode_flag ) { for ( int i = 0 ; i < params -> tone_mapping_param_num ; i ++ ) { const AVHDRVividColorToneMappingParams * tm_params = & params -> tm_params [ i ] ; print_q ( \"targeted_system_display_maximum_luminance\" , tm_params -> targeted_system_display_maximum_luminance , '/' ) ; print_int ( \"base_enable_flag\" , tm_params -> base_enable_flag ) ; if ( tm_params -> base_enable_flag ) { print_q ( \"base_param_m_p\" , tm_params -> base_param_m_p , '/' ) ; print_q ( \"base_param_m_m\" , tm_params -> base_param_m_m , '/' ) ; print_q ( \"base_param_m_a\" , tm_params -> base_param_m_a , '/' ) ; print_q ( \"base_param_m_b\" , tm_params -> base_param_m_b , '/' ) ; print_q ( \"base_param_m_n\" , tm_params -> base_param_m_n , '/' ) ; print_int ( \"base_param_k1\" , tm_params -> base_param_k1 ) ; print_int ( \"base_param_k2\" , tm_params -> base_param_k2 ) ; print_int ( \"base_param_k3\" , tm_params -> base_param_k3 ) ; print_int ( \"base_param_Delta_enable_mode\" , tm_params -> base_param_Delta_enable_mode ) ; print_q ( \"base_param_Delta\" , tm_params -> base_param_Delta , '/' ) ; } print_int ( \"3Spline_enable_flag\" , tm_params -> three_Spline_enable_flag ) ; if ( tm_params -> three_Spline_enable_flag ) { print_int ( \"3Spline_num\" , tm_params -> three_Spline_num ) ; print_int ( \"3Spline_TH_mode\" , tm_params -> three_Spline_TH_mode ) ; for ( int j = 0 ; j < tm_params -> three_Spline_num ; j ++ ) { print_q ( \"3Spline_TH_enable_MB\" , tm_params -> three_Spline_TH_enable_MB , '/' ) ; print_q ( \"3Spline_TH_enable\" , tm_params -> three_Spline_TH_enable , '/' ) ; print_q ( \"3Spline_TH_Delta1\" , tm_params -> three_Spline_TH_Delta1 , '/' ) ; print_q ( \"3Spline_TH_Delta2\" , tm_params -> three_Spline_TH_Delta2 , '/' ) ; print_q ( \"3Spline_enable_Strength\" , tm_params -> three_Spline_enable_Strength , '/' ) ; } } } } print_int ( \"color_saturation_mapping_flag\" , params -> color_saturation_mapping_flag ) ; if ( params -> color_saturation_mapping_flag ) { print_int ( \"color_saturation_num\" , params -> color_saturation_num ) ; for ( int i = 0 ; i < params -> color_saturation_num ; i ++ ) { print_q ( \"color_saturation_gain\" , params -> color_saturation_gain [ i ] , '/' ) ; } } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@print_ambient_viewing_environment": "static void print_ambient_viewing_environment ( WriterContext * w , const AVAmbientViewingEnvironment * env ) { if ( ! env ) return ; print_q ( \"ambient_illuminance\" , env -> ambient_illuminance , '/' ) ; print_q ( \"ambient_light_x\" , env -> ambient_light_x , '/' ) ; print_q ( \"ambient_light_y\" , env -> ambient_light_y , '/' ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@print_pkt_side_data": "static void print_pkt_side_data ( WriterContext * w , AVCodecParameters * par , const AVPacketSideData * side_data , int nb_side_data , SectionID id_data_list , SectionID id_data ) { int i ; writer_print_section_header ( w , id_data_list ) ; for ( i = 0 ; i < nb_side_data ; i ++ ) { const AVPacketSideData * sd = & side_data [ i ] ; const char * name = av_packet_side_data_name ( sd -> type ) ; writer_print_section_header ( w , id_data ) ; print_str ( \"side_data_type\" , name ? name : \"unknown\" ) ; if ( sd -> type == AV_PKT_DATA_DISPLAYMATRIX && sd -> size >= 9 * 4 ) { double rotation = av_display_rotation_get ( ( int32_t * ) sd -> data ) ; if ( isnan ( rotation ) ) rotation = 0 ; writer_print_integers ( w , \"displaymatrix\" , sd -> data , 9 , \" %11d\" , 3 , 4 , 1 ) ; print_int ( \"rotation\" , rotation ) ; } else if ( sd -> type == AV_PKT_DATA_STEREO3D ) { const AVStereo3D * stereo = ( AVStereo3D * ) sd -> data ; print_str ( \"type\" , av_stereo3d_type_name ( stereo -> type ) ) ; print_int ( \"inverted\" , ! ! ( stereo -> flags & AV_STEREO3D_FLAG_INVERT ) ) ; } else if ( sd -> type == AV_PKT_DATA_SPHERICAL ) { const AVSphericalMapping * spherical = ( AVSphericalMapping * ) sd -> data ; print_str ( \"projection\" , av_spherical_projection_name ( spherical -> projection ) ) ; if ( spherical -> projection == AV_SPHERICAL_CUBEMAP ) { print_int ( \"padding\" , spherical -> padding ) ; } else if ( spherical -> projection == AV_SPHERICAL_EQUIRECTANGULAR_TILE ) { size_t l , t , r , b ; av_spherical_tile_bounds ( spherical , par -> width , par -> height , & l , & t , & r , & b ) ; print_int ( \"bound_left\" , l ) ; print_int ( \"bound_top\" , t ) ; print_int ( \"bound_right\" , r ) ; print_int ( \"bound_bottom\" , b ) ; } print_int ( \"yaw\" , ( double ) spherical -> yaw / ( 1 << 16 ) ) ; print_int ( \"pitch\" , ( double ) spherical -> pitch / ( 1 << 16 ) ) ; print_int ( \"roll\" , ( double ) spherical -> roll / ( 1 << 16 ) ) ; } else if ( sd -> type == AV_PKT_DATA_SKIP_SAMPLES && sd -> size == 10 ) { print_int ( \"skip_samples\" , AV_RL32 ( sd -> data ) ) ; print_int ( \"discard_padding\" , AV_RL32 ( sd -> data + 4 ) ) ; print_int ( \"skip_reason\" , AV_RL8 ( sd -> data + 8 ) ) ; print_int ( \"discard_reason\" , AV_RL8 ( sd -> data + 9 ) ) ; } else if ( sd -> type == AV_PKT_DATA_MASTERING_DISPLAY_METADATA ) { AVMasteringDisplayMetadata * metadata = ( AVMasteringDisplayMetadata * ) sd -> data ; if ( metadata -> has_primaries ) { print_q ( \"red_x\" , metadata -> display_primaries [ 0 ] [ 0 ] , '/' ) ; print_q ( \"red_y\" , metadata -> display_primaries [ 0 ] [ 1 ] , '/' ) ; print_q ( \"green_x\" , metadata -> display_primaries [ 1 ] [ 0 ] , '/' ) ; print_q ( \"green_y\" , metadata -> display_primaries [ 1 ] [ 1 ] , '/' ) ; print_q ( \"blue_x\" , metadata -> display_primaries [ 2 ] [ 0 ] , '/' ) ; print_q ( \"blue_y\" , metadata -> display_primaries [ 2 ] [ 1 ] , '/' ) ; print_q ( \"white_point_x\" , metadata -> white_point [ 0 ] , '/' ) ; print_q ( \"white_point_y\" , metadata -> white_point [ 1 ] , '/' ) ; } if ( metadata -> has_luminance ) { print_q ( \"min_luminance\" , metadata -> min_luminance , '/' ) ; print_q ( \"max_luminance\" , metadata -> max_luminance , '/' ) ; } } else if ( sd -> type == AV_PKT_DATA_CONTENT_LIGHT_LEVEL ) { AVContentLightMetadata * metadata = ( AVContentLightMetadata * ) sd -> data ; print_int ( \"max_content\" , metadata -> MaxCLL ) ; print_int ( \"max_average\" , metadata -> MaxFALL ) ; } else if ( sd -> type == AV_PKT_DATA_DOVI_CONF ) { AVDOVIDecoderConfigurationRecord * dovi = ( AVDOVIDecoderConfigurationRecord * ) sd -> data ; print_int ( \"dv_version_major\" , dovi -> dv_version_major ) ; print_int ( \"dv_version_minor\" , dovi -> dv_version_minor ) ; print_int ( \"dv_profile\" , dovi -> dv_profile ) ; print_int ( \"dv_level\" , dovi -> dv_level ) ; print_int ( \"rpu_present_flag\" , dovi -> rpu_present_flag ) ; print_int ( \"el_present_flag\" , dovi -> el_present_flag ) ; print_int ( \"bl_present_flag\" , dovi -> bl_present_flag ) ; print_int ( \"dv_bl_signal_compatibility_id\" , dovi -> dv_bl_signal_compatibility_id ) ; } else if ( sd -> type == AV_PKT_DATA_AUDIO_SERVICE_TYPE ) { enum AVAudioServiceType * t = ( enum AVAudioServiceType * ) sd -> data ; print_int ( \"service_type\" , * t ) ; } else if ( sd -> type == AV_PKT_DATA_MPEGTS_STREAM_ID ) { print_int ( \"id\" , * sd -> data ) ; } else if ( sd -> type == AV_PKT_DATA_CPB_PROPERTIES ) { const AVCPBProperties * prop = ( AVCPBProperties * ) sd -> data ; print_int ( \"max_bitrate\" , prop -> max_bitrate ) ; print_int ( \"min_bitrate\" , prop -> min_bitrate ) ; print_int ( \"avg_bitrate\" , prop -> avg_bitrate ) ; print_int ( \"buffer_size\" , prop -> buffer_size ) ; print_int ( \"vbv_delay\" , prop -> vbv_delay ) ; } else if ( sd -> type == AV_PKT_DATA_WEBVTT_IDENTIFIER || sd -> type == AV_PKT_DATA_WEBVTT_SETTINGS ) { if ( do_show_data ) writer_print_data ( w , \"data\" , sd -> data , sd -> size ) ; writer_print_data_hash ( w , \"data_hash\" , sd -> data , sd -> size ) ; } else if ( sd -> type == AV_PKT_DATA_AFD && sd -> size > 0 ) { print_int ( \"active_format\" , * sd -> data ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@print_color_range": "static void print_color_range ( WriterContext * w , enum AVColorRange color_range ) { const char * val = av_color_range_name ( color_range ) ; if ( ! val || color_range == AVCOL_RANGE_UNSPECIFIED ) { print_str_opt ( \"color_range\" , \"unknown\" ) ; } else { print_str ( \"color_range\" , val ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@print_color_space": "static void print_color_space ( WriterContext * w , enum AVColorSpace color_space ) { const char * val = av_color_space_name ( color_space ) ; if ( ! val || color_space == AVCOL_SPC_UNSPECIFIED ) { print_str_opt ( \"color_space\" , \"unknown\" ) ; } else { print_str ( \"color_space\" , val ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@print_primaries": "static void print_primaries ( WriterContext * w , enum AVColorPrimaries color_primaries ) { const char * val = av_color_primaries_name ( color_primaries ) ; if ( ! val || color_primaries == AVCOL_PRI_UNSPECIFIED ) { print_str_opt ( \"color_primaries\" , \"unknown\" ) ; } else { print_str ( \"color_primaries\" , val ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@print_color_trc": "static void print_color_trc ( WriterContext * w , enum AVColorTransferCharacteristic color_trc ) { const char * val = av_color_transfer_name ( color_trc ) ; if ( ! val || color_trc == AVCOL_TRC_UNSPECIFIED ) { print_str_opt ( \"color_transfer\" , \"unknown\" ) ; } else { print_str ( \"color_transfer\" , val ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@print_chroma_location": "static void print_chroma_location ( WriterContext * w , enum AVChromaLocation chroma_location ) { const char * val = av_chroma_location_name ( chroma_location ) ; if ( ! val || chroma_location == AVCHROMA_LOC_UNSPECIFIED ) { print_str_opt ( \"chroma_location\" , \"unspecified\" ) ; } else { print_str ( \"chroma_location\" , val ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@clear_log": "static void clear_log ( int need_lock ) { int i ; if ( need_lock ) pthread_mutex_lock ( & log_mutex ) ; for ( i = 0 ; i < log_buffer_size ; i ++ ) { av_freep ( & log_buffer [ i ] . context_name ) ; av_freep ( & log_buffer [ i ] . parent_name ) ; av_freep ( & log_buffer [ i ] . log_message ) ; } log_buffer_size = 0 ; if ( need_lock ) pthread_mutex_unlock ( & log_mutex ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_log": "static int show_log ( WriterContext * w , int section_ids , int section_id , int log_level ) { int i ; pthread_mutex_lock ( & log_mutex ) ; if ( ! log_buffer_size ) { pthread_mutex_unlock ( & log_mutex ) ; return 0 ; } writer_print_section_header ( w , section_ids ) ; for ( i = 0 ; i < log_buffer_size ; i ++ ) { if ( log_buffer [ i ] . log_level <= log_level ) { writer_print_section_header ( w , section_id ) ; print_str ( \"context\" , log_buffer [ i ] . context_name ) ; print_int ( \"level\" , log_buffer [ i ] . log_level ) ; print_int ( \"category\" , log_buffer [ i ] . category ) ; if ( log_buffer [ i ] . parent_name ) { print_str ( \"parent_context\" , log_buffer [ i ] . parent_name ) ; print_int ( \"parent_category\" , log_buffer [ i ] . parent_category ) ; } else { print_str_opt ( \"parent_context\" , \"N/A\" ) ; print_str_opt ( \"parent_category\" , \"N/A\" ) ; } print_str ( \"message\" , log_buffer [ i ] . log_message ) ; writer_print_section_footer ( w ) ; } } clear_log ( 0 ) ; pthread_mutex_unlock ( & log_mutex ) ; writer_print_section_footer ( w ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_packet": "static void show_packet ( WriterContext * w , InputFile * ifile , AVPacket * pkt , int packet_idx ) { char val_str [ 128 ] ; AVStream * st = ifile -> streams [ pkt -> stream_index ] . st ; AVBPrint pbuf ; const char * s ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_PACKET ) ; s = av_get_media_type_string ( st -> codecpar -> codec_type ) ; if ( s ) print_str ( \"codec_type\" , s ) ; else print_str_opt ( \"codec_type\" , \"unknown\" ) ; print_int ( \"stream_index\" , pkt -> stream_index ) ; print_ts ( \"pts\" , pkt -> pts ) ; print_time ( \"pts_time\" , pkt -> pts , & st -> time_base ) ; print_ts ( \"dts\" , pkt -> dts ) ; print_time ( \"dts_time\" , pkt -> dts , & st -> time_base ) ; print_duration_ts ( \"duration\" , pkt -> duration ) ; print_duration_time ( \"duration_time\" , pkt -> duration , & st -> time_base ) ; print_val ( \"size\" , pkt -> size , unit_byte_str ) ; if ( pkt -> pos != - 1 ) print_fmt ( \"pos\" , \"%\" PRId64 , pkt -> pos ) ; else print_str_opt ( \"pos\" , \"N/A\" ) ; print_fmt ( \"flags\" , \"%c%c%c\" , pkt -> flags & AV_PKT_FLAG_KEY ? 'K' : '_' , pkt -> flags & AV_PKT_FLAG_DISCARD ? 'D' : '_' , pkt -> flags & AV_PKT_FLAG_CORRUPT ? 'C' : '_' ) ; if ( do_show_data ) writer_print_data ( w , \"data\" , pkt -> data , pkt -> size ) ; writer_print_data_hash ( w , \"data_hash\" , pkt -> data , pkt -> size ) ; if ( pkt -> side_data_elems ) { size_t size ; const uint8_t * side_metadata ; side_metadata = av_packet_get_side_data ( pkt , AV_PKT_DATA_STRINGS_METADATA , & size ) ; if ( side_metadata && size && do_show_packet_tags ) { AVDictionary * dict = NULL ; if ( av_packet_unpack_dictionary ( side_metadata , size , & dict ) >= 0 ) show_tags ( w , dict , SECTION_ID_PACKET_TAGS ) ; av_dict_free ( & dict ) ; } print_pkt_side_data ( w , st -> codecpar , pkt -> side_data , pkt -> side_data_elems , SECTION_ID_PACKET_SIDE_DATA_LIST , SECTION_ID_PACKET_SIDE_DATA ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_subtitle": "static void show_subtitle ( WriterContext * w , AVSubtitle * sub , AVStream * stream , AVFormatContext * fmt_ctx ) { AVBPrint pbuf ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_SUBTITLE ) ; print_str ( \"media_type\" , \"subtitle\" ) ; print_ts ( \"pts\" , sub -> pts ) ; print_time ( \"pts_time\" , sub -> pts , & AV_TIME_BASE_Q ) ; print_int ( \"format\" , sub -> format ) ; print_int ( \"start_display_time\" , sub -> start_display_time ) ; print_int ( \"end_display_time\" , sub -> end_display_time ) ; print_int ( \"num_rects\" , sub -> num_rects ) ; writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_frame": "static void show_frame ( WriterContext * w , AVFrame * frame , AVStream * stream , AVFormatContext * fmt_ctx ) { AVBPrint pbuf ; char val_str [ 128 ] ; const char * s ; int i ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_FRAME ) ; s = av_get_media_type_string ( stream -> codecpar -> codec_type ) ; if ( s ) print_str ( \"media_type\" , s ) ; else print_str_opt ( \"media_type\" , \"unknown\" ) ; print_int ( \"stream_index\" , stream -> index ) ; print_int ( \"key_frame\" , frame -> key_frame ) ; print_ts ( \"pts\" , frame -> pts ) ; print_time ( \"pts_time\" , frame -> pts , & stream -> time_base ) ; print_ts ( \"pkt_dts\" , frame -> pkt_dts ) ; print_time ( \"pkt_dts_time\" , frame -> pkt_dts , & stream -> time_base ) ; print_ts ( \"best_effort_timestamp\" , frame -> best_effort_timestamp ) ; print_time ( \"best_effort_timestamp_time\" , frame -> best_effort_timestamp , & stream -> time_base ) ; # if LIBAVUTIL_VERSION_MAJOR < 59 AV_NOWARN_DEPRECATED ( print_duration_ts ( \"pkt_duration\" , frame -> pkt_duration ) ; print_duration_time ( \"pkt_duration_time\" , frame -> pkt_duration , & stream -> time_base ) ; ) # endif print_duration_ts ( \"duration\" , frame -> duration ) ; print_duration_time ( \"duration_time\" , frame -> duration , & stream -> time_base ) ; if ( frame -> pkt_pos != - 1 ) print_fmt ( \"pkt_pos\" , \"%\" PRId64 , frame -> pkt_pos ) ; else print_str_opt ( \"pkt_pos\" , \"N/A\" ) ; if ( frame -> pkt_size != - 1 ) print_val ( \"pkt_size\" , frame -> pkt_size , unit_byte_str ) ; else print_str_opt ( \"pkt_size\" , \"N/A\" ) ; switch ( stream -> codecpar -> codec_type ) { AVRational sar ; case AVMEDIA_TYPE_VIDEO : print_int ( \"width\" , frame -> width ) ; print_int ( \"height\" , frame -> height ) ; s = av_get_pix_fmt_name ( frame -> format ) ; if ( s ) print_str ( \"pix_fmt\" , s ) ; else print_str_opt ( \"pix_fmt\" , \"unknown\" ) ; sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , frame ) ; if ( sar . num ) { print_q ( \"sample_aspect_ratio\" , sar , ':' ) ; } else { print_str_opt ( \"sample_aspect_ratio\" , \"N/A\" ) ; } print_fmt ( \"pict_type\" , \"%c\" , av_get_picture_type_char ( frame -> pict_type ) ) ; # if LIBAVUTIL_VERSION_MAJOR < 59 AV_NOWARN_DEPRECATED ( print_int ( \"coded_picture_number\" , frame -> coded_picture_number ) ; print_int ( \"display_picture_number\" , frame -> display_picture_number ) ; ) # endif print_int ( \"interlaced_frame\" , frame -> interlaced_frame ) ; print_int ( \"top_field_first\" , frame -> top_field_first ) ; print_int ( \"repeat_pict\" , frame -> repeat_pict ) ; print_color_range ( w , frame -> color_range ) ; print_color_space ( w , frame -> colorspace ) ; print_primaries ( w , frame -> color_primaries ) ; print_color_trc ( w , frame -> color_trc ) ; print_chroma_location ( w , frame -> chroma_location ) ; break ; case AVMEDIA_TYPE_AUDIO : s = av_get_sample_fmt_name ( frame -> format ) ; if ( s ) print_str ( \"sample_fmt\" , s ) ; else print_str_opt ( \"sample_fmt\" , \"unknown\" ) ; print_int ( \"nb_samples\" , frame -> nb_samples ) ; print_int ( \"channels\" , frame -> ch_layout . nb_channels ) ; if ( frame -> ch_layout . order != AV_CHANNEL_ORDER_UNSPEC ) { av_channel_layout_describe ( & frame -> ch_layout , val_str , sizeof ( val_str ) ) ; print_str ( \"channel_layout\" , val_str ) ; } else print_str_opt ( \"channel_layout\" , \"unknown\" ) ; break ; } if ( do_show_frame_tags ) show_tags ( w , frame -> metadata , SECTION_ID_FRAME_TAGS ) ; if ( do_show_log ) show_log ( w , SECTION_ID_FRAME_LOGS , SECTION_ID_FRAME_LOG , do_show_log ) ; if ( frame -> nb_side_data ) { writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_LIST ) ; for ( i = 0 ; i < frame -> nb_side_data ; i ++ ) { AVFrameSideData * sd = frame -> side_data [ i ] ; const char * name ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA ) ; name = av_frame_side_data_name ( sd -> type ) ; print_str ( \"side_data_type\" , name ? name : \"unknown\" ) ; if ( sd -> type == AV_FRAME_DATA_DISPLAYMATRIX && sd -> size >= 9 * 4 ) { double rotation = av_display_rotation_get ( ( int32_t * ) sd -> data ) ; if ( isnan ( rotation ) ) rotation = 0 ; writer_print_integers ( w , \"displaymatrix\" , sd -> data , 9 , \" %11d\" , 3 , 4 , 1 ) ; print_int ( \"rotation\" , rotation ) ; } else if ( sd -> type == AV_FRAME_DATA_AFD && sd -> size > 0 ) { print_int ( \"active_format\" , * sd -> data ) ; } else if ( sd -> type == AV_FRAME_DATA_GOP_TIMECODE && sd -> size >= 8 ) { char tcbuf [ AV_TIMECODE_STR_SIZE ] ; av_timecode_make_mpeg_tc_string ( tcbuf , * ( int64_t * ) ( sd -> data ) ) ; print_str ( \"timecode\" , tcbuf ) ; } else if ( sd -> type == AV_FRAME_DATA_S12M_TIMECODE && sd -> size == 16 ) { uint32_t * tc = ( uint32_t * ) sd -> data ; int m = FFMIN ( tc [ 0 ] , 3 ) ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_TIMECODE_LIST ) ; for ( int j = 1 ; j <= m ; j ++ ) { char tcbuf [ AV_TIMECODE_STR_SIZE ] ; av_timecode_make_smpte_tc_string2 ( tcbuf , stream -> avg_frame_rate , tc [ j ] , 0 , 0 ) ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_TIMECODE ) ; print_str ( \"value\" , tcbuf ) ; writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } else if ( sd -> type == AV_FRAME_DATA_MASTERING_DISPLAY_METADATA ) { AVMasteringDisplayMetadata * metadata = ( AVMasteringDisplayMetadata * ) sd -> data ; if ( metadata -> has_primaries ) { print_q ( \"red_x\" , metadata -> display_primaries [ 0 ] [ 0 ] , '/' ) ; print_q ( \"red_y\" , metadata -> display_primaries [ 0 ] [ 1 ] , '/' ) ; print_q ( \"green_x\" , metadata -> display_primaries [ 1 ] [ 0 ] , '/' ) ; print_q ( \"green_y\" , metadata -> display_primaries [ 1 ] [ 1 ] , '/' ) ; print_q ( \"blue_x\" , metadata -> display_primaries [ 2 ] [ 0 ] , '/' ) ; print_q ( \"blue_y\" , metadata -> display_primaries [ 2 ] [ 1 ] , '/' ) ; print_q ( \"white_point_x\" , metadata -> white_point [ 0 ] , '/' ) ; print_q ( \"white_point_y\" , metadata -> white_point [ 1 ] , '/' ) ; } if ( metadata -> has_luminance ) { print_q ( \"min_luminance\" , metadata -> min_luminance , '/' ) ; print_q ( \"max_luminance\" , metadata -> max_luminance , '/' ) ; } } else if ( sd -> type == AV_FRAME_DATA_DYNAMIC_HDR_PLUS ) { AVDynamicHDRPlus * metadata = ( AVDynamicHDRPlus * ) sd -> data ; print_dynamic_hdr10_plus ( w , metadata ) ; } else if ( sd -> type == AV_FRAME_DATA_CONTENT_LIGHT_LEVEL ) { AVContentLightMetadata * metadata = ( AVContentLightMetadata * ) sd -> data ; print_int ( \"max_content\" , metadata -> MaxCLL ) ; print_int ( \"max_average\" , metadata -> MaxFALL ) ; } else if ( sd -> type == AV_FRAME_DATA_ICC_PROFILE ) { const AVDictionaryEntry * tag = av_dict_get ( sd -> metadata , \"name\" , NULL , AV_DICT_MATCH_CASE ) ; if ( tag ) print_str ( tag -> key , tag -> value ) ; print_int ( \"size\" , sd -> size ) ; } else if ( sd -> type == AV_FRAME_DATA_DOVI_METADATA ) { print_dovi_metadata ( w , ( const AVDOVIMetadata * ) sd -> data ) ; } else if ( sd -> type == AV_FRAME_DATA_DYNAMIC_HDR_VIVID ) { AVDynamicHDRVivid * metadata = ( AVDynamicHDRVivid * ) sd -> data ; print_dynamic_hdr_vivid ( w , metadata ) ; } else if ( sd -> type == AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT ) { print_ambient_viewing_environment ( w , ( const AVAmbientViewingEnvironment * ) sd -> data ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@process_frame": "static av_always_inline int process_frame ( WriterContext * w , InputFile * ifile , AVFrame * frame , const AVPacket * pkt , int * packet_new ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; AVCodecContext * dec_ctx = ifile -> streams [ pkt -> stream_index ] . dec_ctx ; AVCodecParameters * par = ifile -> streams [ pkt -> stream_index ] . st -> codecpar ; AVSubtitle sub ; int ret = 0 , got_frame = 0 ; clear_log ( 1 ) ; if ( dec_ctx ) { switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : case AVMEDIA_TYPE_AUDIO : if ( * packet_new ) { ret = avcodec_send_packet ( dec_ctx , pkt ) ; if ( ret == AVERROR ( EAGAIN ) ) { ret = 0 ; } else if ( ret >= 0 || ret == AVERROR_EOF ) { ret = 0 ; * packet_new = 0 ; } } if ( ret >= 0 ) { ret = avcodec_receive_frame ( dec_ctx , frame ) ; if ( ret >= 0 ) { got_frame = 1 ; } else if ( ret == AVERROR ( EAGAIN ) || ret == AVERROR_EOF ) { ret = 0 ; } } break ; case AVMEDIA_TYPE_SUBTITLE : if ( * packet_new ) ret = avcodec_decode_subtitle2 ( dec_ctx , & sub , & got_frame , pkt ) ; * packet_new = 0 ; break ; default : * packet_new = 0 ; } } else { * packet_new = 0 ; } if ( ret < 0 ) return ret ; if ( got_frame ) { int is_sub = ( par -> codec_type == AVMEDIA_TYPE_SUBTITLE ) ; nb_streams_frames [ pkt -> stream_index ] ++ ; if ( do_show_frames ) { if ( is_sub ) { show_subtitle ( w , & sub , ifile -> streams [ pkt -> stream_index ] . st , fmt_ctx ) ; } else { show_frame ( w , frame , ifile -> streams [ pkt -> stream_index ] . st , fmt_ctx ) ; } } if ( is_sub ) { avsubtitle_free ( & sub ) ; } } return got_frame || * packet_new ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@log_read_interval": "static void log_read_interval ( const ReadInterval * interval , void * log_ctx , int log_level ) { av_log ( log_ctx , log_level , \"id:%d\" , interval -> id ) ; if ( interval -> has_start ) { av_log ( log_ctx , log_level , \" start:%s%s\" , interval -> start_is_offset ? \"+\" : \"\" , av_ts2timestr ( interval -> start , & AV_TIME_BASE_Q ) ) ; } else { av_log ( log_ctx , log_level , \" start:N/A\" ) ; } if ( interval -> has_end ) { av_log ( log_ctx , log_level , \" end:%s\" , interval -> end_is_offset ? \"+\" : \"\" ) ; if ( interval -> duration_frames ) av_log ( log_ctx , log_level , \"#%\" PRId64 , interval -> end ) ; else av_log ( log_ctx , log_level , \"%s\" , av_ts2timestr ( interval -> end , & AV_TIME_BASE_Q ) ) ; } else { av_log ( log_ctx , log_level , \" end:N/A\" ) ; } av_log ( log_ctx , log_level , \"\\n\" ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@read_interval_packets": "static int read_interval_packets ( WriterContext * w , InputFile * ifile , const ReadInterval * interval , int64_t * cur_ts ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; AVPacket * pkt = NULL ; AVFrame * frame = NULL ; int ret = 0 , i = 0 , frame_count = 0 ; int64_t start = - INT64_MAX , end = interval -> end ; int has_start = 0 , has_end = interval -> has_end && ! interval -> end_is_offset ; av_log ( NULL , AV_LOG_VERBOSE , \"Processing read interval \" ) ; log_read_interval ( interval , NULL , AV_LOG_VERBOSE ) ; if ( interval -> has_start ) { int64_t target ; if ( interval -> start_is_offset ) { if ( * cur_ts == AV_NOPTS_VALUE ) { av_log ( NULL , AV_LOG_ERROR , \"Could not seek to relative position since current \" \"timestamp is not defined\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto end ; } target = * cur_ts + interval -> start ; } else { target = interval -> start ; } av_log ( NULL , AV_LOG_VERBOSE , \"Seeking to read interval start point %s\\n\" , av_ts2timestr ( target , & AV_TIME_BASE_Q ) ) ; if ( ( ret = avformat_seek_file ( fmt_ctx , - 1 , - INT64_MAX , target , INT64_MAX , 0 ) ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Could not seek to position %\" PRId64 \": %s\\n\" , interval -> start , av_err2str ( ret ) ) ; goto end ; } } frame = av_frame_alloc ( ) ; if ( ! frame ) { ret = AVERROR ( ENOMEM ) ; goto end ; } pkt = av_packet_alloc ( ) ; if ( ! pkt ) { ret = AVERROR ( ENOMEM ) ; goto end ; } while ( ! av_read_frame ( fmt_ctx , pkt ) ) { if ( fmt_ctx -> nb_streams > nb_streams ) { REALLOCZ_ARRAY_STREAM ( nb_streams_frames , nb_streams , fmt_ctx -> nb_streams ) ; REALLOCZ_ARRAY_STREAM ( nb_streams_packets , nb_streams , fmt_ctx -> nb_streams ) ; REALLOCZ_ARRAY_STREAM ( selected_streams , nb_streams , fmt_ctx -> nb_streams ) ; nb_streams = fmt_ctx -> nb_streams ; } if ( selected_streams [ pkt -> stream_index ] ) { AVRational tb = ifile -> streams [ pkt -> stream_index ] . st -> time_base ; int64_t pts = pkt -> pts != AV_NOPTS_VALUE ? pkt -> pts : pkt -> dts ; if ( pts != AV_NOPTS_VALUE ) * cur_ts = av_rescale_q ( pts , tb , AV_TIME_BASE_Q ) ; if ( ! has_start && * cur_ts != AV_NOPTS_VALUE ) { start = * cur_ts ; has_start = 1 ; } if ( has_start && ! has_end && interval -> end_is_offset ) { end = start + interval -> end ; has_end = 1 ; } if ( interval -> end_is_offset && interval -> duration_frames ) { if ( frame_count >= interval -> end ) break ; } else if ( has_end && * cur_ts != AV_NOPTS_VALUE && * cur_ts >= end ) { break ; } frame_count ++ ; if ( do_read_packets ) { if ( do_show_packets ) show_packet ( w , ifile , pkt , i ++ ) ; nb_streams_packets [ pkt -> stream_index ] ++ ; } if ( do_read_frames ) { int packet_new = 1 ; while ( process_frame ( w , ifile , frame , pkt , & packet_new ) > 0 ) ; } } av_packet_unref ( pkt ) ; } av_packet_unref ( pkt ) ; //Flush remaining frames that are cached in the decoder for ( i = 0 ; i < ifile -> nb_streams ; i ++ ) { pkt -> stream_index = i ; if ( do_read_frames ) { while ( process_frame ( w , ifile , frame , pkt , & ( int ) { 1 } ) > 0 ) ; if ( ifile -> streams [ i ] . dec_ctx ) avcodec_flush_buffers ( ifile -> streams [ i ] . dec_ctx ) ; } } end : av_frame_free ( & frame ) ; av_packet_free ( & pkt ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Could not read packets in interval \" ) ; log_read_interval ( interval , NULL , AV_LOG_ERROR ) ; } return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@read_packets": "static int read_packets ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; int64_t cur_ts = fmt_ctx -> start_time ; if ( read_intervals_nb == 0 ) { ReadInterval interval = ( ReadInterval ) { . has_start = 0 , . has_end = 0 } ; ret = read_interval_packets ( w , ifile , & interval , & cur_ts ) ; } else { for ( i = 0 ; i < read_intervals_nb ; i ++ ) { ret = read_interval_packets ( w , ifile , & read_intervals [ i ] , & cur_ts ) ; if ( ret < 0 ) break ; } } return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_stream": "static int show_stream ( WriterContext * w , AVFormatContext * fmt_ctx , int stream_idx , InputStream * ist , int in_program ) { AVStream * stream = ist -> st ; AVCodecParameters * par ; AVCodecContext * dec_ctx ; char val_str [ 128 ] ; const char * s ; AVRational sar , dar ; AVBPrint pbuf ; const AVCodecDescriptor * cd ; int ret = 0 ; const char * profile = NULL ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM ) ; print_int ( \"index\" , stream -> index ) ; par = stream -> codecpar ; dec_ctx = ist -> dec_ctx ; if ( ( cd = avcodec_descriptor_get ( par -> codec_id ) ) ) { print_str ( \"codec_name\" , cd -> name ) ; if ( ! do_bitexact ) { print_str ( \"codec_long_name\" , cd -> long_name ? cd -> long_name : \"unknown\" ) ; } } else { print_str_opt ( \"codec_name\" , \"unknown\" ) ; if ( ! do_bitexact ) { print_str_opt ( \"codec_long_name\" , \"unknown\" ) ; } } if ( ! do_bitexact && ( profile = avcodec_profile_name ( par -> codec_id , par -> profile ) ) ) print_str ( \"profile\" , profile ) ; else { if ( par -> profile != FF_PROFILE_UNKNOWN ) { char profile_num [ 12 ] ; snprintf ( profile_num , sizeof ( profile_num ) , \"%d\" , par -> profile ) ; print_str ( \"profile\" , profile_num ) ; } else print_str_opt ( \"profile\" , \"unknown\" ) ; } s = av_get_media_type_string ( par -> codec_type ) ; if ( s ) print_str ( \"codec_type\" , s ) ; else print_str_opt ( \"codec_type\" , \"unknown\" ) ; /* print AVI/FourCC tag */ print_str ( \"codec_tag_string\" , av_fourcc2str ( par -> codec_tag ) ) ; print_fmt ( \"codec_tag\" , \"0x%04\" PRIx32 , par -> codec_tag ) ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : print_int ( \"width\" , par -> width ) ; print_int ( \"height\" , par -> height ) ; if ( dec_ctx ) { print_int ( \"coded_width\" , dec_ctx -> coded_width ) ; print_int ( \"coded_height\" , dec_ctx -> coded_height ) ; print_int ( \"closed_captions\" , ! ! ( dec_ctx -> properties & FF_CODEC_PROPERTY_CLOSED_CAPTIONS ) ) ; print_int ( \"film_grain\" , ! ! ( dec_ctx -> properties & FF_CODEC_PROPERTY_FILM_GRAIN ) ) ; } print_int ( \"has_b_frames\" , par -> video_delay ) ; sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , NULL ) ; if ( sar . num ) { print_q ( \"sample_aspect_ratio\" , sar , ':' ) ; av_reduce ( & dar . num , & dar . den , par -> width * sar . num , par -> height * sar . den , 1024 * 1024 ) ; print_q ( \"display_aspect_ratio\" , dar , ':' ) ; } else { print_str_opt ( \"sample_aspect_ratio\" , \"N/A\" ) ; print_str_opt ( \"display_aspect_ratio\" , \"N/A\" ) ; } s = av_get_pix_fmt_name ( par -> format ) ; if ( s ) print_str ( \"pix_fmt\" , s ) ; else print_str_opt ( \"pix_fmt\" , \"unknown\" ) ; print_int ( \"level\" , par -> level ) ; print_color_range ( w , par -> color_range ) ; print_color_space ( w , par -> color_space ) ; print_color_trc ( w , par -> color_trc ) ; print_primaries ( w , par -> color_primaries ) ; print_chroma_location ( w , par -> chroma_location ) ; if ( par -> field_order == AV_FIELD_PROGRESSIVE ) print_str ( \"field_order\" , \"progressive\" ) ; else if ( par -> field_order == AV_FIELD_TT ) print_str ( \"field_order\" , \"tt\" ) ; else if ( par -> field_order == AV_FIELD_BB ) print_str ( \"field_order\" , \"bb\" ) ; else if ( par -> field_order == AV_FIELD_TB ) print_str ( \"field_order\" , \"tb\" ) ; else if ( par -> field_order == AV_FIELD_BT ) print_str ( \"field_order\" , \"bt\" ) ; else print_str_opt ( \"field_order\" , \"unknown\" ) ; if ( dec_ctx ) print_int ( \"refs\" , dec_ctx -> refs ) ; break ; case AVMEDIA_TYPE_AUDIO : s = av_get_sample_fmt_name ( par -> format ) ; if ( s ) print_str ( \"sample_fmt\" , s ) ; else print_str_opt ( \"sample_fmt\" , \"unknown\" ) ; print_val ( \"sample_rate\" , par -> sample_rate , unit_hertz_str ) ; print_int ( \"channels\" , par -> ch_layout . nb_channels ) ; if ( par -> ch_layout . order != AV_CHANNEL_ORDER_UNSPEC ) { av_channel_layout_describe ( & par -> ch_layout , val_str , sizeof ( val_str ) ) ; print_str ( \"channel_layout\" , val_str ) ; } else { print_str_opt ( \"channel_layout\" , \"unknown\" ) ; } print_int ( \"bits_per_sample\" , av_get_bits_per_sample ( par -> codec_id ) ) ; print_int ( \"initial_padding\" , par -> initial_padding ) ; break ; case AVMEDIA_TYPE_SUBTITLE : if ( par -> width ) print_int ( \"width\" , par -> width ) ; else print_str_opt ( \"width\" , \"N/A\" ) ; if ( par -> height ) print_int ( \"height\" , par -> height ) ; else print_str_opt ( \"height\" , \"N/A\" ) ; break ; } if ( dec_ctx && dec_ctx -> codec -> priv_class && show_private_data ) { const AVOption * opt = NULL ; while ( ( opt = av_opt_next ( dec_ctx -> priv_data , opt ) ) ) { uint8_t * str ; if ( ! ( opt -> flags & AV_OPT_FLAG_EXPORT ) ) continue ; if ( av_opt_get ( dec_ctx -> priv_data , opt -> name , 0 , & str ) >= 0 ) { print_str ( opt -> name , str ) ; av_free ( str ) ; } } } if ( fmt_ctx -> iformat -> flags & AVFMT_SHOW_IDS ) print_fmt ( \"id\" , \"0x%x\" , stream -> id ) ; else print_str_opt ( \"id\" , \"N/A\" ) ; print_q ( \"r_frame_rate\" , stream -> r_frame_rate , '/' ) ; print_q ( \"avg_frame_rate\" , stream -> avg_frame_rate , '/' ) ; print_q ( \"time_base\" , stream -> time_base , '/' ) ; print_ts ( \"start_pts\" , stream -> start_time ) ; print_time ( \"start_time\" , stream -> start_time , & stream -> time_base ) ; print_ts ( \"duration_ts\" , stream -> duration ) ; print_time ( \"duration\" , stream -> duration , & stream -> time_base ) ; if ( par -> bit_rate > 0 ) print_val ( \"bit_rate\" , par -> bit_rate , unit_bit_per_second_str ) ; else print_str_opt ( \"bit_rate\" , \"N/A\" ) ; if ( dec_ctx && dec_ctx -> rc_max_rate > 0 ) print_val ( \"max_bit_rate\" , dec_ctx -> rc_max_rate , unit_bit_per_second_str ) ; else print_str_opt ( \"max_bit_rate\" , \"N/A\" ) ; if ( dec_ctx && dec_ctx -> bits_per_raw_sample > 0 ) print_fmt ( \"bits_per_raw_sample\" , \"%d\" , dec_ctx -> bits_per_raw_sample ) ; else print_str_opt ( \"bits_per_raw_sample\" , \"N/A\" ) ; if ( stream -> nb_frames ) print_fmt ( \"nb_frames\" , \"%\" PRId64 , stream -> nb_frames ) ; else print_str_opt ( \"nb_frames\" , \"N/A\" ) ; if ( nb_streams_frames [ stream_idx ] ) print_fmt ( \"nb_read_frames\" , \"%\" PRIu64 , nb_streams_frames [ stream_idx ] ) ; else print_str_opt ( \"nb_read_frames\" , \"N/A\" ) ; if ( nb_streams_packets [ stream_idx ] ) print_fmt ( \"nb_read_packets\" , \"%\" PRIu64 , nb_streams_packets [ stream_idx ] ) ; else print_str_opt ( \"nb_read_packets\" , \"N/A\" ) ; if ( do_show_data ) writer_print_data ( w , \"extradata\" , par -> extradata , par -> extradata_size ) ; if ( par -> extradata_size > 0 ) { print_int ( \"extradata_size\" , par -> extradata_size ) ; writer_print_data_hash ( w , \"extradata_hash\" , par -> extradata , par -> extradata_size ) ; } /* Print disposition information */ # define PRINT_DISPOSITION ( flagname , name ) do { print_int ( name , ! ! ( stream -> disposition & AV_DISPOSITION_ ## flagname ) ) ; } while ( 0 ) if ( do_show_stream_disposition ) { writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION ) ; PRINT_DISPOSITION ( DEFAULT , \"default\" ) ; PRINT_DISPOSITION ( DUB , \"dub\" ) ; PRINT_DISPOSITION ( ORIGINAL , \"original\" ) ; PRINT_DISPOSITION ( COMMENT , \"comment\" ) ; PRINT_DISPOSITION ( LYRICS , \"lyrics\" ) ; PRINT_DISPOSITION ( KARAOKE , \"karaoke\" ) ; PRINT_DISPOSITION ( FORCED , \"forced\" ) ; PRINT_DISPOSITION ( HEARING_IMPAIRED , \"hearing_impaired\" ) ; PRINT_DISPOSITION ( VISUAL_IMPAIRED , \"visual_impaired\" ) ; PRINT_DISPOSITION ( CLEAN_EFFECTS , \"clean_effects\" ) ; PRINT_DISPOSITION ( ATTACHED_PIC , \"attached_pic\" ) ; PRINT_DISPOSITION ( TIMED_THUMBNAILS , \"timed_thumbnails\" ) ; PRINT_DISPOSITION ( CAPTIONS , \"captions\" ) ; PRINT_DISPOSITION ( DESCRIPTIONS , \"descriptions\" ) ; PRINT_DISPOSITION ( METADATA , \"metadata\" ) ; PRINT_DISPOSITION ( DEPENDENT , \"dependent\" ) ; PRINT_DISPOSITION ( STILL_IMAGE , \"still_image\" ) ; writer_print_section_footer ( w ) ; } if ( do_show_stream_tags ) ret = show_tags ( w , stream -> metadata , in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS ) ; if ( stream -> nb_side_data ) { print_pkt_side_data ( w , stream -> codecpar , stream -> side_data , stream -> nb_side_data , SECTION_ID_STREAM_SIDE_DATA_LIST , SECTION_ID_STREAM_SIDE_DATA ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_streams": "static int show_streams ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; writer_print_section_header ( w , SECTION_ID_STREAMS ) ; for ( i = 0 ; i < ifile -> nb_streams ; i ++ ) if ( selected_streams [ i ] ) { ret = show_stream ( w , fmt_ctx , i , & ifile -> streams [ i ] , 0 ) ; if ( ret < 0 ) break ; } writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_program": "static int show_program ( WriterContext * w , InputFile * ifile , AVProgram * program ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; writer_print_section_header ( w , SECTION_ID_PROGRAM ) ; print_int ( \"program_id\" , program -> id ) ; print_int ( \"program_num\" , program -> program_num ) ; print_int ( \"nb_streams\" , program -> nb_stream_indexes ) ; print_int ( \"pmt_pid\" , program -> pmt_pid ) ; print_int ( \"pcr_pid\" , program -> pcr_pid ) ; if ( do_show_program_tags ) ret = show_tags ( w , program -> metadata , SECTION_ID_PROGRAM_TAGS ) ; if ( ret < 0 ) goto end ; writer_print_section_header ( w , SECTION_ID_PROGRAM_STREAMS ) ; for ( i = 0 ; i < program -> nb_stream_indexes ; i ++ ) { if ( selected_streams [ program -> stream_index [ i ] ] ) { ret = show_stream ( w , fmt_ctx , program -> stream_index [ i ] , & ifile -> streams [ program -> stream_index [ i ] ] , 1 ) ; if ( ret < 0 ) break ; } } writer_print_section_footer ( w ) ; end : writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_programs": "static int show_programs ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; writer_print_section_header ( w , SECTION_ID_PROGRAMS ) ; for ( i = 0 ; i < fmt_ctx -> nb_programs ; i ++ ) { AVProgram * program = fmt_ctx -> programs [ i ] ; if ( ! program ) continue ; ret = show_program ( w , ifile , program ) ; if ( ret < 0 ) break ; } writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_chapters": "static int show_chapters ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; writer_print_section_header ( w , SECTION_ID_CHAPTERS ) ; for ( i = 0 ; i < fmt_ctx -> nb_chapters ; i ++ ) { AVChapter * chapter = fmt_ctx -> chapters [ i ] ; writer_print_section_header ( w , SECTION_ID_CHAPTER ) ; print_int ( \"id\" , chapter -> id ) ; print_q ( \"time_base\" , chapter -> time_base , '/' ) ; print_int ( \"start\" , chapter -> start ) ; print_time ( \"start_time\" , chapter -> start , & chapter -> time_base ) ; print_int ( \"end\" , chapter -> end ) ; print_time ( \"end_time\" , chapter -> end , & chapter -> time_base ) ; if ( do_show_chapter_tags ) ret = show_tags ( w , chapter -> metadata , SECTION_ID_CHAPTER_TAGS ) ; writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_format": "static int show_format ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; char val_str [ 128 ] ; int64_t size = fmt_ctx -> pb ? avio_size ( fmt_ctx -> pb ) : - 1 ; int ret = 0 ; writer_print_section_header ( w , SECTION_ID_FORMAT ) ; print_str_validate ( \"filename\" , fmt_ctx -> url ) ; print_int ( \"nb_streams\" , fmt_ctx -> nb_streams ) ; print_int ( \"nb_programs\" , fmt_ctx -> nb_programs ) ; print_str ( \"format_name\" , fmt_ctx -> iformat -> name ) ; if ( ! do_bitexact ) { if ( fmt_ctx -> iformat -> long_name ) print_str ( \"format_long_name\" , fmt_ctx -> iformat -> long_name ) ; else print_str_opt ( \"format_long_name\" , \"unknown\" ) ; } print_time ( \"start_time\" , fmt_ctx -> start_time , & AV_TIME_BASE_Q ) ; print_time ( \"duration\" , fmt_ctx -> duration , & AV_TIME_BASE_Q ) ; if ( size >= 0 ) print_val ( \"size\" , size , unit_byte_str ) ; else print_str_opt ( \"size\" , \"N/A\" ) ; if ( fmt_ctx -> bit_rate > 0 ) print_val ( \"bit_rate\" , fmt_ctx -> bit_rate , unit_bit_per_second_str ) ; else print_str_opt ( \"bit_rate\" , \"N/A\" ) ; print_int ( \"probe_score\" , fmt_ctx -> probe_score ) ; if ( do_show_format_tags ) ret = show_tags ( w , fmt_ctx -> metadata , SECTION_ID_FORMAT_TAGS ) ; writer_print_section_footer ( w ) ; fflush ( stdout ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_error": "static void show_error ( WriterContext * w , int err ) { writer_print_section_header ( w , SECTION_ID_ERROR ) ; print_int ( \"code\" , err ) ; print_str ( \"string\" , av_err2str ( err ) ) ; writer_print_section_footer ( w ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@open_input_file": "static int open_input_file ( InputFile * ifile , const char * filename , const char * print_filename ) { int err , i ; AVFormatContext * fmt_ctx = NULL ; const AVDictionaryEntry * t = NULL ; int scan_all_pmts_set = 0 ; fmt_ctx = avformat_alloc_context ( ) ; if ( ! fmt_ctx ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( ! av_dict_get ( format_opts , \"scan_all_pmts\" , NULL , AV_DICT_MATCH_CASE ) ) { av_dict_set ( & format_opts , \"scan_all_pmts\" , \"1\" , AV_DICT_DONT_OVERWRITE ) ; scan_all_pmts_set = 1 ; } if ( ( err = avformat_open_input ( & fmt_ctx , filename , iformat , & format_opts ) ) < 0 ) { print_error ( filename , err ) ; return err ; } if ( print_filename ) { av_freep ( & fmt_ctx -> url ) ; fmt_ctx -> url = av_strdup ( print_filename ) ; } ifile -> fmt_ctx = fmt_ctx ; if ( scan_all_pmts_set ) av_dict_set ( & format_opts , \"scan_all_pmts\" , NULL , AV_DICT_MATCH_CASE ) ; while ( ( t = av_dict_iterate ( format_opts , t ) ) ) av_log ( NULL , AV_LOG_WARNING , \"Option %s skipped - not known to demuxer.\\n\" , t -> key ) ; if ( find_stream_info ) { AVDictionary * * opts = setup_find_stream_info_opts ( fmt_ctx , codec_opts ) ; int orig_nb_streams = fmt_ctx -> nb_streams ; err = avformat_find_stream_info ( fmt_ctx , opts ) ; for ( i = 0 ; i < orig_nb_streams ; i ++ ) av_dict_free ( & opts [ i ] ) ; av_freep ( & opts ) ; if ( err < 0 ) { print_error ( filename , err ) ; return err ; } } av_dump_format ( fmt_ctx , 0 , filename , 0 ) ; ifile -> streams = av_calloc ( fmt_ctx -> nb_streams , sizeof ( * ifile -> streams ) ) ; if ( ! ifile -> streams ) exit ( 1 ) ; ifile -> nb_streams = fmt_ctx -> nb_streams ; /* bind a decoder to each input stream */ for ( i = 0 ; i < fmt_ctx -> nb_streams ; i ++ ) { InputStream * ist = & ifile -> streams [ i ] ; AVStream * stream = fmt_ctx -> streams [ i ] ; const AVCodec * codec ; ist -> st = stream ; if ( stream -> codecpar -> codec_id == AV_CODEC_ID_PROBE ) { av_log ( NULL , AV_LOG_WARNING , \"Failed to probe codec for input stream %d\\n\" , stream -> index ) ; continue ; } codec = avcodec_find_decoder ( stream -> codecpar -> codec_id ) ; if ( ! codec ) { av_log ( NULL , AV_LOG_WARNING , \"Unsupported codec with id %d for input stream %d\\n\" , stream -> codecpar -> codec_id , stream -> index ) ; continue ; } { AVDictionary * opts = filter_codec_opts ( codec_opts , stream -> codecpar -> codec_id , fmt_ctx , stream , codec ) ; ist -> dec_ctx = avcodec_alloc_context3 ( codec ) ; if ( ! ist -> dec_ctx ) exit ( 1 ) ; err = avcodec_parameters_to_context ( ist -> dec_ctx , stream -> codecpar ) ; if ( err < 0 ) exit ( 1 ) ; if ( do_show_log ) { // For loging it is needed to disable at least frame threads as otherwise // the log information would need to be reordered and matches up to contexts and frames // That is in fact possible but not trivial av_dict_set ( & codec_opts , \"threads\" , \"1\" , 0 ) ; } ist -> dec_ctx -> pkt_timebase = stream -> time_base ; if ( avcodec_open2 ( ist -> dec_ctx , codec , & opts ) < 0 ) { av_log ( NULL , AV_LOG_WARNING , \"Could not open codec for input stream %d\\n\" , stream -> index ) ; exit ( 1 ) ; } if ( ( t = av_dict_get ( opts , \"\" , NULL , AV_DICT_IGNORE_SUFFIX ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"Option %s for input stream %d not found\\n\" , t -> key , stream -> index ) ; return AVERROR_OPTION_NOT_FOUND ; } } } ifile -> fmt_ctx = fmt_ctx ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@close_input_file": "static void close_input_file ( InputFile * ifile ) { int i ; /* close decoder for each stream */ for ( i = 0 ; i < ifile -> nb_streams ; i ++ ) avcodec_free_context ( & ifile -> streams [ i ] . dec_ctx ) ; av_freep ( & ifile -> streams ) ; ifile -> nb_streams = 0 ; avformat_close_input ( & ifile -> fmt_ctx ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@probe_file": "static int probe_file ( WriterContext * wctx , const char * filename , const char * print_filename ) { InputFile ifile = { 0 } ; int ret , i ; int section_id ; do_read_frames = do_show_frames || do_count_frames ; do_read_packets = do_show_packets || do_count_packets ; ret = open_input_file ( & ifile , filename , print_filename ) ; if ( ret < 0 ) goto end ; # define CHECK_END if ( ret < 0 ) goto end nb_streams = ifile . fmt_ctx -> nb_streams ; REALLOCZ_ARRAY_STREAM ( nb_streams_frames , 0 , ifile . fmt_ctx -> nb_streams ) ; REALLOCZ_ARRAY_STREAM ( nb_streams_packets , 0 , ifile . fmt_ctx -> nb_streams ) ; REALLOCZ_ARRAY_STREAM ( selected_streams , 0 , ifile . fmt_ctx -> nb_streams ) ; for ( i = 0 ; i < ifile . fmt_ctx -> nb_streams ; i ++ ) { if ( stream_specifier ) { ret = avformat_match_stream_specifier ( ifile . fmt_ctx , ifile . fmt_ctx -> streams [ i ] , stream_specifier ) ; CHECK_END ; else selected_streams [ i ] = ret ; ret = 0 ; } else { selected_streams [ i ] = 1 ; } if ( ! selected_streams [ i ] ) ifile . fmt_ctx -> streams [ i ] -> discard = AVDISCARD_ALL ; } if ( do_read_frames || do_read_packets ) { if ( do_show_frames && do_show_packets && wctx -> writer -> flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER ) section_id = SECTION_ID_PACKETS_AND_FRAMES ; else if ( do_show_packets && ! do_show_frames ) section_id = SECTION_ID_PACKETS ; else // (!do_show_packets && do_show_frames) section_id = SECTION_ID_FRAMES ; if ( do_show_frames || do_show_packets ) writer_print_section_header ( wctx , section_id ) ; ret = read_packets ( wctx , & ifile ) ; if ( do_show_frames || do_show_packets ) writer_print_section_footer ( wctx ) ; CHECK_END ; } if ( do_show_programs ) { ret = show_programs ( wctx , & ifile ) ; CHECK_END ; } if ( do_show_streams ) { ret = show_streams ( wctx , & ifile ) ; CHECK_END ; } if ( do_show_chapters ) { ret = show_chapters ( wctx , & ifile ) ; CHECK_END ; } if ( do_show_format ) { ret = show_format ( wctx , & ifile ) ; CHECK_END ; } end : if ( ifile . fmt_ctx ) close_input_file ( & ifile ) ; av_freep ( & nb_streams_frames ) ; av_freep ( & nb_streams_packets ) ; av_freep ( & selected_streams ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_usage": "static void show_usage ( void ) { av_log ( NULL , AV_LOG_INFO , \"Simple multimedia streams analyzer\\n\" ) ; av_log ( NULL , AV_LOG_INFO , \"usage: %s [OPTIONS] INPUT_FILE\\n\" , program_name ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@ffprobe_show_program_version": "static void ffprobe_show_program_version ( WriterContext * w ) { AVBPrint pbuf ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_PROGRAM_VERSION ) ; print_str ( \"version\" , FFMPEG_VERSION ) ; print_fmt ( \"copyright\" , \"Copyright (c) %d-%d the FFmpeg developers\" , program_birth_year , CONFIG_THIS_YEAR ) ; print_str ( \"compiler_ident\" , CC_IDENT ) ; print_str ( \"configuration\" , FFMPEG_CONFIGURATION ) ; writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@ffprobe_show_library_versions": "static void ffprobe_show_library_versions ( WriterContext * w ) { writer_print_section_header ( w , SECTION_ID_LIBRARY_VERSIONS ) ; SHOW_LIB_VERSION ( avutil , AVUTIL ) ; SHOW_LIB_VERSION ( avcodec , AVCODEC ) ; SHOW_LIB_VERSION ( avformat , AVFORMAT ) ; SHOW_LIB_VERSION ( avdevice , AVDEVICE ) ; SHOW_LIB_VERSION ( avfilter , AVFILTER ) ; SHOW_LIB_VERSION ( swscale , SWSCALE ) ; SHOW_LIB_VERSION ( swresample , SWRESAMPLE ) ; writer_print_section_footer ( w ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@ffprobe_show_pixel_formats": "static void ffprobe_show_pixel_formats ( WriterContext * w ) { const AVPixFmtDescriptor * pixdesc = NULL ; int i , n ; writer_print_section_header ( w , SECTION_ID_PIXEL_FORMATS ) ; while ( ( pixdesc = av_pix_fmt_desc_next ( pixdesc ) ) ) { writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT ) ; print_str ( \"name\" , pixdesc -> name ) ; print_int ( \"nb_components\" , pixdesc -> nb_components ) ; if ( ( pixdesc -> nb_components >= 3 ) && ! ( pixdesc -> flags & AV_PIX_FMT_FLAG_RGB ) ) { print_int ( \"log2_chroma_w\" , pixdesc -> log2_chroma_w ) ; print_int ( \"log2_chroma_h\" , pixdesc -> log2_chroma_h ) ; } else { print_str_opt ( \"log2_chroma_w\" , \"N/A\" ) ; print_str_opt ( \"log2_chroma_h\" , \"N/A\" ) ; } n = av_get_bits_per_pixel ( pixdesc ) ; if ( n ) print_int ( \"bits_per_pixel\" , n ) ; else print_str_opt ( \"bits_per_pixel\" , \"N/A\" ) ; if ( do_show_pixel_format_flags ) { writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_FLAGS ) ; PRINT_PIX_FMT_FLAG ( BE , \"big_endian\" ) ; PRINT_PIX_FMT_FLAG ( PAL , \"palette\" ) ; PRINT_PIX_FMT_FLAG ( BITSTREAM , \"bitstream\" ) ; PRINT_PIX_FMT_FLAG ( HWACCEL , \"hwaccel\" ) ; PRINT_PIX_FMT_FLAG ( PLANAR , \"planar\" ) ; PRINT_PIX_FMT_FLAG ( RGB , \"rgb\" ) ; PRINT_PIX_FMT_FLAG ( ALPHA , \"alpha\" ) ; writer_print_section_footer ( w ) ; } if ( do_show_pixel_format_components && ( pixdesc -> nb_components > 0 ) ) { writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_COMPONENTS ) ; for ( i = 0 ; i < pixdesc -> nb_components ; i ++ ) { writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_COMPONENT ) ; print_int ( \"index\" , i + 1 ) ; print_int ( \"bit_depth\" , pixdesc -> comp [ i ] . depth ) ; writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_show_optional_fields": "static int opt_show_optional_fields ( void * optctx , const char * opt , const char * arg ) { if ( ! av_strcasecmp ( arg , \"always\" ) ) show_optional_fields = SHOW_OPTIONAL_FIELDS_ALWAYS ; else if ( ! av_strcasecmp ( arg , \"never\" ) ) show_optional_fields = SHOW_OPTIONAL_FIELDS_NEVER ; else if ( ! av_strcasecmp ( arg , \"auto\" ) ) show_optional_fields = SHOW_OPTIONAL_FIELDS_AUTO ; if ( show_optional_fields == SHOW_OPTIONAL_FIELDS_AUTO && av_strcasecmp ( arg , \"auto\" ) ) show_optional_fields = parse_number_or_die ( \"show_optional_fields\" , arg , OPT_INT , SHOW_OPTIONAL_FIELDS_AUTO , SHOW_OPTIONAL_FIELDS_ALWAYS ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_format": "static int opt_format ( void * optctx , const char * opt , const char * arg ) { iformat = av_find_input_format ( arg ) ; if ( ! iformat ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown input format: %s\\n\" , arg ) ; return AVERROR ( EINVAL ) ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@mark_section_show_entries": "static inline void mark_section_show_entries ( SectionID section_id , int show_all_entries , AVDictionary * entries ) { struct section * section = & sections [ section_id ] ; section -> show_all_entries = show_all_entries ; if ( show_all_entries ) { SectionID * id ; for ( id = section -> children_ids ; * id != - 1 ; id ++ ) mark_section_show_entries ( * id , show_all_entries , entries ) ; } else { av_dict_copy ( & section -> entries_to_show , entries , 0 ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@match_section": "static int match_section ( const char * section_name , int show_all_entries , AVDictionary * entries ) { int i , ret = 0 ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( sections ) ; i ++ ) { const struct section * section = & sections [ i ] ; if ( ! strcmp ( section_name , section -> name ) || ( section -> unique_name && ! strcmp ( section_name , section -> unique_name ) ) ) { av_log ( NULL , AV_LOG_DEBUG , \"'%s' matches section with unique name '%s'\\n\" , section_name , ( char * ) av_x_if_null ( section -> unique_name , section -> name ) ) ; ret ++ ; mark_section_show_entries ( section -> id , show_all_entries , entries ) ; } } return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_show_entries": "static int opt_show_entries ( void * optctx , const char * opt , const char * arg ) { const char * p = arg ; int ret = 0 ; while ( * p ) { AVDictionary * entries = NULL ; char * section_name = av_get_token ( & p , \"=:\" ) ; int show_all_entries = 0 ; if ( ! section_name ) { av_log ( NULL , AV_LOG_ERROR , \"Missing section name for option '%s'\\n\" , opt ) ; return AVERROR ( EINVAL ) ; } if ( * p == '=' ) { p ++ ; while ( * p && * p != ':' ) { char * entry = av_get_token ( & p , \",:\" ) ; if ( ! entry ) break ; av_log ( NULL , AV_LOG_VERBOSE , \"Adding '%s' to the entries to show in section '%s'\\n\" , entry , section_name ) ; av_dict_set ( & entries , entry , \"\" , AV_DICT_DONT_STRDUP_KEY ) ; if ( * p == ',' ) p ++ ; } } else { show_all_entries = 1 ; } ret = match_section ( section_name , show_all_entries , entries ) ; if ( ret == 0 ) { av_log ( NULL , AV_LOG_ERROR , \"No match for section '%s'\\n\" , section_name ) ; ret = AVERROR ( EINVAL ) ; } av_dict_free ( & entries ) ; av_free ( section_name ) ; if ( ret <= 0 ) break ; if ( * p ) p ++ ; } return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_input_file": "static void opt_input_file ( void * optctx , const char * arg ) { if ( input_filename ) { av_log ( NULL , AV_LOG_ERROR , \"Argument '%s' provided as input filename, but '%s' was already specified.\\n\" , arg , input_filename ) ; exit_program ( 1 ) ; } if ( ! strcmp ( arg , \"-\" ) ) arg = \"fd:\" ; input_filename = arg ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_input_file_i": "static int opt_input_file_i ( void * optctx , const char * opt , const char * arg ) { opt_input_file ( optctx , arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_output_file": "static void opt_output_file ( void * optctx , const char * arg ) { if ( output_filename ) { av_log ( NULL , AV_LOG_ERROR , \"Argument '%s' provided as output filename, but '%s' was already specified.\\n\" , arg , output_filename ) ; exit_program ( 1 ) ; } if ( ! strcmp ( arg , \"-\" ) ) arg = \"fd:\" ; output_filename = arg ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_output_file_o": "static int opt_output_file_o ( void * optctx , const char * opt , const char * arg ) { opt_output_file ( optctx , arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_print_filename": "static int opt_print_filename ( void * optctx , const char * opt , const char * arg ) { print_input_filename = arg ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@show_help_default_ffprobe": "void show_help_default_ffprobe ( const char * opt , const char * arg ) { show_usage ( ) ; show_help_options ( ffprobe_options , \"Main options:\" , 0 , 0 , 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; show_help_children ( avformat_get_class ( ) , AV_OPT_FLAG_DECODING_PARAM ) ; show_help_children ( avcodec_get_class ( ) , AV_OPT_FLAG_DECODING_PARAM ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@parse_read_interval": "static int parse_read_interval ( const char * interval_spec , ReadInterval * interval ) { int ret = 0 ; char * next , * p , * spec = av_strdup ( interval_spec ) ; if ( ! spec ) return AVERROR ( ENOMEM ) ; if ( ! * spec ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid empty interval specification\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto end ; } p = spec ; next = strchr ( spec , '%' ) ; if ( next ) * next ++ = 0 ; /* parse first part */ if ( * p ) { interval -> has_start = 1 ; if ( * p == '+' ) { interval -> start_is_offset = 1 ; p ++ ; } else { interval -> start_is_offset = 0 ; } ret = av_parse_time ( & interval -> start , p , 1 ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid interval start specification '%s'\\n\" , p ) ; goto end ; } } else { interval -> has_start = 0 ; } /* parse second part */ p = next ; if ( p && * p ) { int64_t us ; interval -> has_end = 1 ; if ( * p == '+' ) { interval -> end_is_offset = 1 ; p ++ ; } else { interval -> end_is_offset = 0 ; } if ( interval -> end_is_offset && * p == '#' ) { long long int lli ; char * tail ; interval -> duration_frames = 1 ; p ++ ; lli = strtoll ( p , & tail , 10 ) ; if ( * tail || lli < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid or negative value '%s' for duration number of frames\\n\" , p ) ; goto end ; } interval -> end = lli ; } else { interval -> duration_frames = 0 ; ret = av_parse_time ( & us , p , 1 ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid interval end/duration specification '%s'\\n\" , p ) ; goto end ; } interval -> end = us ; } } else { interval -> has_end = 0 ; } end : av_free ( spec ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@parse_read_intervals": "static int parse_read_intervals ( const char * intervals_spec ) { int ret , n , i ; char * p , * spec = av_strdup ( intervals_spec ) ; if ( ! spec ) return AVERROR ( ENOMEM ) ; /* preparse specification, get number of intervals */ for ( n = 0 , p = spec ; * p ; p ++ ) if ( * p == ',' ) n ++ ; n ++ ; read_intervals = av_malloc_array ( n , sizeof ( * read_intervals ) ) ; if ( ! read_intervals ) { ret = AVERROR ( ENOMEM ) ; goto end ; } read_intervals_nb = n ; /* parse intervals */ p = spec ; for ( i = 0 ; p ; i ++ ) { char * next ; av_assert0 ( i < read_intervals_nb ) ; next = strchr ( p , ',' ) ; if ( next ) * next ++ = 0 ; read_intervals [ i ] . id = i ; ret = parse_read_interval ( p , & read_intervals [ i ] ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing read interval #%d '%s'\\n\" , i , p ) ; goto end ; } av_log ( NULL , AV_LOG_VERBOSE , \"Parsed log interval \" ) ; log_read_interval ( & read_intervals [ i ] , NULL , AV_LOG_VERBOSE ) ; p = next ; } av_assert0 ( i == read_intervals_nb ) ; end : av_free ( spec ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_read_intervals": "static int opt_read_intervals ( void * optctx , const char * opt , const char * arg ) { return parse_read_intervals ( arg ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_pretty": "static int opt_pretty ( void * optctx , const char * opt , const char * arg ) { show_value_unit = 1 ; use_value_prefix = 1 ; use_byte_value_binary_prefix = 1 ; use_value_sexagesimal_format = 1 ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@print_section": "static void print_section ( SectionID id , int level ) { const SectionID * pid ; const struct section * section = & sections [ id ] ; av_log ( NULL , AV_LOG_STDERR , \"%c%c%c\" , section -> flags & SECTION_FLAG_IS_WRAPPER ? 'W' : '.' , section -> flags & SECTION_FLAG_IS_ARRAY ? 'A' : '.' , section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ? 'V' : '.' ) ; av_log ( NULL , AV_LOG_STDERR , \"%*c  %s\" , level * 4 , ' ' , section -> name ) ; if ( section -> unique_name ) av_log ( NULL , AV_LOG_STDERR , \"/%s\" , section -> unique_name ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; for ( pid = section -> children_ids ; * pid != - 1 ; pid ++ ) print_section ( * pid , level + 1 ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_sections": "static int opt_sections ( void * optctx , const char * opt , const char * arg ) { av_log ( NULL , AV_LOG_STDERR , \"Sections:\\n\" \"W.. = Section is a wrapper (contains other sections, no local entries)\\n\" \".A. = Section contains an array of elements of the same type\\n\" \"..V = Section may contain a variable number of fields with variable keys\\n\" \"FLAGS NAME/UNIQUE_NAME\\n\" \"---\\n\" ) ; print_section ( SECTION_ID_ROOT , 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_show_versions": "static int opt_show_versions ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_PROGRAM_VERSION , 1 , NULL ) ; mark_section_show_entries ( SECTION_ID_LIBRARY_VERSION , 1 , NULL ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_show_chapters": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_show_error": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_show_format": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_show_frames": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_show_library_versions": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_show_packets": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_show_pixel_formats": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_show_program_version": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS ) DEFINE_OPT_SHOW_SECTION ( program_version , PROGRAM_VERSION )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_show_streams": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS ) DEFINE_OPT_SHOW_SECTION ( program_version , PROGRAM_VERSION ) DEFINE_OPT_SHOW_SECTION ( streams , STREAMS )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@opt_show_programs": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS ) DEFINE_OPT_SHOW_SECTION ( program_version , PROGRAM_VERSION ) DEFINE_OPT_SHOW_SECTION ( streams , STREAMS ) DEFINE_OPT_SHOW_SECTION ( programs , PROGRAMS )",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@check_section_show_entries": "static inline int check_section_show_entries ( int section_id ) { int * id ; struct section * section = & sections [ section_id ] ; if ( sections [ section_id ] . show_all_entries || sections [ section_id ] . entries_to_show ) return 1 ; for ( id = section -> children_ids ; * id != - 1 ; id ++ ) if ( check_section_show_entries ( * id ) ) return 1 ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@ffprobe_var_cleanup": "void ffprobe_var_cleanup ( ) { main_ffprobe_return_code = 0 ; longjmp_value = 0 ; do_bitexact = 0 ; do_count_frames = 0 ; do_count_packets = 0 ; do_read_frames = 0 ; do_read_packets = 0 ; do_show_chapters = 0 ; do_show_error = 0 ; do_show_format = 0 ; do_show_frames = 0 ; do_show_packets = 0 ; do_show_programs = 0 ; do_show_streams = 0 ; do_show_stream_disposition = 0 ; do_show_data = 0 ; do_show_program_version = 0 ; do_show_library_versions = 0 ; do_show_pixel_formats = 0 ; do_show_pixel_format_flags = 0 ; do_show_pixel_format_components = 0 ; do_show_log = 0 ; do_show_chapter_tags = 0 ; do_show_format_tags = 0 ; do_show_frame_tags = 0 ; do_show_program_tags = 0 ; do_show_stream_tags = 0 ; do_show_packet_tags = 0 ; show_value_unit = 0 ; use_value_prefix = 0 ; use_byte_value_binary_prefix = 0 ; use_value_sexagesimal_format = 0 ; show_private_data = 1 ; print_format = NULL ; stream_specifier = NULL ; show_data_hash = NULL ; read_intervals = NULL ; read_intervals_nb = 0 ; find_stream_info = 1 ; ffprobe_options = NULL ; input_filename = NULL ; print_input_filename = NULL ; iformat = NULL ; hash = NULL ; main_ffprobe_return_code = 0 ; nb_streams = 0 ; nb_streams_packets = NULL ; nb_streams_frames = NULL ; selected_streams = NULL ; log_buffer = NULL ; log_buffer_size = 0 ; for ( int i = 0 ; i < FF_ARRAY_ELEMS ( sections ) ; i ++ ) { sections [ i ] . show_all_entries = 0 ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffprobe.c@ffprobe_execute": "int ffprobe_execute ( int argc , char * * argv ) { char _program_name [ ] = \"ffprobe\" ; program_name = ( char * ) & _program_name ; program_birth_year = 2007 ; OptionDef options [ ] = { { \"L\" , OPT_EXIT , { . func_arg = show_license } , \"show license\" } , { \"h\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"?\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"help\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"-help\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"version\" , OPT_EXIT , { . func_arg = show_version } , \"show version\" } , { \"buildconf\" , OPT_EXIT , { . func_arg = show_buildconf } , \"show build configuration\" } , { \"formats\" , OPT_EXIT , { . func_arg = show_formats } , \"show available formats\" } , { \"muxers\" , OPT_EXIT , { . func_arg = show_muxers } , \"show available muxers\" } , { \"demuxers\" , OPT_EXIT , { . func_arg = show_demuxers } , \"show available demuxers\" } , { \"devices\" , OPT_EXIT , { . func_arg = show_devices } , \"show available devices\" } , { \"codecs\" , OPT_EXIT , { . func_arg = show_codecs } , \"show available codecs\" } , { \"decoders\" , OPT_EXIT , { . func_arg = show_decoders } , \"show available decoders\" } , { \"encoders\" , OPT_EXIT , { . func_arg = show_encoders } , \"show available encoders\" } , { \"bsfs\" , OPT_EXIT , { . func_arg = show_bsfs } , \"show available bit stream filters\" } , { \"protocols\" , OPT_EXIT , { . func_arg = show_protocols } , \"show available protocols\" } , { \"filters\" , OPT_EXIT , { . func_arg = show_filters } , \"show available filters\" } , { \"pix_fmts\" , OPT_EXIT , { . func_arg = show_pix_fmts } , \"show available pixel formats\" } , { \"layouts\" , OPT_EXIT , { . func_arg = show_layouts } , \"show standard channel layouts\" } , { \"sample_fmts\" , OPT_EXIT , { . func_arg = show_sample_fmts } , \"show available audio sample formats\" } , { \"dispositions\" , OPT_EXIT , { . func_arg = show_dispositions } , \"show available stream dispositions\" } , { \"colors\" , OPT_EXIT , { . func_arg = show_colors } , \"show available color names\" } , { \"loglevel\" , HAS_ARG , { . func_arg = opt_loglevel } , \"set logging level\" , \"loglevel\" } , { \"v\" , HAS_ARG , { . func_arg = opt_loglevel } , \"set logging level\" , \"loglevel\" } , { \"report\" , 0 , { . func_arg = opt_report } , \"generate a report\" } , { \"max_alloc\" , HAS_ARG , { . func_arg = opt_max_alloc } , \"set maximum size of a single allocated block\" , \"bytes\" } , { \"cpuflags\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_cpuflags } , \"force specific cpu flags\" , \"flags\" } , { \"cpucount\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_cpucount } , \"force specific cpu count\" , \"count\" } , { \"hide_banner\" , OPT_BOOL | OPT_EXPERT , { & hide_banner } , \"do not show program banner\" , \"hide_banner\" } , # if CONFIG_AVDEVICE { \"sources\" , OPT_EXIT | HAS_ARG , { . func_arg = show_sources } , \"list sources of the input device\" , \"device\" } , { \"sinks\" , OPT_EXIT | HAS_ARG , { . func_arg = show_sinks } , \"list sinks of the output device\" , \"device\" } , # endif { \"f\" , HAS_ARG , { . func_arg = opt_format } , \"force format\" , \"format\" } , { \"unit\" , OPT_BOOL , { & show_value_unit } , \"show unit of the displayed values\" } , { \"prefix\" , OPT_BOOL , { & use_value_prefix } , \"use SI prefixes for the displayed values\" } , { \"byte_binary_prefix\" , OPT_BOOL , { & use_byte_value_binary_prefix } , \"use binary prefixes for byte units\" } , { \"sexagesimal\" , OPT_BOOL , { & use_value_sexagesimal_format } , \"use sexagesimal format HOURS:MM:SS.MICROSECONDS for time units\" } , { \"pretty\" , 0 , { . func_arg = opt_pretty } , \"prettify the format of displayed values, make it more human readable\" } , { \"print_format\" , OPT_STRING | HAS_ARG , { & print_format } , \"set the output printing format (available formats are: default, compact, csv, flat, ini, json, xml)\" , \"format\" } , { \"of\" , OPT_STRING | HAS_ARG , { & print_format } , \"alias for -print_format\" , \"format\" } , { \"select_streams\" , OPT_STRING | HAS_ARG , { & stream_specifier } , \"select the specified streams\" , \"stream_specifier\" } , { \"sections\" , OPT_EXIT , { . func_arg = opt_sections } , \"print sections structure and section information, and exit\" } , { \"show_data\" , OPT_BOOL , { & do_show_data } , \"show packets data\" } , { \"show_data_hash\" , OPT_STRING | HAS_ARG , { & show_data_hash } , \"show packets data hash\" } , { \"show_error\" , 0 , { . func_arg = & opt_show_error } , \"show probing error\" } , { \"show_format\" , 0 , { . func_arg = & opt_show_format } , \"show format/container info\" } , { \"show_frames\" , 0 , { . func_arg = & opt_show_frames } , \"show frames info\" } , { \"show_entries\" , HAS_ARG , { . func_arg = opt_show_entries } , \"show a set of specified entries\" , \"entry_list\" } , # if HAVE_THREADS { \"show_log\" , OPT_INT | HAS_ARG , { & do_show_log } , \"show log\" } , # endif { \"show_packets\" , 0 , { . func_arg = & opt_show_packets } , \"show packets info\" } , { \"show_programs\" , 0 , { . func_arg = & opt_show_programs } , \"show programs info\" } , { \"show_streams\" , 0 , { . func_arg = & opt_show_streams } , \"show streams info\" } , { \"show_chapters\" , 0 , { . func_arg = & opt_show_chapters } , \"show chapters info\" } , { \"count_frames\" , OPT_BOOL , { & do_count_frames } , \"count the number of frames per stream\" } , { \"count_packets\" , OPT_BOOL , { & do_count_packets } , \"count the number of packets per stream\" } , { \"show_program_version\" , 0 , { . func_arg = & opt_show_program_version } , \"show ffprobe version\" } , { \"show_library_versions\" , 0 , { . func_arg = & opt_show_library_versions } , \"show library versions\" } , { \"show_versions\" , 0 , { . func_arg = & opt_show_versions } , \"show program and library versions\" } , { \"show_pixel_formats\" , 0 , { . func_arg = & opt_show_pixel_formats } , \"show pixel format descriptions\" } , { \"show_optional_fields\" , HAS_ARG , { . func_arg = & opt_show_optional_fields } , \"show optional fields\" } , { \"show_private_data\" , OPT_BOOL , { & show_private_data } , \"show private data\" } , { \"private\" , OPT_BOOL , { & show_private_data } , \"same as show_private_data\" } , { \"bitexact\" , OPT_BOOL , { & do_bitexact } , \"force bitexact output\" } , { \"read_intervals\" , HAS_ARG , { . func_arg = opt_read_intervals } , \"set read intervals\" , \"read_intervals\" } , { \"i\" , HAS_ARG , { . func_arg = opt_input_file_i } , \"read specified file\" , \"input_file\" } , { \"o\" , HAS_ARG , { . func_arg = opt_output_file_o } , \"write to specified output\" , \"output_file\" } , { \"print_filename\" , HAS_ARG , { . func_arg = opt_print_filename } , \"override the printed input filename\" , \"print_file\" } , { \"find_stream_info\" , OPT_BOOL | OPT_INPUT | OPT_EXPERT , { & find_stream_info } , \"read and decode the streams to fill missing information with heuristics\" } , { NULL , } , } ; const Writer * w ; WriterContext * wctx ; char * buf ; char * w_name = NULL , * w_args = NULL ; int ret , input_ret , i ; int savedCode = setjmp ( ex_buf__ ) ; if ( savedCode == 0 ) { ffprobe_var_cleanup ( ) ; init_dynload ( ) ; # if HAVE_THREADS ret = pthread_mutex_init ( & log_mutex , NULL ) ; if ( ret != 0 ) { goto end ; } # endif av_log_set_flags ( AV_LOG_SKIP_REPEATED ) ; register_exit ( ffprobe_cleanup ) ; ffprobe_options = options ; parse_loglevel ( argc , argv , options ) ; avformat_network_init ( ) ; # if CONFIG_AVDEVICE avdevice_register_all ( ) ; # endif show_banner ( argc , argv , options ) ; parse_options ( NULL , argc , argv , options , opt_input_file ) ; if ( do_show_log ) av_log_set_callback ( log_callback ) ; /* mark things to show, based on -show_entries */ SET_DO_SHOW ( CHAPTERS , chapters ) ; SET_DO_SHOW ( ERROR , error ) ; SET_DO_SHOW ( FORMAT , format ) ; SET_DO_SHOW ( FRAMES , frames ) ; SET_DO_SHOW ( LIBRARY_VERSIONS , library_versions ) ; SET_DO_SHOW ( PACKETS , packets ) ; SET_DO_SHOW ( PIXEL_FORMATS , pixel_formats ) ; SET_DO_SHOW ( PIXEL_FORMAT_FLAGS , pixel_format_flags ) ; SET_DO_SHOW ( PIXEL_FORMAT_COMPONENTS , pixel_format_components ) ; SET_DO_SHOW ( PROGRAM_VERSION , program_version ) ; SET_DO_SHOW ( PROGRAMS , programs ) ; SET_DO_SHOW ( STREAMS , streams ) ; SET_DO_SHOW ( STREAM_DISPOSITION , stream_disposition ) ; SET_DO_SHOW ( PROGRAM_STREAM_DISPOSITION , stream_disposition ) ; SET_DO_SHOW ( CHAPTER_TAGS , chapter_tags ) ; SET_DO_SHOW ( FORMAT_TAGS , format_tags ) ; SET_DO_SHOW ( FRAME_TAGS , frame_tags ) ; SET_DO_SHOW ( PROGRAM_TAGS , program_tags ) ; SET_DO_SHOW ( STREAM_TAGS , stream_tags ) ; SET_DO_SHOW ( PROGRAM_STREAM_TAGS , stream_tags ) ; SET_DO_SHOW ( PACKET_TAGS , packet_tags ) ; if ( do_bitexact && ( do_show_program_version || do_show_library_versions ) ) { av_log ( NULL , AV_LOG_ERROR , \"-bitexact and -show_program_version or -show_library_versions \" \"options are incompatible\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto end ; } writer_register_all ( ) ; if ( ! print_format ) print_format = av_strdup ( \"default\" ) ; if ( ! print_format ) { ret = AVERROR ( ENOMEM ) ; goto end ; } w_name = av_strtok ( print_format , \"=\" , & buf ) ; if ( ! w_name ) { av_log ( NULL , AV_LOG_ERROR , \"No name specified for the output format\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto end ; } w_args = buf ; if ( show_data_hash ) { if ( ( ret = av_hash_alloc ( & hash , show_data_hash ) ) < 0 ) { if ( ret == AVERROR ( EINVAL ) ) { const char * n ; av_log ( NULL , AV_LOG_ERROR , \"Unknown hash algorithm '%s'\\nKnown algorithms:\" , show_data_hash ) ; for ( i = 0 ; ( n = av_hash_names ( i ) ) ; i ++ ) av_log ( NULL , AV_LOG_ERROR , \" %s\" , n ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } goto end ; } } w = writer_get_by_name ( w_name ) ; if ( ! w ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown output format with name '%s'\\n\" , w_name ) ; ret = AVERROR ( EINVAL ) ; goto end ; } if ( ( ret = writer_open ( & wctx , w , w_args , sections , FF_ARRAY_ELEMS ( sections ) , output_filename ) ) >= 0 ) { if ( w == & xml_writer ) wctx -> string_validation_utf8_flags |= AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES ; writer_print_section_header ( wctx , SECTION_ID_ROOT ) ; if ( do_show_program_version ) ffprobe_show_program_version ( wctx ) ; if ( do_show_library_versions ) ffprobe_show_library_versions ( wctx ) ; if ( do_show_pixel_formats ) ffprobe_show_pixel_formats ( wctx ) ; if ( ! input_filename && ( ( do_show_format || do_show_programs || do_show_streams || do_show_chapters || do_show_packets || do_show_error ) || ( ! do_show_program_version && ! do_show_library_versions && ! do_show_pixel_formats ) ) ) { show_usage ( ) ; av_log ( NULL , AV_LOG_ERROR , \"You have to specify one input file.\\n\" ) ; av_log ( NULL , AV_LOG_ERROR , \"Use -h to get full help or, even better, run 'man %s'.\\n\" , program_name ) ; ret = AVERROR ( EINVAL ) ; } else if ( input_filename ) { ret = probe_file ( wctx , input_filename , print_input_filename ) ; if ( ret < 0 && do_show_error ) show_error ( wctx , ret ) ; } input_ret = ret ; writer_print_section_footer ( wctx ) ; ret = writer_close ( & wctx ) ; if ( ret < 0 ) av_log ( NULL , AV_LOG_ERROR , \"Writing output failed: %s\\n\" , av_err2str ( ret ) ) ; ret = FFMIN ( ret , input_ret ) ; } main_ffprobe_return_code = ret < 0 ; } else { main_ffprobe_return_code = longjmp_value ; } end : av_freep ( & print_format ) ; av_freep ( & read_intervals ) ; av_hash_freep ( & hash ) ; uninit_opts ( ) ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( sections ) ; i ++ ) av_dict_free ( & ( sections [ i ] . entries_to_show ) ) ; avformat_network_deinit ( ) ; return main_ffprobe_return_code ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@uninit_options": "void uninit_options ( OptionsContext * o ) { const OptionDef * po = ffmpeg_options ; int i ; /* all OPT_SPEC and OPT_STRING can be freed in generic way */ while ( po -> name ) { void * dst = ( uint8_t * ) o + po -> u . off ; if ( po -> flags & OPT_SPEC ) { SpecifierOpt * * so = dst ; int i , * count = ( int * ) ( so + 1 ) ; for ( i = 0 ; i < * count ; i ++ ) { av_freep ( & ( * so ) [ i ] . specifier ) ; if ( po -> flags & OPT_STRING ) av_freep ( & ( * so ) [ i ] . u . str ) ; } av_freep ( so ) ; * count = 0 ; } else if ( po -> flags & OPT_OFFSET && po -> flags & OPT_STRING ) av_freep ( dst ) ; po ++ ; } for ( i = 0 ; i < o -> nb_stream_maps ; i ++ ) av_freep ( & o -> stream_maps [ i ] . linklabel ) ; av_freep ( & o -> stream_maps ) ; # if FFMPEG_OPT_MAP_CHANNEL av_freep ( & o -> audio_channel_maps ) ; # endif av_freep ( & o -> streamid_map ) ; av_freep ( & o -> attachments ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@init_options": "void init_options ( OptionsContext * o ) { memset ( o , 0 , sizeof ( * o ) ) ; o -> stop_time = INT64_MAX ; o -> mux_max_delay = 0.7 ; o -> start_time = AV_NOPTS_VALUE ; o -> start_time_eof = AV_NOPTS_VALUE ; o -> recording_time = INT64_MAX ; o -> limit_filesize = INT64_MAX ; o -> chapters_input_file = INT_MAX ; o -> accurate_seek = 1 ; o -> thread_queue_size = - 1 ; o -> input_sync_ref = - 1 ; o -> find_stream_info = 1 ; o -> shortest_buf_duration = 10.f ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@show_hwaccels": "int show_hwaccels ( void * optctx , const char * opt , const char * arg ) { enum AVHWDeviceType type = AV_HWDEVICE_TYPE_NONE ; av_log ( NULL , AV_LOG_STDERR , \"Hardware acceleration methods:\\n\" ) ; while ( ( type = av_hwdevice_iterate_types ( type ) ) != AV_HWDEVICE_TYPE_NONE ) av_log ( NULL , AV_LOG_STDERR , \"%s\\n\" , av_hwdevice_get_type_name ( type ) ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@strip_specifiers": "AVDictionary * strip_specifiers ( const AVDictionary * dict ) { const AVDictionaryEntry * e = NULL ; AVDictionary * ret = NULL ; while ( ( e = av_dict_iterate ( dict , e ) ) ) { char * p = strchr ( e -> key , ':' ) ; if ( p ) * p = 0 ; av_dict_set ( & ret , e -> key , e -> value , 0 ) ; if ( p ) * p = ':' ; } return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@parse_and_set_vsync": "int parse_and_set_vsync ( const char * arg , int * vsync_var , int file_idx , int st_idx , int is_global ) { if ( ! av_strcasecmp ( arg , \"cfr\" ) ) * vsync_var = VSYNC_CFR ; else if ( ! av_strcasecmp ( arg , \"vfr\" ) ) * vsync_var = VSYNC_VFR ; else if ( ! av_strcasecmp ( arg , \"passthrough\" ) ) * vsync_var = VSYNC_PASSTHROUGH ; else if ( ! av_strcasecmp ( arg , \"drop\" ) ) * vsync_var = VSYNC_DROP ; else if ( ! is_global && ! av_strcasecmp ( arg , \"auto\" ) ) * vsync_var = VSYNC_AUTO ; else if ( ! is_global ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid value %s specified for fps_mode of #%d:%d.\\n\" , arg , file_idx , st_idx ) ; exit_program ( 1 ) ; } if ( is_global && * vsync_var == VSYNC_AUTO ) { video_sync_method = parse_number_or_die ( \"vsync\" , arg , OPT_INT , VSYNC_AUTO , VSYNC_VFR ) ; av_log ( NULL , AV_LOG_WARNING , \"Passing a number to -vsync is deprecated,\" \" use a string argument as described in the manual.\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@correct_input_start_times": "void correct_input_start_times ( void ) { for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * ifile = input_files [ i ] ; AVFormatContext * is = ifile -> ctx ; int64_t new_start_time = INT64_MAX , diff , abs_start_seek ; ifile -> start_time_effective = is -> start_time ; if ( is -> start_time == AV_NOPTS_VALUE || ! ( is -> iformat -> flags & AVFMT_TS_DISCONT ) ) continue ; for ( int j = 0 ; j < is -> nb_streams ; j ++ ) { AVStream * st = is -> streams [ j ] ; if ( st -> discard == AVDISCARD_ALL || st -> start_time == AV_NOPTS_VALUE ) continue ; new_start_time = FFMIN ( new_start_time , av_rescale_q ( st -> start_time , st -> time_base , AV_TIME_BASE_Q ) ) ; } diff = new_start_time - is -> start_time ; if ( diff ) { av_log ( NULL , AV_LOG_VERBOSE , \"Correcting start time of Input #%d by %\" PRId64 \" us.\\n\" , i , diff ) ; ifile -> start_time_effective = new_start_time ; if ( copy_ts && start_at_zero ) ifile -> ts_offset = - new_start_time ; else if ( ! copy_ts ) { abs_start_seek = is -> start_time + ( ( ifile -> start_time != AV_NOPTS_VALUE ) ? ifile -> start_time : 0 ) ; ifile -> ts_offset = abs_start_seek > new_start_time ? - abs_start_seek : - new_start_time ; } else if ( copy_ts ) ifile -> ts_offset = 0 ; ifile -> ts_offset += ifile -> input_ts_offset ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@apply_sync_offsets": "int apply_sync_offsets ( void ) { for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * ref , * self = input_files [ i ] ; int64_t adjustment ; int64_t self_start_time , ref_start_time , self_seek_start , ref_seek_start ; int start_times_set = 1 ; if ( self -> input_sync_ref == - 1 || self -> input_sync_ref == i ) continue ; if ( self -> input_sync_ref >= nb_input_files || self -> input_sync_ref < - 1 ) { av_log ( NULL , AV_LOG_FATAL , \"-isync for input %d references non-existent input %d.\\n\" , i , self -> input_sync_ref ) ; exit_program ( 1 ) ; } if ( copy_ts && ! start_at_zero ) { av_log ( NULL , AV_LOG_FATAL , \"Use of -isync requires that start_at_zero be set if copyts is set.\\n\" ) ; exit_program ( 1 ) ; } ref = input_files [ self -> input_sync_ref ] ; if ( ref -> input_sync_ref != - 1 && ref -> input_sync_ref != self -> input_sync_ref ) { av_log ( NULL , AV_LOG_ERROR , \"-isync for input %d references a resynced input %d. Sync not set.\\n\" , i , self -> input_sync_ref ) ; continue ; } if ( self -> ctx -> start_time_realtime != AV_NOPTS_VALUE && ref -> ctx -> start_time_realtime != AV_NOPTS_VALUE ) { self_start_time = self -> ctx -> start_time_realtime ; ref_start_time = ref -> ctx -> start_time_realtime ; } else if ( self -> start_time_effective != AV_NOPTS_VALUE && ref -> start_time_effective != AV_NOPTS_VALUE ) { self_start_time = self -> start_time_effective ; ref_start_time = ref -> start_time_effective ; } else { start_times_set = 0 ; } if ( start_times_set ) { self_seek_start = self -> start_time == AV_NOPTS_VALUE ? 0 : self -> start_time ; ref_seek_start = ref -> start_time == AV_NOPTS_VALUE ? 0 : ref -> start_time ; adjustment = ( self_start_time - ref_start_time ) + ! copy_ts * ( self_seek_start - ref_seek_start ) + ref -> input_ts_offset ; self -> ts_offset += adjustment ; av_log ( NULL , AV_LOG_INFO , \"Adjusted ts offset for Input #%d by %\" PRId64 \" us to sync with Input #%d.\\n\" , i , adjustment , self -> input_sync_ref ) ; } else { av_log ( NULL , AV_LOG_INFO , \"Unable to identify start times for Inputs #%d and %d both. No sync adjustment made.\\n\" , i , self -> input_sync_ref ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_filter_threads": "int opt_filter_threads ( void * optctx , const char * opt , const char * arg ) { av_free ( filter_nbthreads ) ; filter_nbthreads = av_strdup ( arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_abort_on": "int opt_abort_on ( void * optctx , const char * opt , const char * arg ) { static const AVOption opts [ ] = { { \"abort_on\" , NULL , 0 , AV_OPT_TYPE_FLAGS , { . i64 = 0 } , INT64_MIN , ( double ) INT64_MAX , . unit = \"flags\" } , { \"empty_output\" , NULL , 0 , AV_OPT_TYPE_CONST , { . i64 = ABORT_ON_FLAG_EMPTY_OUTPUT } , . unit = \"flags\" } , { \"empty_output_stream\" , NULL , 0 , AV_OPT_TYPE_CONST , { . i64 = ABORT_ON_FLAG_EMPTY_OUTPUT_STREAM } , . unit = \"flags\" } , { NULL } , } ; static const AVClass class = { . class_name = \"\" , . item_name = av_default_item_name , . option = opts , . version = LIBAVUTIL_VERSION_INT , } ; const AVClass * pclass = & class ; return av_opt_eval_flags ( & pclass , & opts [ 0 ] , arg , & abort_on_flags ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_stats_period": "int opt_stats_period ( void * optctx , const char * opt , const char * arg ) { int64_t user_stats_period = parse_time_or_die ( opt , arg , 1 ) ; if ( user_stats_period <= 0 ) { av_log ( NULL , AV_LOG_ERROR , \"stats_period %s must be positive.\\n\" , arg ) ; return AVERROR ( EINVAL ) ; } stats_period = user_stats_period ; av_log ( NULL , AV_LOG_INFO , \"ffmpeg stats and -progress period set to %s.\\n\" , arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_audio_codec": "int opt_audio_codec ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"codec:a\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_video_codec": "int opt_video_codec ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"codec:v\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_subtitle_codec": "int opt_subtitle_codec ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"codec:s\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_data_codec": "int opt_data_codec ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"codec:d\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_map": "int opt_map ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; StreamMap * m = NULL ; int i , negative = 0 , file_idx , disabled = 0 ; # if FFMPEG_OPT_MAP_SYNC char * sync ; # endif char * map , * p ; char * allow_unused ; if ( * arg == '-' ) { negative = 1 ; arg ++ ; } map = av_strdup ( arg ) ; if ( ! map ) return AVERROR ( ENOMEM ) ; # if FFMPEG_OPT_MAP_SYNC /* parse sync stream first, just pick first matching stream */ if ( ( sync = strchr ( map , ',' ) ) ) { * sync = 0 ; av_log ( NULL , AV_LOG_WARNING , \"Specifying a sync stream is deprecated and has no effect\\n\" ) ; } # endif if ( map [ 0 ] == '[' ) { /* this mapping refers to lavfi output */ const char * c = map + 1 ; GROW_ARRAY ( o -> stream_maps , o -> nb_stream_maps ) ; m = & o -> stream_maps [ o -> nb_stream_maps - 1 ] ; m -> linklabel = av_get_token ( & c , \"]\" ) ; if ( ! m -> linklabel ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid output link label: %s.\\n\" , map ) ; exit_program ( 1 ) ; } } else { if ( ( allow_unused = strchr ( map , '?' ) ) ) * allow_unused = 0 ; file_idx = strtol ( map , & p , 0 ) ; if ( file_idx >= nb_input_files || file_idx < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid input file index: %d.\\n\" , file_idx ) ; exit_program ( 1 ) ; } if ( negative ) /* disable some already defined maps */ for ( i = 0 ; i < o -> nb_stream_maps ; i ++ ) { m = & o -> stream_maps [ i ] ; if ( file_idx == m -> file_index && check_stream_specifier ( input_files [ m -> file_index ] -> ctx , input_files [ m -> file_index ] -> ctx -> streams [ m -> stream_index ] , * p == ':' ? p + 1 : p ) > 0 ) m -> disabled = 1 ; } else for ( i = 0 ; i < input_files [ file_idx ] -> nb_streams ; i ++ ) { if ( check_stream_specifier ( input_files [ file_idx ] -> ctx , input_files [ file_idx ] -> ctx -> streams [ i ] , * p == ':' ? p + 1 : p ) <= 0 ) continue ; if ( input_files [ file_idx ] -> streams [ i ] -> user_set_discard == AVDISCARD_ALL ) { disabled = 1 ; continue ; } GROW_ARRAY ( o -> stream_maps , o -> nb_stream_maps ) ; m = & o -> stream_maps [ o -> nb_stream_maps - 1 ] ; m -> file_index = file_idx ; m -> stream_index = i ; } } if ( ! m ) { if ( allow_unused ) { av_log ( NULL , AV_LOG_VERBOSE , \"Stream map '%s' matches no streams; ignoring.\\n\" , arg ) ; } else if ( disabled ) { av_log ( NULL , AV_LOG_FATAL , \"Stream map '%s' matches disabled streams.\\n\" \"To ignore this, add a trailing '?' to the map.\\n\" , arg ) ; exit_program ( 1 ) ; } else { av_log ( NULL , AV_LOG_FATAL , \"Stream map '%s' matches no streams.\\n\" \"To ignore this, add a trailing '?' to the map.\\n\" , arg ) ; exit_program ( 1 ) ; } } av_freep ( & map ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_attach": "int opt_attach ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; GROW_ARRAY ( o -> attachments , o -> nb_attachments ) ; o -> attachments [ o -> nb_attachments - 1 ] = arg ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_map_channel": "int opt_map_channel ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; int n ; AVStream * st ; AudioChannelMap * m ; char * allow_unused ; char * mapchan ; av_log ( NULL , AV_LOG_WARNING , \"The -%s option is deprecated and will be removed. \" \"It can be replaced by the 'pan' filter, or in some cases by \" \"combinations of 'channelsplit', 'channelmap', 'amerge' filters.\\n\" , opt ) ; mapchan = av_strdup ( arg ) ; if ( ! mapchan ) return AVERROR ( ENOMEM ) ; GROW_ARRAY ( o -> audio_channel_maps , o -> nb_audio_channel_maps ) ; m = & o -> audio_channel_maps [ o -> nb_audio_channel_maps - 1 ] ; /* muted channel syntax */ n = sscanf ( arg , \"%d:%d.%d\" , & m -> channel_idx , & m -> ofile_idx , & m -> ostream_idx ) ; if ( ( n == 1 || n == 3 ) && m -> channel_idx == - 1 ) { m -> file_idx = m -> stream_idx = - 1 ; if ( n == 1 ) m -> ofile_idx = m -> ostream_idx = - 1 ; av_free ( mapchan ) ; return 0 ; } /* normal syntax */ n = sscanf ( arg , \"%d.%d.%d:%d.%d\" , & m -> file_idx , & m -> stream_idx , & m -> channel_idx , & m -> ofile_idx , & m -> ostream_idx ) ; if ( n != 3 && n != 5 ) { av_log ( NULL , AV_LOG_FATAL , \"Syntax error, mapchan usage: \" \"[file.stream.channel|-1][:syncfile:syncstream]\\n\" ) ; exit_program ( 1 ) ; } if ( n != 5 ) // only file.stream.channel specified m -> ofile_idx = m -> ostream_idx = - 1 ; /* check input */ if ( m -> file_idx < 0 || m -> file_idx >= nb_input_files ) { av_log ( NULL , AV_LOG_FATAL , \"mapchan: invalid input file index: %d\\n\" , m -> file_idx ) ; exit_program ( 1 ) ; } if ( m -> stream_idx < 0 || m -> stream_idx >= input_files [ m -> file_idx ] -> nb_streams ) { av_log ( NULL , AV_LOG_FATAL , \"mapchan: invalid input file stream index #%d.%d\\n\" , m -> file_idx , m -> stream_idx ) ; exit_program ( 1 ) ; } st = input_files [ m -> file_idx ] -> ctx -> streams [ m -> stream_idx ] ; if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_FATAL , \"mapchan: stream #%d.%d is not an audio stream.\\n\" , m -> file_idx , m -> stream_idx ) ; exit_program ( 1 ) ; } /* allow trailing ? to map_channel */ if ( ( allow_unused = strchr ( mapchan , '?' ) ) ) * allow_unused = 0 ; if ( m -> channel_idx < 0 || m -> channel_idx >= st -> codecpar -> ch_layout . nb_channels || input_files [ m -> file_idx ] -> streams [ m -> stream_idx ] -> user_set_discard == AVDISCARD_ALL ) { if ( allow_unused ) { av_log ( NULL , AV_LOG_VERBOSE , \"mapchan: invalid audio channel #%d.%d.%d\\n\" , m -> file_idx , m -> stream_idx , m -> channel_idx ) ; } else { av_log ( NULL , AV_LOG_FATAL , \"mapchan: invalid audio channel #%d.%d.%d\\n\" \"To ignore this, add a trailing '?' to the map_channel.\\n\" , m -> file_idx , m -> stream_idx , m -> channel_idx ) ; exit_program ( 1 ) ; } } av_free ( mapchan ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_sdp_file": "int opt_sdp_file ( void * optctx , const char * opt , const char * arg ) { av_free ( sdp_filename ) ; sdp_filename = av_strdup ( arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_init_hw_device": "int opt_init_hw_device ( void * optctx , const char * opt , const char * arg ) { if ( ! strcmp ( arg , \"list\" ) ) { enum AVHWDeviceType type = AV_HWDEVICE_TYPE_NONE ; av_log ( NULL , AV_LOG_STDERR , \"Supported hardware device types:\\n\" ) ; while ( ( type = av_hwdevice_iterate_types ( type ) ) != AV_HWDEVICE_TYPE_NONE ) av_log ( NULL , AV_LOG_STDERR , \"%s\\n\" , av_hwdevice_get_type_name ( type ) ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; exit_program ( 0 ) ; } else { return hw_device_init_from_string ( arg , NULL ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_filter_hw_device": "int opt_filter_hw_device ( void * optctx , const char * opt , const char * arg ) { if ( filter_hw_device ) { av_log ( NULL , AV_LOG_ERROR , \"Only one filter device can be used.\\n\" ) ; return AVERROR ( EINVAL ) ; } filter_hw_device = hw_device_get_by_name ( arg ) ; if ( ! filter_hw_device ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid filter device %s.\\n\" , arg ) ; return AVERROR ( EINVAL ) ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_recording_timestamp": "int opt_recording_timestamp ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; char buf [ 128 ] ; int64_t recording_timestamp = parse_time_or_die ( opt , arg , 0 ) / 1E6 ; struct tm time = * gmtime ( ( time_t * ) & recording_timestamp ) ; if ( ! strftime ( buf , sizeof ( buf ) , \"creation_time=%Y-%m-%dT%H:%M:%S%z\" , & time ) ) return - 1 ; parse_option ( o , \"metadata\" , buf , ffmpeg_options ) ; av_log ( NULL , AV_LOG_WARNING , \"%s is deprecated, set the 'creation_time' metadata \" \"tag instead.\\n\" , opt ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@find_codec_or_die": "const AVCodec * find_codec_or_die ( void * logctx , const char * name , enum AVMediaType type , int encoder ) { const AVCodecDescriptor * desc ; const char * codec_string = encoder ? \"encoder\" : \"decoder\" ; const AVCodec * codec ; codec = encoder ? avcodec_find_encoder_by_name ( name ) : avcodec_find_decoder_by_name ( name ) ; if ( ! codec && ( desc = avcodec_descriptor_get_by_name ( name ) ) ) { codec = encoder ? avcodec_find_encoder ( desc -> id ) : avcodec_find_decoder ( desc -> id ) ; if ( codec ) av_log ( logctx , AV_LOG_VERBOSE , \"Matched %s '%s' for codec '%s'.\\n\" , codec_string , codec -> name , desc -> name ) ; } if ( ! codec ) { av_log ( logctx , AV_LOG_FATAL , \"Unknown %s '%s'\\n\" , codec_string , name ) ; exit_program ( 1 ) ; } if ( codec -> type != type && ! recast_media ) { av_log ( logctx , AV_LOG_FATAL , \"Invalid %s type '%s'\\n\" , codec_string , name ) ; exit_program ( 1 ) ; } return codec ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@assert_file_overwrite": "void assert_file_overwrite ( const char * filename ) { const char * proto_name = avio_find_protocol_name ( filename ) ; if ( file_overwrite && no_file_overwrite ) { av_log ( NULL , AV_LOG_FATAL , \"Error, both -y and -n supplied. Exiting.\\n\" ) ; exit_program ( 1 ) ; } if ( ! file_overwrite ) { if ( proto_name && ! strcmp ( proto_name , \"file\" ) && avio_check ( filename , 0 ) == 0 ) { if ( stdin_interaction && ! no_file_overwrite ) { av_log ( NULL , AV_LOG_FATAL , \"File '%s' already exists. Overwrite? [y/N] \" , filename ) ; term_exit ( ) ; signal ( SIGINT , SIG_DFL ) ; if ( ! read_yesno ( ) ) { av_log ( NULL , AV_LOG_FATAL , \"Not overwriting - exiting\\n\" ) ; exit_program ( 1 ) ; } term_init ( ) ; } else { av_log ( NULL , AV_LOG_FATAL , \"File '%s' already exists. Exiting.\\n\" , filename ) ; exit_program ( 1 ) ; } } } if ( proto_name && ! strcmp ( proto_name , \"file\" ) ) { for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * file = input_files [ i ] ; if ( file -> ctx -> iformat -> flags & AVFMT_NOFILE ) continue ; if ( ! strcmp ( filename , file -> ctx -> url ) ) { av_log ( NULL , AV_LOG_FATAL , \"Output %s same as Input #%d - exiting\\n\" , filename , i ) ; av_log ( NULL , AV_LOG_WARNING , \"FFmpeg cannot edit existing files in-place.\\n\" ) ; exit_program ( 1 ) ; } } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@file_read": "char * file_read ( const char * filename ) { AVIOContext * pb = NULL ; int ret = avio_open ( & pb , filename , AVIO_FLAG_READ ) ; AVBPrint bprint ; char * str ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error opening file %s.\\n\" , filename ) ; return NULL ; } av_bprint_init ( & bprint , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; ret = avio_read_to_bprint ( pb , & bprint , SIZE_MAX ) ; avio_closep ( & pb ) ; if ( ret < 0 ) { av_bprint_finalize ( & bprint , NULL ) ; return NULL ; } ret = av_bprint_finalize ( & bprint , & str ) ; if ( ret < 0 ) return NULL ; return str ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_streamid": "int opt_streamid ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; int idx ; char * p ; char idx_str [ 16 ] ; av_strlcpy ( idx_str , arg , sizeof ( idx_str ) ) ; p = strchr ( idx_str , ':' ) ; if ( ! p ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid value '%s' for option '%s', required syntax is 'index:value'\\n\" , arg , opt ) ; exit_program ( 1 ) ; } * p ++ = '\\0' ; idx = parse_number_or_die ( opt , idx_str , OPT_INT , 0 , MAX_STREAMS - 1 ) ; o -> streamid_map = grow_array ( o -> streamid_map , sizeof ( * o -> streamid_map ) , & o -> nb_streamid_map , idx + 1 ) ; o -> streamid_map [ idx ] = parse_number_or_die ( opt , p , OPT_INT , 0 , INT_MAX ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@init_complex_filters": "int init_complex_filters ( void ) { int i , ret = 0 ; for ( i = 0 ; i < nb_filtergraphs ; i ++ ) { ret = init_complex_filtergraph ( filtergraphs [ i ] ) ; if ( ret < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_target": "int opt_target ( void * optctx , const char * opt , const char * arg ) { const OptionDef * options = ffmpeg_options ; OptionsContext * o = optctx ; enum { PAL , NTSC , FILM , UNKNOWN } norm = UNKNOWN ; static const char * const frame_rates [ ] = { \"25\" , \"30000/1001\" , \"24000/1001\" } ; if ( ! strncmp ( arg , \"pal-\" , 4 ) ) { norm = PAL ; arg += 4 ; } else if ( ! strncmp ( arg , \"ntsc-\" , 5 ) ) { norm = NTSC ; arg += 5 ; } else if ( ! strncmp ( arg , \"film-\" , 5 ) ) { norm = FILM ; arg += 5 ; } else { /* Try to determine PAL/NTSC by peeking in the input files */ if ( nb_input_files ) { int i , j ; for ( j = 0 ; j < nb_input_files ; j ++ ) { for ( i = 0 ; i < input_files [ j ] -> nb_streams ; i ++ ) { AVStream * st = input_files [ j ] -> ctx -> streams [ i ] ; int64_t fr ; if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_VIDEO ) continue ; fr = st -> time_base . den * 1000LL / st -> time_base . num ; if ( fr == 25000 ) { norm = PAL ; break ; } else if ( ( fr == 29970 ) || ( fr == 23976 ) ) { norm = NTSC ; break ; } } if ( norm != UNKNOWN ) break ; } } if ( norm != UNKNOWN ) av_log ( NULL , AV_LOG_INFO , \"Assuming %s for target.\\n\" , norm == PAL ? \"PAL\" : \"NTSC\" ) ; } if ( norm == UNKNOWN ) { av_log ( NULL , AV_LOG_FATAL , \"Could not determine norm (PAL/NTSC/NTSC-Film) for target.\\n\" ) ; av_log ( NULL , AV_LOG_FATAL , \"Please prefix target with \\\"pal-\\\", \\\"ntsc-\\\" or \\\"film-\\\",\\n\" ) ; av_log ( NULL , AV_LOG_FATAL , \"or set a framerate with \\\"-r xxx\\\".\\n\" ) ; exit_program ( 1 ) ; } if ( ! strcmp ( arg , \"vcd\" ) ) { opt_video_codec ( o , \"c:v\" , \"mpeg1video\" ) ; opt_audio_codec ( o , \"c:a\" , \"mp2\" ) ; parse_option ( o , \"f\" , \"vcd\" , options ) ; parse_option ( o , \"s\" , norm == PAL ? \"352x288\" : \"352x240\" , options ) ; parse_option ( o , \"r\" , frame_rates [ norm ] , options ) ; opt_default ( NULL , \"g\" , norm == PAL ? \"15\" : \"18\" ) ; opt_default ( NULL , \"b:v\" , \"1150000\" ) ; opt_default ( NULL , \"maxrate:v\" , \"1150000\" ) ; opt_default ( NULL , \"minrate:v\" , \"1150000\" ) ; opt_default ( NULL , \"bufsize:v\" , \"327680\" ) ; // 40*1024*8; opt_default ( NULL , \"b:a\" , \"224000\" ) ; parse_option ( o , \"ar\" , \"44100\" , options ) ; parse_option ( o , \"ac\" , \"2\" , options ) ; opt_default ( NULL , \"packetsize\" , \"2324\" ) ; opt_default ( NULL , \"muxrate\" , \"1411200\" ) ; // 2352 * 75 * 8; /* We have to offset the PTS, so that it is consistent with the SCR.\n           SCR starts at 36000, but the first two packs contain only padding\n           and the first pack from the other stream, respectively, may also have\n           been written before.\n           So the real data starts at SCR 36000+3*1200. */ o -> mux_preload = ( 36000 + 3 * 1200 ) / 90000.0 ; // 0.44 } else if ( ! strcmp ( arg , \"svcd\" ) ) { opt_video_codec ( o , \"c:v\" , \"mpeg2video\" ) ; opt_audio_codec ( o , \"c:a\" , \"mp2\" ) ; parse_option ( o , \"f\" , \"svcd\" , options ) ; parse_option ( o , \"s\" , norm == PAL ? \"480x576\" : \"480x480\" , options ) ; parse_option ( o , \"r\" , frame_rates [ norm ] , options ) ; parse_option ( o , \"pix_fmt\" , \"yuv420p\" , options ) ; opt_default ( NULL , \"g\" , norm == PAL ? \"15\" : \"18\" ) ; opt_default ( NULL , \"b:v\" , \"2040000\" ) ; opt_default ( NULL , \"maxrate:v\" , \"2516000\" ) ; opt_default ( NULL , \"minrate:v\" , \"0\" ) ; // 1145000; opt_default ( NULL , \"bufsize:v\" , \"1835008\" ) ; // 224*1024*8; opt_default ( NULL , \"scan_offset\" , \"1\" ) ; opt_default ( NULL , \"b:a\" , \"224000\" ) ; parse_option ( o , \"ar\" , \"44100\" , options ) ; opt_default ( NULL , \"packetsize\" , \"2324\" ) ; } else if ( ! strcmp ( arg , \"dvd\" ) ) { opt_video_codec ( o , \"c:v\" , \"mpeg2video\" ) ; opt_audio_codec ( o , \"c:a\" , \"ac3\" ) ; parse_option ( o , \"f\" , \"dvd\" , options ) ; parse_option ( o , \"s\" , norm == PAL ? \"720x576\" : \"720x480\" , options ) ; parse_option ( o , \"r\" , frame_rates [ norm ] , options ) ; parse_option ( o , \"pix_fmt\" , \"yuv420p\" , options ) ; opt_default ( NULL , \"g\" , norm == PAL ? \"15\" : \"18\" ) ; opt_default ( NULL , \"b:v\" , \"6000000\" ) ; opt_default ( NULL , \"maxrate:v\" , \"9000000\" ) ; opt_default ( NULL , \"minrate:v\" , \"0\" ) ; // 1500000; opt_default ( NULL , \"bufsize:v\" , \"1835008\" ) ; // 224*1024*8; opt_default ( NULL , \"packetsize\" , \"2048\" ) ; // from www.mpucoder.com: DVD sectors contain 2048 bytes of data, this is also the size of one pack. opt_default ( NULL , \"muxrate\" , \"10080000\" ) ; // from mplex project: data_rate = 1260000. mux_rate = data_rate * 8 opt_default ( NULL , \"b:a\" , \"448000\" ) ; parse_option ( o , \"ar\" , \"48000\" , options ) ; } else if ( ! strncmp ( arg , \"dv\" , 2 ) ) { parse_option ( o , \"f\" , \"dv\" , options ) ; parse_option ( o , \"s\" , norm == PAL ? \"720x576\" : \"720x480\" , options ) ; parse_option ( o , \"pix_fmt\" , ! strncmp ( arg , \"dv50\" , 4 ) ? \"yuv422p\" : norm == PAL ? \"yuv420p\" : \"yuv411p\" , options ) ; parse_option ( o , \"r\" , frame_rates [ norm ] , options ) ; parse_option ( o , \"ar\" , \"48000\" , options ) ; parse_option ( o , \"ac\" , \"2\" , options ) ; } else { av_log ( NULL , AV_LOG_ERROR , \"Unknown target: %s\\n\" , arg ) ; return AVERROR ( EINVAL ) ; } av_dict_copy ( & o -> g -> codec_opts , codec_opts , AV_DICT_DONT_OVERWRITE ) ; av_dict_copy ( & o -> g -> format_opts , format_opts , AV_DICT_DONT_OVERWRITE ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_vstats_file": "int opt_vstats_file ( void * optctx , const char * opt , const char * arg ) { av_free ( vstats_filename ) ; vstats_filename = av_strdup ( arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_vstats": "int opt_vstats ( void * optctx , const char * opt , const char * arg ) { char filename [ 40 ] ; time_t today2 = time ( NULL ) ; struct tm * today = localtime ( & today2 ) ; if ( ! today ) { // maybe tomorrow av_log ( NULL , AV_LOG_FATAL , \"Unable to get current time: %s\\n\" , strerror ( errno ) ) ; exit_program ( 1 ) ; } snprintf ( filename , sizeof ( filename ) , \"vstats_%02d%02d%02d.log\" , today -> tm_hour , today -> tm_min , today -> tm_sec ) ; return opt_vstats_file ( NULL , opt , filename ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_video_frames": "int opt_video_frames ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"frames:v\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_audio_frames": "int opt_audio_frames ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"frames:a\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_data_frames": "int opt_data_frames ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"frames:d\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_default_new": "int opt_default_new ( OptionsContext * o , const char * opt , const char * arg ) { int ret ; AVDictionary * cbak = codec_opts ; AVDictionary * fbak = format_opts ; codec_opts = NULL ; format_opts = NULL ; ret = opt_default ( NULL , opt , arg ) ; av_dict_copy ( & o -> g -> codec_opts , codec_opts , 0 ) ; av_dict_copy ( & o -> g -> format_opts , format_opts , 0 ) ; av_dict_free ( & codec_opts ) ; av_dict_free ( & format_opts ) ; codec_opts = cbak ; format_opts = fbak ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_preset": "int opt_preset ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; FILE * f = NULL ; char filename [ 1000 ] , line [ 1000 ] , tmp_line [ 1000 ] ; const char * codec_name = NULL ; tmp_line [ 0 ] = * opt ; tmp_line [ 1 ] = 0 ; MATCH_PER_TYPE_OPT ( codec_names , str , codec_name , NULL , tmp_line ) ; if ( ! ( f = get_preset_file ( filename , sizeof ( filename ) , arg , * opt == 'f' , codec_name ) ) ) { if ( ! strncmp ( arg , \"libx264-lossless\" , strlen ( \"libx264-lossless\" ) ) ) { av_log ( NULL , AV_LOG_FATAL , \"Please use -preset <speed> -qp 0\\n\" ) ; } else av_log ( NULL , AV_LOG_FATAL , \"File for preset '%s' not found\\n\" , arg ) ; exit_program ( 1 ) ; } while ( fgets ( line , sizeof ( line ) , f ) ) { char * key = tmp_line , * value , * endptr ; if ( strcspn ( line , \"#\\n\\r\" ) == 0 ) continue ; av_strlcpy ( tmp_line , line , sizeof ( tmp_line ) ) ; if ( ! av_strtok ( key , \"=\" , & value ) || ! av_strtok ( value , \"\\r\\n\" , & endptr ) ) { av_log ( NULL , AV_LOG_FATAL , \"%s: Invalid syntax: '%s'\\n\" , filename , line ) ; exit_program ( 1 ) ; } av_log ( NULL , AV_LOG_DEBUG , \"ffpreset[%s]: set '%s' = '%s'\\n\" , filename , key , value ) ; if ( ! strcmp ( key , \"acodec\" ) ) opt_audio_codec ( o , key , value ) ; else if ( ! strcmp ( key , \"vcodec\" ) ) opt_video_codec ( o , key , value ) ; else if ( ! strcmp ( key , \"scodec\" ) ) opt_subtitle_codec ( o , key , value ) ; else if ( ! strcmp ( key , \"dcodec\" ) ) opt_data_codec ( o , key , value ) ; else if ( opt_default_new ( o , key , value ) < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"%s: Invalid option or argument: '%s', parsed as '%s' = '%s'\\n\" , filename , line , key , value ) ; exit_program ( 1 ) ; } } fclose ( f ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_old2new": "int opt_old2new ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; int ret ; char * s = av_asprintf ( \"%s:%c\" , opt + 1 , * opt ) ; if ( ! s ) return AVERROR ( ENOMEM ) ; ret = parse_option ( o , s , arg , ffmpeg_options ) ; av_free ( s ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_bitrate": "int opt_bitrate ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; if ( ! strcmp ( opt , \"ab\" ) ) { av_dict_set ( & o -> g -> codec_opts , \"b:a\" , arg , 0 ) ; return 0 ; } else if ( ! strcmp ( opt , \"b\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"Please use -b:a or -b:v, -b is ambiguous\\n\" ) ; av_dict_set ( & o -> g -> codec_opts , \"b:v\" , arg , 0 ) ; return 0 ; } av_dict_set ( & o -> g -> codec_opts , opt , arg , 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_qscale": "int opt_qscale ( void * optctx , const char * opt , const char * arg ) { OptionDef * options = ffmpeg_options ; OptionsContext * o = optctx ; char * s ; int ret ; if ( ! strcmp ( opt , \"qscale\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"Please use -q:a or -q:v, -qscale is ambiguous\\n\" ) ; return parse_option ( o , \"q:v\" , arg , options ) ; } s = av_asprintf ( \"q%s\" , opt + 6 ) ; if ( ! s ) return AVERROR ( ENOMEM ) ; ret = parse_option ( o , s , arg , options ) ; av_free ( s ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_profile": "int opt_profile ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; if ( ! strcmp ( opt , \"profile\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"Please use -profile:a or -profile:v, -profile is ambiguous\\n\" ) ; av_dict_set ( & o -> g -> codec_opts , \"profile:v\" , arg , 0 ) ; return 0 ; } av_dict_set ( & o -> g -> codec_opts , opt , arg , 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_video_filters": "int opt_video_filters ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"filter:v\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_audio_filters": "int opt_audio_filters ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"filter:a\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_vsync": "int opt_vsync ( void * optctx , const char * opt , const char * arg ) { av_log ( NULL , AV_LOG_WARNING , \"-vsync is deprecated. Use -fps_mode\\n\" ) ; parse_and_set_vsync ( arg , & video_sync_method , - 1 , - 1 , 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_timecode": "int opt_timecode ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; int ret ; char * tcr = av_asprintf ( \"timecode=%s\" , arg ) ; if ( ! tcr ) return AVERROR ( ENOMEM ) ; ret = parse_option ( o , \"metadata:g\" , tcr , ffmpeg_options ) ; if ( ret >= 0 ) ret = av_dict_set ( & o -> g -> codec_opts , \"gop_timecode\" , arg , 0 ) ; av_free ( tcr ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_audio_qscale": "int opt_audio_qscale ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"q:a\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_filter_complex": "int opt_filter_complex ( void * optctx , const char * opt , const char * arg ) { FilterGraph * fg = ALLOC_ARRAY_ELEM ( filtergraphs , nb_filtergraphs ) ; fg -> index = nb_filtergraphs - 1 ; fg -> graph_desc = av_strdup ( arg ) ; if ( ! fg -> graph_desc ) return AVERROR ( ENOMEM ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_filter_complex_script": "int opt_filter_complex_script ( void * optctx , const char * opt , const char * arg ) { FilterGraph * fg ; char * graph_desc = file_read ( arg ) ; if ( ! graph_desc ) return AVERROR ( EINVAL ) ; fg = ALLOC_ARRAY_ELEM ( filtergraphs , nb_filtergraphs ) ; fg -> index = nb_filtergraphs - 1 ; fg -> graph_desc = graph_desc ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@show_help_default_ffmpeg": "void show_help_default_ffmpeg ( const char * opt , const char * arg ) { OptionDef * options = ffmpeg_options ; /* per-file options have at least one of those set */ const int per_file = OPT_SPEC | OPT_OFFSET | OPT_PERFILE ; int show_advanced = 0 , show_avoptions = 0 ; if ( opt && * opt ) { if ( ! strcmp ( opt , \"long\" ) ) show_advanced = 1 ; else if ( ! strcmp ( opt , \"full\" ) ) show_advanced = show_avoptions = 1 ; else av_log ( NULL , AV_LOG_ERROR , \"Unknown help option '%s'.\\n\" , opt ) ; } show_usage ( ) ; av_log ( NULL , AV_LOG_STDERR , \"Getting help:\\n\" \"    -h      -- print basic options\\n\" \"    -h long -- print more options\\n\" \"    -h full -- print all options (including all format and codec specific options, very long)\\n\" \"    -h type=name -- print all options for the named decoder/encoder/demuxer/muxer/filter/bsf/protocol\\n\" \"    See man %s for detailed description of the options.\\n\" \"\\n\" , program_name ) ; show_help_options ( options , \"Print help / information / capabilities:\" , OPT_EXIT , 0 , 0 ) ; show_help_options ( options , \"Global options (affect whole program \" \"instead of just one file):\" , 0 , per_file | OPT_EXIT | OPT_EXPERT , 0 ) ; if ( show_advanced ) show_help_options ( options , \"Advanced global options:\" , OPT_EXPERT , per_file | OPT_EXIT , 0 ) ; show_help_options ( options , \"Per-file main options:\" , 0 , OPT_EXPERT | OPT_AUDIO | OPT_VIDEO | OPT_SUBTITLE | OPT_EXIT , per_file ) ; if ( show_advanced ) show_help_options ( options , \"Advanced per-file options:\" , OPT_EXPERT , OPT_AUDIO | OPT_VIDEO | OPT_SUBTITLE , per_file ) ; show_help_options ( options , \"Video options:\" , OPT_VIDEO , OPT_EXPERT | OPT_AUDIO , 0 ) ; if ( show_advanced ) show_help_options ( options , \"Advanced Video options:\" , OPT_EXPERT | OPT_VIDEO , OPT_AUDIO , 0 ) ; show_help_options ( options , \"Audio options:\" , OPT_AUDIO , OPT_EXPERT | OPT_VIDEO , 0 ) ; if ( show_advanced ) show_help_options ( options , \"Advanced Audio options:\" , OPT_EXPERT | OPT_AUDIO , OPT_VIDEO , 0 ) ; show_help_options ( options , \"Subtitle options:\" , OPT_SUBTITLE , 0 , 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; if ( show_avoptions ) { int flags = AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_ENCODING_PARAM ; show_help_children ( avcodec_get_class ( ) , flags ) ; show_help_children ( avformat_get_class ( ) , flags ) ; # if CONFIG_SWSCALE show_help_children ( sws_get_class ( ) , flags ) ; # endif # if CONFIG_SWRESAMPLE show_help_children ( swr_get_class ( ) , AV_OPT_FLAG_AUDIO_PARAM ) ; # endif show_help_children ( avfilter_get_class ( ) , AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM ) ; show_help_children ( av_bsf_get_class ( ) , AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_BSF_PARAM ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@show_usage": "void show_usage ( void ) { av_log ( NULL , AV_LOG_INFO , \"Hyper fast Audio and Video encoder\\n\" ) ; av_log ( NULL , AV_LOG_INFO , \"usage: %s [options] [[infile options] -i infile]... {[outfile options] outfile}...\\n\" , program_name ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@open_files": "int open_files ( OptionGroupList * l , const char * inout , int ( * open_file ) ( const OptionsContext * , const char * ) ) { int i , ret ; for ( i = 0 ; i < l -> nb_groups ; i ++ ) { OptionGroup * g = & l -> groups [ i ] ; OptionsContext o ; init_options ( & o ) ; o . g = g ; ret = parse_optgroup ( & o , g ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing options for %s file \" \"%s.\\n\" , inout , g -> arg ) ; uninit_options ( & o ) ; return ret ; } av_log ( NULL , AV_LOG_DEBUG , \"Opening an %s file: %s.\\n\" , inout , g -> arg ) ; ret = open_file ( & o , g -> arg ) ; uninit_options ( & o ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error opening %s file %s.\\n\" , inout , g -> arg ) ; return ret ; } av_log ( NULL , AV_LOG_DEBUG , \"Successfully opened the file.\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@ffmpeg_parse_options": "int ffmpeg_parse_options ( int argc , char * * argv ) { OptionParseContext octx ; int ret ; memset ( & octx , 0 , sizeof ( octx ) ) ; /* split the commandline into an internal representation */ ret = split_commandline ( & octx , argc , argv , ffmpeg_options , groups , FF_ARRAY_ELEMS ( groups ) ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error splitting the argument list: \" ) ; goto fail ; } /* apply global options */ ret = parse_optgroup ( NULL , & octx . global_opts ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error parsing global options: \" ) ; goto fail ; } /* configure terminal and setup signal handlers */ term_init ( ) ; /* open input files */ ret = open_files ( & octx . groups [ GROUP_INFILE ] , \"input\" , ifile_open ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error opening input files: \" ) ; goto fail ; } /* create the complex filtergraphs */ ret = init_complex_filters ( ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error initializing complex filters.\\n\" ) ; goto fail ; } /* open output files */ ret = open_files ( & octx . groups [ GROUP_OUTFILE ] , \"output\" , of_open ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error opening output files: \" ) ; goto fail ; } correct_input_start_times ( ) ; apply_sync_offsets ( ) ; check_filter_outputs ( ) ; fail : uninit_parse_context ( & octx ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"%s\\n\" , av_err2str ( ret ) ) ; } return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_progress": "int opt_progress ( void * optctx , const char * opt , const char * arg ) { AVIOContext * avio = NULL ; int ret ; if ( ! strcmp ( arg , \"-\" ) ) arg = \"pipe:\" ; ret = avio_open2 ( & avio , arg , AVIO_FLAG_WRITE , & int_cb , NULL ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Failed to open progress URL \\\"%s\\\": %s\\n\" , arg , av_err2str ( ret ) ) ; return ret ; } progress_avio = avio ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_opt.c@opt_timelimit": "int opt_timelimit ( void * optctx , const char * opt , const char * arg ) { # if HAVE_SETRLIMIT int lim = parse_number_or_die ( opt , arg , OPT_INT64 , 0 , INT_MAX ) ; struct rlimit rl = { lim , lim + 1 } ; if ( setrlimit ( RLIMIT_CPU , & rl ) ) perror ( \"setrlimit\" ) ; # else av_log ( NULL , AV_LOG_WARNING , \"-%s not implemented on this OS\\n\" , opt ) ; # endif return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_license": "int show_license ( void * optctx , const char * opt , const char * arg ) { # if CONFIG_NONFREE av_log ( NULL , AV_LOG_ERROR , \"This version of %s has nonfree parts compiled in.\\n\" \"Therefore it is not legally redistributable.\\n\" , program_name ) ; # elif CONFIG_GPLV3 av_log ( NULL , AV_LOG_ERROR , \"%s is free software; you can redistribute it and/or modify\\n\" \"it under the terms of the GNU General Public License as published by\\n\" \"the Free Software Foundation; either version 3 of the License, or\\n\" \"(at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\" \"GNU General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU General Public License\\n\" \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\" , program_name , program_name , program_name ) ; # elif CONFIG_GPL av_log ( NULL , AV_LOG_ERROR , \"%s is free software; you can redistribute it and/or modify\\n\" \"it under the terms of the GNU General Public License as published by\\n\" \"the Free Software Foundation; either version 2 of the License, or\\n\" \"(at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\" \"GNU General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU General Public License\\n\" \"along with %s; if not, write to the Free Software\\n\" \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\" , program_name , program_name , program_name ) ; # elif CONFIG_LGPLV3 av_log ( NULL , AV_LOG_ERROR , \"%s is free software; you can redistribute it and/or modify\\n\" \"it under the terms of the GNU Lesser General Public License as published by\\n\" \"the Free Software Foundation; either version 3 of the License, or\\n\" \"(at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\" \"GNU Lesser General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU Lesser General Public License\\n\" \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\" , program_name , program_name , program_name ) ; # else av_log ( NULL , AV_LOG_ERROR , \"%s is free software; you can redistribute it and/or\\n\" \"modify it under the terms of the GNU Lesser General Public\\n\" \"License as published by the Free Software Foundation; either\\n\" \"version 2.1 of the License, or (at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\n\" \"Lesser General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU Lesser General Public\\n\" \"License along with %s; if not, write to the Free Software\\n\" \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\" , program_name , program_name , program_name ) ; # endif return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@print_all_libs_info": "static void print_all_libs_info ( int flags , int level ) { PRINT_LIB_INFO ( avutil , AVUTIL , flags , level ) ; PRINT_LIB_INFO ( avcodec , AVCODEC , flags , level ) ; PRINT_LIB_INFO ( avformat , AVFORMAT , flags , level ) ; PRINT_LIB_INFO ( avdevice , AVDEVICE , flags , level ) ; PRINT_LIB_INFO ( avfilter , AVFILTER , flags , level ) ; PRINT_LIB_INFO ( swscale , SWSCALE , flags , level ) ; PRINT_LIB_INFO ( swresample , SWRESAMPLE , flags , level ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@print_program_info": "static void print_program_info ( int flags , int level ) { const char * indent = flags & INDENT ? \"  \" : \"\" ; av_log ( NULL , level , \"%s version \" FFMPEG_VERSION , program_name ) ; if ( flags & SHOW_COPYRIGHT ) av_log ( NULL , level , \" Copyright (c) %d-%d the FFmpeg developers\" , program_birth_year , CONFIG_THIS_YEAR ) ; av_log ( NULL , level , \"\\n\" ) ; av_log ( NULL , level , \"%sbuilt with %s\\n\" , indent , CC_IDENT ) ; av_log ( NULL , level , \"%sconfiguration: \" FFMPEG_CONFIGURATION \"\\n\" , indent ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@print_buildconf": "static void print_buildconf ( int flags , int level ) { const char * indent = flags & INDENT ? \"  \" : \"\" ; char str [ ] = { FFMPEG_CONFIGURATION } ; char * conflist , * remove_tilde , * splitconf ; // Change all the ' --' strings to '~--' so that // they can be identified as tokens. while ( ( conflist = strstr ( str , \" --\" ) ) != NULL ) { conflist [ 0 ] = '~' ; } // Compensate for the weirdness this would cause // when passing 'pkg-config --static'. while ( ( remove_tilde = strstr ( str , \"pkg-config~\" ) ) != NULL ) { remove_tilde [ sizeof ( \"pkg-config~\" ) - 2 ] = ' ' ; } splitconf = strtok ( str , \"~\" ) ; av_log ( NULL , level , \"\\n%sconfiguration:\\n\" , indent ) ; while ( splitconf != NULL ) { av_log ( NULL , level , \"%s%s%s\\n\" , indent , indent , splitconf ) ; splitconf = strtok ( NULL , \"~\" ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_banner": "void show_banner ( int argc , char * * argv , const OptionDef * options ) { int idx = locate_option ( argc , argv , options , \"version\" ) ; if ( hide_banner || idx ) return ; print_program_info ( INDENT | SHOW_COPYRIGHT , AV_LOG_INFO ) ; print_all_libs_info ( INDENT | SHOW_CONFIG , AV_LOG_INFO ) ; print_all_libs_info ( INDENT | SHOW_VERSION , AV_LOG_INFO ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_version": "int show_version ( void * optctx , const char * opt , const char * arg ) { print_program_info ( SHOW_COPYRIGHT , AV_LOG_INFO ) ; print_all_libs_info ( SHOW_VERSION , AV_LOG_INFO ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_buildconf": "int show_buildconf ( void * optctx , const char * opt , const char * arg ) { print_buildconf ( INDENT | 0 , AV_LOG_INFO ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@print_codec": "static void print_codec ( const AVCodec * c ) { int encoder = av_codec_is_encoder ( c ) ; av_log ( NULL , AV_LOG_ERROR , \"%s %s [%s]:\\n\" , encoder ? \"Encoder\" : \"Decoder\" , c -> name , c -> long_name ? c -> long_name : \"\" ) ; av_log ( NULL , AV_LOG_ERROR , \"    General capabilities: \" ) ; if ( c -> capabilities & AV_CODEC_CAP_DRAW_HORIZ_BAND ) av_log ( NULL , AV_LOG_ERROR , \"horizband \" ) ; if ( c -> capabilities & AV_CODEC_CAP_DR1 ) av_log ( NULL , AV_LOG_ERROR , \"dr1 \" ) ; if ( c -> capabilities & AV_CODEC_CAP_DELAY ) av_log ( NULL , AV_LOG_ERROR , \"delay \" ) ; if ( c -> capabilities & AV_CODEC_CAP_SMALL_LAST_FRAME ) av_log ( NULL , AV_LOG_ERROR , \"small \" ) ; if ( c -> capabilities & AV_CODEC_CAP_SUBFRAMES ) av_log ( NULL , AV_LOG_ERROR , \"subframes \" ) ; if ( c -> capabilities & AV_CODEC_CAP_EXPERIMENTAL ) av_log ( NULL , AV_LOG_ERROR , \"exp \" ) ; if ( c -> capabilities & AV_CODEC_CAP_CHANNEL_CONF ) av_log ( NULL , AV_LOG_ERROR , \"chconf \" ) ; if ( c -> capabilities & AV_CODEC_CAP_PARAM_CHANGE ) av_log ( NULL , AV_LOG_ERROR , \"paramchange \" ) ; if ( c -> capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE ) av_log ( NULL , AV_LOG_ERROR , \"variable \" ) ; if ( c -> capabilities & ( AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_OTHER_THREADS ) ) av_log ( NULL , AV_LOG_ERROR , \"threads \" ) ; if ( c -> capabilities & AV_CODEC_CAP_AVOID_PROBING ) av_log ( NULL , AV_LOG_ERROR , \"avoidprobe \" ) ; if ( c -> capabilities & AV_CODEC_CAP_HARDWARE ) av_log ( NULL , AV_LOG_ERROR , \"hardware \" ) ; if ( c -> capabilities & AV_CODEC_CAP_HYBRID ) av_log ( NULL , AV_LOG_ERROR , \"hybrid \" ) ; if ( ! c -> capabilities ) av_log ( NULL , AV_LOG_ERROR , \"none\" ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; if ( c -> type == AVMEDIA_TYPE_VIDEO || c -> type == AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_ERROR , \"    Threading capabilities: \" ) ; switch ( c -> capabilities & ( AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_OTHER_THREADS ) ) { case AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS : av_log ( NULL , AV_LOG_ERROR , \"frame and slice\" ) ; break ; case AV_CODEC_CAP_FRAME_THREADS : av_log ( NULL , AV_LOG_ERROR , \"frame\" ) ; break ; case AV_CODEC_CAP_SLICE_THREADS : av_log ( NULL , AV_LOG_ERROR , \"slice\" ) ; break ; case AV_CODEC_CAP_OTHER_THREADS : av_log ( NULL , AV_LOG_ERROR , \"other\" ) ; break ; default : av_log ( NULL , AV_LOG_ERROR , \"none\" ) ; break ; } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } if ( avcodec_get_hw_config ( c , 0 ) ) { av_log ( NULL , AV_LOG_ERROR , \"    Supported hardware devices: \" ) ; for ( int i = 0 ; ; i ++ ) { const AVCodecHWConfig * config = avcodec_get_hw_config ( c , i ) ; if ( ! config ) break ; av_log ( NULL , AV_LOG_ERROR , \"%s \" , av_hwdevice_get_type_name ( config -> device_type ) ) ; } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } if ( c -> supported_framerates ) { const AVRational * fps = c -> supported_framerates ; av_log ( NULL , AV_LOG_ERROR , \"    Supported framerates:\" ) ; while ( fps -> num ) { av_log ( NULL , AV_LOG_ERROR , \" %d/%d\" , fps -> num , fps -> den ) ; fps ++ ; } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } PRINT_CODEC_SUPPORTED ( c , pix_fmts , enum AVPixelFormat , \"pixel formats\" , AV_PIX_FMT_NONE , GET_PIX_FMT_NAME ) ; PRINT_CODEC_SUPPORTED ( c , supported_samplerates , int , \"sample rates\" , 0 , GET_SAMPLE_RATE_NAME ) ; PRINT_CODEC_SUPPORTED ( c , sample_fmts , enum AVSampleFormat , \"sample formats\" , AV_SAMPLE_FMT_NONE , GET_SAMPLE_FMT_NAME ) ; if ( c -> ch_layouts ) { const AVChannelLayout * p = c -> ch_layouts ; av_log ( NULL , AV_LOG_ERROR , \"    Supported channel layouts:\" ) ; while ( p -> nb_channels ) { char name [ 128 ] ; av_channel_layout_describe ( p , name , sizeof ( name ) ) ; av_log ( NULL , AV_LOG_ERROR , \" %s\" , name ) ; p ++ ; } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } if ( c -> priv_class ) { show_help_children ( c -> priv_class , AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_DECODING_PARAM ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@next_codec_for_id": "static const AVCodec * next_codec_for_id ( enum AVCodecID id , void * * iter , int encoder ) { const AVCodec * c ; while ( ( c = av_codec_iterate ( iter ) ) ) { if ( c -> id == id && ( encoder ? av_codec_is_encoder ( c ) : av_codec_is_decoder ( c ) ) ) return c ; } return NULL ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_help_codec": "static void show_help_codec ( const char * name , int encoder ) { const AVCodecDescriptor * desc ; const AVCodec * codec ; if ( ! name ) { av_log ( NULL , AV_LOG_ERROR , \"No codec name specified.\\n\" ) ; return ; } codec = encoder ? avcodec_find_encoder_by_name ( name ) : avcodec_find_decoder_by_name ( name ) ; if ( codec ) print_codec ( codec ) ; else if ( ( desc = avcodec_descriptor_get_by_name ( name ) ) ) { void * iter = NULL ; int printed = 0 ; while ( ( codec = next_codec_for_id ( desc -> id , & iter , encoder ) ) ) { printed = 1 ; print_codec ( codec ) ; } if ( ! printed ) { av_log ( NULL , AV_LOG_ERROR , \"Codec '%s' is known to FFmpeg, \" \"but no %s for it are available. FFmpeg might need to be \" \"recompiled with additional external libraries.\\n\" , name , encoder ? \"encoders\" : \"decoders\" ) ; } } else { av_log ( NULL , AV_LOG_ERROR , \"Codec '%s' is not recognized by FFmpeg.\\n\" , name ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_help_demuxer": "static void show_help_demuxer ( const char * name ) { const AVInputFormat * fmt = av_find_input_format ( name ) ; if ( ! fmt ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown format '%s'.\\n\" , name ) ; return ; } av_log ( NULL , AV_LOG_ERROR , \"Demuxer %s [%s]:\\n\" , fmt -> name , fmt -> long_name ) ; if ( fmt -> extensions ) av_log ( NULL , AV_LOG_ERROR , \"    Common extensions: %s.\\n\" , fmt -> extensions ) ; if ( fmt -> priv_class ) show_help_children ( fmt -> priv_class , AV_OPT_FLAG_DECODING_PARAM ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_help_protocol": "static void show_help_protocol ( const char * name ) { const AVClass * proto_class ; if ( ! name ) { av_log ( NULL , AV_LOG_ERROR , \"No protocol name specified.\\n\" ) ; return ; } proto_class = avio_protocol_get_class ( name ) ; if ( ! proto_class ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown protocol '%s'.\\n\" , name ) ; return ; } show_help_children ( proto_class , AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_ENCODING_PARAM ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_help_muxer": "static void show_help_muxer ( const char * name ) { const AVCodecDescriptor * desc ; const AVOutputFormat * fmt = av_guess_format ( name , NULL , NULL ) ; if ( ! fmt ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown format '%s'.\\n\" , name ) ; return ; } av_log ( NULL , AV_LOG_ERROR , \"Muxer %s [%s]:\\n\" , fmt -> name , fmt -> long_name ) ; if ( fmt -> extensions ) av_log ( NULL , AV_LOG_ERROR , \"    Common extensions: %s.\\n\" , fmt -> extensions ) ; if ( fmt -> mime_type ) av_log ( NULL , AV_LOG_ERROR , \"    Mime type: %s.\\n\" , fmt -> mime_type ) ; if ( fmt -> video_codec != AV_CODEC_ID_NONE && ( desc = avcodec_descriptor_get ( fmt -> video_codec ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"    Default video codec: %s.\\n\" , desc -> name ) ; } if ( fmt -> audio_codec != AV_CODEC_ID_NONE && ( desc = avcodec_descriptor_get ( fmt -> audio_codec ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"    Default audio codec: %s.\\n\" , desc -> name ) ; } if ( fmt -> subtitle_codec != AV_CODEC_ID_NONE && ( desc = avcodec_descriptor_get ( fmt -> subtitle_codec ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"    Default subtitle codec: %s.\\n\" , desc -> name ) ; } if ( fmt -> priv_class ) show_help_children ( fmt -> priv_class , AV_OPT_FLAG_ENCODING_PARAM ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_help_bsf": "static void show_help_bsf ( const char * name ) { const AVBitStreamFilter * bsf = av_bsf_get_by_name ( name ) ; if ( ! name ) { av_log ( NULL , AV_LOG_ERROR , \"No bitstream filter name specified.\\n\" ) ; return ; } else if ( ! bsf ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown bit stream filter '%s'.\\n\" , name ) ; return ; } av_log ( NULL , AV_LOG_ERROR , \"Bit stream filter %s\\n\" , bsf -> name ) ; PRINT_CODEC_SUPPORTED ( bsf , codec_ids , enum AVCodecID , \"codecs\" , AV_CODEC_ID_NONE , GET_CODEC_NAME ) ; if ( bsf -> priv_class ) show_help_children ( bsf -> priv_class , AV_OPT_FLAG_BSF_PARAM ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_help": "int show_help ( void * optctx , const char * opt , const char * arg ) { char * topic , * par ; topic = av_strdup ( arg ? arg : \"\" ) ; if ( ! topic ) return AVERROR ( ENOMEM ) ; par = strchr ( topic , '=' ) ; if ( par ) * par ++ = 0 ; if ( ! * topic ) { if ( program_name && ! strcmp ( program_name , \"ffmpeg\" ) ) { show_help_default_ffmpeg ( topic , par ) ; } else { show_help_default_ffprobe ( topic , par ) ; } } else if ( ! strcmp ( topic , \"decoder\" ) ) { show_help_codec ( par , 0 ) ; } else if ( ! strcmp ( topic , \"encoder\" ) ) { show_help_codec ( par , 1 ) ; } else if ( ! strcmp ( topic , \"demuxer\" ) ) { show_help_demuxer ( par ) ; } else if ( ! strcmp ( topic , \"muxer\" ) ) { show_help_muxer ( par ) ; } else if ( ! strcmp ( topic , \"protocol\" ) ) { show_help_protocol ( par ) ; # if CONFIG_AVFILTER } else if ( ! strcmp ( topic , \"filter\" ) ) { show_help_filter ( par ) ; # endif } else if ( ! strcmp ( topic , \"bsf\" ) ) { show_help_bsf ( par ) ; } else { if ( program_name && ! strcmp ( program_name , \"ffmpeg\" ) ) { show_help_default_ffmpeg ( topic , par ) ; } else { show_help_default_ffprobe ( topic , par ) ; } } av_freep ( & topic ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@print_codecs_for_id": "static void print_codecs_for_id ( enum AVCodecID id , int encoder ) { void * iter = NULL ; const AVCodec * codec ; av_log ( NULL , AV_LOG_ERROR , \" (%s: \" , encoder ? \"encoders\" : \"decoders\" ) ; while ( ( codec = next_codec_for_id ( id , & iter , encoder ) ) ) av_log ( NULL , AV_LOG_ERROR , \"%s \" , codec -> name ) ; av_log ( NULL , AV_LOG_ERROR , \")\" ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@compare_codec_desc": "static int compare_codec_desc ( const void * a , const void * b ) { const AVCodecDescriptor * const * da = a ; const AVCodecDescriptor * const * db = b ; return ( * da ) -> type != ( * db ) -> type ? FFDIFFSIGN ( ( * da ) -> type , ( * db ) -> type ) : strcmp ( ( * da ) -> name , ( * db ) -> name ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@get_codecs_sorted": "static unsigned get_codecs_sorted ( const AVCodecDescriptor * * * rcodecs ) { const AVCodecDescriptor * desc = NULL ; const AVCodecDescriptor * * codecs ; unsigned nb_codecs = 0 , i = 0 ; while ( ( desc = avcodec_descriptor_next ( desc ) ) ) nb_codecs ++ ; if ( ! ( codecs = av_calloc ( nb_codecs , sizeof ( * codecs ) ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"Out of memory\\n\" ) ; exit_program ( 1 ) ; } desc = NULL ; while ( ( desc = avcodec_descriptor_next ( desc ) ) ) codecs [ i ++ ] = desc ; av_assert0 ( i == nb_codecs ) ; qsort ( codecs , nb_codecs , sizeof ( * codecs ) , compare_codec_desc ) ; * rcodecs = codecs ; return nb_codecs ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@get_media_type_char": "static char get_media_type_char ( enum AVMediaType type ) { switch ( type ) { case AVMEDIA_TYPE_VIDEO : return 'V' ; case AVMEDIA_TYPE_AUDIO : return 'A' ; case AVMEDIA_TYPE_DATA : return 'D' ; case AVMEDIA_TYPE_SUBTITLE : return 'S' ; case AVMEDIA_TYPE_ATTACHMENT : return 'T' ; default : return '?' ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_codecs": "int show_codecs ( void * optctx , const char * opt , const char * arg ) { const AVCodecDescriptor * * codecs ; unsigned i , nb_codecs = get_codecs_sorted ( & codecs ) ; av_log ( NULL , AV_LOG_ERROR , \"Codecs:\\n\" \" D..... = Decoding supported\\n\" \" .E.... = Encoding supported\\n\" \" ..V... = Video codec\\n\" \" ..A... = Audio codec\\n\" \" ..S... = Subtitle codec\\n\" \" ..D... = Data codec\\n\" \" ..T... = Attachment codec\\n\" \" ...I.. = Intra frame-only codec\\n\" \" ....L. = Lossy compression\\n\" \" .....S = Lossless compression\\n\" \" -------\\n\" ) ; for ( i = 0 ; i < nb_codecs ; i ++ ) { const AVCodecDescriptor * desc = codecs [ i ] ; const AVCodec * codec ; void * iter = NULL ; if ( strstr ( desc -> name , \"_deprecated\" ) ) continue ; av_log ( NULL , AV_LOG_ERROR , \" \" ) ; av_log ( NULL , AV_LOG_ERROR , avcodec_find_decoder ( desc -> id ) ? \"D\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , avcodec_find_encoder ( desc -> id ) ? \"E\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , \"%c\" , get_media_type_char ( desc -> type ) ) ; av_log ( NULL , AV_LOG_ERROR , ( desc -> props & AV_CODEC_PROP_INTRA_ONLY ) ? \"I\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( desc -> props & AV_CODEC_PROP_LOSSY ) ? \"L\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( desc -> props & AV_CODEC_PROP_LOSSLESS ) ? \"S\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , \" %-20s %s\" , desc -> name , desc -> long_name ? desc -> long_name : \"\" ) ; /* print decoders/encoders when there's more than one or their\n         * names are different from codec name */ while ( ( codec = next_codec_for_id ( desc -> id , & iter , 0 ) ) ) { if ( strcmp ( codec -> name , desc -> name ) ) { print_codecs_for_id ( desc -> id , 0 ) ; break ; } } iter = NULL ; while ( ( codec = next_codec_for_id ( desc -> id , & iter , 1 ) ) ) { if ( strcmp ( codec -> name , desc -> name ) ) { print_codecs_for_id ( desc -> id , 1 ) ; break ; } } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } av_free ( codecs ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@print_codecs": "static void print_codecs ( int encoder ) { const AVCodecDescriptor * * codecs ; unsigned i , nb_codecs = get_codecs_sorted ( & codecs ) ; av_log ( NULL , AV_LOG_ERROR , \"%s:\\n\" \" V..... = Video\\n\" \" A..... = Audio\\n\" \" S..... = Subtitle\\n\" \" .F.... = Frame-level multithreading\\n\" \" ..S... = Slice-level multithreading\\n\" \" ...X.. = Codec is experimental\\n\" \" ....B. = Supports draw_horiz_band\\n\" \" .....D = Supports direct rendering method 1\\n\" \" ------\\n\" , encoder ? \"Encoders\" : \"Decoders\" ) ; for ( i = 0 ; i < nb_codecs ; i ++ ) { const AVCodecDescriptor * desc = codecs [ i ] ; const AVCodec * codec ; void * iter = NULL ; while ( ( codec = next_codec_for_id ( desc -> id , & iter , encoder ) ) ) { av_log ( NULL , AV_LOG_ERROR , \" %c\" , get_media_type_char ( desc -> type ) ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_FRAME_THREADS ) ? \"F\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_SLICE_THREADS ) ? \"S\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_EXPERIMENTAL ) ? \"X\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_DRAW_HORIZ_BAND ) ? \"B\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_DR1 ) ? \"D\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , \" %-20s %s\" , codec -> name , codec -> long_name ? codec -> long_name : \"\" ) ; if ( strcmp ( codec -> name , desc -> name ) ) av_log ( NULL , AV_LOG_ERROR , \" (codec %s)\" , desc -> name ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } } av_free ( codecs ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_decoders": "int show_decoders ( void * optctx , const char * opt , const char * arg ) { print_codecs ( 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_encoders": "int show_encoders ( void * optctx , const char * opt , const char * arg ) { print_codecs ( 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_bsfs": "int show_bsfs ( void * optctx , const char * opt , const char * arg ) { const AVBitStreamFilter * bsf = NULL ; void * opaque = NULL ; av_log ( NULL , AV_LOG_ERROR , \"Bitstream filters:\\n\" ) ; while ( ( bsf = av_bsf_iterate ( & opaque ) ) ) av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" , bsf -> name ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_filters": "int show_filters ( void * optctx , const char * opt , const char * arg ) { # if CONFIG_AVFILTER const AVFilter * filter = NULL ; char descr [ 64 ] , * descr_cur ; void * opaque = NULL ; int i , j ; const AVFilterPad * pad ; av_log ( NULL , AV_LOG_ERROR , \"Filters:\\n\" \"  T.. = Timeline support\\n\" \"  .S. = Slice threading\\n\" \"  ..C = Command support\\n\" \"  A = Audio input/output\\n\" \"  V = Video input/output\\n\" \"  N = Dynamic number and/or type of input/output\\n\" \"  | = Source or sink filter\\n\" ) ; while ( ( filter = av_filter_iterate ( & opaque ) ) ) { descr_cur = descr ; for ( i = 0 ; i < 2 ; i ++ ) { unsigned nb_pads ; if ( i ) { * ( descr_cur ++ ) = '-' ; * ( descr_cur ++ ) = '>' ; } pad = i ? filter -> outputs : filter -> inputs ; nb_pads = avfilter_filter_pad_count ( filter , i ) ; for ( j = 0 ; j < nb_pads ; j ++ ) { if ( descr_cur >= descr + sizeof ( descr ) - 4 ) break ; * ( descr_cur ++ ) = get_media_type_char ( avfilter_pad_get_type ( pad , j ) ) ; } if ( ! j ) * ( descr_cur ++ ) = ( ( ! i && ( filter -> flags & AVFILTER_FLAG_DYNAMIC_INPUTS ) ) || ( i && ( filter -> flags & AVFILTER_FLAG_DYNAMIC_OUTPUTS ) ) ) ? 'N' : '|' ; } * descr_cur = 0 ; av_log ( NULL , AV_LOG_ERROR , \" %c%c%c %-17s %-10s %s\\n\" , filter -> flags & AVFILTER_FLAG_SUPPORT_TIMELINE ? 'T' : '.' , filter -> flags & AVFILTER_FLAG_SLICE_THREADS ? 'S' : '.' , filter -> process_command ? 'C' : '.' , filter -> name , descr , filter -> description ) ; } # else av_log ( NULL , AV_LOG_ERROR , \"No filters available: libavfilter disabled\\n\" ) ; # endif return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@is_device": "static int is_device ( const AVClass * avclass ) { if ( ! avclass ) return 0 ; return AV_IS_INPUT_DEVICE ( avclass -> category ) || AV_IS_OUTPUT_DEVICE ( avclass -> category ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_formats_devices": "static int show_formats_devices ( void * optctx , const char * opt , const char * arg , int device_only , int muxdemuxers ) { void * ifmt_opaque = NULL ; const AVInputFormat * ifmt = NULL ; void * ofmt_opaque = NULL ; const AVOutputFormat * ofmt = NULL ; const char * last_name ; int is_dev ; av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" \" D. = Demuxing supported\\n\" \" .E = Muxing supported\\n\" \" --\\n\" , device_only ? \"Devices:\" : \"File formats:\" ) ; last_name = \"000\" ; for ( ; ; ) { int decode = 0 ; int encode = 0 ; const char * name = NULL ; const char * long_name = NULL ; if ( muxdemuxers != SHOW_DEMUXERS ) { ofmt_opaque = NULL ; while ( ( ofmt = av_muxer_iterate ( & ofmt_opaque ) ) ) { is_dev = is_device ( ofmt -> priv_class ) ; if ( ! is_dev && device_only ) continue ; if ( ( ! name || strcmp ( ofmt -> name , name ) < 0 ) && strcmp ( ofmt -> name , last_name ) > 0 ) { name = ofmt -> name ; long_name = ofmt -> long_name ; encode = 1 ; } } } if ( muxdemuxers != SHOW_MUXERS ) { ifmt_opaque = NULL ; while ( ( ifmt = av_demuxer_iterate ( & ifmt_opaque ) ) ) { is_dev = is_device ( ifmt -> priv_class ) ; if ( ! is_dev && device_only ) continue ; if ( ( ! name || strcmp ( ifmt -> name , name ) < 0 ) && strcmp ( ifmt -> name , last_name ) > 0 ) { name = ifmt -> name ; long_name = ifmt -> long_name ; encode = 0 ; } if ( name && strcmp ( ifmt -> name , name ) == 0 ) decode = 1 ; } } if ( ! name ) break ; last_name = name ; av_log ( NULL , AV_LOG_ERROR , \" %c%c %-15s %s\\n\" , decode ? 'D' : ' ' , encode ? 'E' : ' ' , name , long_name ? long_name : \" \" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_formats": "int show_formats ( void * optctx , const char * opt , const char * arg ) { return show_formats_devices ( optctx , opt , arg , 0 , SHOW_DEFAULT ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_muxers": "int show_muxers ( void * optctx , const char * opt , const char * arg ) { return show_formats_devices ( optctx , opt , arg , 0 , SHOW_MUXERS ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_demuxers": "int show_demuxers ( void * optctx , const char * opt , const char * arg ) { return show_formats_devices ( optctx , opt , arg , 0 , SHOW_DEMUXERS ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_devices": "int show_devices ( void * optctx , const char * opt , const char * arg ) { return show_formats_devices ( optctx , opt , arg , 1 , SHOW_DEFAULT ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_protocols": "int show_protocols ( void * optctx , const char * opt , const char * arg ) { void * opaque = NULL ; const char * name ; av_log ( NULL , AV_LOG_ERROR , \"Supported file protocols:\\n\" \"Input:\\n\" ) ; while ( ( name = avio_enum_protocols ( & opaque , 0 ) ) ) av_log ( NULL , AV_LOG_ERROR , \"  %s\\n\" , name ) ; av_log ( NULL , AV_LOG_ERROR , \"Output:\\n\" ) ; while ( ( name = avio_enum_protocols ( & opaque , 1 ) ) ) av_log ( NULL , AV_LOG_ERROR , \"  %s\\n\" , name ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_colors": "int show_colors ( void * optctx , const char * opt , const char * arg ) { const char * name ; const uint8_t * rgb ; int i ; av_log ( NULL , AV_LOG_ERROR , \"%-32s #RRGGBB\\n\" , \"name\" ) ; for ( i = 0 ; ( name = av_get_known_color_name ( i , & rgb ) ) ; i ++ ) av_log ( NULL , AV_LOG_ERROR , \"%-32s #%02x%02x%02x\\n\" , name , rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_pix_fmts": "int show_pix_fmts ( void * optctx , const char * opt , const char * arg ) { const AVPixFmtDescriptor * pix_desc = NULL ; av_log ( NULL , AV_LOG_ERROR , \"Pixel formats:\\n\" \"I.... = Supported Input  format for conversion\\n\" \".O... = Supported Output format for conversion\\n\" \"..H.. = Hardware accelerated format\\n\" \"...P. = Paletted format\\n\" \"....B = Bitstream format\\n\" \"FLAGS NAME            NB_COMPONENTS BITS_PER_PIXEL BIT_DEPTHS\\n\" \"-----\\n\" ) ; # if ! CONFIG_SWSCALE # define sws_isSupportedInput ( x ) 0 # define sws_isSupportedOutput ( x ) 0 # endif while ( ( pix_desc = av_pix_fmt_desc_next ( pix_desc ) ) ) { enum AVPixelFormat av_unused pix_fmt = av_pix_fmt_desc_get_id ( pix_desc ) ; av_log ( NULL , AV_LOG_ERROR , \"%c%c%c%c%c %-16s       %d            %3d      %d\" , sws_isSupportedInput ( pix_fmt ) ? 'I' : '.' , sws_isSupportedOutput ( pix_fmt ) ? 'O' : '.' , pix_desc -> flags & AV_PIX_FMT_FLAG_HWACCEL ? 'H' : '.' , pix_desc -> flags & AV_PIX_FMT_FLAG_PAL ? 'P' : '.' , pix_desc -> flags & AV_PIX_FMT_FLAG_BITSTREAM ? 'B' : '.' , pix_desc -> name , pix_desc -> nb_components , av_get_bits_per_pixel ( pix_desc ) , pix_desc -> comp [ 0 ] . depth ) ; for ( unsigned i = 1 ; i < pix_desc -> nb_components ; i ++ ) av_log ( NULL , AV_LOG_ERROR , \"-%d\" , pix_desc -> comp [ i ] . depth ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_layouts": "int show_layouts ( void * optctx , const char * opt , const char * arg ) { const AVChannelLayout * ch_layout ; void * iter = NULL ; char buf [ 128 ] , buf2 [ 128 ] ; int i = 0 ; av_log ( NULL , AV_LOG_ERROR , \"Individual channels:\\n\" \"NAME           DESCRIPTION\\n\" ) ; for ( i = 0 ; i < 63 ; i ++ ) { av_channel_name ( buf , sizeof ( buf ) , i ) ; if ( strstr ( buf , \"USR\" ) ) continue ; av_channel_description ( buf2 , sizeof ( buf2 ) , i ) ; av_log ( NULL , AV_LOG_ERROR , \"%-14s %s\\n\" , buf , buf2 ) ; } av_log ( NULL , AV_LOG_ERROR , \"\\nStandard channel layouts:\\n\" \"NAME           DECOMPOSITION\\n\" ) ; while ( ( ch_layout = av_channel_layout_standard ( & iter ) ) ) { av_channel_layout_describe ( ch_layout , buf , sizeof ( buf ) ) ; av_log ( NULL , AV_LOG_ERROR , \"%-14s \" , buf ) ; for ( i = 0 ; i < 63 ; i ++ ) { int idx = av_channel_layout_index_from_channel ( ch_layout , i ) ; if ( idx >= 0 ) { av_channel_name ( buf2 , sizeof ( buf2 ) , i ) ; av_log ( NULL , AV_LOG_ERROR , \"%s%s\" , idx ? \"+\" : \"\" , buf2 ) ; } } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_sample_fmts": "int show_sample_fmts ( void * optctx , const char * opt , const char * arg ) { int i ; char fmt_str [ 128 ] ; for ( i = - 1 ; i < AV_SAMPLE_FMT_NB ; i ++ ) av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" , av_get_sample_fmt_string ( fmt_str , sizeof ( fmt_str ) , i ) ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@show_dispositions": "int show_dispositions ( void * optctx , const char * opt , const char * arg ) { for ( int i = 0 ; i < 32 ; i ++ ) { const char * str = av_disposition_to_string ( 1U << i ) ; if ( str ) av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" , str ) ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@opt_cpuflags": "int opt_cpuflags ( void * optctx , const char * opt , const char * arg ) { int ret ; unsigned flags = av_get_cpu_flags ( ) ; if ( ( ret = av_parse_cpu_caps ( & flags , arg ) ) < 0 ) return ret ; av_force_cpu_flags ( flags ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@opt_cpucount": "int opt_cpucount ( void * optctx , const char * opt , const char * arg ) { int ret ; int count ; static const AVOption opts [ ] = { { \"count\" , NULL , 0 , AV_OPT_TYPE_INT , { . i64 = - 1 } , - 1 , INT_MAX } , { NULL } , } ; static const AVClass class = { . class_name = \"cpucount\" , . item_name = av_default_item_name , . option = opts , . version = LIBAVUTIL_VERSION_INT , } ; const AVClass * pclass = & class ; ret = av_opt_eval_int ( & pclass , opts , arg , & count ) ; if ( ! ret ) { av_cpu_force_count ( count ) ; } return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@expand_filename_template": "static void expand_filename_template ( AVBPrint * bp , const char * template , struct tm * tm ) { int c ; while ( ( c = * ( template ++ ) ) ) { if ( c == '%' ) { if ( ! ( c = * ( template ++ ) ) ) break ; switch ( c ) { case 'p' : av_bprintf ( bp , \"%s\" , program_name ) ; break ; case 't' : av_bprintf ( bp , \"%04d%02d%02d-%02d%02d%02d\" , tm -> tm_year + 1900 , tm -> tm_mon + 1 , tm -> tm_mday , tm -> tm_hour , tm -> tm_min , tm -> tm_sec ) ; break ; case '%' : av_bprint_chars ( bp , c , 1 ) ; break ; } } else { av_bprint_chars ( bp , c , 1 ) ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@log_callback_report": "static void log_callback_report ( void * ptr , int level , const char * fmt , va_list vl ) { va_list vl2 ; char line [ 1024 ] ; static int print_prefix = 1 ; va_copy ( vl2 , vl ) ; if ( report_callback == NULL ) { av_log_default_callback ( ptr , level , fmt , vl ) ; } else { ffmpegkit_log_callback_function ( ptr , level , fmt , vl ) ; } av_log_format_line ( ptr , level , fmt , vl2 , line , sizeof ( line ) , & print_prefix ) ; va_end ( vl2 ) ; if ( report_file && report_file_level >= level ) { fputs ( line , report_file ) ; fflush ( report_file ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@init_report": "int init_report ( const char * env , FILE * * file ) { char * filename_template = NULL ; char * key , * val ; int ret , count = 0 ; int prog_loglevel , envlevel = 0 ; time_t now ; struct tm * tm ; AVBPrint filename ; if ( report_file ) /* already opened */ return 0 ; time ( & now ) ; tm = localtime ( & now ) ; while ( env && * env ) { if ( ( ret = av_opt_get_key_value ( & env , \"=\" , \":\" , 0 , & key , & val ) ) < 0 ) { if ( count ) av_log ( NULL , AV_LOG_ERROR , \"Failed to parse FFREPORT environment variable: %s\\n\" , av_err2str ( ret ) ) ; break ; } if ( * env ) env ++ ; count ++ ; if ( ! strcmp ( key , \"file\" ) ) { av_free ( filename_template ) ; filename_template = val ; val = NULL ; } else if ( ! strcmp ( key , \"level\" ) ) { char * tail ; report_file_level = strtol ( val , & tail , 10 ) ; if ( * tail ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid report file level\\n\" ) ; exit_program ( 1 ) ; } envlevel = 1 ; } else { av_log ( NULL , AV_LOG_ERROR , \"Unknown key '%s' in FFREPORT\\n\" , key ) ; } av_free ( val ) ; av_free ( key ) ; } av_bprint_init ( & filename , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; expand_filename_template ( & filename , av_x_if_null ( filename_template , \"%p-%t.log\" ) , tm ) ; av_free ( filename_template ) ; if ( ! av_bprint_is_complete ( & filename ) ) { av_log ( NULL , AV_LOG_ERROR , \"Out of memory building report file name\\n\" ) ; return AVERROR ( ENOMEM ) ; } prog_loglevel = av_log_get_level ( ) ; if ( ! envlevel ) report_file_level = FFMAX ( report_file_level , prog_loglevel ) ; report_file = fopen ( filename . str , \"w\" ) ; if ( ! report_file ) { int ret = AVERROR ( errno ) ; av_log ( NULL , AV_LOG_ERROR , \"Failed to open report \\\"%s\\\": %s\\n\" , filename . str , strerror ( errno ) ) ; return ret ; } av_log_set_callback ( log_callback_report ) ; av_log ( NULL , AV_LOG_INFO , \"%s started on %04d-%02d-%02d at %02d:%02d:%02d\\n\" \"Report written to \\\"%s\\\"\\n\" \"Log level: %d\\n\" , program_name , tm -> tm_year + 1900 , tm -> tm_mon + 1 , tm -> tm_mday , tm -> tm_hour , tm -> tm_min , tm -> tm_sec , filename . str , report_file_level ) ; av_bprint_finalize ( & filename , NULL ) ; if ( file ) * file = report_file ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@opt_report": "int opt_report ( void * optctx , const char * opt , const char * arg ) { return init_report ( NULL , NULL ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@opt_max_alloc": "int opt_max_alloc ( void * optctx , const char * opt , const char * arg ) { char * tail ; size_t max ; max = strtol ( arg , & tail , 10 ) ; if ( * tail ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid max_alloc \\\"%s\\\".\\n\" , arg ) ; exit_program ( 1 ) ; } av_max_alloc ( max ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_opt_common.c@opt_loglevel": "int opt_loglevel ( void * optctx , const char * opt , const char * arg ) { const struct { const char * name ; int level ; } log_levels [ ] = { { \"quiet\" , AV_LOG_QUIET } , { \"panic\" , AV_LOG_PANIC } , { \"fatal\" , AV_LOG_FATAL } , { \"error\" , AV_LOG_ERROR } , { \"warning\" , AV_LOG_WARNING } , { \"info\" , AV_LOG_INFO } , { \"verbose\" , AV_LOG_VERBOSE } , { \"debug\" , AV_LOG_DEBUG } , { \"trace\" , AV_LOG_TRACE } , } ; const char * token ; char * tail ; int flags = av_log_get_flags ( ) ; int level = av_log_get_level ( ) ; int cmd , i = 0 ; av_assert0 ( arg ) ; while ( * arg ) { token = arg ; if ( * token == '+' || * token == '-' ) { cmd = * token ++ ; } else { cmd = 0 ; } if ( ! i && ! cmd ) { flags = 0 ; /* missing relative prefix, build absolute value */ } if ( av_strstart ( token , \"repeat\" , & arg ) ) { if ( cmd == '-' ) { flags |= AV_LOG_SKIP_REPEATED ; } else { flags &= ~ AV_LOG_SKIP_REPEATED ; } } else if ( av_strstart ( token , \"level\" , & arg ) ) { if ( cmd == '-' ) { flags &= ~ AV_LOG_PRINT_LEVEL ; } else { flags |= AV_LOG_PRINT_LEVEL ; } } else { break ; } i ++ ; } if ( ! * arg ) { goto end ; } else if ( * arg == '+' ) { arg ++ ; } else if ( ! i ) { flags = av_log_get_flags ( ) ; /* level value without prefix, reset flags */ } for ( i = 0 ; i < FF_ARRAY_ELEMS ( log_levels ) ; i ++ ) { if ( ! strcmp ( log_levels [ i ] . name , arg ) ) { level = log_levels [ i ] . level ; goto end ; } } level = strtol ( arg , & tail , 10 ) ; if ( * tail ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid loglevel \\\"%s\\\". \" \"Possible levels are numbers or:\\n\" , arg ) ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( log_levels ) ; i ++ ) av_log ( NULL , AV_LOG_FATAL , \"\\\"%s\\\"\\n\" , log_levels [ i ] . name ) ; exit_program ( 1 ) ; } end : av_log_set_flags ( flags ) ; av_log_set_level ( level ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@sub2video_get_blank_frame": "static int sub2video_get_blank_frame ( InputStream * ist ) { int ret ; AVFrame * frame = ist -> sub2video . frame ; av_frame_unref ( frame ) ; ist -> sub2video . frame -> width = ist -> dec_ctx -> width ? ist -> dec_ctx -> width : ist -> sub2video . w ; ist -> sub2video . frame -> height = ist -> dec_ctx -> height ? ist -> dec_ctx -> height : ist -> sub2video . h ; ist -> sub2video . frame -> format = AV_PIX_FMT_RGB32 ; if ( ( ret = av_frame_get_buffer ( frame , 0 ) ) < 0 ) return ret ; memset ( frame -> data [ 0 ] , 0 , frame -> height * frame -> linesize [ 0 ] ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@sub2video_copy_rect": "static void sub2video_copy_rect ( uint8_t * dst , int dst_linesize , int w , int h , AVSubtitleRect * r ) { uint32_t * pal , * dst2 ; uint8_t * src , * src2 ; int x , y ; if ( r -> type != SUBTITLE_BITMAP ) { av_log ( NULL , AV_LOG_WARNING , \"sub2video: non-bitmap subtitle\\n\" ) ; return ; } if ( r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h ) { av_log ( NULL , AV_LOG_WARNING , \"sub2video: rectangle (%d %d %d %d) overflowing %d %d\\n\" , r -> x , r -> y , r -> w , r -> h , w , h ) ; return ; } dst += r -> y * dst_linesize + r -> x * 4 ; src = r -> data [ 0 ] ; pal = ( uint32_t * ) r -> data [ 1 ] ; for ( y = 0 ; y < r -> h ; y ++ ) { dst2 = ( uint32_t * ) dst ; src2 = src ; for ( x = 0 ; x < r -> w ; x ++ ) * ( dst2 ++ ) = pal [ * ( src2 ++ ) ] ; dst += dst_linesize ; src += r -> linesize [ 0 ] ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@sub2video_push_ref": "static void sub2video_push_ref ( InputStream * ist , int64_t pts ) { AVFrame * frame = ist -> sub2video . frame ; int i ; int ret ; av_assert1 ( frame -> data [ 0 ] ) ; ist -> sub2video . last_pts = frame -> pts = pts ; for ( i = 0 ; i < ist -> nb_filters ; i ++ ) { ret = av_buffersrc_add_frame_flags ( ist -> filters [ i ] -> filter , frame , AV_BUFFERSRC_FLAG_KEEP_REF | AV_BUFFERSRC_FLAG_PUSH ) ; if ( ret != AVERROR_EOF && ret < 0 ) av_log ( NULL , AV_LOG_WARNING , \"Error while add the frame to buffer source(%s).\\n\" , av_err2str ( ret ) ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@sub2video_update": "void sub2video_update ( InputStream * ist , int64_t heartbeat_pts , AVSubtitle * sub ) { AVFrame * frame = ist -> sub2video . frame ; int8_t * dst ; int dst_linesize ; int num_rects , i ; int64_t pts , end_pts ; if ( ! frame ) return ; if ( sub ) { pts = av_rescale_q ( sub -> pts + sub -> start_display_time * 1000LL , AV_TIME_BASE_Q , ist -> st -> time_base ) ; end_pts = av_rescale_q ( sub -> pts + sub -> end_display_time * 1000LL , AV_TIME_BASE_Q , ist -> st -> time_base ) ; num_rects = sub -> num_rects ; } else { /* If we are initializing the system, utilize current heartbeat\n           PTS as the start time, and show until the following subpicture\n           is received. Otherwise, utilize the previous subpicture's end time\n           as the fall-back value. */ pts = ist -> sub2video . initialize ? heartbeat_pts : ist -> sub2video . end_pts ; end_pts = INT64_MAX ; num_rects = 0 ; } if ( sub2video_get_blank_frame ( ist ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Impossible to get a blank canvas.\\n\" ) ; return ; } dst = frame -> data [ 0 ] ; dst_linesize = frame -> linesize [ 0 ] ; for ( i = 0 ; i < num_rects ; i ++ ) sub2video_copy_rect ( dst , dst_linesize , frame -> width , frame -> height , sub -> rects [ i ] ) ; sub2video_push_ref ( ist , pts ) ; ist -> sub2video . end_pts = end_pts ; ist -> sub2video . initialize = 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@sub2video_heartbeat": "static void sub2video_heartbeat ( InputStream * ist , int64_t pts ) { InputFile * infile = input_files [ ist -> file_index ] ; int i , j , nb_reqs ; int64_t pts2 ; /* When a frame is read from a file, examine all sub2video streams in\n       the same file and send the sub2video frame again. Otherwise, decoded\n       video frames could be accumulating in the filter graph while a filter\n       (possibly overlay) is desperately waiting for a subtitle frame. */ for ( i = 0 ; i < infile -> nb_streams ; i ++ ) { InputStream * ist2 = infile -> streams [ i ] ; if ( ! ist2 -> sub2video . frame ) continue ; /* subtitles seem to be usually muxed ahead of other streams;\n           if not, subtracting a larger time here is necessary */ pts2 = av_rescale_q ( pts , ist -> st -> time_base , ist2 -> st -> time_base ) - 1 ; /* do not send the heartbeat frame if the subtitle is already ahead */ if ( pts2 <= ist2 -> sub2video . last_pts ) continue ; if ( pts2 >= ist2 -> sub2video . end_pts || ist2 -> sub2video . initialize ) /* if we have hit the end of the current displayed subpicture,\n               or if we need to initialize the system, update the\n               overlayed subpicture and its start/end times */ sub2video_update ( ist2 , pts2 + 1 , NULL ) ; for ( j = 0 , nb_reqs = 0 ; j < ist2 -> nb_filters ; j ++ ) nb_reqs += av_buffersrc_get_nb_failed_requests ( ist2 -> filters [ j ] -> filter ) ; if ( nb_reqs ) sub2video_push_ref ( ist2 , pts2 ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@sub2video_flush": "static void sub2video_flush ( InputStream * ist ) { int i ; int ret ; if ( ist -> sub2video . end_pts < INT64_MAX ) sub2video_update ( ist , INT64_MAX , NULL ) ; for ( i = 0 ; i < ist -> nb_filters ; i ++ ) { ret = av_buffersrc_add_frame ( ist -> filters [ i ] -> filter , NULL ) ; if ( ret != AVERROR_EOF && ret < 0 ) av_log ( NULL , AV_LOG_WARNING , \"Flush the frame error.\\n\" ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@term_exit_sigsafe": "static void term_exit_sigsafe ( void ) { # if HAVE_TERMIOS_H if ( restore_tty ) tcsetattr ( 0 , TCSANOW , & oldtty ) ; # endif }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@term_exit": "void term_exit ( void ) { av_log ( NULL , AV_LOG_QUIET , \"%s\" , \"\" ) ; term_exit_sigsafe ( ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@sigterm_handler": "static void sigterm_handler ( int sig ) { // int ret; received_sigterm = sig ; received_nb_signals ++ ; term_exit_sigsafe ( ) ; // FFmpegKit - Hard Exit Disabled // if(received_nb_signals > 3) { //     ret = write(2/*STDERR_FILENO*/, \"Received > 3 system signals, hard exiting\\n\", //                 strlen(\"Received > 3 system signals, hard exiting\\n\")); //     if (ret < 0) { /* Do nothing */ }; //     exit(123); // } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@term_init": "void term_init ( void ) { # if defined __linux__ # if defined __aarch64__ || defined __amd64__ || defined __x86_64__ struct sigaction action = { 0 } ; # else struct sigaction action = { { 0 } } ; # endif action . sa_handler = sigterm_handler ; /* block other interrupts while processing this one */ sigfillset ( & action . sa_mask ) ; /* restart interruptible functions (i.e. don't fail with EINTR)  */ action . sa_flags = SA_RESTART ; # endif # if HAVE_TERMIOS_H if ( stdin_interaction ) { struct termios tty ; if ( tcgetattr ( 0 , & tty ) == 0 ) { oldtty = tty ; restore_tty = 1 ; tty . c_iflag &= ~ ( IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL | IXON ) ; tty . c_oflag |= OPOST ; tty . c_lflag &= ~ ( ECHO | ECHONL | ICANON | IEXTEN ) ; tty . c_cflag &= ~ ( CSIZE | PARENB ) ; tty . c_cflag |= CS8 ; tty . c_cc [ VMIN ] = 1 ; tty . c_cc [ VTIME ] = 0 ; tcsetattr ( 0 , TCSANOW , & tty ) ; } if ( handleSIGQUIT == 1 ) { SIGNAL ( SIGQUIT , sigterm_handler ) ; /* Quit (POSIX).  */ } } # endif if ( handleSIGINT == 1 ) { SIGNAL ( SIGINT , sigterm_handler ) ; /* Interrupt (ANSI).    */ } if ( handleSIGTERM == 1 ) { SIGNAL ( SIGTERM , sigterm_handler ) ; /* Termination (ANSI).  */ } # ifdef SIGXCPU if ( handleSIGXCPU == 1 ) { SIGNAL ( SIGXCPU , sigterm_handler ) ; } # endif # ifdef SIGPIPE if ( handleSIGPIPE == 1 ) { SIGNAL ( SIGPIPE , SIG_IGN ) ; /* Broken pipe (POSIX). */ } # endif # if HAVE_SETCONSOLECTRLHANDLER SetConsoleCtrlHandler ( ( PHANDLER_ROUTINE ) CtrlHandler , TRUE ) ; # endif }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@read_key": "static int read_key ( void ) { unsigned char ch ; # if HAVE_TERMIOS_H int n = 1 ; struct timeval tv ; fd_set rfds ; FD_ZERO ( & rfds ) ; FD_SET ( 0 , & rfds ) ; tv . tv_sec = 0 ; tv . tv_usec = 0 ; n = select ( 1 , & rfds , NULL , NULL , & tv ) ; if ( n > 0 ) { n = read ( 0 , & ch , 1 ) ; if ( n == 1 ) return ch ; return n ; } # elif HAVE_KBHIT # if HAVE_PEEKNAMEDPIPE static int is_pipe ; static HANDLE input_handle ; DWORD dw , nchars ; if ( ! input_handle ) { input_handle = GetStdHandle ( STD_INPUT_HANDLE ) ; is_pipe = ! GetConsoleMode ( input_handle , & dw ) ; } if ( is_pipe ) { /* When running under a GUI, you will end here. */ if ( ! PeekNamedPipe ( input_handle , NULL , 0 , NULL , & nchars , NULL ) ) { // input pipe may have been closed by the program that ran ffmpeg return - 1 ; } //Read it if ( nchars != 0 ) { read ( 0 , & ch , 1 ) ; return ch ; } else { return - 1 ; } } # endif if ( kbhit ( ) ) return ( getch ( ) ) ; # endif return - 1 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@decode_interrupt_cb": "int decode_interrupt_cb ( void * ctx ) { return received_nb_signals > atomic_load ( & transcode_init_done ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@ffmpeg_cleanup": "static void ffmpeg_cleanup ( int ret ) { int i , j ; if ( do_benchmark ) { int maxrss = getmaxrss ( ) / 1024 ; av_log ( NULL , AV_LOG_INFO , \"bench: maxrss=%ikB\\n\" , maxrss ) ; } for ( i = 0 ; i < nb_filtergraphs ; i ++ ) { FilterGraph * fg = filtergraphs [ i ] ; avfilter_graph_free ( & fg -> graph ) ; for ( j = 0 ; j < fg -> nb_inputs ; j ++ ) { InputFilter * ifilter = fg -> inputs [ j ] ; struct InputStream * ist = ifilter -> ist ; if ( ifilter -> frame_queue ) { AVFrame * frame ; while ( av_fifo_read ( ifilter -> frame_queue , & frame , 1 ) >= 0 ) av_frame_free ( & frame ) ; av_fifo_freep2 ( & ifilter -> frame_queue ) ; } av_freep ( & ifilter -> displaymatrix ) ; if ( ist -> sub2video . sub_queue ) { AVSubtitle sub ; while ( av_fifo_read ( ist -> sub2video . sub_queue , & sub , 1 ) >= 0 ) avsubtitle_free ( & sub ) ; av_fifo_freep2 ( & ist -> sub2video . sub_queue ) ; } av_buffer_unref ( & ifilter -> hw_frames_ctx ) ; av_freep ( & ifilter -> name ) ; av_freep ( & fg -> inputs [ j ] ) ; } av_freep ( & fg -> inputs ) ; for ( j = 0 ; j < fg -> nb_outputs ; j ++ ) { OutputFilter * ofilter = fg -> outputs [ j ] ; avfilter_inout_free ( & ofilter -> out_tmp ) ; av_freep ( & ofilter -> name ) ; av_channel_layout_uninit ( & ofilter -> ch_layout ) ; av_freep ( & fg -> outputs [ j ] ) ; } av_freep ( & fg -> outputs ) ; av_freep ( & fg -> graph_desc ) ; av_freep ( & filtergraphs [ i ] ) ; } av_freep ( & filtergraphs ) ; /* close files */ for ( i = 0 ; i < nb_output_files ; i ++ ) of_close ( & output_files [ i ] ) ; for ( i = 0 ; i < nb_input_files ; i ++ ) ifile_close ( & input_files [ i ] ) ; if ( vstats_file ) { if ( fclose ( vstats_file ) ) av_log ( NULL , AV_LOG_ERROR , \"Error closing vstats file, loss of information possible: %s\\n\" , av_err2str ( AVERROR ( errno ) ) ) ; } av_freep ( & vstats_filename ) ; of_enc_stats_close ( ) ; av_freep ( & filter_nbthreads ) ; av_freep ( & input_files ) ; av_freep ( & output_files ) ; uninit_opts ( ) ; avformat_network_deinit ( ) ; if ( received_sigterm ) { av_log ( NULL , AV_LOG_INFO , \"Exiting normally, received signal %d.\\n\" , ( int ) received_sigterm ) ; } else if ( cancelRequested ( globalSessionId ) ) { av_log ( NULL , AV_LOG_INFO , \"Exiting normally, received cancel request.\\n\" ) ; } else if ( ret && atomic_load ( & transcode_init_done ) ) { av_log ( NULL , AV_LOG_INFO , \"Conversion failed!\\n\" ) ; } term_exit ( ) ; ffmpeg_exited = 1 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@ost_iter": "static OutputStream * ost_iter ( OutputStream * prev ) { int of_idx = prev ? prev -> file_index : 0 ; int ost_idx = prev ? prev -> index + 1 : 0 ; for ( ; of_idx < nb_output_files ; of_idx ++ ) { OutputFile * of = output_files [ of_idx ] ; if ( ost_idx < of -> nb_streams ) return of -> streams [ ost_idx ] ; ost_idx = 0 ; } return NULL ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@ist_iter": "InputStream * ist_iter ( InputStream * prev ) { int if_idx = prev ? prev -> file_index : 0 ; int ist_idx = prev ? prev -> st -> index + 1 : 0 ; for ( ; if_idx < nb_input_files ; if_idx ++ ) { InputFile * f = input_files [ if_idx ] ; if ( ist_idx < f -> nb_streams ) return f -> streams [ ist_idx ] ; ist_idx = 0 ; } return NULL ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@remove_avoptions": "void remove_avoptions ( AVDictionary * * a , AVDictionary * b ) { const AVDictionaryEntry * t = NULL ; while ( ( t = av_dict_iterate ( b , t ) ) ) { av_dict_set ( a , t -> key , NULL , AV_DICT_MATCH_CASE ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@assert_avoptions": "void assert_avoptions ( AVDictionary * m ) { const AVDictionaryEntry * t ; if ( ( t = av_dict_get ( m , \"\" , NULL , AV_DICT_IGNORE_SUFFIX ) ) ) { av_log ( NULL , AV_LOG_FATAL , \"Option %s not found.\\n\" , t -> key ) ; exit_program ( 1 ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@abort_codec_experimental": "static void abort_codec_experimental ( const AVCodec * c , int encoder ) { exit_program ( 1 ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@update_benchmark": "static void update_benchmark ( const char * fmt , ... ) { if ( do_benchmark_all ) { BenchmarkTimeStamps t = get_benchmark_time_stamps ( ) ; va_list va ; char buf [ 1024 ] ; if ( fmt ) { va_start ( va , fmt ) ; vsnprintf ( buf , sizeof ( buf ) , fmt , va ) ; va_end ( va ) ; av_log ( NULL , AV_LOG_INFO , \"bench: %8\" PRIu64 \" user %8\" PRIu64 \" sys %8\" PRIu64 \" real %s \\n\" , t . user_usec - current_time . user_usec , t . sys_usec - current_time . sys_usec , t . real_usec - current_time . real_usec , buf ) ; } current_time = t ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@close_output_stream": "static void close_output_stream ( OutputStream * ost ) { OutputFile * of = output_files [ ost -> file_index ] ; ost -> finished |= ENCODER_FINISHED ; if ( ost -> sq_idx_encode >= 0 ) sq_send ( of -> sq_encode , ost -> sq_idx_encode , SQFRAME ( NULL ) ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@check_recording_time": "static int check_recording_time ( OutputStream * ost , int64_t ts , AVRational tb ) { OutputFile * of = output_files [ ost -> file_index ] ; if ( of -> recording_time != INT64_MAX && av_compare_ts ( ts , tb , of -> recording_time , AV_TIME_BASE_Q ) >= 0 ) { close_output_stream ( ost ) ; return 0 ; } return 1 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@adjust_frame_pts_to_encoder_tb": "static double adjust_frame_pts_to_encoder_tb ( OutputFile * of , OutputStream * ost , AVFrame * frame ) { double float_pts = AV_NOPTS_VALUE ; // this is identical to frame.pts but with higher precision const int64_t start_time = ( of -> start_time == AV_NOPTS_VALUE ) ? 0 : of -> start_time ; AVCodecContext * const enc = ost -> enc_ctx ; AVRational tb = enc -> time_base ; AVRational filter_tb = frame -> time_base ; const int extra_bits = av_clip ( 29 - av_log2 ( tb . den ) , 0 , 16 ) ; if ( frame -> pts == AV_NOPTS_VALUE ) goto early_exit ; tb . den <<= extra_bits ; float_pts = av_rescale_q ( frame -> pts , filter_tb , tb ) - av_rescale_q ( start_time , AV_TIME_BASE_Q , tb ) ; float_pts /= 1 << extra_bits ; // avoid exact midoints to reduce the chance of rounding differences, this // can be removed in case the fps code is changed to work with integers float_pts += FFSIGN ( float_pts ) * 1.0 / ( 1 << 17 ) ; frame -> pts = av_rescale_q ( frame -> pts , filter_tb , enc -> time_base ) - av_rescale_q ( start_time , AV_TIME_BASE_Q , enc -> time_base ) ; frame -> time_base = enc -> time_base ; early_exit : if ( debug_ts ) { av_log ( NULL , AV_LOG_INFO , \"filter -> pts:%s pts_time:%s exact:%f time_base:%d/%d\\n\" , frame ? av_ts2str ( frame -> pts ) : \"NULL\" , ( enc && frame ) ? av_ts2timestr ( frame -> pts , & enc -> time_base ) : \"NULL\" , float_pts , enc ? enc -> time_base . num : - 1 , enc ? enc -> time_base . den : - 1 ) ; } return float_pts ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@init_output_stream_wrapper": "static int init_output_stream_wrapper ( OutputStream * ost , AVFrame * frame , unsigned int fatal ) { int ret = AVERROR_BUG ; char error [ 1024 ] = { 0 } ; if ( ost -> initialized ) return 0 ; ret = init_output_stream ( ost , frame , error , sizeof ( error ) ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error initializing output stream: %s\\n\" , error ) ; if ( fatal ) exit_program ( 1 ) ; } return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@psnr": "static double psnr ( double d ) { return - 10.0 * log10 ( d ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@update_video_stats": "static void update_video_stats ( OutputStream * ost , const AVPacket * pkt , int write_vstats ) { const uint8_t * sd = av_packet_get_side_data ( pkt , AV_PKT_DATA_QUALITY_STATS , NULL ) ; AVCodecContext * enc = ost -> enc_ctx ; int64_t frame_number ; double ti1 , bitrate , avg_bitrate ; ost -> quality = sd ? AV_RL32 ( sd ) : - 1 ; ost -> pict_type = sd ? sd [ 4 ] : AV_PICTURE_TYPE_NONE ; for ( int i = 0 ; i < FF_ARRAY_ELEMS ( ost -> error ) ; i ++ ) { if ( sd && i < sd [ 5 ] ) ost -> error [ i ] = AV_RL64 ( sd + 8 + 8 * i ) ; else ost -> error [ i ] = - 1 ; } if ( ! write_vstats ) return ; /* this is executed just the first time update_video_stats is called */ if ( ! vstats_file ) { vstats_file = fopen ( vstats_filename , \"w\" ) ; if ( ! vstats_file ) { perror ( \"fopen\" ) ; exit_program ( 1 ) ; } } frame_number = ost -> packets_encoded ; if ( vstats_version <= 1 ) { fprintf ( vstats_file , \"frame= %5\" PRId64 \" q= %2.1f \" , frame_number , ost -> quality / ( float ) FF_QP2LAMBDA ) ; } else { fprintf ( vstats_file , \"out= %2d st= %2d frame= %5\" PRId64 \" q= %2.1f \" , ost -> file_index , ost -> index , frame_number , ost -> quality / ( float ) FF_QP2LAMBDA ) ; } if ( ost -> error [ 0 ] >= 0 && ( enc -> flags & AV_CODEC_FLAG_PSNR ) ) fprintf ( vstats_file , \"PSNR= %6.2f \" , psnr ( ost -> error [ 0 ] / ( enc -> width * enc -> height * 255.0 * 255.0 ) ) ) ; fprintf ( vstats_file , \"f_size= %6d \" , pkt -> size ) ; /* compute pts value */ ti1 = pkt -> dts * av_q2d ( pkt -> time_base ) ; if ( ti1 < 0.01 ) ti1 = 0.01 ; bitrate = ( pkt -> size * 8 ) / av_q2d ( enc -> time_base ) / 1000.0 ; avg_bitrate = ( double ) ( ost -> data_size_enc * 8 ) / ti1 / 1000.0 ; fprintf ( vstats_file , \"s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s \" , ( double ) ost -> data_size_enc / 1024 , ti1 , bitrate , avg_bitrate ) ; fprintf ( vstats_file , \"type= %c\\n\" , av_get_picture_type_char ( ost -> pict_type ) ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@enc_stats_write": "void enc_stats_write ( OutputStream * ost , EncStats * es , const AVFrame * frame , const AVPacket * pkt , uint64_t frame_num ) { AVIOContext * io = es -> io ; AVRational tb = frame ? frame -> time_base : pkt -> time_base ; int64_t pts = frame ? frame -> pts : pkt -> pts ; AVRational tbi = ( AVRational ) { 0 , 1 } ; int64_t ptsi = INT64_MAX ; const FrameData * fd ; if ( ( frame && frame -> opaque_ref ) || ( pkt && pkt -> opaque_ref ) ) { fd = ( const FrameData * ) ( frame ? frame -> opaque_ref -> data : pkt -> opaque_ref -> data ) ; tbi = fd -> tb ; ptsi = fd -> pts ; } for ( size_t i = 0 ; i < es -> nb_components ; i ++ ) { const EncStatsComponent * c = & es -> components [ i ] ; switch ( c -> type ) { case ENC_STATS_LITERAL : avio_write ( io , c -> str , c -> str_len ) ; continue ; case ENC_STATS_FILE_IDX : avio_printf ( io , \"%d\" , ost -> file_index ) ; continue ; case ENC_STATS_STREAM_IDX : avio_printf ( io , \"%d\" , ost -> index ) ; continue ; case ENC_STATS_TIMEBASE : avio_printf ( io , \"%d/%d\" , tb . num , tb . den ) ; continue ; case ENC_STATS_TIMEBASE_IN : avio_printf ( io , \"%d/%d\" , tbi . num , tbi . den ) ; continue ; case ENC_STATS_PTS : avio_printf ( io , \"%\" PRId64 , pts ) ; continue ; case ENC_STATS_PTS_IN : avio_printf ( io , \"%\" PRId64 , ptsi ) ; continue ; case ENC_STATS_PTS_TIME : avio_printf ( io , \"%g\" , pts * av_q2d ( tb ) ) ; continue ; case ENC_STATS_PTS_TIME_IN : avio_printf ( io , \"%g\" , ptsi == INT64_MAX ? INFINITY : ptsi * av_q2d ( tbi ) ) ; continue ; case ENC_STATS_FRAME_NUM : avio_printf ( io , \"%\" PRIu64 , frame_num ) ; continue ; case ENC_STATS_FRAME_NUM_IN : avio_printf ( io , \"%\" PRIu64 , fd ? fd -> idx : - 1 ) ; continue ; } if ( frame ) { switch ( c -> type ) { case ENC_STATS_SAMPLE_NUM : avio_printf ( io , \"%\" PRIu64 , ost -> samples_encoded ) ; continue ; case ENC_STATS_NB_SAMPLES : avio_printf ( io , \"%d\" , frame -> nb_samples ) ; continue ; default : av_assert0 ( 0 ) ; } } else { switch ( c -> type ) { case ENC_STATS_DTS : avio_printf ( io , \"%\" PRId64 , pkt -> dts ) ; continue ; case ENC_STATS_DTS_TIME : avio_printf ( io , \"%g\" , pkt -> dts * av_q2d ( tb ) ) ; continue ; case ENC_STATS_PKT_SIZE : avio_printf ( io , \"%d\" , pkt -> size ) ; continue ; case ENC_STATS_BITRATE : { double duration = FFMAX ( pkt -> duration , 1 ) * av_q2d ( tb ) ; avio_printf ( io , \"%g\" , 8.0 * pkt -> size / duration ) ; continue ; } case ENC_STATS_AVG_BITRATE : { double duration = pkt -> dts * av_q2d ( tb ) ; avio_printf ( io , \"%g\" , duration > 0 ? 8.0 * ost -> data_size_enc / duration : - 1. ) ; continue ; } default : av_assert0 ( 0 ) ; } } } avio_w8 ( io , '\\n' ) ; avio_flush ( io ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@encode_frame": "static int encode_frame ( OutputFile * of , OutputStream * ost , AVFrame * frame ) { AVCodecContext * enc = ost -> enc_ctx ; AVPacket * pkt = ost -> pkt ; const char * type_desc = av_get_media_type_string ( enc -> codec_type ) ; const char * action = frame ? \"encode\" : \"flush\" ; int ret ; if ( frame ) { if ( ost -> enc_stats_pre . io ) enc_stats_write ( ost , & ost -> enc_stats_pre , frame , NULL , ost -> frames_encoded ) ; ost -> frames_encoded ++ ; ost -> samples_encoded += frame -> nb_samples ; if ( debug_ts ) { av_log ( ost , AV_LOG_INFO , \"encoder <- type:%s \" \"frame_pts:%s frame_pts_time:%s time_base:%d/%d\\n\" , type_desc , av_ts2str ( frame -> pts ) , av_ts2timestr ( frame -> pts , & enc -> time_base ) , enc -> time_base . num , enc -> time_base . den ) ; } } update_benchmark ( NULL ) ; ret = avcodec_send_frame ( enc , frame ) ; if ( ret < 0 && ! ( ret == AVERROR_EOF && ! frame ) ) { av_log ( ost , AV_LOG_ERROR , \"Error submitting %s frame to the encoder\\n\" , type_desc ) ; return ret ; } while ( 1 ) { ret = avcodec_receive_packet ( enc , pkt ) ; update_benchmark ( \"%s_%s %d.%d\" , action , type_desc , ost -> file_index , ost -> index ) ; pkt -> time_base = enc -> time_base ; /* if two pass, output log on success and EOF */ if ( ( ret >= 0 || ret == AVERROR_EOF ) && ost -> logfile && enc -> stats_out ) fprintf ( ost -> logfile , \"%s\" , enc -> stats_out ) ; if ( ret == AVERROR ( EAGAIN ) ) { av_assert0 ( frame ) ; // should never happen during flushing return 0 ; } else if ( ret == AVERROR_EOF ) { of_output_packet ( of , pkt , ost , 1 ) ; return ret ; } else if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"%s encoding failed\\n\" , type_desc ) ; return ret ; } if ( enc -> codec_type == AVMEDIA_TYPE_VIDEO ) update_video_stats ( ost , pkt , ! ! vstats_filename ) ; if ( ost -> enc_stats_post . io ) enc_stats_write ( ost , & ost -> enc_stats_post , NULL , pkt , ost -> packets_encoded ) ; if ( debug_ts ) { av_log ( ost , AV_LOG_INFO , \"encoder -> type:%s \" \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s \" \"duration:%s duration_time:%s\\n\" , type_desc , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & enc -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & enc -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & enc -> time_base ) ) ; } av_packet_rescale_ts ( pkt , pkt -> time_base , ost -> mux_timebase ) ; pkt -> time_base = ost -> mux_timebase ; if ( debug_ts ) { av_log ( ost , AV_LOG_INFO , \"encoder -> type:%s \" \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s \" \"duration:%s duration_time:%s\\n\" , type_desc , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & enc -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & enc -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & enc -> time_base ) ) ; } if ( ( ret = trigger_fix_sub_duration_heartbeat ( ost , pkt ) ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Subtitle heartbeat logic failed in %s! (%s)\\n\" , __func__ , av_err2str ( ret ) ) ; exit_program ( 1 ) ; } ost -> data_size_enc += pkt -> size ; ost -> packets_encoded ++ ; of_output_packet ( of , pkt , ost , 0 ) ; } av_assert0 ( 0 ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@submit_encode_frame": "static int submit_encode_frame ( OutputFile * of , OutputStream * ost , AVFrame * frame ) { int ret ; if ( ost -> sq_idx_encode < 0 ) return encode_frame ( of , ost , frame ) ; if ( frame ) { ret = av_frame_ref ( ost -> sq_frame , frame ) ; if ( ret < 0 ) return ret ; frame = ost -> sq_frame ; } ret = sq_send ( of -> sq_encode , ost -> sq_idx_encode , SQFRAME ( frame ) ) ; if ( ret < 0 ) { if ( frame ) av_frame_unref ( frame ) ; if ( ret != AVERROR_EOF ) return ret ; } while ( 1 ) { AVFrame * enc_frame = ost -> sq_frame ; ret = sq_receive ( of -> sq_encode , ost -> sq_idx_encode , SQFRAME ( enc_frame ) ) ; if ( ret == AVERROR_EOF ) { enc_frame = NULL ; } else if ( ret < 0 ) { return ( ret == AVERROR ( EAGAIN ) ) ? 0 : ret ; } ret = encode_frame ( of , ost , enc_frame ) ; if ( enc_frame ) av_frame_unref ( enc_frame ) ; if ( ret < 0 ) { if ( ret == AVERROR_EOF ) close_output_stream ( ost ) ; return ret ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@do_audio_out": "static void do_audio_out ( OutputFile * of , OutputStream * ost , AVFrame * frame ) { AVCodecContext * enc = ost -> enc_ctx ; int ret ; if ( frame -> pts == AV_NOPTS_VALUE ) frame -> pts = ost -> next_pts ; else { int64_t start_time = ( of -> start_time == AV_NOPTS_VALUE ) ? 0 : of -> start_time ; frame -> pts = av_rescale_q ( frame -> pts , frame -> time_base , enc -> time_base ) - av_rescale_q ( start_time , AV_TIME_BASE_Q , enc -> time_base ) ; } frame -> time_base = enc -> time_base ; if ( ! check_recording_time ( ost , frame -> pts , frame -> time_base ) ) return ; ost -> next_pts = frame -> pts + frame -> nb_samples ; ret = submit_encode_frame ( of , ost , frame ) ; if ( ret < 0 && ret != AVERROR_EOF ) exit_program ( 1 ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@do_subtitle_out": "static void do_subtitle_out ( OutputFile * of , OutputStream * ost , AVSubtitle * sub ) { int subtitle_out_max_size = 1024 * 1024 ; int subtitle_out_size , nb , i , ret ; AVCodecContext * enc ; AVPacket * pkt = ost -> pkt ; int64_t pts ; if ( sub -> pts == AV_NOPTS_VALUE ) { av_log ( ost , AV_LOG_ERROR , \"Subtitle packets must have a pts\\n\" ) ; if ( exit_on_error ) exit_program ( 1 ) ; return ; } enc = ost -> enc_ctx ; /* Note: DVB subtitle need one packet to draw them and one other\n       packet to clear them */ /* XXX: signal it in the codec context ? */ if ( enc -> codec_id == AV_CODEC_ID_DVB_SUBTITLE ) nb = 2 ; else nb = 1 ; /* shift timestamp to honor -ss and make check_recording_time() work with -t */ pts = sub -> pts ; if ( output_files [ ost -> file_index ] -> start_time != AV_NOPTS_VALUE ) pts -= output_files [ ost -> file_index ] -> start_time ; for ( i = 0 ; i < nb ; i ++ ) { unsigned save_num_rects = sub -> num_rects ; if ( ! check_recording_time ( ost , pts , AV_TIME_BASE_Q ) ) return ; ret = av_new_packet ( pkt , subtitle_out_max_size ) ; if ( ret < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; sub -> pts = pts ; // start_display_time is required to be 0 sub -> pts += av_rescale_q ( sub -> start_display_time , ( AVRational ) { 1 , 1000 } , AV_TIME_BASE_Q ) ; sub -> end_display_time -= sub -> start_display_time ; sub -> start_display_time = 0 ; if ( i == 1 ) sub -> num_rects = 0 ; ost -> frames_encoded ++ ; subtitle_out_size = avcodec_encode_subtitle ( enc , pkt -> data , pkt -> size , sub ) ; if ( i == 1 ) sub -> num_rects = save_num_rects ; if ( subtitle_out_size < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Subtitle encoding failed\\n\" ) ; exit_program ( 1 ) ; } av_shrink_packet ( pkt , subtitle_out_size ) ; pkt -> time_base = ost -> mux_timebase ; pkt -> pts = av_rescale_q ( sub -> pts , AV_TIME_BASE_Q , pkt -> time_base ) ; pkt -> duration = av_rescale_q ( sub -> end_display_time , ( AVRational ) { 1 , 1000 } , pkt -> time_base ) ; if ( enc -> codec_id == AV_CODEC_ID_DVB_SUBTITLE ) { /* XXX: the pts correction is handled here. Maybe handling\n               it in the codec would be better */ if ( i == 0 ) pkt -> pts += av_rescale_q ( sub -> start_display_time , ( AVRational ) { 1 , 1000 } , pkt -> time_base ) ; else pkt -> pts += av_rescale_q ( sub -> end_display_time , ( AVRational ) { 1 , 1000 } , pkt -> time_base ) ; } pkt -> dts = pkt -> pts ; of_output_packet ( of , pkt , ost , 0 ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@video_sync_process": "static void video_sync_process ( OutputFile * of , OutputStream * ost , AVFrame * next_picture , double duration , int64_t * nb_frames , int64_t * nb_frames_prev ) { double delta0 , delta ; double sync_ipts = adjust_frame_pts_to_encoder_tb ( of , ost , next_picture ) ; /* delta0 is the \"drift\" between the input frame (next_picture) and\n     * where it would fall in the output. */ delta0 = sync_ipts - ost -> next_pts ; delta = delta0 + duration ; // tracks the number of times the PREVIOUS frame should be duplicated, // mostly for variable framerate (VFR) * nb_frames_prev = 0 ; /* by default, we output a single frame */ * nb_frames = 1 ; if ( delta0 < 0 && delta > 0 && ost -> vsync_method != VSYNC_PASSTHROUGH && ost -> vsync_method != VSYNC_DROP ) { if ( delta0 < - 0.6 ) { av_log ( ost , AV_LOG_VERBOSE , \"Past duration %f too large\\n\" , - delta0 ) ; } else av_log ( ost , AV_LOG_DEBUG , \"Clipping frame in rate conversion by %f\\n\" , - delta0 ) ; sync_ipts = ost -> next_pts ; duration += delta0 ; delta0 = 0 ; } switch ( ost -> vsync_method ) { case VSYNC_VSCFR : if ( ost -> vsync_frame_number == 0 && delta0 >= 0.5 ) { av_log ( ost , AV_LOG_DEBUG , \"Not duplicating %d initial frames\\n\" , ( int ) lrintf ( delta0 ) ) ; delta = duration ; delta0 = 0 ; ost -> next_pts = llrint ( sync_ipts ) ; } case VSYNC_CFR : // FIXME set to 0.5 after we fix some dts/pts bugs like in avidec.c if ( frame_drop_threshold && delta < frame_drop_threshold && ost -> vsync_frame_number ) { * nb_frames = 0 ; } else if ( delta < - 1.1 ) * nb_frames = 0 ; else if ( delta > 1.1 ) { * nb_frames = llrintf ( delta ) ; if ( delta0 > 1.1 ) * nb_frames_prev = llrintf ( delta0 - 0.6 ) ; } next_picture -> duration = 1 ; break ; case VSYNC_VFR : if ( delta <= - 0.6 ) * nb_frames = 0 ; else if ( delta > 0.6 ) ost -> next_pts = llrint ( sync_ipts ) ; next_picture -> duration = duration ; break ; case VSYNC_DROP : case VSYNC_PASSTHROUGH : next_picture -> duration = duration ; ost -> next_pts = llrint ( sync_ipts ) ; break ; default : av_assert0 ( 0 ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@forced_kf_apply": "enum AVPictureType forced_kf_apply ( void * logctx , KeyframeForceCtx * kf , AVRational tb , const AVFrame * in_picture , int dup_idx ) { double pts_time ; if ( kf -> ref_pts == AV_NOPTS_VALUE ) kf -> ref_pts = in_picture -> pts ; pts_time = ( in_picture -> pts - kf -> ref_pts ) * av_q2d ( tb ) ; if ( kf -> index < kf -> nb_pts && av_compare_ts ( in_picture -> pts , tb , kf -> pts [ kf -> index ] , AV_TIME_BASE_Q ) >= 0 ) { kf -> index ++ ; goto force_keyframe ; } else if ( kf -> pexpr ) { double res ; kf -> expr_const_values [ FKF_T ] = pts_time ; res = av_expr_eval ( kf -> pexpr , kf -> expr_const_values , NULL ) ; ff_dlog ( NULL , \"force_key_frame: n:%f n_forced:%f prev_forced_n:%f t:%f prev_forced_t:%f -> res:%f\\n\" , kf -> expr_const_values [ FKF_N ] , kf -> expr_const_values [ FKF_N_FORCED ] , kf -> expr_const_values [ FKF_PREV_FORCED_N ] , kf -> expr_const_values [ FKF_T ] , kf -> expr_const_values [ FKF_PREV_FORCED_T ] , res ) ; kf -> expr_const_values [ FKF_N ] += 1 ; if ( res ) { kf -> expr_const_values [ FKF_PREV_FORCED_N ] = kf -> expr_const_values [ FKF_N ] - 1 ; kf -> expr_const_values [ FKF_PREV_FORCED_T ] = kf -> expr_const_values [ FKF_T ] ; kf -> expr_const_values [ FKF_N_FORCED ] += 1 ; goto force_keyframe ; } } else if ( kf -> type == KF_FORCE_SOURCE && in_picture -> key_frame == 1 && ! dup_idx ) { goto force_keyframe ; } else if ( kf -> type == KF_FORCE_SOURCE_NO_DROP && ! dup_idx ) { kf -> dropped_keyframe = 0 ; if ( ( in_picture -> key_frame == 1 ) || kf -> dropped_keyframe ) goto force_keyframe ; } return AV_PICTURE_TYPE_NONE ; force_keyframe : av_log ( logctx , AV_LOG_DEBUG , \"Forced keyframe at time %f\\n\" , pts_time ) ; return AV_PICTURE_TYPE_I ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@do_video_out": "static void do_video_out ( OutputFile * of , OutputStream * ost , AVFrame * next_picture ) { int ret ; AVCodecContext * enc = ost -> enc_ctx ; AVRational frame_rate ; int64_t nb_frames , nb_frames_prev , i ; double duration = 0 ; InputStream * ist = ost -> ist ; AVFilterContext * filter = ost -> filter -> filter ; init_output_stream_wrapper ( ost , next_picture , 1 ) ; frame_rate = av_buffersink_get_frame_rate ( filter ) ; if ( frame_rate . num > 0 && frame_rate . den > 0 ) duration = 1 / ( av_q2d ( frame_rate ) * av_q2d ( enc -> time_base ) ) ; if ( ist && ist -> st -> start_time != AV_NOPTS_VALUE && ist -> first_dts != AV_NOPTS_VALUE && ost -> frame_rate . num ) duration = FFMIN ( duration , 1 / ( av_q2d ( ost -> frame_rate ) * av_q2d ( enc -> time_base ) ) ) ; if ( ! ost -> filters_script && ! ost -> filters && ( nb_filtergraphs == 0 || ! filtergraphs [ 0 ] -> graph_desc ) && next_picture && ist && lrintf ( next_picture -> duration * av_q2d ( ist -> st -> time_base ) / av_q2d ( enc -> time_base ) ) > 0 ) { duration = lrintf ( next_picture -> duration * av_q2d ( ist -> st -> time_base ) / av_q2d ( enc -> time_base ) ) ; } if ( ! next_picture ) { //end, flushing nb_frames_prev = nb_frames = mid_pred ( ost -> last_nb0_frames [ 0 ] , ost -> last_nb0_frames [ 1 ] , ost -> last_nb0_frames [ 2 ] ) ; } else { video_sync_process ( of , ost , next_picture , duration , & nb_frames , & nb_frames_prev ) ; } memmove ( ost -> last_nb0_frames + 1 , ost -> last_nb0_frames , sizeof ( ost -> last_nb0_frames [ 0 ] ) * ( FF_ARRAY_ELEMS ( ost -> last_nb0_frames ) - 1 ) ) ; ost -> last_nb0_frames [ 0 ] = nb_frames_prev ; if ( nb_frames_prev == 0 && ost -> last_dropped ) { nb_frames_drop ++ ; av_log ( ost , AV_LOG_VERBOSE , \"*** dropping frame %\" PRId64 \" at ts %\" PRId64 \"\\n\" , ost -> vsync_frame_number , ost -> last_frame -> pts ) ; } if ( nb_frames > ( nb_frames_prev && ost -> last_dropped ) + ( nb_frames > nb_frames_prev ) ) { if ( nb_frames > dts_error_threshold * 30 ) { av_log ( ost , AV_LOG_ERROR , \"%\" PRId64 \" frame duplication too large, skipping\\n\" , nb_frames - 1 ) ; nb_frames_drop ++ ; return ; } nb_frames_dup += nb_frames - ( nb_frames_prev && ost -> last_dropped ) - ( nb_frames > nb_frames_prev ) ; av_log ( ost , AV_LOG_VERBOSE , \"*** %\" PRId64 \" dup!\\n\" , nb_frames - 1 ) ; if ( nb_frames_dup > dup_warning ) { av_log ( ost , AV_LOG_WARNING , \"More than %\" PRIu64 \" frames duplicated\\n\" , dup_warning ) ; dup_warning *= 10 ; } } ost -> last_dropped = nb_frames == nb_frames_prev && next_picture ; ost -> kf . dropped_keyframe = ost -> last_dropped && next_picture && next_picture -> key_frame ; /* duplicates frame if needed */ for ( i = 0 ; i < nb_frames ; i ++ ) { AVFrame * in_picture ; if ( i < nb_frames_prev && ost -> last_frame -> buf [ 0 ] ) { in_picture = ost -> last_frame ; } else in_picture = next_picture ; if ( ! in_picture ) return ; in_picture -> pts = ost -> next_pts ; if ( ! check_recording_time ( ost , in_picture -> pts , ost -> enc_ctx -> time_base ) ) return ; in_picture -> quality = enc -> global_quality ; in_picture -> pict_type = forced_kf_apply ( ost , & ost -> kf , enc -> time_base , in_picture , i ) ; ret = submit_encode_frame ( of , ost , in_picture ) ; if ( ret == AVERROR_EOF ) break ; else if ( ret < 0 ) exit_program ( 1 ) ; ost -> next_pts ++ ; ost -> vsync_frame_number ++ ; } av_frame_unref ( ost -> last_frame ) ; if ( next_picture ) av_frame_move_ref ( ost -> last_frame , next_picture ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@reap_filters": "static int reap_filters ( int flush ) { AVFrame * filtered_frame = NULL ; /* Reap all buffers present in the buffer sinks */ for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { OutputFile * of = output_files [ ost -> file_index ] ; AVFilterContext * filter ; AVCodecContext * enc = ost -> enc_ctx ; int ret = 0 ; if ( ! ost -> filter || ! ost -> filter -> graph -> graph ) continue ; filter = ost -> filter -> filter ; /*\n         * Unlike video, with audio the audio frame size matters.\n         * Currently we are fully reliant on the lavfi filter chain to\n         * do the buffering deed for us, and thus the frame size parameter\n         * needs to be set accordingly. Where does one get the required\n         * frame size? From the initialized AVCodecContext of an audio\n         * encoder. Thus, if we have gotten to an audio stream, initialize\n         * the encoder earlier than receiving the first AVFrame.\n         */ if ( av_buffersink_get_type ( filter ) == AVMEDIA_TYPE_AUDIO ) init_output_stream_wrapper ( ost , NULL , 1 ) ; filtered_frame = ost -> filtered_frame ; while ( 1 ) { ret = av_buffersink_get_frame_flags ( filter , filtered_frame , AV_BUFFERSINK_FLAG_NO_REQUEST ) ; if ( ret < 0 ) { if ( ret != AVERROR ( EAGAIN ) && ret != AVERROR_EOF ) { av_log ( NULL , AV_LOG_WARNING , \"Error in av_buffersink_get_frame_flags(): %s\\n\" , av_err2str ( ret ) ) ; } else if ( flush && ret == AVERROR_EOF ) { if ( av_buffersink_get_type ( filter ) == AVMEDIA_TYPE_VIDEO ) do_video_out ( of , ost , NULL ) ; } break ; } if ( ost -> finished ) { av_frame_unref ( filtered_frame ) ; continue ; } if ( filtered_frame -> pts != AV_NOPTS_VALUE ) { AVRational tb = av_buffersink_get_time_base ( filter ) ; ost -> last_filter_pts = av_rescale_q ( filtered_frame -> pts , tb , AV_TIME_BASE_Q ) ; filtered_frame -> time_base = tb ; if ( debug_ts ) av_log ( NULL , AV_LOG_INFO , \"filter_raw -> pts:%s pts_time:%s time_base:%d/%d\\n\" , av_ts2str ( filtered_frame -> pts ) , av_ts2timestr ( filtered_frame -> pts , & tb ) , tb . num , tb . den ) ; } switch ( av_buffersink_get_type ( filter ) ) { case AVMEDIA_TYPE_VIDEO : if ( ! ost -> frame_aspect_ratio . num ) enc -> sample_aspect_ratio = filtered_frame -> sample_aspect_ratio ; do_video_out ( of , ost , filtered_frame ) ; break ; case AVMEDIA_TYPE_AUDIO : if ( ! ( enc -> codec -> capabilities & AV_CODEC_CAP_PARAM_CHANGE ) && enc -> ch_layout . nb_channels != filtered_frame -> ch_layout . nb_channels ) { av_log ( NULL , AV_LOG_ERROR , \"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\" ) ; break ; } do_audio_out ( of , ost , filtered_frame ) ; break ; default : // TODO support subtitle filters av_assert0 ( 0 ) ; } av_frame_unref ( filtered_frame ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@print_final_stats": "static void print_final_stats ( int64_t total_size ) { uint64_t video_size = 0 , audio_size = 0 , extra_size = 0 , other_size = 0 ; uint64_t subtitle_size = 0 ; uint64_t data_size = 0 ; float percent = - 1.0 ; int i , j ; int pass1_used = 1 ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { AVCodecParameters * par = ost -> st -> codecpar ; const uint64_t s = ost -> data_size_mux ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : video_size += s ; break ; case AVMEDIA_TYPE_AUDIO : audio_size += s ; break ; case AVMEDIA_TYPE_SUBTITLE : subtitle_size += s ; break ; default : other_size += s ; break ; } extra_size += par -> extradata_size ; data_size += s ; if ( ost -> enc_ctx && ( ost -> enc_ctx -> flags & ( AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2 ) ) != AV_CODEC_FLAG_PASS1 ) pass1_used = 0 ; } if ( data_size && total_size > 0 && total_size >= data_size ) percent = 100.0 * ( total_size - data_size ) / data_size ; av_log ( NULL , AV_LOG_INFO , \"video:%1.0fkB audio:%1.0fkB subtitle:%1.0fkB other streams:%1.0fkB global headers:%1.0fkB muxing overhead: \" , video_size / 1024.0 , audio_size / 1024.0 , subtitle_size / 1024.0 , other_size / 1024.0 , extra_size / 1024.0 ) ; if ( percent >= 0.0 ) av_log ( NULL , AV_LOG_INFO , \"%f%%\" , percent ) ; else av_log ( NULL , AV_LOG_INFO , \"unknown\" ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; /* print verbose per-stream stats */ for ( i = 0 ; i < nb_input_files ; i ++ ) { InputFile * f = input_files [ i ] ; uint64_t total_packets = 0 , total_size = 0 ; av_log ( NULL , AV_LOG_VERBOSE , \"Input file #%d (%s):\\n\" , i , f -> ctx -> url ) ; for ( j = 0 ; j < f -> nb_streams ; j ++ ) { InputStream * ist = f -> streams [ j ] ; enum AVMediaType type = ist -> par -> codec_type ; total_size += ist -> data_size ; total_packets += ist -> nb_packets ; av_log ( NULL , AV_LOG_VERBOSE , \"  Input stream #%d:%d (%s): \" , i , j , av_get_media_type_string ( type ) ) ; av_log ( NULL , AV_LOG_VERBOSE , \"%\" PRIu64 \" packets read (%\" PRIu64 \" bytes); \" , ist -> nb_packets , ist -> data_size ) ; if ( ist -> decoding_needed ) { av_log ( NULL , AV_LOG_VERBOSE , \"%\" PRIu64 \" frames decoded\" , ist -> frames_decoded ) ; if ( type == AVMEDIA_TYPE_AUDIO ) av_log ( NULL , AV_LOG_VERBOSE , \" (%\" PRIu64 \" samples)\" , ist -> samples_decoded ) ; av_log ( NULL , AV_LOG_VERBOSE , \"; \" ) ; } av_log ( NULL , AV_LOG_VERBOSE , \"\\n\" ) ; } av_log ( NULL , AV_LOG_VERBOSE , \"  Total: %\" PRIu64 \" packets (%\" PRIu64 \" bytes) demuxed\\n\" , total_packets , total_size ) ; } for ( i = 0 ; i < nb_output_files ; i ++ ) { OutputFile * of = output_files [ i ] ; uint64_t total_packets = 0 , total_size = 0 ; av_log ( NULL , AV_LOG_VERBOSE , \"Output file #%d (%s):\\n\" , i , of -> url ) ; for ( j = 0 ; j < of -> nb_streams ; j ++ ) { OutputStream * ost = of -> streams [ j ] ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; total_size += ost -> data_size_mux ; total_packets += atomic_load ( & ost -> packets_written ) ; av_log ( NULL , AV_LOG_VERBOSE , \"  Output stream #%d:%d (%s): \" , i , j , av_get_media_type_string ( type ) ) ; if ( ost -> enc_ctx ) { av_log ( NULL , AV_LOG_VERBOSE , \"%\" PRIu64 \" frames encoded\" , ost -> frames_encoded ) ; if ( type == AVMEDIA_TYPE_AUDIO ) av_log ( NULL , AV_LOG_VERBOSE , \" (%\" PRIu64 \" samples)\" , ost -> samples_encoded ) ; av_log ( NULL , AV_LOG_VERBOSE , \"; \" ) ; } av_log ( NULL , AV_LOG_VERBOSE , \"%\" PRIu64 \" packets muxed (%\" PRIu64 \" bytes); \" , atomic_load ( & ost -> packets_written ) , ost -> data_size_mux ) ; av_log ( NULL , AV_LOG_VERBOSE , \"\\n\" ) ; } av_log ( NULL , AV_LOG_VERBOSE , \"  Total: %\" PRIu64 \" packets (%\" PRIu64 \" bytes) muxed\\n\" , total_packets , total_size ) ; } if ( video_size + data_size + audio_size + subtitle_size + extra_size == 0 ) { av_log ( NULL , AV_LOG_WARNING , \"Output file is empty, nothing was encoded \" ) ; if ( pass1_used ) { av_log ( NULL , AV_LOG_WARNING , \"\\n\" ) ; } else { av_log ( NULL , AV_LOG_WARNING , \"(check -ss / -t / -frames parameters if used)\\n\" ) ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@forward_report": "static void forward_report ( uint64_t frame_number , float fps , float quality , int64_t total_size , int64_t pts , double bitrate , double speed ) { // FORWARD DATA if ( report_callback != NULL ) { double milliseconds = 0 ; if ( pts != AV_NOPTS_VALUE ) { milliseconds = ( ( double ) FFABS64U ( pts ) ) / 1000 ; } if ( pts < 0 ) { report_callback ( frame_number , fps , quality , total_size , 0 - milliseconds , bitrate , speed ) ; } else { report_callback ( frame_number , fps , quality , total_size , milliseconds , bitrate , speed ) ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@print_report": "static void print_report ( int is_last_report , int64_t timer_start , int64_t cur_time ) { AVBPrint buf , buf_script ; int64_t total_size = of_filesize ( output_files [ 0 ] ) ; int vid ; double bitrate ; double speed ; int64_t pts = AV_NOPTS_VALUE ; int mins , secs , us ; int64_t hours ; const char * hours_sign ; int ret ; float t ; // FFmpegKit field declarations int local_print_stats = 1 ; uint64_t frame_number = 0 ; float fps = 0 ; float q = 0 ; if ( ! print_stats && ! is_last_report && ! progress_avio ) local_print_stats = 0 ; if ( ! is_last_report ) { if ( last_time == - 1 ) { last_time = cur_time ; } if ( ( ( cur_time - last_time ) < stats_period && ! first_report ) || ( first_report && nb_output_dumped < nb_output_files ) ) return ; last_time = cur_time ; } t = ( cur_time - timer_start ) / 1000000.0 ; vid = 0 ; if ( local_print_stats ) { av_bprint_init ( & buf , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; av_bprint_init ( & buf_script , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; } for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { const AVCodecContext * const enc = ost -> enc_ctx ; q = enc ? ost -> quality / ( float ) FF_QP2LAMBDA : - 1 ; if ( local_print_stats && vid && ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { av_bprintf ( & buf , \"q=%2.1f \" , q ) ; av_bprintf ( & buf_script , \"stream_%d_%d_q=%.1f\\n\" , ost -> file_index , ost -> index , q ) ; } if ( ! vid && ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { frame_number = atomic_load ( & ost -> packets_written ) ; fps = t > 1 ? frame_number / t : 0 ; if ( local_print_stats ) { av_bprintf ( & buf , \"frame=%5\" PRId64 \" fps=%3.*f q=%3.1f \" , frame_number , fps < 9.95 , fps , q ) ; av_bprintf ( & buf_script , \"frame=%\" PRId64 \"\\n\" , frame_number ) ; av_bprintf ( & buf_script , \"fps=%.2f\\n\" , fps ) ; av_bprintf ( & buf_script , \"stream_%d_%d_q=%.1f\\n\" , ost -> file_index , ost -> index , q ) ; } if ( local_print_stats && is_last_report ) av_bprintf ( & buf , \"L\" ) ; if ( qp_hist ) { int j ; int qp = lrintf ( q ) ; if ( qp >= 0 && qp < FF_ARRAY_ELEMS ( qp_histogram ) ) qp_histogram [ qp ] ++ ; if ( local_print_stats ) { for ( j = 0 ; j < 32 ; j ++ ) av_bprintf ( & buf , \"%X\" , av_log2 ( qp_histogram [ j ] + 1 ) ) ; } } if ( local_print_stats && enc && ( enc -> flags & AV_CODEC_FLAG_PSNR ) && ( ost -> pict_type != AV_PICTURE_TYPE_NONE || is_last_report ) ) { int j ; double error , error_sum = 0 ; double scale , scale_sum = 0 ; double p ; char type [ 3 ] = { 'Y' , 'U' , 'V' } ; av_bprintf ( & buf , \"PSNR=\" ) ; for ( j = 0 ; j < 3 ; j ++ ) { if ( is_last_report ) { error = enc -> error [ j ] ; scale = enc -> width * enc -> height * 255.0 * 255.0 * frame_number ; } else { error = ost -> error [ j ] ; scale = enc -> width * enc -> height * 255.0 * 255.0 ; } if ( j ) scale /= 4 ; error_sum += error ; scale_sum += scale ; p = psnr ( error / scale ) ; av_bprintf ( & buf , \"%c:%2.2f \" , type [ j ] , p ) ; av_bprintf ( & buf_script , \"stream_%d_%d_psnr_%c=%2.2f\\n\" , ost -> file_index , ost -> index , type [ j ] | 32 , p ) ; } p = psnr ( error_sum / scale_sum ) ; av_bprintf ( & buf , \"*:%2.2f \" , psnr ( error_sum / scale_sum ) ) ; av_bprintf ( & buf_script , \"stream_%d_%d_psnr_all=%2.2f\\n\" , ost -> file_index , ost -> index , p ) ; } vid = 1 ; } /* compute min output value */ if ( ost -> last_mux_dts != AV_NOPTS_VALUE ) { if ( pts == AV_NOPTS_VALUE || ost -> last_mux_dts > pts ) pts = ost -> last_mux_dts ; if ( copy_ts ) { if ( copy_ts_first_pts == AV_NOPTS_VALUE && pts > 1 ) copy_ts_first_pts = pts ; if ( copy_ts_first_pts != AV_NOPTS_VALUE ) pts -= copy_ts_first_pts ; } } if ( is_last_report ) nb_frames_drop += ost -> last_dropped ; } us = FFABS64U ( pts ) % AV_TIME_BASE ; secs = FFABS64U ( pts ) / AV_TIME_BASE % 60 ; mins = FFABS64U ( pts ) / AV_TIME_BASE / 60 % 60 ; hours = FFABS64U ( pts ) / AV_TIME_BASE / 3600 ; hours_sign = ( pts < 0 ) ? \"-\" : \"\" ; bitrate = pts != AV_NOPTS_VALUE && pts && total_size >= 0 ? total_size * 8 / ( pts / 1000.0 ) : - 1 ; speed = pts != AV_NOPTS_VALUE && t != 0.0 ? ( double ) pts / AV_TIME_BASE / t : - 1 ; // FFmpegKit forward report forward_report ( frame_number , fps , q , total_size , pts , bitrate , speed ) ; if ( local_print_stats ) { if ( total_size < 0 ) av_bprintf ( & buf , \"size=N/A time=\" ) ; else av_bprintf ( & buf , \"size=%8.0fkB time=\" , total_size / 1024.0 ) ; if ( pts == AV_NOPTS_VALUE ) { av_bprintf ( & buf , \"N/A \" ) ; } else { av_bprintf ( & buf , \"%s%02\" PRId64 \":%02d:%02d.%02d \" , hours_sign , hours , mins , secs , ( 100 * us ) / AV_TIME_BASE ) ; } if ( bitrate < 0 ) { av_bprintf ( & buf , \"bitrate=N/A\" ) ; av_bprintf ( & buf_script , \"bitrate=N/A\\n\" ) ; } else { av_bprintf ( & buf , \"bitrate=%6.1fkbits/s\" , bitrate ) ; av_bprintf ( & buf_script , \"bitrate=%6.1fkbits/s\\n\" , bitrate ) ; } if ( total_size < 0 ) av_bprintf ( & buf_script , \"total_size=N/A\\n\" ) ; else av_bprintf ( & buf_script , \"total_size=%\" PRId64 \"\\n\" , total_size ) ; if ( pts == AV_NOPTS_VALUE ) { av_bprintf ( & buf_script , \"out_time_us=N/A\\n\" ) ; av_bprintf ( & buf_script , \"out_time_ms=N/A\\n\" ) ; av_bprintf ( & buf_script , \"out_time=N/A\\n\" ) ; } else { av_bprintf ( & buf_script , \"out_time_us=%\" PRId64 \"\\n\" , pts ) ; av_bprintf ( & buf_script , \"out_time_ms=%\" PRId64 \"\\n\" , pts ) ; av_bprintf ( & buf_script , \"out_time=%s%02\" PRId64 \":%02d:%02d.%06d\\n\" , hours_sign , hours , mins , secs , us ) ; } if ( nb_frames_dup || nb_frames_drop ) av_bprintf ( & buf , \" dup=%\" PRId64 \" drop=%\" PRId64 , nb_frames_dup , nb_frames_drop ) ; av_bprintf ( & buf_script , \"dup_frames=%\" PRId64 \"\\n\" , nb_frames_dup ) ; av_bprintf ( & buf_script , \"drop_frames=%\" PRId64 \"\\n\" , nb_frames_drop ) ; if ( speed < 0 ) { av_bprintf ( & buf , \" speed=N/A\" ) ; av_bprintf ( & buf_script , \"speed=N/A\\n\" ) ; } else { av_bprintf ( & buf , \" speed=%4.3gx\" , speed ) ; av_bprintf ( & buf_script , \"speed=%4.3gx\\n\" , speed ) ; } if ( print_stats || is_last_report ) { const char end = is_last_report ? '\\n' : '\\r' ; if ( print_stats == 1 && AV_LOG_INFO > av_log_get_level ( ) ) { av_log ( NULL , AV_LOG_STDERR , \"%s    %c\" , buf . str , end ) ; } else av_log ( NULL , AV_LOG_INFO , \"%s    %c\" , buf . str , end ) ; } av_bprint_finalize ( & buf , NULL ) ; if ( progress_avio ) { av_bprintf ( & buf_script , \"progress=%s\\n\" , is_last_report ? \"end\" : \"continue\" ) ; avio_write ( progress_avio , buf_script . str , FFMIN ( buf_script . len , buf_script . size - 1 ) ) ; avio_flush ( progress_avio ) ; av_bprint_finalize ( & buf_script , NULL ) ; if ( is_last_report ) { if ( ( ret = avio_closep ( & progress_avio ) ) < 0 ) av_log ( NULL , AV_LOG_ERROR , \"Error closing progress log, loss of information possible: %s\\n\" , av_err2str ( ret ) ) ; } } first_report = 0 ; if ( is_last_report ) print_final_stats ( total_size ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@ifilter_parameters_from_codecpar": "static int ifilter_parameters_from_codecpar ( InputFilter * ifilter , AVCodecParameters * par ) { int ret ; // We never got any input. Set a fake format, which will // come from libavformat. ifilter -> format = par -> format ; ifilter -> sample_rate = par -> sample_rate ; ifilter -> width = par -> width ; ifilter -> height = par -> height ; ifilter -> sample_aspect_ratio = par -> sample_aspect_ratio ; ret = av_channel_layout_copy ( & ifilter -> ch_layout , & par -> ch_layout ) ; if ( ret < 0 ) return ret ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@flush_encoders": "static void flush_encoders ( void ) { int ret ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { OutputFile * of = output_files [ ost -> file_index ] ; if ( ost -> sq_idx_encode >= 0 ) sq_send ( of -> sq_encode , ost -> sq_idx_encode , SQFRAME ( NULL ) ) ; } for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { AVCodecContext * enc = ost -> enc_ctx ; OutputFile * of = output_files [ ost -> file_index ] ; if ( ! enc ) continue ; // Try to enable encoding with no input frames. // Maybe we should just let encoding fail instead. if ( ! ost -> initialized ) { FilterGraph * fg = ost -> filter -> graph ; av_log ( ost , AV_LOG_WARNING , \"Finishing stream without any data written to it.\\n\" ) ; if ( ost -> filter && ! fg -> graph ) { int x ; for ( x = 0 ; x < fg -> nb_inputs ; x ++ ) { InputFilter * ifilter = fg -> inputs [ x ] ; if ( ifilter -> format < 0 && ifilter_parameters_from_codecpar ( ifilter , ifilter -> ist -> par ) < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error copying paramerets from input stream\\n\" ) ; exit_program ( 1 ) ; } } if ( ! ifilter_has_all_input_formats ( fg ) ) continue ; ret = configure_filtergraph ( fg ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error configuring filter graph\\n\" ) ; exit_program ( 1 ) ; } of_output_packet ( of , ost -> pkt , ost , 1 ) ; } init_output_stream_wrapper ( ost , NULL , 1 ) ; } if ( enc -> codec_type != AVMEDIA_TYPE_VIDEO && enc -> codec_type != AVMEDIA_TYPE_AUDIO ) continue ; ret = submit_encode_frame ( of , ost , NULL ) ; if ( ret != AVERROR_EOF ) exit_program ( 1 ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@check_output_constraints": "static int check_output_constraints ( InputStream * ist , OutputStream * ost ) { OutputFile * of = output_files [ ost -> file_index ] ; if ( ost -> ist != ist ) return 0 ; if ( ost -> finished & MUXER_FINISHED ) return 0 ; if ( of -> start_time != AV_NOPTS_VALUE && ist -> pts < of -> start_time ) return 0 ; return 1 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@do_streamcopy": "static void do_streamcopy ( InputStream * ist , OutputStream * ost , const AVPacket * pkt ) { OutputFile * of = output_files [ ost -> file_index ] ; InputFile * f = input_files [ ist -> file_index ] ; int64_t start_time = ( of -> start_time == AV_NOPTS_VALUE ) ? 0 : of -> start_time ; int64_t ost_tb_start_time = av_rescale_q ( start_time , AV_TIME_BASE_Q , ost -> mux_timebase ) ; AVPacket * opkt = ost -> pkt ; av_packet_unref ( opkt ) ; // EOF: flush output bitstream filters. if ( ! pkt ) { of_output_packet ( of , opkt , ost , 1 ) ; return ; } if ( ! ost -> streamcopy_started && ! ( pkt -> flags & AV_PKT_FLAG_KEY ) && ! ost -> copy_initial_nonkeyframes ) return ; if ( ! ost -> streamcopy_started && ! ost -> copy_prior_start ) { if ( pkt -> pts == AV_NOPTS_VALUE ? ist -> pts < ost -> ts_copy_start : pkt -> pts < av_rescale_q ( ost -> ts_copy_start , AV_TIME_BASE_Q , ist -> st -> time_base ) ) return ; } if ( of -> recording_time != INT64_MAX && ist -> pts >= of -> recording_time + start_time ) { close_output_stream ( ost ) ; return ; } if ( f -> recording_time != INT64_MAX ) { start_time = 0 ; if ( copy_ts ) { start_time += f -> start_time != AV_NOPTS_VALUE ? f -> start_time : 0 ; start_time += start_at_zero ? 0 : f -> start_time_effective ; } if ( ist -> pts >= f -> recording_time + start_time ) { close_output_stream ( ost ) ; return ; } } if ( av_packet_ref ( opkt , pkt ) < 0 ) exit_program ( 1 ) ; opkt -> time_base = ost -> mux_timebase ; if ( pkt -> pts != AV_NOPTS_VALUE ) opkt -> pts = av_rescale_q ( pkt -> pts , ist -> st -> time_base , opkt -> time_base ) - ost_tb_start_time ; if ( pkt -> dts == AV_NOPTS_VALUE ) { opkt -> dts = av_rescale_q ( ist -> dts , AV_TIME_BASE_Q , opkt -> time_base ) ; } else if ( ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { int duration = av_get_audio_frame_duration2 ( ist -> par , pkt -> size ) ; if ( ! duration ) duration = ist -> par -> frame_size ; opkt -> dts = av_rescale_delta ( ist -> st -> time_base , pkt -> dts , ( AVRational ) { 1 , ist -> par -> sample_rate } , duration , & ist -> filter_in_rescale_delta_last , opkt -> time_base ) ; /* dts will be set immediately afterwards to what pts is now */ opkt -> pts = opkt -> dts - ost_tb_start_time ; } else opkt -> dts = av_rescale_q ( pkt -> dts , ist -> st -> time_base , opkt -> time_base ) ; opkt -> dts -= ost_tb_start_time ; opkt -> duration = av_rescale_q ( pkt -> duration , ist -> st -> time_base , opkt -> time_base ) ; { int ret = trigger_fix_sub_duration_heartbeat ( ost , pkt ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Subtitle heartbeat logic failed in %s! (%s)\\n\" , __func__ , av_err2str ( ret ) ) ; exit_program ( 1 ) ; } } of_output_packet ( of , opkt , ost , 0 ) ; ost -> streamcopy_started = 1 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@check_decode_result": "static void check_decode_result ( InputStream * ist , int * got_output , int ret ) { if ( * got_output || ret < 0 ) decode_error_stat [ ret < 0 ] ++ ; if ( ret < 0 && exit_on_error ) exit_program ( 1 ) ; if ( * got_output && ist ) { if ( ist -> decoded_frame -> decode_error_flags || ( ist -> decoded_frame -> flags & AV_FRAME_FLAG_CORRUPT ) ) { av_log ( NULL , exit_on_error ? AV_LOG_FATAL : AV_LOG_WARNING , \"%s: corrupt decoded frame in stream %d\\n\" , input_files [ ist -> file_index ] -> ctx -> url , ist -> st -> index ) ; if ( exit_on_error ) exit_program ( 1 ) ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@ifilter_has_all_input_formats": "static int ifilter_has_all_input_formats ( FilterGraph * fg ) { int i ; for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) { if ( fg -> inputs [ i ] -> format < 0 && ( fg -> inputs [ i ] -> type == AVMEDIA_TYPE_AUDIO || fg -> inputs [ i ] -> type == AVMEDIA_TYPE_VIDEO ) ) return 0 ; } return 1 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@ifilter_send_frame": "static int ifilter_send_frame ( InputFilter * ifilter , AVFrame * frame , int keep_reference ) { FilterGraph * fg = ifilter -> graph ; AVFrameSideData * sd ; int need_reinit , ret ; int buffersrc_flags = AV_BUFFERSRC_FLAG_PUSH ; if ( keep_reference ) buffersrc_flags |= AV_BUFFERSRC_FLAG_KEEP_REF ; /* determine if the parameters for this input changed */ need_reinit = ifilter -> format != frame -> format ; switch ( ifilter -> ist -> par -> codec_type ) { case AVMEDIA_TYPE_AUDIO : need_reinit |= ifilter -> sample_rate != frame -> sample_rate || av_channel_layout_compare ( & ifilter -> ch_layout , & frame -> ch_layout ) ; break ; case AVMEDIA_TYPE_VIDEO : need_reinit |= ifilter -> width != frame -> width || ifilter -> height != frame -> height ; break ; } if ( ! ifilter -> ist -> reinit_filters && fg -> graph ) need_reinit = 0 ; if ( ! ! ifilter -> hw_frames_ctx != ! ! frame -> hw_frames_ctx || ( ifilter -> hw_frames_ctx && ifilter -> hw_frames_ctx -> data != frame -> hw_frames_ctx -> data ) ) need_reinit = 1 ; if ( ( sd = av_frame_get_side_data ( frame , AV_FRAME_DATA_DISPLAYMATRIX ) ) ) { if ( ! ifilter -> displaymatrix || memcmp ( sd -> data , ifilter -> displaymatrix , sizeof ( int32_t ) * 9 ) ) need_reinit = 1 ; } else if ( ifilter -> displaymatrix ) need_reinit = 1 ; if ( need_reinit ) { ret = ifilter_parameters_from_frame ( ifilter , frame ) ; if ( ret < 0 ) return ret ; } /* (re)init the graph if possible, otherwise buffer the frame and return */ if ( need_reinit || ! fg -> graph ) { if ( ! ifilter_has_all_input_formats ( fg ) ) { AVFrame * tmp = av_frame_clone ( frame ) ; if ( ! tmp ) return AVERROR ( ENOMEM ) ; ret = av_fifo_write ( ifilter -> frame_queue , & tmp , 1 ) ; if ( ret < 0 ) av_frame_free ( & tmp ) ; return ret ; } ret = reap_filters ( 1 ) ; if ( ret < 0 && ret != AVERROR_EOF ) { av_log ( NULL , AV_LOG_ERROR , \"Error while filtering: %s\\n\" , av_err2str ( ret ) ) ; return ret ; } ret = configure_filtergraph ( fg ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error reinitializing filters!\\n\" ) ; return ret ; } } ret = av_buffersrc_add_frame_flags ( ifilter -> filter , frame , buffersrc_flags ) ; if ( ret < 0 ) { if ( ret != AVERROR_EOF ) av_log ( NULL , AV_LOG_ERROR , \"Error while filtering: %s\\n\" , av_err2str ( ret ) ) ; return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@ifilter_send_eof": "static int ifilter_send_eof ( InputFilter * ifilter , int64_t pts ) { int ret = 0 ; ifilter -> eof = 1 ; if ( ifilter -> filter ) { /* THIS VALIDATION IS REQUIRED TO COMPLETE CANCELLATION */ if ( ! received_sigterm && ! cancelRequested ( globalSessionId ) ) { ret = av_buffersrc_close ( ifilter -> filter , pts , AV_BUFFERSRC_FLAG_PUSH ) ; } if ( ret < 0 ) return ret ; } else { // the filtergraph was never configured if ( ifilter -> format < 0 ) { ret = ifilter_parameters_from_codecpar ( ifilter , ifilter -> ist -> par ) ; if ( ret < 0 ) return ret ; } if ( ifilter -> format < 0 && ( ifilter -> type == AVMEDIA_TYPE_AUDIO || ifilter -> type == AVMEDIA_TYPE_VIDEO ) ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot determine format of input stream %d:%d after EOF\\n\" , ifilter -> ist -> file_index , ifilter -> ist -> st -> index ) ; return AVERROR_INVALIDDATA ; } } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@decode": "static int decode ( InputStream * ist , AVCodecContext * avctx , AVFrame * frame , int * got_frame , AVPacket * pkt ) { int ret ; * got_frame = 0 ; if ( pkt ) { ret = avcodec_send_packet ( avctx , pkt ) ; // In particular, we don't expect AVERROR(EAGAIN), because we read all // decoded frames with avcodec_receive_frame() until done. if ( ret < 0 && ret != AVERROR_EOF ) return ret ; } ret = avcodec_receive_frame ( avctx , frame ) ; if ( ret < 0 && ret != AVERROR ( EAGAIN ) ) return ret ; if ( ret >= 0 ) { if ( ist -> want_frame_data ) { FrameData * fd ; av_assert0 ( ! frame -> opaque_ref ) ; frame -> opaque_ref = av_buffer_allocz ( sizeof ( * fd ) ) ; if ( ! frame -> opaque_ref ) { av_frame_unref ( frame ) ; return AVERROR ( ENOMEM ) ; } fd = ( FrameData * ) frame -> opaque_ref -> data ; fd -> pts = frame -> pts ; fd -> tb = avctx -> pkt_timebase ; fd -> idx = avctx -> frame_num - 1 ; } * got_frame = 1 ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@send_frame_to_filters": "static int send_frame_to_filters ( InputStream * ist , AVFrame * decoded_frame ) { int i , ret ; av_assert1 ( ist -> nb_filters > 0 ) ; /* ensure ret is initialized */ for ( i = 0 ; i < ist -> nb_filters ; i ++ ) { ret = ifilter_send_frame ( ist -> filters [ i ] , decoded_frame , i < ist -> nb_filters - 1 ) ; if ( ret == AVERROR_EOF ) ret = 0 ; /* ignore */ if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Failed to inject frame into filter network: %s\\n\" , av_err2str ( ret ) ) ; break ; } } return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@decode_audio": "static int decode_audio ( InputStream * ist , AVPacket * pkt , int * got_output , int * decode_failed ) { AVFrame * decoded_frame = ist -> decoded_frame ; AVCodecContext * avctx = ist -> dec_ctx ; int ret , err = 0 ; AVRational decoded_frame_tb ; update_benchmark ( NULL ) ; ret = decode ( ist , avctx , decoded_frame , got_output , pkt ) ; update_benchmark ( \"decode_audio %d.%d\" , ist -> file_index , ist -> st -> index ) ; if ( ret < 0 ) * decode_failed = 1 ; if ( ret != AVERROR_EOF ) check_decode_result ( ist , got_output , ret ) ; if ( ! * got_output || ret < 0 ) return ret ; ist -> samples_decoded += decoded_frame -> nb_samples ; ist -> frames_decoded ++ ; /* increment next_dts to use for the case where the input stream does not\n       have timestamps or there are multiple frames in the packet */ ist -> next_pts += ( ( int64_t ) AV_TIME_BASE * decoded_frame -> nb_samples ) / decoded_frame -> sample_rate ; ist -> next_dts += ( ( int64_t ) AV_TIME_BASE * decoded_frame -> nb_samples ) / decoded_frame -> sample_rate ; if ( decoded_frame -> pts != AV_NOPTS_VALUE ) { decoded_frame_tb = ist -> st -> time_base ; } else if ( pkt && pkt -> pts != AV_NOPTS_VALUE ) { decoded_frame -> pts = pkt -> pts ; decoded_frame_tb = ist -> st -> time_base ; } else { decoded_frame -> pts = ist -> dts ; decoded_frame_tb = AV_TIME_BASE_Q ; } if ( pkt && pkt -> duration && ist -> prev_pkt_pts != AV_NOPTS_VALUE && pkt -> pts != AV_NOPTS_VALUE && pkt -> pts - ist -> prev_pkt_pts > pkt -> duration ) ist -> filter_in_rescale_delta_last = AV_NOPTS_VALUE ; if ( pkt ) ist -> prev_pkt_pts = pkt -> pts ; if ( decoded_frame -> pts != AV_NOPTS_VALUE ) decoded_frame -> pts = av_rescale_delta ( decoded_frame_tb , decoded_frame -> pts , ( AVRational ) { 1 , decoded_frame -> sample_rate } , decoded_frame -> nb_samples , & ist -> filter_in_rescale_delta_last , ( AVRational ) { 1 , decoded_frame -> sample_rate } ) ; ist -> nb_samples = decoded_frame -> nb_samples ; err = send_frame_to_filters ( ist , decoded_frame ) ; av_frame_unref ( decoded_frame ) ; return err < 0 ? err : ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@decode_video": "static int decode_video ( InputStream * ist , AVPacket * pkt , int * got_output , int64_t * duration_pts , int eof , int * decode_failed ) { AVFrame * decoded_frame = ist -> decoded_frame ; int i , ret = 0 , err = 0 ; int64_t best_effort_timestamp ; int64_t dts = AV_NOPTS_VALUE ; // With fate-indeo3-2, we're getting 0-sized packets before EOF for some // reason. This seems like a semi-critical bug. Don't trigger EOF, and // skip the packet. if ( ! eof && pkt && pkt -> size == 0 ) return 0 ; if ( ist -> dts != AV_NOPTS_VALUE ) dts = av_rescale_q ( ist -> dts , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt ) { pkt -> dts = dts ; // ffmpeg.c probably shouldn't do this } // The old code used to set dts on the drain packet, which does not work // with the new API anymore. if ( eof ) { void * new = av_realloc_array ( ist -> dts_buffer , ist -> nb_dts_buffer + 1 , sizeof ( ist -> dts_buffer [ 0 ] ) ) ; if ( ! new ) return AVERROR ( ENOMEM ) ; ist -> dts_buffer = new ; ist -> dts_buffer [ ist -> nb_dts_buffer ++ ] = dts ; } update_benchmark ( NULL ) ; ret = decode ( ist , ist -> dec_ctx , decoded_frame , got_output , pkt ) ; update_benchmark ( \"decode_video %d.%d\" , ist -> file_index , ist -> st -> index ) ; if ( ret < 0 ) * decode_failed = 1 ; // The following line may be required in some cases where there is no parser // or the parser does not has_b_frames correctly if ( ist -> par -> video_delay < ist -> dec_ctx -> has_b_frames ) { if ( ist -> dec_ctx -> codec_id == AV_CODEC_ID_H264 ) { ist -> par -> video_delay = ist -> dec_ctx -> has_b_frames ; } else av_log ( ist -> dec_ctx , AV_LOG_WARNING , \"video_delay is larger in decoder than demuxer %d > %d.\\n\" \"If you want to help, upload a sample \" \"of this file to https://streams.videolan.org/upload/ \" \"and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)\\n\" , ist -> dec_ctx -> has_b_frames , ist -> par -> video_delay ) ; } if ( ret != AVERROR_EOF ) check_decode_result ( ist , got_output , ret ) ; if ( * got_output && ret >= 0 ) { if ( ist -> dec_ctx -> width != decoded_frame -> width || ist -> dec_ctx -> height != decoded_frame -> height || ist -> dec_ctx -> pix_fmt != decoded_frame -> format ) { av_log ( NULL , AV_LOG_DEBUG , \"Frame parameters mismatch context %d,%d,%d != %d,%d,%d\\n\" , decoded_frame -> width , decoded_frame -> height , decoded_frame -> format , ist -> dec_ctx -> width , ist -> dec_ctx -> height , ist -> dec_ctx -> pix_fmt ) ; } } if ( ! * got_output || ret < 0 ) return ret ; if ( ist -> top_field_first >= 0 ) decoded_frame -> top_field_first = ist -> top_field_first ; ist -> frames_decoded ++ ; if ( ist -> hwaccel_retrieve_data && decoded_frame -> format == ist -> hwaccel_pix_fmt ) { err = ist -> hwaccel_retrieve_data ( ist -> dec_ctx , decoded_frame ) ; if ( err < 0 ) goto fail ; } best_effort_timestamp = decoded_frame -> best_effort_timestamp ; * duration_pts = decoded_frame -> duration ; if ( ist -> framerate . num ) best_effort_timestamp = ist -> cfr_next_pts ++ ; if ( eof && best_effort_timestamp == AV_NOPTS_VALUE && ist -> nb_dts_buffer > 0 ) { best_effort_timestamp = ist -> dts_buffer [ 0 ] ; for ( i = 0 ; i < ist -> nb_dts_buffer - 1 ; i ++ ) ist -> dts_buffer [ i ] = ist -> dts_buffer [ i + 1 ] ; ist -> nb_dts_buffer -- ; } if ( best_effort_timestamp != AV_NOPTS_VALUE ) { int64_t ts = av_rescale_q ( decoded_frame -> pts = best_effort_timestamp , ist -> st -> time_base , AV_TIME_BASE_Q ) ; if ( ts != AV_NOPTS_VALUE ) ist -> next_pts = ist -> pts = ts ; } if ( debug_ts ) { av_log ( NULL , AV_LOG_INFO , \"decoder -> ist_index:%d type:video \" \"frame_pts:%s frame_pts_time:%s best_effort_ts:%\" PRId64 \" best_effort_ts_time:%s keyframe:%d frame_type:%d time_base:%d/%d\\n\" , ist -> st -> index , av_ts2str ( decoded_frame -> pts ) , av_ts2timestr ( decoded_frame -> pts , & ist -> st -> time_base ) , best_effort_timestamp , av_ts2timestr ( best_effort_timestamp , & ist -> st -> time_base ) , decoded_frame -> key_frame , decoded_frame -> pict_type , ist -> st -> time_base . num , ist -> st -> time_base . den ) ; } if ( ist -> st -> sample_aspect_ratio . num ) decoded_frame -> sample_aspect_ratio = ist -> st -> sample_aspect_ratio ; err = send_frame_to_filters ( ist , decoded_frame ) ; fail : av_frame_unref ( decoded_frame ) ; return err < 0 ? err : ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@process_subtitle": "static int process_subtitle ( InputStream * ist , AVSubtitle * subtitle , int * got_output ) { int ret = 0 ; int free_sub = 1 ; if ( ist -> fix_sub_duration ) { int end = 1 ; if ( ist -> prev_sub . got_output ) { end = av_rescale ( subtitle -> pts - ist -> prev_sub . subtitle . pts , 1000 , AV_TIME_BASE ) ; if ( end < ist -> prev_sub . subtitle . end_display_time ) { av_log ( NULL , AV_LOG_DEBUG , \"Subtitle duration reduced from %\" PRId32 \" to %d%s\\n\" , ist -> prev_sub . subtitle . end_display_time , end , end <= 0 ? \", dropping it\" : \"\" ) ; ist -> prev_sub . subtitle . end_display_time = end ; } } FFSWAP ( int , * got_output , ist -> prev_sub . got_output ) ; FFSWAP ( int , ret , ist -> prev_sub . ret ) ; FFSWAP ( AVSubtitle , * subtitle , ist -> prev_sub . subtitle ) ; if ( end <= 0 ) goto out ; } if ( ! * got_output ) return ret ; if ( ist -> sub2video . frame ) { sub2video_update ( ist , INT64_MIN , subtitle ) ; } else if ( ist -> nb_filters ) { if ( ! ist -> sub2video . sub_queue ) ist -> sub2video . sub_queue = av_fifo_alloc2 ( 8 , sizeof ( AVSubtitle ) , AV_FIFO_FLAG_AUTO_GROW ) ; if ( ! ist -> sub2video . sub_queue ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ret = av_fifo_write ( ist -> sub2video . sub_queue , subtitle , 1 ) ; if ( ret < 0 ) exit_program ( 1 ) ; free_sub = 0 ; } if ( ! subtitle -> num_rects ) goto out ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ! check_output_constraints ( ist , ost ) || ! ost -> enc_ctx || ost -> enc_ctx -> codec_type != AVMEDIA_TYPE_SUBTITLE ) continue ; do_subtitle_out ( output_files [ ost -> file_index ] , ost , subtitle ) ; } out : if ( free_sub ) avsubtitle_free ( subtitle ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@copy_av_subtitle": "static int copy_av_subtitle ( AVSubtitle * dst , AVSubtitle * src ) { int ret = AVERROR_BUG ; AVSubtitle tmp = { . format = src -> format , . start_display_time = src -> start_display_time , . end_display_time = src -> end_display_time , . num_rects = 0 , . rects = NULL , . pts = src -> pts } ; if ( ! src -> num_rects ) goto success ; if ( ! ( tmp . rects = av_calloc ( src -> num_rects , sizeof ( * tmp . rects ) ) ) ) return AVERROR ( ENOMEM ) ; for ( int i = 0 ; i < src -> num_rects ; i ++ ) { AVSubtitleRect * src_rect = src -> rects [ i ] ; AVSubtitleRect * dst_rect ; if ( ! ( dst_rect = tmp . rects [ i ] = av_mallocz ( sizeof ( * tmp . rects [ 0 ] ) ) ) ) { ret = AVERROR ( ENOMEM ) ; goto cleanup ; } tmp . num_rects ++ ; dst_rect -> type = src_rect -> type ; dst_rect -> flags = src_rect -> flags ; dst_rect -> x = src_rect -> x ; dst_rect -> y = src_rect -> y ; dst_rect -> w = src_rect -> w ; dst_rect -> h = src_rect -> h ; dst_rect -> nb_colors = src_rect -> nb_colors ; if ( src_rect -> text ) if ( ! ( dst_rect -> text = av_strdup ( src_rect -> text ) ) ) { ret = AVERROR ( ENOMEM ) ; goto cleanup ; } if ( src_rect -> ass ) if ( ! ( dst_rect -> ass = av_strdup ( src_rect -> ass ) ) ) { ret = AVERROR ( ENOMEM ) ; goto cleanup ; } for ( int j = 0 ; j < 4 ; j ++ ) { // SUBTITLE_BITMAP images are special in the sense that they // are like PAL8 images. first pointer to data, second to // palette. This makes the size calculation match this. size_t buf_size = src_rect -> type == SUBTITLE_BITMAP && j == 1 ? AVPALETTE_SIZE : src_rect -> h * src_rect -> linesize [ j ] ; if ( ! src_rect -> data [ j ] ) continue ; if ( ! ( dst_rect -> data [ j ] = av_memdup ( src_rect -> data [ j ] , buf_size ) ) ) { ret = AVERROR ( ENOMEM ) ; goto cleanup ; } dst_rect -> linesize [ j ] = src_rect -> linesize [ j ] ; } } success : * dst = tmp ; return 0 ; cleanup : avsubtitle_free ( & tmp ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@fix_sub_duration_heartbeat": "static int fix_sub_duration_heartbeat ( InputStream * ist , int64_t signal_pts ) { int ret = AVERROR_BUG ; int got_output = 1 ; AVSubtitle * prev_subtitle = & ist -> prev_sub . subtitle ; AVSubtitle subtitle ; if ( ! ist -> fix_sub_duration || ! prev_subtitle -> num_rects || signal_pts <= prev_subtitle -> pts ) return 0 ; if ( ( ret = copy_av_subtitle ( & subtitle , prev_subtitle ) ) < 0 ) return ret ; subtitle . pts = signal_pts ; return process_subtitle ( ist , & subtitle , & got_output ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@trigger_fix_sub_duration_heartbeat": "static int trigger_fix_sub_duration_heartbeat ( OutputStream * ost , const AVPacket * pkt ) { OutputFile * of = output_files [ ost -> file_index ] ; int64_t signal_pts = av_rescale_q ( pkt -> pts , pkt -> time_base , AV_TIME_BASE_Q ) ; if ( ! ost -> fix_sub_duration_heartbeat || ! ( pkt -> flags & AV_PKT_FLAG_KEY ) ) // we are only interested in heartbeats on streams configured, and // only on random access points. return 0 ; for ( int i = 0 ; i < of -> nb_streams ; i ++ ) { OutputStream * iter_ost = of -> streams [ i ] ; InputStream * ist = iter_ost -> ist ; int ret = AVERROR_BUG ; if ( iter_ost == ost || ! ist || ! ist -> decoding_needed || ist -> dec_ctx -> codec_type != AVMEDIA_TYPE_SUBTITLE ) // We wish to skip the stream that causes the heartbeat, // output streams without an input stream, streams not decoded // (as fix_sub_duration is only done for decoded subtitles) as // well as non-subtitle streams. continue ; if ( ( ret = fix_sub_duration_heartbeat ( ist , signal_pts ) ) < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@transcode_subtitles": "static int transcode_subtitles ( InputStream * ist , const AVPacket * pkt , int * got_output , int * decode_failed ) { AVSubtitle subtitle ; int ret = avcodec_decode_subtitle2 ( ist -> dec_ctx , & subtitle , got_output , pkt ) ; check_decode_result ( NULL , got_output , ret ) ; if ( ret < 0 || ! * got_output ) { * decode_failed = 1 ; if ( ! pkt -> size ) sub2video_flush ( ist ) ; return ret ; } ist -> frames_decoded ++ ; return process_subtitle ( ist , & subtitle , got_output ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@send_filter_eof": "static int send_filter_eof ( InputStream * ist ) { int i , ret ; /* TODO keep pts also in stream time base to avoid converting back */ int64_t pts = av_rescale_q_rnd ( ist -> pts , AV_TIME_BASE_Q , ist -> st -> time_base , AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX ) ; for ( i = 0 ; i < ist -> nb_filters ; i ++ ) { ret = ifilter_send_eof ( ist -> filters [ i ] , pts ) ; if ( ret < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@process_input_packet": "static int process_input_packet ( InputStream * ist , const AVPacket * pkt , int no_eof ) { const AVCodecParameters * par = ist -> par ; int ret = 0 ; int repeating = 0 ; int eof_reached = 0 ; AVPacket * avpkt = ist -> pkt ; if ( ! ist -> saw_first_ts ) { ist -> first_dts = ist -> dts = ist -> st -> avg_frame_rate . num ? - ist -> dec_ctx -> has_b_frames * AV_TIME_BASE / av_q2d ( ist -> st -> avg_frame_rate ) : 0 ; ist -> pts = 0 ; if ( pkt && pkt -> pts != AV_NOPTS_VALUE && ! ist -> decoding_needed ) { ist -> first_dts = ist -> dts += av_rescale_q ( pkt -> pts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; ist -> pts = ist -> dts ; //unused but better to set it to a value thats not totally wrong } ist -> saw_first_ts = 1 ; } if ( ist -> next_dts == AV_NOPTS_VALUE ) ist -> next_dts = ist -> dts ; if ( ist -> next_pts == AV_NOPTS_VALUE ) ist -> next_pts = ist -> pts ; if ( pkt ) { av_packet_unref ( avpkt ) ; ret = av_packet_ref ( avpkt , pkt ) ; if ( ret < 0 ) return ret ; } if ( pkt && pkt -> dts != AV_NOPTS_VALUE ) { ist -> next_dts = ist -> dts = av_rescale_q ( pkt -> dts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; if ( par -> codec_type != AVMEDIA_TYPE_VIDEO || ! ist -> decoding_needed ) ist -> next_pts = ist -> pts = ist -> dts ; } // while we have more to decode or while the decoder did output something on EOF while ( ist -> decoding_needed ) { int64_t duration_dts = 0 ; int64_t duration_pts = 0 ; int got_output = 0 ; int decode_failed = 0 ; ist -> pts = ist -> next_pts ; ist -> dts = ist -> next_dts ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_AUDIO : ret = decode_audio ( ist , repeating ? NULL : avpkt , & got_output , & decode_failed ) ; av_packet_unref ( avpkt ) ; break ; case AVMEDIA_TYPE_VIDEO : ret = decode_video ( ist , repeating ? NULL : avpkt , & got_output , & duration_pts , ! pkt , & decode_failed ) ; if ( ! repeating || ! pkt || got_output ) { if ( pkt && pkt -> duration ) { duration_dts = av_rescale_q ( pkt -> duration , ist -> st -> time_base , AV_TIME_BASE_Q ) ; } else if ( ist -> dec_ctx -> framerate . num != 0 && ist -> dec_ctx -> framerate . den != 0 ) { int ticks = ist -> last_pkt_repeat_pict >= 0 ? ist -> last_pkt_repeat_pict + 1 : ist -> dec_ctx -> ticks_per_frame ; duration_dts = ( ( int64_t ) AV_TIME_BASE * ist -> dec_ctx -> framerate . den * ticks ) / ist -> dec_ctx -> framerate . num / ist -> dec_ctx -> ticks_per_frame ; } if ( ist -> dts != AV_NOPTS_VALUE && duration_dts ) { ist -> next_dts += duration_dts ; } else ist -> next_dts = AV_NOPTS_VALUE ; } if ( got_output ) { if ( duration_pts > 0 ) { ist -> next_pts += av_rescale_q ( duration_pts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; } else { ist -> next_pts += duration_dts ; } } av_packet_unref ( avpkt ) ; break ; case AVMEDIA_TYPE_SUBTITLE : if ( repeating ) break ; ret = transcode_subtitles ( ist , avpkt , & got_output , & decode_failed ) ; if ( ! pkt && ret >= 0 ) ret = AVERROR_EOF ; av_packet_unref ( avpkt ) ; break ; default : return - 1 ; } if ( ret == AVERROR_EOF ) { eof_reached = 1 ; break ; } if ( ret < 0 ) { if ( decode_failed ) { av_log ( NULL , AV_LOG_ERROR , \"Error while decoding stream #%d:%d: %s\\n\" , ist -> file_index , ist -> st -> index , av_err2str ( ret ) ) ; } else { av_log ( NULL , AV_LOG_FATAL , \"Error while processing the decoded \" \"data for stream #%d:%d\\n\" , ist -> file_index , ist -> st -> index ) ; } if ( ! decode_failed || exit_on_error ) exit_program ( 1 ) ; break ; } if ( got_output ) ist -> got_output = 1 ; if ( ! got_output ) break ; // During draining, we might get multiple output frames in this loop. // ffmpeg.c does not drain the filter chain on configuration changes, // which means if we send multiple frames at once to the filters, and // one of those frames changes configuration, the buffered frames will // be lost. This can upset certain FATE tests. // Decode only 1 frame per call on EOF to appease these FATE tests. // The ideal solution would be to rewrite decoding to use the new // decoding API in a better way. if ( ! pkt ) break ; repeating = 1 ; } /* after flushing, send an EOF on all the filter inputs attached to the stream */ /* except when looping we need to flush but not to send an EOF */ if ( ! pkt && ist -> decoding_needed && eof_reached && ! no_eof ) { int ret = send_filter_eof ( ist ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error marking filters as finished\\n\" ) ; exit_program ( 1 ) ; } } /* handle stream copy */ if ( ! ist -> decoding_needed && pkt ) { ist -> dts = ist -> next_dts ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_AUDIO : av_assert1 ( pkt -> duration >= 0 ) ; if ( par -> sample_rate ) { ist -> next_dts += ( ( int64_t ) AV_TIME_BASE * par -> frame_size ) / par -> sample_rate ; } else { ist -> next_dts += av_rescale_q ( pkt -> duration , ist -> st -> time_base , AV_TIME_BASE_Q ) ; } break ; case AVMEDIA_TYPE_VIDEO : if ( ist -> framerate . num ) { // TODO: Remove work-around for c99-to-c89 issue 7 AVRational time_base_q = AV_TIME_BASE_Q ; int64_t next_dts = av_rescale_q ( ist -> next_dts , time_base_q , av_inv_q ( ist -> framerate ) ) ; ist -> next_dts = av_rescale_q ( next_dts + 1 , av_inv_q ( ist -> framerate ) , time_base_q ) ; } else if ( pkt -> duration ) { ist -> next_dts += av_rescale_q ( pkt -> duration , ist -> st -> time_base , AV_TIME_BASE_Q ) ; } else if ( ist -> dec_ctx -> framerate . num != 0 ) { int ticks = ist -> last_pkt_repeat_pict >= 0 ? ist -> last_pkt_repeat_pict + 1 : ist -> dec_ctx -> ticks_per_frame ; ist -> next_dts += ( ( int64_t ) AV_TIME_BASE * ist -> dec_ctx -> framerate . den * ticks ) / ist -> dec_ctx -> framerate . num / ist -> dec_ctx -> ticks_per_frame ; } break ; } ist -> pts = ist -> dts ; ist -> next_pts = ist -> next_dts ; } else if ( ! ist -> decoding_needed ) eof_reached = 1 ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ! check_output_constraints ( ist , ost ) || ost -> enc_ctx || ( ! pkt && no_eof ) ) continue ; do_streamcopy ( ist , ost , pkt ) ; } return ! eof_reached ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@get_format": "static enum AVPixelFormat get_format ( AVCodecContext * s , const enum AVPixelFormat * pix_fmts ) { InputStream * ist = s -> opaque ; const enum AVPixelFormat * p ; int ret ; for ( p = pix_fmts ; * p != AV_PIX_FMT_NONE ; p ++ ) { const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( * p ) ; const AVCodecHWConfig * config = NULL ; int i ; if ( ! ( desc -> flags & AV_PIX_FMT_FLAG_HWACCEL ) ) break ; if ( ist -> hwaccel_id == HWACCEL_GENERIC || ist -> hwaccel_id == HWACCEL_AUTO ) { for ( i = 0 ; ; i ++ ) { config = avcodec_get_hw_config ( s -> codec , i ) ; if ( ! config ) break ; if ( ! ( config -> methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX ) ) continue ; if ( config -> pix_fmt == * p ) break ; } } if ( config && config -> device_type == ist -> hwaccel_device_type ) { ret = hwaccel_decode_init ( s ) ; if ( ret < 0 ) { if ( ist -> hwaccel_id == HWACCEL_GENERIC ) { av_log ( NULL , AV_LOG_FATAL , \"%s hwaccel requested for input stream #%d:%d, \" \"but cannot be initialized.\\n\" , av_hwdevice_get_type_name ( config -> device_type ) , ist -> file_index , ist -> st -> index ) ; return AV_PIX_FMT_NONE ; } continue ; } ist -> hwaccel_pix_fmt = * p ; break ; } } return * p ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@init_input_stream": "static int init_input_stream ( InputStream * ist , char * error , int error_len ) { int ret ; if ( ist -> decoding_needed ) { const AVCodec * codec = ist -> dec ; if ( ! codec ) { snprintf ( error , error_len , \"Decoder (codec %s) not found for input stream #%d:%d\" , avcodec_get_name ( ist -> dec_ctx -> codec_id ) , ist -> file_index , ist -> st -> index ) ; return AVERROR ( EINVAL ) ; } ist -> dec_ctx -> opaque = ist ; ist -> dec_ctx -> get_format = get_format ; if ( ist -> dec_ctx -> codec_id == AV_CODEC_ID_DVB_SUBTITLE && ( ist -> decoding_needed & DECODING_FOR_OST ) ) { av_dict_set ( & ist -> decoder_opts , \"compute_edt\" , \"1\" , AV_DICT_DONT_OVERWRITE ) ; if ( ist -> decoding_needed & DECODING_FOR_FILTER ) av_log ( NULL , AV_LOG_WARNING , \"Warning using DVB subtitles for filtering and output at the same time is not fully supported, also see -compute_edt [0|1]\\n\" ) ; } /* Useful for subtitles retiming by lavf (FIXME), skipping samples in\n         * audio, and video decoders such as cuvid or mediacodec */ ist -> dec_ctx -> pkt_timebase = ist -> st -> time_base ; if ( ! av_dict_get ( ist -> decoder_opts , \"threads\" , NULL , 0 ) ) av_dict_set ( & ist -> decoder_opts , \"threads\" , \"auto\" , 0 ) ; /* Attached pics are sparse, therefore we would not want to delay their decoding till EOF. */ if ( ist -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) av_dict_set ( & ist -> decoder_opts , \"threads\" , \"1\" , 0 ) ; ret = hw_device_setup_for_decode ( ist ) ; if ( ret < 0 ) { snprintf ( error , error_len , \"Device setup failed for \" \"decoder on input stream #%d:%d : %s\" , ist -> file_index , ist -> st -> index , av_err2str ( ret ) ) ; return ret ; } if ( ( ret = avcodec_open2 ( ist -> dec_ctx , codec , & ist -> decoder_opts ) ) < 0 ) { if ( ret == AVERROR_EXPERIMENTAL ) abort_codec_experimental ( codec , 0 ) ; snprintf ( error , error_len , \"Error while opening decoder for input stream \" \"#%d:%d : %s\" , ist -> file_index , ist -> st -> index , av_err2str ( ret ) ) ; return ret ; } assert_avoptions ( ist -> decoder_opts ) ; } ist -> next_pts = AV_NOPTS_VALUE ; ist -> next_dts = AV_NOPTS_VALUE ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@init_output_stream_streamcopy": "static int init_output_stream_streamcopy ( OutputStream * ost ) { OutputFile * of = output_files [ ost -> file_index ] ; InputStream * ist = ost -> ist ; InputFile * ifile = input_files [ ist -> file_index ] ; AVCodecParameters * par = ost -> st -> codecpar ; AVCodecContext * codec_ctx ; AVRational sar ; int i , ret ; uint32_t codec_tag = par -> codec_tag ; av_assert0 ( ist && ! ost -> filter ) ; codec_ctx = avcodec_alloc_context3 ( NULL ) ; if ( ! codec_ctx ) return AVERROR ( ENOMEM ) ; ret = avcodec_parameters_to_context ( codec_ctx , ist -> par ) ; if ( ret >= 0 ) ret = av_opt_set_dict ( codec_ctx , & ost -> encoder_opts ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Error setting up codec context options.\\n\" ) ; avcodec_free_context ( & codec_ctx ) ; return ret ; } ret = avcodec_parameters_from_context ( par , codec_ctx ) ; avcodec_free_context ( & codec_ctx ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Error getting reference codec parameters.\\n\" ) ; return ret ; } if ( ! codec_tag ) { unsigned int codec_tag_tmp ; if ( ! of -> format -> codec_tag || av_codec_get_id ( of -> format -> codec_tag , par -> codec_tag ) == par -> codec_id || ! av_codec_get_tag2 ( of -> format -> codec_tag , par -> codec_id , & codec_tag_tmp ) ) codec_tag = par -> codec_tag ; } par -> codec_tag = codec_tag ; if ( ! ost -> frame_rate . num ) ost -> frame_rate = ist -> framerate ; if ( ost -> frame_rate . num ) ost -> st -> avg_frame_rate = ost -> frame_rate ; else ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate ; ret = avformat_transfer_internal_stream_timing_info ( of -> format , ost -> st , ist -> st , copy_tb ) ; if ( ret < 0 ) return ret ; // copy timebase while removing common factors if ( ost -> st -> time_base . num <= 0 || ost -> st -> time_base . den <= 0 ) { if ( ost -> frame_rate . num ) ost -> st -> time_base = av_inv_q ( ost -> frame_rate ) ; else ost -> st -> time_base = av_add_q ( av_stream_get_codec_timebase ( ost -> st ) , ( AVRational ) { 0 , 1 } ) ; } // copy estimated duration as a hint to the muxer if ( ost -> st -> duration <= 0 && ist -> st -> duration > 0 ) ost -> st -> duration = av_rescale_q ( ist -> st -> duration , ist -> st -> time_base , ost -> st -> time_base ) ; if ( ! ost -> copy_prior_start ) { ost -> ts_copy_start = ( of -> start_time == AV_NOPTS_VALUE ) ? 0 : of -> start_time ; if ( copy_ts && ifile -> start_time != AV_NOPTS_VALUE ) { ost -> ts_copy_start = FFMAX ( ost -> ts_copy_start , ifile -> start_time + ifile -> ts_offset ) ; } } if ( ist -> st -> nb_side_data ) { for ( i = 0 ; i < ist -> st -> nb_side_data ; i ++ ) { const AVPacketSideData * sd_src = & ist -> st -> side_data [ i ] ; uint8_t * dst_data ; dst_data = av_stream_new_side_data ( ost -> st , sd_src -> type , sd_src -> size ) ; if ( ! dst_data ) return AVERROR ( ENOMEM ) ; memcpy ( dst_data , sd_src -> data , sd_src -> size ) ; } } # if FFMPEG_ROTATION_METADATA if ( ost -> rotate_overridden ) { uint8_t * sd = av_stream_new_side_data ( ost -> st , AV_PKT_DATA_DISPLAYMATRIX , sizeof ( int32_t ) * 9 ) ; if ( sd ) av_display_rotation_set ( ( int32_t * ) sd , - ost -> rotate_override_value ) ; } # endif switch ( par -> codec_type ) { case AVMEDIA_TYPE_AUDIO : if ( ( par -> block_align == 1 || par -> block_align == 1152 || par -> block_align == 576 ) && par -> codec_id == AV_CODEC_ID_MP3 ) par -> block_align = 0 ; if ( par -> codec_id == AV_CODEC_ID_AC3 ) par -> block_align = 0 ; break ; case AVMEDIA_TYPE_VIDEO : if ( ost -> frame_aspect_ratio . num ) { // overridden by the -aspect cli option sar = av_mul_q ( ost -> frame_aspect_ratio , ( AVRational ) { par -> height , par -> width } ) ; av_log ( ost , AV_LOG_WARNING , \"Overriding aspect ratio \" \"with stream copy may produce invalid files\\n\" ) ; } else if ( ist -> st -> sample_aspect_ratio . num ) sar = ist -> st -> sample_aspect_ratio ; else sar = par -> sample_aspect_ratio ; ost -> st -> sample_aspect_ratio = par -> sample_aspect_ratio = sar ; ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate ; ost -> st -> r_frame_rate = ist -> st -> r_frame_rate ; break ; } ost -> mux_timebase = ist -> st -> time_base ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@set_encoder_id": "static void set_encoder_id ( OutputFile * of , OutputStream * ost ) { const char * cname = ost -> enc_ctx -> codec -> name ; uint8_t * encoder_string ; int encoder_string_len ; if ( av_dict_get ( ost -> st -> metadata , \"encoder\" , NULL , 0 ) ) return ; encoder_string_len = sizeof ( LIBAVCODEC_IDENT ) + strlen ( cname ) + 2 ; encoder_string = av_mallocz ( encoder_string_len ) ; if ( ! encoder_string ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( ! of -> bitexact && ! ost -> bitexact ) av_strlcpy ( encoder_string , LIBAVCODEC_IDENT \" \" , encoder_string_len ) ; else av_strlcpy ( encoder_string , \"Lavc \" , encoder_string_len ) ; av_strlcat ( encoder_string , cname , encoder_string_len ) ; av_dict_set ( & ost -> st -> metadata , \"encoder\" , encoder_string , AV_DICT_DONT_STRDUP_VAL | AV_DICT_DONT_OVERWRITE ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@init_encoder_time_base": "static void init_encoder_time_base ( OutputStream * ost , AVRational default_time_base ) { InputStream * ist = ost -> ist ; AVCodecContext * enc_ctx = ost -> enc_ctx ; if ( ost -> enc_timebase . num > 0 ) { enc_ctx -> time_base = ost -> enc_timebase ; return ; } if ( ost -> enc_timebase . num < 0 ) { if ( ist ) { enc_ctx -> time_base = ist -> st -> time_base ; return ; } av_log ( ost , AV_LOG_WARNING , \"Input stream data not available, using default time base\\n\" ) ; } enc_ctx -> time_base = default_time_base ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@init_output_stream_encode": "static int init_output_stream_encode ( OutputStream * ost , AVFrame * frame ) { InputStream * ist = ost -> ist ; AVCodecContext * enc_ctx = ost -> enc_ctx ; AVCodecContext * dec_ctx = NULL ; OutputFile * of = output_files [ ost -> file_index ] ; int ret ; set_encoder_id ( output_files [ ost -> file_index ] , ost ) ; if ( ist ) { dec_ctx = ist -> dec_ctx ; } if ( enc_ctx -> codec_type == AVMEDIA_TYPE_VIDEO ) { if ( ! ost -> frame_rate . num ) ost -> frame_rate = av_buffersink_get_frame_rate ( ost -> filter -> filter ) ; if ( ! ost -> frame_rate . num && ! ost -> max_frame_rate . num ) { ost -> frame_rate = ( AVRational ) { 25 , 1 } ; av_log ( ost , AV_LOG_WARNING , \"No information \" \"about the input framerate is available. Falling \" \"back to a default value of 25fps. Use the -r option \" \"if you want a different framerate.\\n\" ) ; } if ( ost -> max_frame_rate . num && ( av_q2d ( ost -> frame_rate ) > av_q2d ( ost -> max_frame_rate ) || ! ost -> frame_rate . den ) ) ost -> frame_rate = ost -> max_frame_rate ; if ( enc_ctx -> codec -> supported_framerates && ! ost -> force_fps ) { int idx = av_find_nearest_q_idx ( ost -> frame_rate , enc_ctx -> codec -> supported_framerates ) ; ost -> frame_rate = enc_ctx -> codec -> supported_framerates [ idx ] ; } // reduce frame rate for mpeg4 to be within the spec limits if ( enc_ctx -> codec_id == AV_CODEC_ID_MPEG4 ) { av_reduce ( & ost -> frame_rate . num , & ost -> frame_rate . den , ost -> frame_rate . num , ost -> frame_rate . den , 65535 ) ; } } switch ( enc_ctx -> codec_type ) { case AVMEDIA_TYPE_AUDIO : enc_ctx -> sample_fmt = av_buffersink_get_format ( ost -> filter -> filter ) ; enc_ctx -> sample_rate = av_buffersink_get_sample_rate ( ost -> filter -> filter ) ; ret = av_buffersink_get_ch_layout ( ost -> filter -> filter , & enc_ctx -> ch_layout ) ; if ( ret < 0 ) return ret ; if ( ost -> bits_per_raw_sample ) enc_ctx -> bits_per_raw_sample = ost -> bits_per_raw_sample ; else if ( dec_ctx && ost -> filter -> graph -> is_meta ) enc_ctx -> bits_per_raw_sample = FFMIN ( dec_ctx -> bits_per_raw_sample , av_get_bytes_per_sample ( enc_ctx -> sample_fmt ) << 3 ) ; init_encoder_time_base ( ost , av_make_q ( 1 , enc_ctx -> sample_rate ) ) ; break ; case AVMEDIA_TYPE_VIDEO : init_encoder_time_base ( ost , av_inv_q ( ost -> frame_rate ) ) ; if ( ! ( enc_ctx -> time_base . num && enc_ctx -> time_base . den ) ) enc_ctx -> time_base = av_buffersink_get_time_base ( ost -> filter -> filter ) ; if ( av_q2d ( enc_ctx -> time_base ) < 0.001 && ost -> vsync_method != VSYNC_PASSTHROUGH && ( ost -> vsync_method == VSYNC_CFR || ost -> vsync_method == VSYNC_VSCFR || ( ost -> vsync_method == VSYNC_AUTO && ! ( of -> format -> flags & AVFMT_VARIABLE_FPS ) ) ) ) { av_log ( ost , AV_LOG_WARNING , \"Frame rate very high for a muxer not efficiently supporting it.\\n\" \"Please consider specifying a lower framerate, a different muxer or \" \"setting vsync/fps_mode to vfr\\n\" ) ; } enc_ctx -> width = av_buffersink_get_w ( ost -> filter -> filter ) ; enc_ctx -> height = av_buffersink_get_h ( ost -> filter -> filter ) ; enc_ctx -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = ost -> frame_aspect_ratio . num ? // overridden by the -aspect cli option av_mul_q ( ost -> frame_aspect_ratio , ( AVRational ) { enc_ctx -> height , enc_ctx -> width } ) : av_buffersink_get_sample_aspect_ratio ( ost -> filter -> filter ) ; enc_ctx -> pix_fmt = av_buffersink_get_format ( ost -> filter -> filter ) ; if ( ost -> bits_per_raw_sample ) enc_ctx -> bits_per_raw_sample = ost -> bits_per_raw_sample ; else if ( dec_ctx && ost -> filter -> graph -> is_meta ) enc_ctx -> bits_per_raw_sample = FFMIN ( dec_ctx -> bits_per_raw_sample , av_pix_fmt_desc_get ( enc_ctx -> pix_fmt ) -> comp [ 0 ] . depth ) ; if ( frame ) { enc_ctx -> color_range = frame -> color_range ; enc_ctx -> color_primaries = frame -> color_primaries ; enc_ctx -> color_trc = frame -> color_trc ; enc_ctx -> colorspace = frame -> colorspace ; enc_ctx -> chroma_sample_location = frame -> chroma_location ; } enc_ctx -> framerate = ost -> frame_rate ; ost -> st -> avg_frame_rate = ost -> frame_rate ; // Field order: autodetection if ( frame ) { if ( enc_ctx -> flags & ( AV_CODEC_FLAG_INTERLACED_DCT | AV_CODEC_FLAG_INTERLACED_ME ) && ost -> top_field_first >= 0 ) frame -> top_field_first = ! ! ost -> top_field_first ; if ( frame -> interlaced_frame ) { if ( enc_ctx -> codec -> id == AV_CODEC_ID_MJPEG ) enc_ctx -> field_order = frame -> top_field_first ? AV_FIELD_TT : AV_FIELD_BB ; else enc_ctx -> field_order = frame -> top_field_first ? AV_FIELD_TB : AV_FIELD_BT ; } else enc_ctx -> field_order = AV_FIELD_PROGRESSIVE ; } // Field order: override if ( ost -> top_field_first == 0 ) { enc_ctx -> field_order = AV_FIELD_BB ; } else if ( ost -> top_field_first == 1 ) { enc_ctx -> field_order = AV_FIELD_TT ; } break ; case AVMEDIA_TYPE_SUBTITLE : enc_ctx -> time_base = AV_TIME_BASE_Q ; if ( ! enc_ctx -> width ) { enc_ctx -> width = ost -> ist -> par -> width ; enc_ctx -> height = ost -> ist -> par -> height ; } if ( dec_ctx && dec_ctx -> subtitle_header ) { /* ASS code assumes this buffer is null terminated so add extra byte. */ ost -> enc_ctx -> subtitle_header = av_mallocz ( dec_ctx -> subtitle_header_size + 1 ) ; if ( ! ost -> enc_ctx -> subtitle_header ) return AVERROR ( ENOMEM ) ; memcpy ( ost -> enc_ctx -> subtitle_header , dec_ctx -> subtitle_header , dec_ctx -> subtitle_header_size ) ; ost -> enc_ctx -> subtitle_header_size = dec_ctx -> subtitle_header_size ; } if ( ist && ist -> dec -> type == AVMEDIA_TYPE_SUBTITLE && enc_ctx -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { int input_props = 0 , output_props = 0 ; AVCodecDescriptor const * input_descriptor = avcodec_descriptor_get ( ist -> dec -> id ) ; AVCodecDescriptor const * output_descriptor = avcodec_descriptor_get ( ost -> enc_ctx -> codec_id ) ; if ( input_descriptor ) input_props = input_descriptor -> props & ( AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB ) ; if ( output_descriptor ) output_props = output_descriptor -> props & ( AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB ) ; if ( input_props && output_props && input_props != output_props ) { av_log ( ost , AV_LOG_ERROR , \"Subtitle encoding currently only possible from text to text \" \"or bitmap to bitmap\" ) ; return AVERROR_INVALIDDATA ; } } break ; case AVMEDIA_TYPE_DATA : break ; default : abort ( ) ; break ; } if ( ost -> bitexact ) enc_ctx -> flags |= AV_CODEC_FLAG_BITEXACT ; if ( ost -> sq_idx_encode >= 0 ) sq_set_tb ( of -> sq_encode , ost -> sq_idx_encode , enc_ctx -> time_base ) ; ost -> mux_timebase = enc_ctx -> time_base ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@init_output_stream": "static int init_output_stream ( OutputStream * ost , AVFrame * frame , char * error , int error_len ) { int ret = 0 ; if ( ost -> enc_ctx ) { const AVCodec * codec = ost -> enc_ctx -> codec ; InputStream * ist = ost -> ist ; ret = init_output_stream_encode ( ost , frame ) ; if ( ret < 0 ) return ret ; if ( ! av_dict_get ( ost -> encoder_opts , \"threads\" , NULL , 0 ) ) av_dict_set ( & ost -> encoder_opts , \"threads\" , \"auto\" , 0 ) ; if ( codec -> capabilities & AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE ) { ret = av_dict_set ( & ost -> encoder_opts , \"flags\" , \"+copy_opaque\" , AV_DICT_MULTIKEY ) ; if ( ret < 0 ) return ret ; } ret = hw_device_setup_for_encode ( ost ) ; if ( ret < 0 ) { snprintf ( error , error_len , \"Device setup failed for \" \"encoder on output stream #%d:%d : %s\" , ost -> file_index , ost -> index , av_err2str ( ret ) ) ; return ret ; } if ( ( ret = avcodec_open2 ( ost -> enc_ctx , codec , & ost -> encoder_opts ) ) < 0 ) { if ( ret == AVERROR_EXPERIMENTAL ) abort_codec_experimental ( codec , 1 ) ; snprintf ( error , error_len , \"Error while opening encoder for output stream #%d:%d - \" \"maybe incorrect parameters such as bit_rate, rate, width or height\" , ost -> file_index , ost -> index ) ; return ret ; } if ( codec -> type == AVMEDIA_TYPE_AUDIO && ! ( codec -> capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE ) ) av_buffersink_set_frame_size ( ost -> filter -> filter , ost -> enc_ctx -> frame_size ) ; assert_avoptions ( ost -> encoder_opts ) ; if ( ost -> enc_ctx -> bit_rate && ost -> enc_ctx -> bit_rate < 1000 && ost -> enc_ctx -> codec_id != AV_CODEC_ID_CODEC2 /* don't complain about 700 bit/s modes */ ) av_log ( ost , AV_LOG_WARNING , \"The bitrate parameter is set too low.\" \" It takes bits/s as argument, not kbits/s\\n\" ) ; ret = avcodec_parameters_from_context ( ost -> st -> codecpar , ost -> enc_ctx ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Error initializing the output stream codec context.\\n\" ) ; exit_program ( 1 ) ; } if ( ost -> enc_ctx -> nb_coded_side_data ) { int i ; for ( i = 0 ; i < ost -> enc_ctx -> nb_coded_side_data ; i ++ ) { const AVPacketSideData * sd_src = & ost -> enc_ctx -> coded_side_data [ i ] ; uint8_t * dst_data ; dst_data = av_stream_new_side_data ( ost -> st , sd_src -> type , sd_src -> size ) ; if ( ! dst_data ) return AVERROR ( ENOMEM ) ; memcpy ( dst_data , sd_src -> data , sd_src -> size ) ; } } /*\n         * Add global input side data. For now this is naive, and copies it\n         * from the input stream's global side data. All side data should\n         * really be funneled over AVFrame and libavfilter, then added back to\n         * packet side data, and then potentially using the first packet for\n         * global side data.\n         */ if ( ist ) { int i ; for ( i = 0 ; i < ist -> st -> nb_side_data ; i ++ ) { AVPacketSideData * sd = & ist -> st -> side_data [ i ] ; if ( sd -> type != AV_PKT_DATA_CPB_PROPERTIES ) { uint8_t * dst = av_stream_new_side_data ( ost -> st , sd -> type , sd -> size ) ; if ( ! dst ) return AVERROR ( ENOMEM ) ; memcpy ( dst , sd -> data , sd -> size ) ; if ( ist -> autorotate && sd -> type == AV_PKT_DATA_DISPLAYMATRIX ) av_display_rotation_set ( ( int32_t * ) dst , 0 ) ; } } } // copy timebase while removing common factors if ( ost -> st -> time_base . num <= 0 || ost -> st -> time_base . den <= 0 ) ost -> st -> time_base = av_add_q ( ost -> enc_ctx -> time_base , ( AVRational ) { 0 , 1 } ) ; // copy estimated duration as a hint to the muxer if ( ost -> st -> duration <= 0 && ist && ist -> st -> duration > 0 ) ost -> st -> duration = av_rescale_q ( ist -> st -> duration , ist -> st -> time_base , ost -> st -> time_base ) ; } else if ( ost -> ist ) { ret = init_output_stream_streamcopy ( ost ) ; if ( ret < 0 ) return ret ; } ret = of_stream_init ( output_files [ ost -> file_index ] , ost ) ; if ( ret < 0 ) return ret ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@transcode_init": "static int transcode_init ( void ) { int ret = 0 ; char error [ 1024 ] = { 0 } ; /* init framerate emulation */ for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * ifile = input_files [ i ] ; if ( ifile -> readrate || ifile -> rate_emu ) for ( int j = 0 ; j < ifile -> nb_streams ; j ++ ) ifile -> streams [ j ] -> start = av_gettime_relative ( ) ; } /* init input streams */ for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) if ( ( ret = init_input_stream ( ist , error , sizeof ( error ) ) ) < 0 ) goto dump_format ; /*\n     * initialize stream copy and subtitle/data streams.\n     * Encoded AVFrame based streams will get initialized as follows:\n     * - when the first AVFrame is received in do_video_out\n     * - just before the first AVFrame is received in either transcode_step\n     *   or reap_filters due to us requiring the filter chain buffer sink\n     *   to be configured with the correct audio frame size, which is only\n     *   known after the encoder is initialized.\n     */ for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> enc_ctx && ( ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO || ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) ) continue ; ret = init_output_stream_wrapper ( ost , NULL , 0 ) ; if ( ret < 0 ) goto dump_format ; } /* discard unused programs */ for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * ifile = input_files [ i ] ; for ( int j = 0 ; j < ifile -> ctx -> nb_programs ; j ++ ) { AVProgram * p = ifile -> ctx -> programs [ j ] ; int discard = AVDISCARD_ALL ; for ( int k = 0 ; k < p -> nb_stream_indexes ; k ++ ) if ( ! ifile -> streams [ p -> stream_index [ k ] ] -> discard ) { discard = AVDISCARD_DEFAULT ; break ; } p -> discard = discard ; } } dump_format : /* dump the stream mapping */ av_log ( NULL , AV_LOG_INFO , \"Stream mapping:\\n\" ) ; for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) { for ( int j = 0 ; j < ist -> nb_filters ; j ++ ) { if ( ! filtergraph_is_simple ( ist -> filters [ j ] -> graph ) ) { av_log ( NULL , AV_LOG_INFO , \"  Stream #%d:%d (%s) -> %s\" , ist -> file_index , ist -> st -> index , ist -> dec ? ist -> dec -> name : \"?\" , ist -> filters [ j ] -> name ) ; if ( nb_filtergraphs > 1 ) av_log ( NULL , AV_LOG_INFO , \" (graph %d)\" , ist -> filters [ j ] -> graph -> index ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; } } } for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> attachment_filename ) { /* an attached file */ av_log ( NULL , AV_LOG_INFO , \"  File %s -> Stream #%d:%d\\n\" , ost -> attachment_filename , ost -> file_index , ost -> index ) ; continue ; } if ( ost -> filter && ! filtergraph_is_simple ( ost -> filter -> graph ) ) { /* output from a complex graph */ av_log ( NULL , AV_LOG_INFO , \"  %s\" , ost -> filter -> name ) ; if ( nb_filtergraphs > 1 ) av_log ( NULL , AV_LOG_INFO , \" (graph %d)\" , ost -> filter -> graph -> index ) ; av_log ( NULL , AV_LOG_INFO , \" -> Stream #%d:%d (%s)\\n\" , ost -> file_index , ost -> index , ost -> enc_ctx -> codec -> name ) ; continue ; } av_log ( NULL , AV_LOG_INFO , \"  Stream #%d:%d -> #%d:%d\" , ost -> ist -> file_index , ost -> ist -> st -> index , ost -> file_index , ost -> index ) ; if ( ost -> enc_ctx ) { const AVCodec * in_codec = ost -> ist -> dec ; const AVCodec * out_codec = ost -> enc_ctx -> codec ; const char * decoder_name = \"?\" ; const char * in_codec_name = \"?\" ; const char * encoder_name = \"?\" ; const char * out_codec_name = \"?\" ; const AVCodecDescriptor * desc ; if ( in_codec ) { decoder_name = in_codec -> name ; desc = avcodec_descriptor_get ( in_codec -> id ) ; if ( desc ) in_codec_name = desc -> name ; if ( ! strcmp ( decoder_name , in_codec_name ) ) decoder_name = \"native\" ; } if ( out_codec ) { encoder_name = out_codec -> name ; desc = avcodec_descriptor_get ( out_codec -> id ) ; if ( desc ) out_codec_name = desc -> name ; if ( ! strcmp ( encoder_name , out_codec_name ) ) encoder_name = \"native\" ; } av_log ( NULL , AV_LOG_INFO , \" (%s (%s) -> %s (%s))\" , in_codec_name , decoder_name , out_codec_name , encoder_name ) ; } else av_log ( NULL , AV_LOG_INFO , \" (copy)\" ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; } if ( ret ) { av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" , error ) ; return ret ; } atomic_store ( & transcode_init_done , 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@need_output": "static int need_output ( void ) { for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> finished ) continue ; return 1 ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@choose_output": "static OutputStream * choose_output ( void ) { int64_t opts_min = INT64_MAX ; OutputStream * ost_min = NULL ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { int64_t opts ; if ( ost -> filter && ost -> last_filter_pts != AV_NOPTS_VALUE ) { opts = ost -> last_filter_pts ; } else { opts = ost -> last_mux_dts == AV_NOPTS_VALUE ? INT64_MIN : ost -> last_mux_dts ; if ( ost -> last_mux_dts == AV_NOPTS_VALUE ) av_log ( ost , AV_LOG_DEBUG , \"cur_dts is invalid [init:%d i_done:%d finish:%d] (this is harmless if it occurs once at the start per stream)\\n\" , ost -> initialized , ost -> inputs_done , ost -> finished ) ; } if ( ! ost -> initialized && ! ost -> inputs_done ) return ost -> unavailable ? NULL : ost ; if ( ! ost -> finished && opts < opts_min ) { opts_min = opts ; ost_min = ost -> unavailable ? NULL : ost ; } } return ost_min ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@set_tty_echo": "static void set_tty_echo ( int on ) { # if HAVE_TERMIOS_H struct termios tty ; if ( tcgetattr ( 0 , & tty ) == 0 ) { if ( on ) tty . c_lflag |= ECHO ; else tty . c_lflag &= ~ ECHO ; tcsetattr ( 0 , TCSANOW , & tty ) ; } # endif }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@check_keyboard_interaction": "static int check_keyboard_interaction ( int64_t cur_time ) { int i , ret , key ; if ( received_nb_signals ) return AVERROR_EXIT ; /* read_key() returns 0 on EOF */ if ( cur_time - keyboard_last_time >= 100000 ) { key = read_key ( ) ; keyboard_last_time = cur_time ; } else key = - 1 ; if ( key == 'q' ) { av_log ( NULL , AV_LOG_INFO , \"\\n\\n[q] command received. Exiting.\\n\\n\" ) ; return AVERROR_EXIT ; } if ( key == '+' ) av_log_set_level ( av_log_get_level ( ) + 10 ) ; if ( key == '-' ) av_log_set_level ( av_log_get_level ( ) - 10 ) ; if ( key == 's' ) qp_hist ^= 1 ; if ( key == 'c' || key == 'C' ) { char buf [ 4096 ] , target [ 64 ] , command [ 256 ] , arg [ 256 ] = { 0 } ; double time ; int k , n = 0 ; av_log ( NULL , AV_LOG_STDERR , \"\\nEnter command: <target>|all <time>|-1 <command>[ <argument>]\\n\" ) ; i = 0 ; set_tty_echo ( 1 ) ; while ( ( k = read_key ( ) ) != '\\n' && k != '\\r' && i < sizeof ( buf ) - 1 ) if ( k > 0 ) buf [ i ++ ] = k ; buf [ i ] = 0 ; set_tty_echo ( 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; if ( k > 0 && ( n = sscanf ( buf , \"%63[^ ] %lf %255[^ ] %255[^\\n]\" , target , & time , command , arg ) ) >= 3 ) { av_log ( NULL , AV_LOG_DEBUG , \"Processing command target:%s time:%f command:%s arg:%s\" , target , time , command , arg ) ; for ( i = 0 ; i < nb_filtergraphs ; i ++ ) { FilterGraph * fg = filtergraphs [ i ] ; if ( fg -> graph ) { if ( time < 0 ) { ret = avfilter_graph_send_command ( fg -> graph , target , command , arg , buf , sizeof ( buf ) , key == 'c' ? AVFILTER_CMD_FLAG_ONE : 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"Command reply for stream %d: ret:%d res:\\n%s\" , i , ret , buf ) ; } else if ( key == 'c' ) { av_log ( NULL , AV_LOG_STDERR , \"Queuing commands only on filters supporting the specific command is unsupported\\n\" ) ; ret = AVERROR_PATCHWELCOME ; } else { ret = avfilter_graph_queue_command ( fg -> graph , target , command , arg , 0 , time ) ; if ( ret < 0 ) av_log ( NULL , AV_LOG_STDERR , \"Queuing command failed with error %s\\n\" , av_err2str ( ret ) ) ; } } } } else { av_log ( NULL , AV_LOG_ERROR , \"Parse error, at least 3 arguments were expected, \" \"only %d given in string '%s'\\n\" , n , buf ) ; } } if ( key == 'd' || key == 'D' ) { int debug = 0 ; if ( key == 'D' ) { InputStream * ist = ist_iter ( NULL ) ; if ( ist ) debug = ist -> dec_ctx -> debug << 1 ; if ( ! debug ) debug = 1 ; while ( debug & FF_DEBUG_DCT_COEFF ) //unsupported, would just crash debug += debug ; } else { char buf [ 32 ] ; int k = 0 ; i = 0 ; set_tty_echo ( 1 ) ; while ( ( k = read_key ( ) ) != '\\n' && k != '\\r' && i < sizeof ( buf ) - 1 ) if ( k > 0 ) buf [ i ++ ] = k ; buf [ i ] = 0 ; set_tty_echo ( 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; if ( k <= 0 || sscanf ( buf , \"%d\" , & debug ) != 1 ) av_log ( NULL , AV_LOG_STDERR , \"error parsing debug value\\n\" ) ; } for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) ist -> dec_ctx -> debug = debug ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> enc_ctx ) ost -> enc_ctx -> debug = debug ; } if ( debug ) av_log_set_level ( AV_LOG_DEBUG ) ; av_log ( NULL , AV_LOG_STDERR , \"debug=%d\\n\" , debug ) ; } if ( key == '?' ) { av_log ( NULL , AV_LOG_STDERR , \"key    function\\n\" \"?      show this help\\n\" \"+      increase verbosity\\n\" \"-      decrease verbosity\\n\" \"c      Send command to first matching filter supporting it\\n\" \"C      Send/Queue command to all matching filters\\n\" \"D      cycle through available debug modes\\n\" \"h      dump packets/hex press to cycle through the 3 states\\n\" \"q      quit\\n\" \"s      Show QP histogram\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@got_eagain": "static int got_eagain ( void ) { for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) if ( ost -> unavailable ) return 1 ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@reset_eagain": "static void reset_eagain ( void ) { int i ; for ( i = 0 ; i < nb_input_files ; i ++ ) input_files [ i ] -> eagain = 0 ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) ost -> unavailable = 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@decode_flush": "static void decode_flush ( InputFile * ifile ) { for ( int i = 0 ; i < ifile -> nb_streams ; i ++ ) { InputStream * ist = ifile -> streams [ i ] ; int ret ; if ( ! ist -> processing_needed ) continue ; do { ret = process_input_packet ( ist , NULL , 1 ) ; } while ( ret > 0 ) ; if ( ist -> decoding_needed ) { /* report last frame duration to the demuxer thread */ if ( ist -> par -> codec_type == AVMEDIA_TYPE_AUDIO ) { LastFrameDuration dur ; dur . stream_idx = i ; dur . duration = av_rescale_q ( ist -> nb_samples , ( AVRational ) { 1 , ist -> dec_ctx -> sample_rate } , ist -> st -> time_base ) ; av_thread_message_queue_send ( ifile -> audio_duration_queue , & dur , 0 ) ; } avcodec_flush_buffers ( ist -> dec_ctx ) ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@ts_discontinuity_detect": "static void ts_discontinuity_detect ( InputFile * ifile , InputStream * ist , AVPacket * pkt ) { const int fmt_is_discont = ifile -> ctx -> iformat -> flags & AVFMT_TS_DISCONT ; int disable_discontinuity_correction = copy_ts ; int64_t pkt_dts = av_rescale_q_rnd ( pkt -> dts , ist -> st -> time_base , AV_TIME_BASE_Q , AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX ) ; if ( copy_ts && ist -> next_dts != AV_NOPTS_VALUE && fmt_is_discont && ist -> st -> pts_wrap_bits < 60 ) { int64_t wrap_dts = av_rescale_q_rnd ( pkt -> dts + ( 1LL << ist -> st -> pts_wrap_bits ) , ist -> st -> time_base , AV_TIME_BASE_Q , AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX ) ; if ( FFABS ( wrap_dts - ist -> next_dts ) < FFABS ( pkt_dts - ist -> next_dts ) / 10 ) disable_discontinuity_correction = 0 ; } if ( ist -> next_dts != AV_NOPTS_VALUE && ! disable_discontinuity_correction ) { int64_t delta = pkt_dts - ist -> next_dts ; if ( fmt_is_discont ) { if ( FFABS ( delta ) > 1LL * dts_delta_threshold * AV_TIME_BASE || pkt_dts + AV_TIME_BASE / 10 < FFMAX ( ist -> pts , ist -> dts ) ) { ifile -> ts_offset_discont -= delta ; av_log ( NULL , AV_LOG_DEBUG , \"timestamp discontinuity for stream #%d:%d \" \"(id=%d, type=%s): %\" PRId64 \", new offset= %\" PRId64 \"\\n\" , ist -> file_index , ist -> st -> index , ist -> st -> id , av_get_media_type_string ( ist -> par -> codec_type ) , delta , ifile -> ts_offset_discont ) ; pkt -> dts -= av_rescale_q ( delta , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts -= av_rescale_q ( delta , AV_TIME_BASE_Q , ist -> st -> time_base ) ; } } else { if ( FFABS ( delta ) > 1LL * dts_error_threshold * AV_TIME_BASE ) { av_log ( NULL , AV_LOG_WARNING , \"DTS %\" PRId64 \", next:%\" PRId64 \" st:%d invalid dropping\\n\" , pkt -> dts , ist -> next_dts , pkt -> stream_index ) ; pkt -> dts = AV_NOPTS_VALUE ; } if ( pkt -> pts != AV_NOPTS_VALUE ) { int64_t pkt_pts = av_rescale_q ( pkt -> pts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; delta = pkt_pts - ist -> next_dts ; if ( FFABS ( delta ) > 1LL * dts_error_threshold * AV_TIME_BASE ) { av_log ( NULL , AV_LOG_WARNING , \"PTS %\" PRId64 \", next:%\" PRId64 \" invalid dropping st:%d\\n\" , pkt -> pts , ist -> next_dts , pkt -> stream_index ) ; pkt -> pts = AV_NOPTS_VALUE ; } } } } else if ( ist -> next_dts == AV_NOPTS_VALUE && ! copy_ts && fmt_is_discont && ifile -> last_ts != AV_NOPTS_VALUE ) { int64_t delta = pkt_dts - ifile -> last_ts ; if ( FFABS ( delta ) > 1LL * dts_delta_threshold * AV_TIME_BASE ) { ifile -> ts_offset_discont -= delta ; av_log ( NULL , AV_LOG_DEBUG , \"Inter stream timestamp discontinuity %\" PRId64 \", new offset= %\" PRId64 \"\\n\" , delta , ifile -> ts_offset_discont ) ; pkt -> dts -= av_rescale_q ( delta , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts -= av_rescale_q ( delta , AV_TIME_BASE_Q , ist -> st -> time_base ) ; } } ifile -> last_ts = av_rescale_q ( pkt -> dts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@ts_discontinuity_process": "static void ts_discontinuity_process ( InputFile * ifile , InputStream * ist , AVPacket * pkt ) { int64_t offset = av_rescale_q ( ifile -> ts_offset_discont , AV_TIME_BASE_Q , ist -> st -> time_base ) ; // apply previously-detected timestamp-discontinuity offset // (to all streams, not just audio/video) if ( pkt -> dts != AV_NOPTS_VALUE ) pkt -> dts += offset ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts += offset ; // detect timestamp discontinuities for audio/video if ( ( ist -> par -> codec_type == AVMEDIA_TYPE_VIDEO || ist -> par -> codec_type == AVMEDIA_TYPE_AUDIO ) && pkt -> dts != AV_NOPTS_VALUE ) ts_discontinuity_detect ( ifile , ist , pkt ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@process_input": "static int process_input ( int file_index ) { InputFile * ifile = input_files [ file_index ] ; AVFormatContext * is ; InputStream * ist ; AVPacket * pkt ; int ret , i ; is = ifile -> ctx ; ret = ifile_get_packet ( ifile , & pkt ) ; if ( ret == AVERROR ( EAGAIN ) ) { ifile -> eagain = 1 ; return ret ; } if ( ret == 1 ) { /* the input file is looped: flush the decoders */ decode_flush ( ifile ) ; return AVERROR ( EAGAIN ) ; } if ( ret < 0 ) { if ( ret != AVERROR_EOF ) { print_error ( is -> url , ret ) ; if ( exit_on_error ) exit_program ( 1 ) ; } for ( i = 0 ; i < ifile -> nb_streams ; i ++ ) { ist = ifile -> streams [ i ] ; if ( ist -> processing_needed ) { ret = process_input_packet ( ist , NULL , 0 ) ; if ( ret > 0 ) return 0 ; } /* mark all outputs that don't go through lavfi as finished */ for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> ist == ist && ( ! ost -> enc_ctx || ost -> enc_ctx -> codec_type == AVMEDIA_TYPE_SUBTITLE ) ) { OutputFile * of = output_files [ ost -> file_index ] ; of_output_packet ( of , ost -> pkt , ost , 1 ) ; } } } ifile -> eof_reached = 1 ; return AVERROR ( EAGAIN ) ; } reset_eagain ( ) ; ist = ifile -> streams [ pkt -> stream_index ] ; ist -> data_size += pkt -> size ; ist -> nb_packets ++ ; if ( ist -> discard ) goto discard_packet ; /* add the stream-global side data to the first packet */ if ( ist -> nb_packets == 1 ) { for ( i = 0 ; i < ist -> st -> nb_side_data ; i ++ ) { AVPacketSideData * src_sd = & ist -> st -> side_data [ i ] ; uint8_t * dst_data ; if ( src_sd -> type == AV_PKT_DATA_DISPLAYMATRIX ) continue ; if ( av_packet_get_side_data ( pkt , src_sd -> type , NULL ) ) continue ; dst_data = av_packet_new_side_data ( pkt , src_sd -> type , src_sd -> size ) ; if ( ! dst_data ) report_and_exit ( AVERROR ( ENOMEM ) ) ; memcpy ( dst_data , src_sd -> data , src_sd -> size ) ; } } // detect and try to correct for timestamp discontinuities ts_discontinuity_process ( ifile , ist , pkt ) ; if ( debug_ts ) { av_log ( NULL , AV_LOG_INFO , \"demuxer+ffmpeg -> ist_index:%d:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s off:%s off_time:%s\\n\" , ifile -> index , pkt -> stream_index , av_get_media_type_string ( ist -> par -> codec_type ) , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & ist -> st -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & ist -> st -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & ist -> st -> time_base ) , av_ts2str ( input_files [ ist -> file_index ] -> ts_offset ) , av_ts2timestr ( input_files [ ist -> file_index ] -> ts_offset , & AV_TIME_BASE_Q ) ) ; } sub2video_heartbeat ( ist , pkt -> pts ) ; process_input_packet ( ist , pkt , 0 ) ; discard_packet : av_packet_free ( & pkt ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@transcode_from_filter": "static int transcode_from_filter ( FilterGraph * graph , InputStream * * best_ist ) { int i , ret ; int nb_requests , nb_requests_max = 0 ; InputFilter * ifilter ; InputStream * ist ; * best_ist = NULL ; ret = avfilter_graph_request_oldest ( graph -> graph ) ; if ( ret >= 0 ) return reap_filters ( 0 ) ; if ( ret == AVERROR_EOF ) { ret = reap_filters ( 1 ) ; for ( i = 0 ; i < graph -> nb_outputs ; i ++ ) close_output_stream ( graph -> outputs [ i ] -> ost ) ; return ret ; } if ( ret != AVERROR ( EAGAIN ) ) return ret ; for ( i = 0 ; i < graph -> nb_inputs ; i ++ ) { ifilter = graph -> inputs [ i ] ; ist = ifilter -> ist ; if ( input_files [ ist -> file_index ] -> eagain || input_files [ ist -> file_index ] -> eof_reached ) continue ; nb_requests = av_buffersrc_get_nb_failed_requests ( ifilter -> filter ) ; if ( nb_requests > nb_requests_max ) { nb_requests_max = nb_requests ; * best_ist = ist ; } } if ( ! * best_ist ) for ( i = 0 ; i < graph -> nb_outputs ; i ++ ) graph -> outputs [ i ] -> ost -> unavailable = 1 ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@transcode_step": "static int transcode_step ( void ) { OutputStream * ost ; InputStream * ist = NULL ; int ret ; ost = choose_output ( ) ; if ( ! ost ) { if ( got_eagain ( ) ) { reset_eagain ( ) ; av_usleep ( 10000 ) ; return 0 ; } av_log ( NULL , AV_LOG_VERBOSE , \"No more inputs to read from, finishing.\\n\" ) ; return AVERROR_EOF ; } if ( ost -> filter && ! ost -> filter -> graph -> graph ) { if ( ifilter_has_all_input_formats ( ost -> filter -> graph ) ) { ret = configure_filtergraph ( ost -> filter -> graph ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error reinitializing filters!\\n\" ) ; return ret ; } } } if ( ost -> filter && ost -> filter -> graph -> graph ) { /*\n         * Similar case to the early audio initialization in reap_filters.\n         * Audio is special in ffmpeg.c currently as we depend on lavfi's\n         * audio frame buffering/creation to get the output audio frame size\n         * in samples correct. The audio frame size for the filter chain is\n         * configured during the output stream initialization.\n         *\n         * Apparently avfilter_graph_request_oldest (called in\n         * transcode_from_filter just down the line) peeks. Peeking already\n         * puts one frame \"ready to be given out\", which means that any\n         * update in filter buffer sink configuration afterwards will not\n         * help us. And yes, even if it would be utilized,\n         * av_buffersink_get_samples is affected, as it internally utilizes\n         * the same early exit for peeked frames.\n         *\n         * In other words, if avfilter_graph_request_oldest would not make\n         * further filter chain configuration or usage of\n         * av_buffersink_get_samples useless (by just causing the return\n         * of the peeked AVFrame as-is), we could get rid of this additional\n         * early encoder initialization.\n         */ if ( av_buffersink_get_type ( ost -> filter -> filter ) == AVMEDIA_TYPE_AUDIO ) init_output_stream_wrapper ( ost , NULL , 1 ) ; if ( ( ret = transcode_from_filter ( ost -> filter -> graph , & ist ) ) < 0 ) return ret ; if ( ! ist ) return 0 ; } else if ( ost -> filter ) { int i ; for ( i = 0 ; i < ost -> filter -> graph -> nb_inputs ; i ++ ) { InputFilter * ifilter = ost -> filter -> graph -> inputs [ i ] ; if ( ! ifilter -> ist -> got_output && ! input_files [ ifilter -> ist -> file_index ] -> eof_reached ) { ist = ifilter -> ist ; break ; } } if ( ! ist ) { ost -> inputs_done = 1 ; return 0 ; } } else { ist = ost -> ist ; av_assert0 ( ist ) ; } ret = process_input ( ist -> file_index ) ; if ( ret == AVERROR ( EAGAIN ) ) { if ( input_files [ ist -> file_index ] -> eagain ) ost -> unavailable = 1 ; return 0 ; } if ( ret < 0 ) return ret == AVERROR_EOF ? 0 : ret ; return reap_filters ( 0 ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@transcode": "static int transcode ( void ) { int ret , i ; InputStream * ist ; int64_t timer_start ; int64_t total_packets_written = 0 ; ret = transcode_init ( ) ; if ( ret < 0 ) goto fail ; if ( stdin_interaction ) { av_log ( NULL , AV_LOG_INFO , \"Press [q] to stop, [?] for help\\n\" ) ; } timer_start = av_gettime_relative ( ) ; while ( ! received_sigterm && ! cancelRequested ( globalSessionId ) ) { int64_t cur_time = av_gettime_relative ( ) ; /* if 'q' pressed, exits */ if ( stdin_interaction ) if ( check_keyboard_interaction ( cur_time ) < 0 ) break ; /* check if there's any stream where output is still needed */ if ( ! need_output ( ) ) { av_log ( NULL , AV_LOG_VERBOSE , \"No more output streams to write to, finishing.\\n\" ) ; break ; } ret = transcode_step ( ) ; if ( ret < 0 && ret != AVERROR_EOF ) { av_log ( NULL , AV_LOG_ERROR , \"Error while filtering: %s\\n\" , av_err2str ( ret ) ) ; break ; } /* dump report by using the output first video and audio streams */ print_report ( 0 , timer_start , cur_time ) ; } /* at the end of stream, we must flush the decoder buffers */ for ( ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) { if ( ! input_files [ ist -> file_index ] -> eof_reached ) { process_input_packet ( ist , NULL , 0 ) ; } } flush_encoders ( ) ; term_exit ( ) ; /* write the trailer if needed */ for ( i = 0 ; i < nb_output_files ; i ++ ) { ret = of_write_trailer ( output_files [ i ] ) ; if ( ret < 0 && exit_on_error ) exit_program ( 1 ) ; } /* dump report by using the first video and audio streams */ print_report ( 1 , timer_start , av_gettime_relative ( ) ) ; /* close each encoder */ for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { uint64_t packets_written ; packets_written = atomic_load ( & ost -> packets_written ) ; total_packets_written += packets_written ; if ( ! packets_written && ( abort_on_flags & ABORT_ON_FLAG_EMPTY_OUTPUT_STREAM ) ) { av_log ( ost , AV_LOG_FATAL , \"Empty output\\n\" ) ; exit_program ( 1 ) ; } } if ( ! total_packets_written && ( abort_on_flags & ABORT_ON_FLAG_EMPTY_OUTPUT ) ) { av_log ( NULL , AV_LOG_FATAL , \"Empty output\\n\" ) ; exit_program ( 1 ) ; } hw_device_free_all ( ) ; /* finished ! */ ret = 0 ; fail : return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@get_benchmark_time_stamps": "static BenchmarkTimeStamps get_benchmark_time_stamps ( void ) { BenchmarkTimeStamps time_stamps = { av_gettime_relative ( ) } ; # if HAVE_GETRUSAGE struct rusage rusage ; getrusage ( RUSAGE_SELF , & rusage ) ; time_stamps . user_usec = ( rusage . ru_utime . tv_sec * 1000000LL ) + rusage . ru_utime . tv_usec ; time_stamps . sys_usec = ( rusage . ru_stime . tv_sec * 1000000LL ) + rusage . ru_stime . tv_usec ; # elif HAVE_GETPROCESSTIMES HANDLE proc ; FILETIME c , e , k , u ; proc = GetCurrentProcess ( ) ; GetProcessTimes ( proc , & c , & e , & k , & u ) ; time_stamps . user_usec = ( ( int64_t ) u . dwHighDateTime << 32 | u . dwLowDateTime ) / 10 ; time_stamps . sys_usec = ( ( int64_t ) k . dwHighDateTime << 32 | k . dwLowDateTime ) / 10 ; # else time_stamps . user_usec = time_stamps . sys_usec = 0 ; # endif return time_stamps ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@getmaxrss": "static int64_t getmaxrss ( void ) { # if HAVE_GETRUSAGE && HAVE_STRUCT_RUSAGE_RU_MAXRSS struct rusage rusage ; getrusage ( RUSAGE_SELF , & rusage ) ; return ( int64_t ) rusage . ru_maxrss * 1024 ; # elif HAVE_GETPROCESSMEMORYINFO HANDLE proc ; PROCESS_MEMORY_COUNTERS memcounters ; proc = GetCurrentProcess ( ) ; memcounters . cb = sizeof ( memcounters ) ; GetProcessMemoryInfo ( proc , & memcounters , sizeof ( memcounters ) ) ; return memcounters . PeakPagefileUsage ; # else return 0 ; # endif }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@ffmpeg_var_cleanup": "void ffmpeg_var_cleanup ( ) { received_sigterm = 0 ; received_nb_signals = 0 ; transcode_init_done = ATOMIC_VAR_INIT ( 0 ) ; ffmpeg_exited = 0 ; main_ffmpeg_return_code = 0 ; copy_ts_first_pts = AV_NOPTS_VALUE ; longjmp_value = 0 ; want_sdp = 1 ; enc_stats_files = NULL ; nb_enc_stats_files = 0 ; vstats_file = NULL ; nb_frames_dup = 0 ; dup_warning = 1000 ; nb_frames_drop = 0 ; decode_error_stat [ 0 ] = 0 ; decode_error_stat [ 1 ] = 0 ; nb_output_dumped = 0 ; progress_avio = NULL ; input_files = NULL ; nb_input_files = 0 ; output_files = NULL ; nb_output_files = 0 ; filtergraphs = NULL ; nb_filtergraphs = 0 ; last_time = - 1 ; keyboard_last_time = 0 ; first_report = 1 ; for ( int i = 0 ; i < FF_ARRAY_ELEMS ( qp_histogram ) ; i ++ ) { qp_histogram [ i ] = 0 ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@set_report_callback": "void set_report_callback ( void ( * callback ) ( int , float , float , int64_t , double , double , double ) ) { report_callback = callback ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@cancel_operation": "void cancel_operation ( long id ) { if ( id == 0 ) { sigterm_handler ( SIGINT ) ; } else { cancelSession ( id ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg.c@ffmpeg_execute": "int ffmpeg_execute ( int argc , char * * argv ) { char _program_name [ ] = \"ffmpeg\" ; program_name = ( char * ) & _program_name ; program_birth_year = 2000 ; # define OFFSET ( x ) offsetof ( OptionsContext , x ) OptionDef options [ ] = { /* main options */ { \"L\" , OPT_EXIT , { . func_arg = show_license } , \"show license\" } , { \"h\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"?\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"help\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"-help\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"version\" , OPT_EXIT , { . func_arg = show_version } , \"show version\" } , { \"buildconf\" , OPT_EXIT , { . func_arg = show_buildconf } , \"show build configuration\" } , { \"formats\" , OPT_EXIT , { . func_arg = show_formats } , \"show available formats\" } , { \"muxers\" , OPT_EXIT , { . func_arg = show_muxers } , \"show available muxers\" } , { \"demuxers\" , OPT_EXIT , { . func_arg = show_demuxers } , \"show available demuxers\" } , { \"devices\" , OPT_EXIT , { . func_arg = show_devices } , \"show available devices\" } , { \"codecs\" , OPT_EXIT , { . func_arg = show_codecs } , \"show available codecs\" } , { \"decoders\" , OPT_EXIT , { . func_arg = show_decoders } , \"show available decoders\" } , { \"encoders\" , OPT_EXIT , { . func_arg = show_encoders } , \"show available encoders\" } , { \"bsfs\" , OPT_EXIT , { . func_arg = show_bsfs } , \"show available bit stream filters\" } , { \"protocols\" , OPT_EXIT , { . func_arg = show_protocols } , \"show available protocols\" } , { \"filters\" , OPT_EXIT , { . func_arg = show_filters } , \"show available filters\" } , { \"pix_fmts\" , OPT_EXIT , { . func_arg = show_pix_fmts } , \"show available pixel formats\" } , { \"layouts\" , OPT_EXIT , { . func_arg = show_layouts } , \"show standard channel layouts\" } , { \"sample_fmts\" , OPT_EXIT , { . func_arg = show_sample_fmts } , \"show available audio sample formats\" } , { \"dispositions\" , OPT_EXIT , { . func_arg = show_dispositions } , \"show available stream dispositions\" } , { \"colors\" , OPT_EXIT , { . func_arg = show_colors } , \"show available color names\" } , { \"loglevel\" , HAS_ARG , { . func_arg = opt_loglevel } , \"set logging level\" , \"loglevel\" } , { \"v\" , HAS_ARG , { . func_arg = opt_loglevel } , \"set logging level\" , \"loglevel\" } , { \"report\" , 0 , { . func_arg = opt_report } , \"generate a report\" } , { \"max_alloc\" , HAS_ARG , { . func_arg = opt_max_alloc } , \"set maximum size of a single allocated block\" , \"bytes\" } , { \"cpuflags\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_cpuflags } , \"force specific cpu flags\" , \"flags\" } , { \"cpucount\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_cpucount } , \"force specific cpu count\" , \"count\" } , { \"hide_banner\" , OPT_BOOL | OPT_EXPERT , { & hide_banner } , \"do not show program banner\" , \"hide_banner\" } , # if CONFIG_AVDEVICE { \"sources\" , OPT_EXIT | HAS_ARG , { . func_arg = show_sources } , \"list sources of the input device\" , \"device\" } , { \"sinks\" , OPT_EXIT | HAS_ARG , { . func_arg = show_sinks } , \"list sinks of the output device\" , \"device\" } , # endif { \"f\" , HAS_ARG | OPT_STRING | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( format ) } , \"force format\" , \"fmt\" } , { \"y\" , OPT_BOOL , { & file_overwrite } , \"overwrite output files\" } , { \"n\" , OPT_BOOL , { & no_file_overwrite } , \"never overwrite output files\" } , { \"ignore_unknown\" , OPT_BOOL , { & ignore_unknown_streams } , \"Ignore unknown stream types\" } , { \"copy_unknown\" , OPT_BOOL | OPT_EXPERT , { & copy_unknown_streams } , \"Copy unknown stream types\" } , { \"recast_media\" , OPT_BOOL | OPT_EXPERT , { & recast_media } , \"allow recasting stream type in order to force a decoder of different media type\" } , { \"c\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( codec_names ) } , \"codec name\" , \"codec\" } , { \"codec\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( codec_names ) } , \"codec name\" , \"codec\" } , { \"pre\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( presets ) } , \"preset name\" , \"preset\" } , { \"map\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_map } , \"set input stream mapping\" , \"[-]input_file_id[:stream_specifier][,sync_file_id[:stream_specifier]]\" } , # if FFMPEG_OPT_MAP_CHANNEL { \"map_channel\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_map_channel } , \"map an audio channel from one stream to another (deprecated)\" , \"file.stream.channel[:syncfile.syncstream]\" } , # endif { \"map_metadata\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( metadata_map ) } , \"set metadata information of outfile from infile\" , \"outfile[,metadata]:infile[,metadata]\" } , { \"map_chapters\" , HAS_ARG | OPT_INT | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( chapters_input_file ) } , \"set chapters mapping\" , \"input_file_index\" } , { \"t\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( recording_time ) } , \"record or transcode \\\"duration\\\" seconds of audio/video\" , \"duration\" } , { \"to\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( stop_time ) } , \"record or transcode stop time\" , \"time_stop\" } , { \"fs\" , HAS_ARG | OPT_INT64 | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( limit_filesize ) } , \"set the limit file size in bytes\" , \"limit_size\" } , { \"ss\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( start_time ) } , \"set the start time offset\" , \"time_off\" } , { \"sseof\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_INPUT , { . off = OFFSET ( start_time_eof ) } , \"set the start time offset relative to EOF\" , \"time_off\" } , { \"seek_timestamp\" , HAS_ARG | OPT_INT | OPT_OFFSET | OPT_INPUT , { . off = OFFSET ( seek_timestamp ) } , \"enable/disable seeking by timestamp with -ss\" } , { \"accurate_seek\" , OPT_BOOL | OPT_OFFSET | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( accurate_seek ) } , \"enable/disable accurate seeking with -ss\" } , { \"isync\" , HAS_ARG | OPT_INT | OPT_OFFSET | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( input_sync_ref ) } , \"Indicate the input index for sync reference\" , \"sync ref\" } , { \"itsoffset\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( input_ts_offset ) } , \"set the input ts offset\" , \"time_off\" } , { \"itsscale\" , HAS_ARG | OPT_DOUBLE | OPT_SPEC | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( ts_scale ) } , \"set the input ts scale\" , \"scale\" } , { \"timestamp\" , HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_recording_timestamp } , \"set the recording timestamp ('now' to set the current time)\" , \"time\" } , { \"metadata\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( metadata ) } , \"add metadata\" , \"string=string\" } , { \"program\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( program ) } , \"add program with specified streams\" , \"title=string:st=number...\" } , { \"dframes\" , HAS_ARG | OPT_PERFILE | OPT_EXPERT | OPT_OUTPUT , { . func_arg = opt_data_frames } , \"set the number of data frames to output\" , \"number\" } , { \"benchmark\" , OPT_BOOL | OPT_EXPERT , { & do_benchmark } , \"add timings for benchmarking\" } , { \"benchmark_all\" , OPT_BOOL | OPT_EXPERT , { & do_benchmark_all } , \"add timings for each task\" } , { \"progress\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_progress } , \"write program-readable progress information\" , \"url\" } , { \"stdin\" , OPT_BOOL | OPT_EXPERT , { & stdin_interaction } , \"enable or disable interaction on standard input\" } , { \"timelimit\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_timelimit } , \"set max runtime in seconds in CPU user time\" , \"limit\" } , { \"dump\" , OPT_BOOL | OPT_EXPERT , { & do_pkt_dump } , \"dump each input packet\" } , { \"hex\" , OPT_BOOL | OPT_EXPERT , { & do_hex_dump } , \"when dumping packets, also dump the payload\" } , { \"re\" , OPT_BOOL | OPT_EXPERT | OPT_OFFSET | OPT_INPUT , { . off = OFFSET ( rate_emu ) } , \"read input at native frame rate; equivalent to -readrate 1\" , \"\" } , { \"readrate\" , HAS_ARG | OPT_FLOAT | OPT_OFFSET | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( readrate ) } , \"read input at specified rate\" , \"speed\" } , { \"target\" , HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_target } , \"specify target file type (\\\"vcd\\\", \\\"svcd\\\", \\\"dvd\\\", \\\"dv\\\" or \\\"dv50\\\" \" \"with optional prefixes \\\"pal-\\\", \\\"ntsc-\\\" or \\\"film-\\\")\" , \"type\" } , { \"vsync\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_vsync } , \"set video sync method globally; deprecated, use -fps_mode\" , \"\" } , { \"frame_drop_threshold\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT , { & frame_drop_threshold } , \"frame drop threshold\" , \"\" } , { \"adrift_threshold\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT , { & audio_drift_threshold } , \"audio drift threshold\" , \"threshold\" } , { \"copyts\" , OPT_BOOL | OPT_EXPERT , { & copy_ts } , \"copy timestamps\" } , { \"start_at_zero\" , OPT_BOOL | OPT_EXPERT , { & start_at_zero } , \"shift input timestamps to start at 0 when using copyts\" } , { \"copytb\" , HAS_ARG | OPT_INT | OPT_EXPERT , { & copy_tb } , \"copy input stream time base when stream copying\" , \"mode\" } , { \"shortest\" , OPT_BOOL | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( shortest ) } , \"finish encoding within shortest input\" } , { \"shortest_buf_duration\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( shortest_buf_duration ) } , \"maximum buffering duration (in seconds) for the -shortest option\" } , { \"bitexact\" , OPT_BOOL | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT | OPT_INPUT , { . off = OFFSET ( bitexact ) } , \"bitexact mode\" } , { \"apad\" , OPT_STRING | HAS_ARG | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( apad ) } , \"audio pad\" , \"\" } , { \"dts_delta_threshold\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT , { & dts_delta_threshold } , \"timestamp discontinuity delta threshold\" , \"threshold\" } , { \"dts_error_threshold\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT , { & dts_error_threshold } , \"timestamp error delta threshold\" , \"threshold\" } , { \"xerror\" , OPT_BOOL | OPT_EXPERT , { & exit_on_error } , \"exit on error\" , \"error\" } , { \"abort_on\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_abort_on } , \"abort on the specified condition flags\" , \"flags\" } , { \"copyinkf\" , OPT_BOOL | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( copy_initial_nonkeyframes ) } , \"copy initial non-keyframes\" } , { \"copypriorss\" , OPT_INT | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( copy_prior_start ) } , \"copy or discard frames before start time\" } , { \"frames\" , OPT_INT64 | HAS_ARG | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( max_frames ) } , \"set the number of frames to output\" , \"number\" } , { \"tag\" , OPT_STRING | HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_INPUT , { . off = OFFSET ( codec_tags ) } , \"force codec tag/fourcc\" , \"fourcc/tag\" } , { \"q\" , HAS_ARG | OPT_EXPERT | OPT_DOUBLE | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( qscale ) } , \"use fixed quality scale (VBR)\" , \"q\" } , { \"qscale\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_qscale } , \"use fixed quality scale (VBR)\" , \"q\" } , { \"profile\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_profile } , \"set profile\" , \"profile\" } , { \"filter\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( filters ) } , \"set stream filtergraph\" , \"filter_graph\" } , { \"filter_threads\" , HAS_ARG , { . func_arg = opt_filter_threads } , \"number of non-complex filter threads\" } , { \"filter_script\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( filter_scripts ) } , \"read stream filtergraph description from a file\" , \"filename\" } , { \"reinit_filter\" , HAS_ARG | OPT_INT | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( reinit_filters ) } , \"reinit filtergraph on input parameter changes\" , \"\" } , { \"filter_complex\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_filter_complex } , \"create a complex filtergraph\" , \"graph_description\" } , { \"filter_complex_threads\" , HAS_ARG | OPT_INT , { & filter_complex_nbthreads } , \"number of threads for -filter_complex\" } , { \"lavfi\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_filter_complex } , \"create a complex filtergraph\" , \"graph_description\" } , { \"filter_complex_script\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_filter_complex_script } , \"read complex filtergraph description from a file\" , \"filename\" } , { \"auto_conversion_filters\" , OPT_BOOL | OPT_EXPERT , { & auto_conversion_filters } , \"enable automatic conversion filters globally\" } , { \"stats\" , OPT_BOOL , { & print_stats } , \"print progress report during encoding\" , } , { \"stats_period\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_stats_period } , \"set the period at which ffmpeg updates stats and -progress output\" , \"time\" } , { \"attach\" , HAS_ARG | OPT_PERFILE | OPT_EXPERT | OPT_OUTPUT , { . func_arg = opt_attach } , \"add an attachment to the output file\" , \"filename\" } , { \"dump_attachment\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( dump_attachment ) } , \"extract an attachment into a file\" , \"filename\" } , { \"stream_loop\" , OPT_INT | HAS_ARG | OPT_EXPERT | OPT_INPUT | OPT_OFFSET , { . off = OFFSET ( loop ) } , \"set number of times input stream shall be looped\" , \"loop count\" } , { \"debug_ts\" , OPT_BOOL | OPT_EXPERT , { & debug_ts } , \"print timestamp debugging info\" } , { \"max_error_rate\" , HAS_ARG | OPT_FLOAT , { & max_error_rate } , \"ratio of decoding errors (0.0: no errors, 1.0: 100% errors) above which ffmpeg returns an error instead of success.\" , \"maximum error rate\" } , { \"discard\" , OPT_STRING | HAS_ARG | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( discard ) } , \"discard\" , \"\" } , { \"disposition\" , OPT_STRING | HAS_ARG | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( disposition ) } , \"disposition\" , \"\" } , { \"thread_queue_size\" , HAS_ARG | OPT_INT | OPT_OFFSET | OPT_EXPERT | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( thread_queue_size ) } , \"set the maximum number of queued packets from the demuxer\" } , { \"find_stream_info\" , OPT_BOOL | OPT_INPUT | OPT_EXPERT | OPT_OFFSET , { . off = OFFSET ( find_stream_info ) } , \"read and decode the streams to fill missing information with heuristics\" } , { \"bits_per_raw_sample\" , OPT_INT | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( bits_per_raw_sample ) } , \"set the number of bits per raw sample\" , \"number\" } , { \"stats_enc_pre\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( enc_stats_pre ) } , \"write encoding stats before encoding\" } , { \"stats_enc_post\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( enc_stats_post ) } , \"write encoding stats after encoding\" } , { \"stats_mux_pre\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( mux_stats ) } , \"write packets stats before muxing\" } , { \"stats_enc_pre_fmt\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( enc_stats_pre_fmt ) } , \"format of the stats written with -stats_enc_pre\" } , { \"stats_enc_post_fmt\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( enc_stats_post_fmt ) } , \"format of the stats written with -stats_enc_post\" } , { \"stats_mux_pre_fmt\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( mux_stats_fmt ) } , \"format of the stats written with -stats_mux_pre\" } , /* video options */ { \"vframes\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_video_frames } , \"set the number of video frames to output\" , \"number\" } , { \"r\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( frame_rates ) } , \"set frame rate (Hz value, fraction or abbreviation)\" , \"rate\" } , { \"fpsmax\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( max_frame_rates ) } , \"set max frame rate (Hz value, fraction or abbreviation)\" , \"rate\" } , { \"s\" , OPT_VIDEO | HAS_ARG | OPT_SUBTITLE | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( frame_sizes ) } , \"set frame size (WxH or abbreviation)\" , \"size\" } , { \"aspect\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( frame_aspect_ratios ) } , \"set aspect ratio (4:3, 16:9 or 1.3333, 1.7777)\" , \"aspect\" } , { \"pix_fmt\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( frame_pix_fmts ) } , \"set pixel format\" , \"format\" } , { \"display_rotation\" , OPT_VIDEO | HAS_ARG | OPT_DOUBLE | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( display_rotations ) } , \"set pure counter-clockwise rotation in degrees for stream(s)\" , \"angle\" } , { \"display_hflip\" , OPT_VIDEO | OPT_BOOL | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( display_hflips ) } , \"set display horizontal flip for stream(s) \" \"(overrides any display rotation if it is not set)\" } , { \"display_vflip\" , OPT_VIDEO | OPT_BOOL | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( display_vflips ) } , \"set display vertical flip for stream(s) \" \"(overrides any display rotation if it is not set)\" } , { \"vn\" , OPT_VIDEO | OPT_BOOL | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( video_disable ) } , \"disable video\" } , { \"rc_override\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( rc_overrides ) } , \"rate control override for specific intervals\" , \"override\" } , { \"vcodec\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_video_codec } , \"force video codec ('copy' to copy stream)\" , \"codec\" } , { \"timecode\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_timecode } , \"set initial TimeCode value.\" , \"hh:mm:ss[:;.]ff\" } , { \"pass\" , OPT_VIDEO | HAS_ARG | OPT_SPEC | OPT_INT | OPT_OUTPUT , { . off = OFFSET ( pass ) } , \"select the pass number (1 to 3)\" , \"n\" } , { \"passlogfile\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( passlogfiles ) } , \"select two pass log file name prefix\" , \"prefix\" } , # if FFMPEG_OPT_PSNR { \"psnr\" , OPT_VIDEO | OPT_BOOL | OPT_EXPERT , { & do_psnr } , \"calculate PSNR of compressed frames (deprecated, use -flags +psnr)\" } , # endif { \"vstats\" , OPT_VIDEO | OPT_EXPERT , { . func_arg = opt_vstats } , \"dump video coding statistics to file\" } , { \"vstats_file\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT , { . func_arg = opt_vstats_file } , \"dump video coding statistics to file\" , \"file\" } , { \"vstats_version\" , OPT_VIDEO | OPT_INT | HAS_ARG | OPT_EXPERT , { & vstats_version } , \"Version of the vstats format to use.\" } , { \"vf\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_video_filters } , \"set video filters\" , \"filter_graph\" } , { \"intra_matrix\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( intra_matrices ) } , \"specify intra matrix coeffs\" , \"matrix\" } , { \"inter_matrix\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( inter_matrices ) } , \"specify inter matrix coeffs\" , \"matrix\" } , { \"chroma_intra_matrix\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( chroma_intra_matrices ) } , \"specify intra matrix coeffs\" , \"matrix\" } , { \"top\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_INT | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( top_field_first ) } , \"top=1/bottom=0/auto=-1 field first\" , \"\" } , { \"vtag\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_old2new } , \"force video tag/fourcc\" , \"fourcc/tag\" } , { \"qphist\" , OPT_VIDEO | OPT_BOOL | OPT_EXPERT , { & qp_hist } , \"show QP histogram\" } , { \"fps_mode\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( fps_mode ) } , \"set framerate mode for matching video streams; overrides vsync\" } , { \"force_fps\" , OPT_VIDEO | OPT_BOOL | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( force_fps ) } , \"force the selected framerate, disable the best supported framerate selection\" } , { \"streamid\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_streamid } , \"set the value of an outfile streamid\" , \"streamIndex:value\" } , { \"force_key_frames\" , OPT_VIDEO | OPT_STRING | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( forced_key_frames ) } , \"force key frames at specified timestamps\" , \"timestamps\" } , { \"b\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_bitrate } , \"video bitrate (please use -b:v)\" , \"bitrate\" } , { \"hwaccel\" , OPT_VIDEO | OPT_STRING | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( hwaccels ) } , \"use HW accelerated decoding\" , \"hwaccel name\" } , { \"hwaccel_device\" , OPT_VIDEO | OPT_STRING | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( hwaccel_devices ) } , \"select a device for HW acceleration\" , \"devicename\" } , { \"hwaccel_output_format\" , OPT_VIDEO | OPT_STRING | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( hwaccel_output_formats ) } , \"select output format used with HW accelerated decoding\" , \"format\" } , { \"hwaccels\" , OPT_EXIT , { . func_arg = show_hwaccels } , \"show available HW acceleration methods\" } , { \"autorotate\" , HAS_ARG | OPT_BOOL | OPT_SPEC | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( autorotate ) } , \"automatically insert correct rotate filters\" } , { \"autoscale\" , HAS_ARG | OPT_BOOL | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT , { . off = OFFSET ( autoscale ) } , \"automatically insert a scale filter at the end of the filter graph\" } , { \"fix_sub_duration_heartbeat\" , OPT_VIDEO | OPT_BOOL | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( fix_sub_duration_heartbeat ) } , \"set this video output stream to be a heartbeat stream for \" \"fix_sub_duration, according to which subtitles should be split at \" \"random access points\" } , /* audio options */ { \"aframes\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_audio_frames } , \"set the number of audio frames to output\" , \"number\" } , { \"aq\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_audio_qscale } , \"set audio quality (codec-specific)\" , \"quality\" , } , { \"ar\" , OPT_AUDIO | HAS_ARG | OPT_INT | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_sample_rate ) } , \"set audio sampling rate (in Hz)\" , \"rate\" } , { \"ac\" , OPT_AUDIO | HAS_ARG | OPT_INT | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_channels ) } , \"set number of audio channels\" , \"channels\" } , { \"an\" , OPT_AUDIO | OPT_BOOL | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_disable ) } , \"disable audio\" } , { \"acodec\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_audio_codec } , \"force audio codec ('copy' to copy stream)\" , \"codec\" } , { \"ab\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_bitrate } , \"audio bitrate (please use -b:a)\" , \"bitrate\" } , { \"atag\" , OPT_AUDIO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_old2new } , \"force audio tag/fourcc\" , \"fourcc/tag\" } , { \"sample_fmt\" , OPT_AUDIO | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_STRING | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( sample_fmts ) } , \"set sample format\" , \"format\" } , { \"channel_layout\" , OPT_AUDIO | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_STRING | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_ch_layouts ) } , \"set channel layout\" , \"layout\" } , { \"ch_layout\" , OPT_AUDIO | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_STRING | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_ch_layouts ) } , \"set channel layout\" , \"layout\" } , { \"af\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_audio_filters } , \"set audio filters\" , \"filter_graph\" } , { \"guess_layout_max\" , OPT_AUDIO | HAS_ARG | OPT_INT | OPT_SPEC | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( guess_layout_max ) } , \"set the maximum number of channels to try to guess the channel layout\" } , /* subtitle options */ { \"sn\" , OPT_SUBTITLE | OPT_BOOL | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( subtitle_disable ) } , \"disable subtitle\" } , { \"scodec\" , OPT_SUBTITLE | HAS_ARG | OPT_PERFILE | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_subtitle_codec } , \"force subtitle codec ('copy' to copy stream)\" , \"codec\" } , { \"stag\" , OPT_SUBTITLE | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_old2new } , \"force subtitle tag/fourcc\" , \"fourcc/tag\" } , { \"fix_sub_duration\" , OPT_BOOL | OPT_EXPERT | OPT_SUBTITLE | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( fix_sub_duration ) } , \"fix subtitles duration\" } , { \"canvas_size\" , OPT_SUBTITLE | HAS_ARG | OPT_STRING | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( canvas_sizes ) } , \"set canvas size (WxH or abbreviation)\" , \"size\" } , /* muxer options */ { \"muxdelay\" , OPT_FLOAT | HAS_ARG | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( mux_max_delay ) } , \"set the maximum demux-decode delay\" , \"seconds\" } , { \"muxpreload\" , OPT_FLOAT | HAS_ARG | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( mux_preload ) } , \"set the initial demux-decode delay\" , \"seconds\" } , { \"sdp_file\" , HAS_ARG | OPT_EXPERT | OPT_OUTPUT , { . func_arg = opt_sdp_file } , \"specify a file in which to print sdp information\" , \"file\" } , { \"time_base\" , HAS_ARG | OPT_STRING | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( time_bases ) } , \"set the desired time base hint for output stream (1:24, 1:48000 or 0.04166, 2.0833e-5)\" , \"ratio\" } , { \"enc_time_base\" , HAS_ARG | OPT_STRING | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( enc_time_bases ) } , \"set the desired time base for the encoder (1:24, 1:48000 or 0.04166, 2.0833e-5). \" \"two special values are defined - \" \"0 = use frame rate (video) or sample rate (audio),\" \"-1 = match source time base\" , \"ratio\" } , { \"bsf\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT , { . off = OFFSET ( bitstream_filters ) } , \"A comma-separated list of bitstream filters\" , \"bitstream_filters\" } , { \"absf\" , HAS_ARG | OPT_AUDIO | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_old2new } , \"deprecated\" , \"audio bitstream_filters\" } , { \"vbsf\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_old2new } , \"deprecated\" , \"video bitstream_filters\" } , { \"apre\" , HAS_ARG | OPT_AUDIO | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_preset } , \"set the audio options to the indicated preset\" , \"preset\" } , { \"vpre\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_preset } , \"set the video options to the indicated preset\" , \"preset\" } , { \"spre\" , HAS_ARG | OPT_SUBTITLE | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_preset } , \"set the subtitle options to the indicated preset\" , \"preset\" } , { \"fpre\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_preset } , \"set options from indicated preset file\" , \"filename\" } , { \"max_muxing_queue_size\" , HAS_ARG | OPT_INT | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT , { . off = OFFSET ( max_muxing_queue_size ) } , \"maximum number of packets that can be buffered while waiting for all streams to initialize\" , \"packets\" } , { \"muxing_queue_data_threshold\" , HAS_ARG | OPT_INT | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT , { . off = OFFSET ( muxing_queue_data_threshold ) } , \"set the threshold after which max_muxing_queue_size is taken into account\" , \"bytes\" } , /* data codec support */ { \"dcodec\" , HAS_ARG | OPT_DATA | OPT_PERFILE | OPT_EXPERT | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_data_codec } , \"force data codec ('copy' to copy stream)\" , \"codec\" } , { \"dn\" , OPT_BOOL | OPT_VIDEO | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( data_disable ) } , \"disable data\" } , # if CONFIG_VAAPI { \"vaapi_device\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_vaapi_device } , \"set VAAPI hardware device (DRM path or X11 display name)\" , \"device\" } , # endif # if CONFIG_QSV { \"qsv_device\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_qsv_device } , \"set QSV hardware device (DirectX adapter index, DRM path or X11 display name)\" , \"device\" } , # endif { \"init_hw_device\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_init_hw_device } , \"initialise hardware device\" , \"args\" } , { \"filter_hw_device\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_filter_hw_device } , \"set hardware device used when filtering\" , \"device\" } , { NULL , } , } ; ffmpeg_options = options ; int ret ; BenchmarkTimeStamps ti ; int savedCode = setjmp ( ex_buf__ ) ; if ( savedCode == 0 ) { ffmpeg_var_cleanup ( ) ; init_dynload ( ) ; register_exit ( ffmpeg_cleanup ) ; av_log_set_flags ( AV_LOG_SKIP_REPEATED ) ; parse_loglevel ( argc , argv , options ) ; # if CONFIG_AVDEVICE avdevice_register_all ( ) ; # endif avformat_network_init ( ) ; show_banner ( argc , argv , options ) ; /* parse options and open all input/output files */ ret = ffmpeg_parse_options ( argc , argv ) ; if ( ret < 0 ) exit_program ( 1 ) ; if ( nb_output_files <= 0 && nb_input_files == 0 ) { show_usage ( ) ; av_log ( NULL , AV_LOG_WARNING , \"Use -h to get full help or, even better, run 'man %s'\\n\" , program_name ) ; exit_program ( 1 ) ; } /* file converter / grab */ if ( nb_output_files <= 0 ) { av_log ( NULL , AV_LOG_FATAL , \"At least one output file must be specified\\n\" ) ; exit_program ( 1 ) ; } current_time = ti = get_benchmark_time_stamps ( ) ; if ( transcode ( ) < 0 ) exit_program ( 1 ) ; if ( do_benchmark ) { int64_t utime , stime , rtime ; current_time = get_benchmark_time_stamps ( ) ; utime = current_time . user_usec - ti . user_usec ; stime = current_time . sys_usec - ti . sys_usec ; rtime = current_time . real_usec - ti . real_usec ; av_log ( NULL , AV_LOG_INFO , \"bench: utime=%0.3fs stime=%0.3fs rtime=%0.3fs\\n\" , utime / 1000000.0 , stime / 1000000.0 , rtime / 1000000.0 ) ; } av_log ( NULL , AV_LOG_DEBUG , \"%\" PRIu64 \" frames successfully decoded, %\" PRIu64 \" decoding errors\\n\" , decode_error_stat [ 0 ] , decode_error_stat [ 1 ] ) ; if ( ( decode_error_stat [ 0 ] + decode_error_stat [ 1 ] ) * max_error_rate < decode_error_stat [ 1 ] ) exit_program ( 69 ) ; exit_program ( ( received_nb_signals || cancelRequested ( globalSessionId ) ) ? 255 : main_ffmpeg_return_code ) ; } else { main_ffmpeg_return_code = ( received_nb_signals || cancelRequested ( globalSessionId ) ) ? 255 : longjmp_value ; } return main_ffmpeg_return_code ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_hw.c@hw_device_get_by_type": "static HWDevice * hw_device_get_by_type ( enum AVHWDeviceType type ) { HWDevice * found = NULL ; int i ; for ( i = 0 ; i < nb_hw_devices ; i ++ ) { if ( hw_devices [ i ] -> type == type ) { if ( found ) return NULL ; found = hw_devices [ i ] ; } } return found ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_hw.c@hw_device_get_by_name": "HWDevice * hw_device_get_by_name ( const char * name ) { int i ; for ( i = 0 ; i < nb_hw_devices ; i ++ ) { if ( ! strcmp ( hw_devices [ i ] -> name , name ) ) return hw_devices [ i ] ; } return NULL ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_hw.c@hw_device_add": "static HWDevice * hw_device_add ( void ) { int err ; err = av_reallocp_array ( & hw_devices , nb_hw_devices + 1 , sizeof ( * hw_devices ) ) ; if ( err ) { nb_hw_devices = 0 ; return NULL ; } hw_devices [ nb_hw_devices ] = av_mallocz ( sizeof ( HWDevice ) ) ; if ( ! hw_devices [ nb_hw_devices ] ) return NULL ; return hw_devices [ nb_hw_devices ++ ] ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_hw.c@hw_device_default_name": "static char * hw_device_default_name ( enum AVHWDeviceType type ) { // Make an automatic name of the form \"type%d\".  We arbitrarily // limit at 1000 anonymous devices of the same type - there is // probably something else very wrong if you get to this limit. const char * type_name = av_hwdevice_get_type_name ( type ) ; char * name ; size_t index_pos ; int index , index_limit = 1000 ; index_pos = strlen ( type_name ) ; name = av_malloc ( index_pos + 4 ) ; if ( ! name ) return NULL ; for ( index = 0 ; index < index_limit ; index ++ ) { snprintf ( name , index_pos + 4 , \"%s%d\" , type_name , index ) ; if ( ! hw_device_get_by_name ( name ) ) break ; } if ( index >= index_limit ) { av_freep ( & name ) ; return NULL ; } return name ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_hw.c@hw_device_init_from_string": "int hw_device_init_from_string ( const char * arg , HWDevice * * dev_out ) { // \"type=name\" // \"type=name,key=value,key2=value2\" // \"type=name:device,key=value,key2=value2\" // \"type:device,key=value,key2=value2\" // -> av_hwdevice_ctx_create() // \"type=name@name\" // \"type@name\" // -> av_hwdevice_ctx_create_derived() AVDictionary * options = NULL ; const char * type_name = NULL , * name = NULL , * device = NULL ; enum AVHWDeviceType type ; HWDevice * dev , * src ; AVBufferRef * device_ref = NULL ; int err ; const char * errmsg , * p , * q ; size_t k ; k = strcspn ( arg , \":=@\" ) ; p = arg + k ; type_name = av_strndup ( arg , k ) ; if ( ! type_name ) { err = AVERROR ( ENOMEM ) ; goto fail ; } type = av_hwdevice_find_type_by_name ( type_name ) ; if ( type == AV_HWDEVICE_TYPE_NONE ) { errmsg = \"unknown device type\" ; goto invalid ; } if ( * p == '=' ) { k = strcspn ( p + 1 , \":@,\" ) ; name = av_strndup ( p + 1 , k ) ; if ( ! name ) { err = AVERROR ( ENOMEM ) ; goto fail ; } if ( hw_device_get_by_name ( name ) ) { errmsg = \"named device already exists\" ; goto invalid ; } p += 1 + k ; } else { name = hw_device_default_name ( type ) ; if ( ! name ) { err = AVERROR ( ENOMEM ) ; goto fail ; } } if ( ! * p ) { // New device with no parameters. err = av_hwdevice_ctx_create ( & device_ref , type , NULL , NULL , 0 ) ; if ( err < 0 ) goto fail ; } else if ( * p == ':' ) { // New device with some parameters. ++ p ; q = strchr ( p , ',' ) ; if ( q ) { if ( q - p > 0 ) { device = av_strndup ( p , q - p ) ; if ( ! device ) { err = AVERROR ( ENOMEM ) ; goto fail ; } } err = av_dict_parse_string ( & options , q + 1 , \"=\" , \",\" , 0 ) ; if ( err < 0 ) { errmsg = \"failed to parse options\" ; goto invalid ; } } err = av_hwdevice_ctx_create ( & device_ref , type , q ? device : p [ 0 ] ? p : NULL , options , 0 ) ; if ( err < 0 ) goto fail ; } else if ( * p == '@' ) { // Derive from existing device. src = hw_device_get_by_name ( p + 1 ) ; if ( ! src ) { errmsg = \"invalid source device name\" ; goto invalid ; } err = av_hwdevice_ctx_create_derived ( & device_ref , type , src -> device_ref , 0 ) ; if ( err < 0 ) goto fail ; } else if ( * p == ',' ) { err = av_dict_parse_string ( & options , p + 1 , \"=\" , \",\" , 0 ) ; if ( err < 0 ) { errmsg = \"failed to parse options\" ; goto invalid ; } err = av_hwdevice_ctx_create ( & device_ref , type , NULL , options , 0 ) ; if ( err < 0 ) goto fail ; } else { errmsg = \"parse error\" ; goto invalid ; } dev = hw_device_add ( ) ; if ( ! dev ) { err = AVERROR ( ENOMEM ) ; goto fail ; } dev -> name = name ; dev -> type = type ; dev -> device_ref = device_ref ; if ( dev_out ) * dev_out = dev ; name = NULL ; err = 0 ; done : av_freep ( & type_name ) ; av_freep ( & name ) ; av_freep ( & device ) ; av_dict_free ( & options ) ; return err ; invalid : av_log ( NULL , AV_LOG_ERROR , \"Invalid device specification \\\"%s\\\": %s\\n\" , arg , errmsg ) ; err = AVERROR ( EINVAL ) ; goto done ; fail : av_log ( NULL , AV_LOG_ERROR , \"Device creation failed: %d.\\n\" , err ) ; av_buffer_unref ( & device_ref ) ; goto done ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_hw.c@hw_device_init_from_type": "static int hw_device_init_from_type ( enum AVHWDeviceType type , const char * device , HWDevice * * dev_out ) { AVBufferRef * device_ref = NULL ; HWDevice * dev ; char * name ; int err ; name = hw_device_default_name ( type ) ; if ( ! name ) { err = AVERROR ( ENOMEM ) ; goto fail ; } err = av_hwdevice_ctx_create ( & device_ref , type , device , NULL , 0 ) ; if ( err < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Device creation failed: %d.\\n\" , err ) ; goto fail ; } dev = hw_device_add ( ) ; if ( ! dev ) { err = AVERROR ( ENOMEM ) ; goto fail ; } dev -> name = name ; dev -> type = type ; dev -> device_ref = device_ref ; if ( dev_out ) * dev_out = dev ; return 0 ; fail : av_freep ( & name ) ; av_buffer_unref ( & device_ref ) ; return err ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_hw.c@hw_device_free_all": "void hw_device_free_all ( void ) { int i ; for ( i = 0 ; i < nb_hw_devices ; i ++ ) { av_freep ( & hw_devices [ i ] -> name ) ; av_buffer_unref ( & hw_devices [ i ] -> device_ref ) ; av_freep ( & hw_devices [ i ] ) ; } av_freep ( & hw_devices ) ; nb_hw_devices = 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_hw.c@hw_device_match_by_codec": "static HWDevice * hw_device_match_by_codec ( const AVCodec * codec ) { const AVCodecHWConfig * config ; HWDevice * dev ; int i ; for ( i = 0 ; ; i ++ ) { config = avcodec_get_hw_config ( codec , i ) ; if ( ! config ) return NULL ; if ( ! ( config -> methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX ) ) continue ; dev = hw_device_get_by_type ( config -> device_type ) ; if ( dev ) return dev ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_hw.c@hw_device_setup_for_decode": "int hw_device_setup_for_decode ( InputStream * ist ) { const AVCodecHWConfig * config ; enum AVHWDeviceType type ; HWDevice * dev = NULL ; int err , auto_device = 0 ; if ( ist -> hwaccel_device ) { dev = hw_device_get_by_name ( ist -> hwaccel_device ) ; if ( ! dev ) { if ( ist -> hwaccel_id == HWACCEL_AUTO ) { auto_device = 1 ; } else if ( ist -> hwaccel_id == HWACCEL_GENERIC ) { type = ist -> hwaccel_device_type ; err = hw_device_init_from_type ( type , ist -> hwaccel_device , & dev ) ; } else { // This will be dealt with by API-specific initialisation // (using hwaccel_device), so nothing further needed here. return 0 ; } } else { if ( ist -> hwaccel_id == HWACCEL_AUTO ) { ist -> hwaccel_device_type = dev -> type ; } else if ( ist -> hwaccel_device_type != dev -> type ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid hwaccel device \" \"specified for decoder: device %s of type %s is not \" \"usable with hwaccel %s.\\n\" , dev -> name , av_hwdevice_get_type_name ( dev -> type ) , av_hwdevice_get_type_name ( ist -> hwaccel_device_type ) ) ; return AVERROR ( EINVAL ) ; } } } else { if ( ist -> hwaccel_id == HWACCEL_AUTO ) { auto_device = 1 ; } else if ( ist -> hwaccel_id == HWACCEL_GENERIC ) { type = ist -> hwaccel_device_type ; dev = hw_device_get_by_type ( type ) ; // When \"-qsv_device device\" is used, an internal QSV device named // as \"__qsv_device\" is created. Another QSV device is created too // if \"-init_hw_device qsv=name:device\" is used. There are 2 QSV devices // if both \"-qsv_device device\" and \"-init_hw_device qsv=name:device\" // are used, hw_device_get_by_type(AV_HWDEVICE_TYPE_QSV) returns NULL. // To keep back-compatibility with the removed ad-hoc libmfx setup code, // call hw_device_get_by_name(\"__qsv_device\") to select the internal QSV // device. if ( ! dev && type == AV_HWDEVICE_TYPE_QSV ) dev = hw_device_get_by_name ( \"__qsv_device\" ) ; if ( ! dev ) err = hw_device_init_from_type ( type , NULL , & dev ) ; } else { dev = hw_device_match_by_codec ( ist -> dec ) ; if ( ! dev ) { // No device for this codec, but not using generic hwaccel // and therefore may well not need one - ignore. return 0 ; } } } if ( auto_device ) { int i ; if ( ! avcodec_get_hw_config ( ist -> dec , 0 ) ) { // Decoder does not support any hardware devices. return 0 ; } for ( i = 0 ; ! dev ; i ++ ) { config = avcodec_get_hw_config ( ist -> dec , i ) ; if ( ! config ) break ; type = config -> device_type ; dev = hw_device_get_by_type ( type ) ; if ( dev ) { av_log ( NULL , AV_LOG_INFO , \"Using auto \" \"hwaccel type %s with existing device %s.\\n\" , av_hwdevice_get_type_name ( type ) , dev -> name ) ; } } for ( i = 0 ; ! dev ; i ++ ) { config = avcodec_get_hw_config ( ist -> dec , i ) ; if ( ! config ) break ; type = config -> device_type ; // Try to make a new device of this type. err = hw_device_init_from_type ( type , ist -> hwaccel_device , & dev ) ; if ( err < 0 ) { // Can't make a device of this type. continue ; } if ( ist -> hwaccel_device ) { av_log ( NULL , AV_LOG_INFO , \"Using auto \" \"hwaccel type %s with new device created \" \"from %s.\\n\" , av_hwdevice_get_type_name ( type ) , ist -> hwaccel_device ) ; } else { av_log ( NULL , AV_LOG_INFO , \"Using auto \" \"hwaccel type %s with new default device.\\n\" , av_hwdevice_get_type_name ( type ) ) ; } } if ( dev ) { ist -> hwaccel_device_type = type ; } else { av_log ( NULL , AV_LOG_INFO , \"Auto hwaccel \" \"disabled: no device found.\\n\" ) ; ist -> hwaccel_id = HWACCEL_NONE ; return 0 ; } } if ( ! dev ) { av_log ( NULL , AV_LOG_ERROR , \"No device available \" \"for decoder: device type %s needed for codec %s.\\n\" , av_hwdevice_get_type_name ( type ) , ist -> dec -> name ) ; return err ; } ist -> dec_ctx -> hw_device_ctx = av_buffer_ref ( dev -> device_ref ) ; if ( ! ist -> dec_ctx -> hw_device_ctx ) return AVERROR ( ENOMEM ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_hw.c@hw_device_setup_for_encode": "int hw_device_setup_for_encode ( OutputStream * ost ) { const AVCodecHWConfig * config ; HWDevice * dev = NULL ; AVBufferRef * frames_ref = NULL ; int i ; if ( ost -> filter ) { frames_ref = av_buffersink_get_hw_frames_ctx ( ost -> filter -> filter ) ; if ( frames_ref && ( ( AVHWFramesContext * ) frames_ref -> data ) -> format == ost -> enc_ctx -> pix_fmt ) { // Matching format, will try to use hw_frames_ctx. } else { frames_ref = NULL ; } } for ( i = 0 ; ; i ++ ) { config = avcodec_get_hw_config ( ost -> enc_ctx -> codec , i ) ; if ( ! config ) break ; if ( frames_ref && config -> methods & AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX && ( config -> pix_fmt == AV_PIX_FMT_NONE || config -> pix_fmt == ost -> enc_ctx -> pix_fmt ) ) { av_log ( ost -> enc_ctx , AV_LOG_VERBOSE , \"Using input \" \"frames context (format %s) with %s encoder.\\n\" , av_get_pix_fmt_name ( ost -> enc_ctx -> pix_fmt ) , ost -> enc_ctx -> codec -> name ) ; ost -> enc_ctx -> hw_frames_ctx = av_buffer_ref ( frames_ref ) ; if ( ! ost -> enc_ctx -> hw_frames_ctx ) return AVERROR ( ENOMEM ) ; return 0 ; } if ( ! dev && config -> methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX ) dev = hw_device_get_by_type ( config -> device_type ) ; } if ( dev ) { av_log ( ost -> enc_ctx , AV_LOG_VERBOSE , \"Using device %s \" \"(type %s) with %s encoder.\\n\" , dev -> name , av_hwdevice_get_type_name ( dev -> type ) , ost -> enc_ctx -> codec -> name ) ; ost -> enc_ctx -> hw_device_ctx = av_buffer_ref ( dev -> device_ref ) ; if ( ! ost -> enc_ctx -> hw_device_ctx ) return AVERROR ( ENOMEM ) ; } else { // No device required, or no device available. } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_hw.c@hwaccel_retrieve_data": "static int hwaccel_retrieve_data ( AVCodecContext * avctx , AVFrame * input ) { InputStream * ist = avctx -> opaque ; AVFrame * output = NULL ; enum AVPixelFormat output_format = ist -> hwaccel_output_format ; int err ; if ( input -> format == output_format ) { // Nothing to do. return 0 ; } output = av_frame_alloc ( ) ; if ( ! output ) return AVERROR ( ENOMEM ) ; output -> format = output_format ; err = av_hwframe_transfer_data ( output , input , 0 ) ; if ( err < 0 ) { av_log ( avctx , AV_LOG_ERROR , \"Failed to transfer data to \" \"output frame: %d.\\n\" , err ) ; goto fail ; } err = av_frame_copy_props ( output , input ) ; if ( err < 0 ) { av_frame_unref ( output ) ; goto fail ; } av_frame_unref ( input ) ; av_frame_move_ref ( input , output ) ; av_frame_free ( & output ) ; return 0 ; fail : av_frame_free ( & output ) ; return err ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_hw.c@hwaccel_decode_init": "int hwaccel_decode_init ( AVCodecContext * avctx ) { InputStream * ist = avctx -> opaque ; ist -> hwaccel_retrieve_data = & hwaccel_retrieve_data ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_hw.c@hw_device_setup_for_filter": "int hw_device_setup_for_filter ( FilterGraph * fg ) { HWDevice * dev ; int i ; // Pick the last hardware device if the user doesn't pick the device for // filters explicitly with the filter_hw_device option. if ( filter_hw_device ) dev = filter_hw_device ; else if ( nb_hw_devices > 0 ) { dev = hw_devices [ nb_hw_devices - 1 ] ; if ( nb_hw_devices > 1 ) av_log ( NULL , AV_LOG_WARNING , \"There are %d hardware devices. device \" \"%s of type %s is picked for filters by default. Set hardware \" \"device explicitly with the filter_hw_device option if device \" \"%s is not usable for filters.\\n\" , nb_hw_devices , dev -> name , av_hwdevice_get_type_name ( dev -> type ) , dev -> name ) ; } else dev = NULL ; if ( dev ) { for ( i = 0 ; i < fg -> graph -> nb_filters ; i ++ ) { fg -> graph -> filters [ i ] -> hw_device_ctx = av_buffer_ref ( dev -> device_ref ) ; if ( ! fg -> graph -> filters [ i ] -> hw_device_ctx ) return AVERROR ( ENOMEM ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@fopen_utf8": "static inline FILE * fopen_utf8 ( const char * path , const char * mode ) { return fopen ( path , mode ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@check_opt_bitexact": "static int check_opt_bitexact ( void * ctx , const AVDictionary * opts , const char * opt_name , int flag ) { const AVDictionaryEntry * e = av_dict_get ( opts , opt_name , NULL , 0 ) ; if ( e ) { const AVOption * o = av_opt_find ( ctx , opt_name , NULL , 0 , 0 ) ; int val = 0 ; if ( ! o ) return 0 ; av_opt_eval_flags ( ctx , o , e -> value , & val ) ; return ! ! ( val & flag ) ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@choose_encoder": "static int choose_encoder ( const OptionsContext * o , AVFormatContext * s , OutputStream * ost , const AVCodec * * enc ) { enum AVMediaType type = ost -> st -> codecpar -> codec_type ; char * codec_name = NULL ; * enc = NULL ; if ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO || type == AVMEDIA_TYPE_SUBTITLE ) { MATCH_PER_STREAM_OPT ( codec_names , str , codec_name , s , ost -> st ) ; if ( ! codec_name ) { ost -> st -> codecpar -> codec_id = av_guess_codec ( s -> oformat , NULL , s -> url , NULL , ost -> st -> codecpar -> codec_type ) ; * enc = avcodec_find_encoder ( ost -> st -> codecpar -> codec_id ) ; if ( ! * enc ) { av_log ( ost , AV_LOG_FATAL , \"Automatic encoder selection failed \" \"Default encoder for format %s (codec %s) is \" \"probably disabled. Please choose an encoder manually.\\n\" , s -> oformat -> name , avcodec_get_name ( ost -> st -> codecpar -> codec_id ) ) ; return AVERROR_ENCODER_NOT_FOUND ; } } else if ( strcmp ( codec_name , \"copy\" ) ) { * enc = find_codec_or_die ( ost , codec_name , ost -> st -> codecpar -> codec_type , 1 ) ; ost -> st -> codecpar -> codec_id = ( * enc ) -> id ; } } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@get_line": "static char * get_line ( AVIOContext * s , AVBPrint * bprint ) { char c ; while ( ( c = avio_r8 ( s ) ) && c != '\\n' ) av_bprint_chars ( bprint , c , 1 ) ; if ( ! av_bprint_is_complete ( bprint ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return bprint -> str ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@get_preset_file_2": "static int get_preset_file_2 ( const char * preset_name , const char * codec_name , AVIOContext * * s ) { int i , ret = - 1 ; char filename [ 1000 ] ; char * env_avconv_datadir = getenv_utf8 ( \"AVCONV_DATADIR\" ) ; char * env_home = getenv_utf8 ( \"HOME\" ) ; const char * base [ 3 ] = { env_avconv_datadir , env_home , AVCONV_DATADIR , } ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( base ) && ret < 0 ; i ++ ) { if ( ! base [ i ] ) continue ; if ( codec_name ) { snprintf ( filename , sizeof ( filename ) , \"%s%s/%s-%s.avpreset\" , base [ i ] , i != 1 ? \"\" : \"/.avconv\" , codec_name , preset_name ) ; ret = avio_open2 ( s , filename , AVIO_FLAG_READ , & int_cb , NULL ) ; } if ( ret < 0 ) { snprintf ( filename , sizeof ( filename ) , \"%s%s/%s.avpreset\" , base [ i ] , i != 1 ? \"\" : \"/.avconv\" , preset_name ) ; ret = avio_open2 ( s , filename , AVIO_FLAG_READ , & int_cb , NULL ) ; } } freeenv_utf8 ( env_home ) ; freeenv_utf8 ( env_avconv_datadir ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@enc_stats_get_file": "static int enc_stats_get_file ( AVIOContext * * io , const char * path ) { EncStatsFile * esf ; int ret ; for ( int i = 0 ; i < nb_enc_stats_files ; i ++ ) if ( ! strcmp ( path , enc_stats_files [ i ] . path ) ) { * io = enc_stats_files [ i ] . io ; return 0 ; } GROW_ARRAY ( enc_stats_files , nb_enc_stats_files ) ; esf = & enc_stats_files [ nb_enc_stats_files - 1 ] ; ret = avio_open2 ( & esf -> io , path , AVIO_FLAG_WRITE , & int_cb , NULL ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error opening stats file '%s': %s\\n\" , path , av_err2str ( ret ) ) ; return ret ; } esf -> path = av_strdup ( path ) ; if ( ! esf -> path ) return AVERROR ( ENOMEM ) ; * io = esf -> io ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@of_enc_stats_close": "void of_enc_stats_close ( void ) { for ( int i = 0 ; i < nb_enc_stats_files ; i ++ ) { av_freep ( & enc_stats_files [ i ] . path ) ; avio_closep ( & enc_stats_files [ i ] . io ) ; } av_freep ( & enc_stats_files ) ; nb_enc_stats_files = 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@unescape": "static int unescape ( char * * pdst , size_t * dst_len , const char * * pstr , char delim ) { const char * str = * pstr ; char * dst ; size_t len , idx ; * pdst = NULL ; len = strlen ( str ) ; if ( ! len ) return 0 ; dst = av_malloc ( len + 1 ) ; if ( ! dst ) return AVERROR ( ENOMEM ) ; for ( idx = 0 ; * str ; idx ++ , str ++ ) { if ( str [ 0 ] == '\\\\' && str [ 1 ] ) str ++ ; else if ( * str == delim ) break ; dst [ idx ] = * str ; } if ( ! idx ) { av_freep ( & dst ) ; return 0 ; } dst [ idx ] = 0 ; * pdst = dst ; * dst_len = idx ; * pstr = str ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@enc_stats_init": "static int enc_stats_init ( OutputStream * ost , EncStats * es , int pre , const char * path , const char * fmt_spec ) { static const struct { enum EncStatsType type ; const char * str ; int pre_only : 1 ; int post_only : 1 ; int need_input_data : 1 ; } fmt_specs [ ] = { { ENC_STATS_FILE_IDX , \"fidx\" } , { ENC_STATS_STREAM_IDX , \"sidx\" } , { ENC_STATS_FRAME_NUM , \"n\" } , { ENC_STATS_FRAME_NUM_IN , \"ni\" , 0 , 0 , 1 } , { ENC_STATS_TIMEBASE , \"tb\" } , { ENC_STATS_TIMEBASE_IN , \"tbi\" , 0 , 0 , 1 } , { ENC_STATS_PTS , \"pts\" } , { ENC_STATS_PTS_TIME , \"t\" } , { ENC_STATS_PTS_IN , \"ptsi\" , 0 , 0 , 1 } , { ENC_STATS_PTS_TIME_IN , \"ti\" , 0 , 0 , 1 } , { ENC_STATS_DTS , \"dts\" , 0 , 1 } , { ENC_STATS_DTS_TIME , \"dt\" , 0 , 1 } , { ENC_STATS_SAMPLE_NUM , \"sn\" , 1 } , { ENC_STATS_NB_SAMPLES , \"samp\" , 1 } , { ENC_STATS_PKT_SIZE , \"size\" , 0 , 1 } , { ENC_STATS_BITRATE , \"br\" , 0 , 1 } , { ENC_STATS_AVG_BITRATE , \"abr\" , 0 , 1 } , } ; const char * next = fmt_spec ; int ret ; while ( * next ) { EncStatsComponent * c ; char * val ; size_t val_len ; // get the sequence up until next opening brace ret = unescape ( & val , & val_len , & next , '{' ) ; if ( ret < 0 ) return ret ; if ( val ) { GROW_ARRAY ( es -> components , es -> nb_components ) ; c = & es -> components [ es -> nb_components - 1 ] ; c -> type = ENC_STATS_LITERAL ; c -> str = val ; c -> str_len = val_len ; } if ( ! * next ) break ; next ++ ; // get the part inside braces ret = unescape ( & val , & val_len , & next , '}' ) ; if ( ret < 0 ) return ret ; if ( ! val ) { av_log ( NULL , AV_LOG_ERROR , \"Empty formatting directive in: %s\\n\" , fmt_spec ) ; return AVERROR ( EINVAL ) ; } if ( ! * next ) { av_log ( NULL , AV_LOG_ERROR , \"Missing closing brace in: %s\\n\" , fmt_spec ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } next ++ ; GROW_ARRAY ( es -> components , es -> nb_components ) ; c = & es -> components [ es -> nb_components - 1 ] ; for ( size_t i = 0 ; i < FF_ARRAY_ELEMS ( fmt_specs ) ; i ++ ) { if ( ! strcmp ( val , fmt_specs [ i ] . str ) ) { if ( ( pre && fmt_specs [ i ] . post_only ) || ( ! pre && fmt_specs [ i ] . pre_only ) ) { av_log ( NULL , AV_LOG_ERROR , \"Format directive '%s' may only be used %s-encoding\\n\" , val , pre ? \"post\" : \"pre\" ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } c -> type = fmt_specs [ i ] . type ; if ( fmt_specs [ i ] . need_input_data ) { if ( ost -> ist ) ost -> ist -> want_frame_data = 1 ; else { av_log ( ost , AV_LOG_WARNING , \"Format directive '%s' is unavailable, because \" \"this output stream has no associated input stream\\n\" , val ) ; } } break ; } } if ( ! c -> type ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid format directive: %s\\n\" , val ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } fail : av_freep ( & val ) ; if ( ret < 0 ) return ret ; } ret = enc_stats_get_file ( & es -> io , path ) ; if ( ret < 0 ) return ret ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@output_stream_item_name": "static const char * output_stream_item_name ( void * obj ) { const MuxStream * ms = obj ; return ms -> log_name ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@mux_stream_alloc": "static MuxStream * mux_stream_alloc ( Muxer * mux , enum AVMediaType type ) { const char * type_str = av_get_media_type_string ( type ) ; MuxStream * ms = allocate_array_elem ( & mux -> of . streams , sizeof ( * ms ) , & mux -> of . nb_streams ) ; ms -> ost . file_index = mux -> of . index ; ms -> ost . index = mux -> of . nb_streams - 1 ; ms -> ost . clazz = & output_stream_class ; snprintf ( ms -> log_name , sizeof ( ms -> log_name ) , \"%cost#%d:%d\" , type_str ? * type_str : '?' , mux -> of . index , ms -> ost . index ) ; return ms ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@new_output_stream": "static OutputStream * new_output_stream ( Muxer * mux , const OptionsContext * o , enum AVMediaType type , InputStream * ist ) { AVFormatContext * oc = mux -> fc ; MuxStream * ms ; OutputStream * ost ; const AVCodec * enc ; AVStream * st = avformat_new_stream ( oc , NULL ) ; int ret = 0 ; const char * bsfs = NULL , * time_base = NULL ; char * next , * codec_tag = NULL ; double qscale = - 1 ; int i ; if ( ! st ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( oc -> nb_streams - 1 < o -> nb_streamid_map ) st -> id = o -> streamid_map [ oc -> nb_streams - 1 ] ; ms = mux_stream_alloc ( mux , type ) ; ost = & ms -> ost ; ms -> muxing_queue = av_fifo_alloc2 ( 8 , sizeof ( AVPacket * ) , 0 ) ; if ( ! ms -> muxing_queue ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ms -> last_mux_dts = AV_NOPTS_VALUE ; ost -> st = st ; ost -> ist = ist ; ost -> kf . ref_pts = AV_NOPTS_VALUE ; st -> codecpar -> codec_type = type ; ret = choose_encoder ( o , oc , ost , & enc ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Error selecting an encoder\\n\" ) ; exit_program ( 1 ) ; } if ( enc ) { ost -> enc_ctx = avcodec_alloc_context3 ( enc ) ; if ( ! ost -> enc_ctx ) report_and_exit ( AVERROR ( ENOMEM ) ) ; av_strlcat ( ms -> log_name , \"/\" , sizeof ( ms -> log_name ) ) ; av_strlcat ( ms -> log_name , enc -> name , sizeof ( ms -> log_name ) ) ; } else { av_strlcat ( ms -> log_name , \"/copy\" , sizeof ( ms -> log_name ) ) ; } ost -> filtered_frame = av_frame_alloc ( ) ; if ( ! ost -> filtered_frame ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ost -> pkt = av_packet_alloc ( ) ; if ( ! ost -> pkt ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( ost -> enc_ctx ) { AVCodecContext * enc = ost -> enc_ctx ; AVIOContext * s = NULL ; char * buf = NULL , * arg = NULL , * preset = NULL ; const char * enc_stats_pre = NULL , * enc_stats_post = NULL , * mux_stats = NULL ; ost -> encoder_opts = filter_codec_opts ( o -> g -> codec_opts , enc -> codec_id , oc , st , enc -> codec ) ; MATCH_PER_STREAM_OPT ( presets , str , preset , oc , st ) ; ost -> autoscale = 1 ; MATCH_PER_STREAM_OPT ( autoscale , i , ost -> autoscale , oc , st ) ; if ( preset && ( ! ( ret = get_preset_file_2 ( preset , enc -> codec -> name , & s ) ) ) ) { AVBPrint bprint ; av_bprint_init ( & bprint , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; do { av_bprint_clear ( & bprint ) ; buf = get_line ( s , & bprint ) ; if ( ! buf [ 0 ] || buf [ 0 ] == '#' ) continue ; if ( ! ( arg = strchr ( buf , '=' ) ) ) { av_log ( ost , AV_LOG_FATAL , \"Invalid line found in the preset file.\\n\" ) ; exit_program ( 1 ) ; } * arg ++ = 0 ; av_dict_set ( & ost -> encoder_opts , buf , arg , AV_DICT_DONT_OVERWRITE ) ; } while ( ! s -> eof_reached ) ; av_bprint_finalize ( & bprint , NULL ) ; avio_closep ( & s ) ; } if ( ret ) { av_log ( ost , AV_LOG_FATAL , \"Preset %s specified, but could not be opened.\\n\" , preset ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( enc_stats_pre , str , enc_stats_pre , oc , st ) ; if ( enc_stats_pre && ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO ) ) { const char * format = \"{fidx} {sidx} {n} {t}\" ; MATCH_PER_STREAM_OPT ( enc_stats_pre_fmt , str , format , oc , st ) ; ret = enc_stats_init ( ost , & ost -> enc_stats_pre , 1 , enc_stats_pre , format ) ; if ( ret < 0 ) exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( enc_stats_post , str , enc_stats_post , oc , st ) ; if ( enc_stats_post && ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO ) ) { const char * format = \"{fidx} {sidx} {n} {t}\" ; MATCH_PER_STREAM_OPT ( enc_stats_post_fmt , str , format , oc , st ) ; ret = enc_stats_init ( ost , & ost -> enc_stats_post , 0 , enc_stats_post , format ) ; if ( ret < 0 ) exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( mux_stats , str , mux_stats , oc , st ) ; if ( mux_stats && ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO ) ) { const char * format = \"{fidx} {sidx} {n} {t}\" ; MATCH_PER_STREAM_OPT ( mux_stats_fmt , str , format , oc , st ) ; ret = enc_stats_init ( ost , & ms -> stats , 0 , mux_stats , format ) ; if ( ret < 0 ) exit_program ( 1 ) ; } } else { ost -> encoder_opts = filter_codec_opts ( o -> g -> codec_opts , AV_CODEC_ID_NONE , oc , st , NULL ) ; } if ( o -> bitexact ) { ost -> bitexact = 1 ; } else if ( ost -> enc_ctx ) { ost -> bitexact = check_opt_bitexact ( ost -> enc_ctx , ost -> encoder_opts , \"flags\" , AV_CODEC_FLAG_BITEXACT ) ; } MATCH_PER_STREAM_OPT ( time_bases , str , time_base , oc , st ) ; if ( time_base ) { AVRational q ; if ( av_parse_ratio ( & q , time_base , INT_MAX , 0 , NULL ) < 0 || q . num <= 0 || q . den <= 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid time base: %s\\n\" , time_base ) ; exit_program ( 1 ) ; } st -> time_base = q ; } MATCH_PER_STREAM_OPT ( enc_time_bases , str , time_base , oc , st ) ; if ( time_base ) { AVRational q ; if ( av_parse_ratio ( & q , time_base , INT_MAX , 0 , NULL ) < 0 || q . den <= 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid time base: %s\\n\" , time_base ) ; exit_program ( 1 ) ; } ost -> enc_timebase = q ; } ms -> max_frames = INT64_MAX ; MATCH_PER_STREAM_OPT ( max_frames , i64 , ms -> max_frames , oc , st ) ; for ( i = 0 ; i < o -> nb_max_frames ; i ++ ) { char * p = o -> max_frames [ i ] . specifier ; if ( ! * p && type != AVMEDIA_TYPE_VIDEO ) { av_log ( ost , AV_LOG_WARNING , \"Applying unspecific -frames to non video streams, maybe you meant -vframes ?\\n\" ) ; break ; } } ost -> copy_prior_start = - 1 ; MATCH_PER_STREAM_OPT ( copy_prior_start , i , ost -> copy_prior_start , oc , st ) ; MATCH_PER_STREAM_OPT ( bitstream_filters , str , bsfs , oc , st ) ; if ( bsfs && * bsfs ) { ret = av_bsf_list_parse_str ( bsfs , & ms -> bsf_ctx ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error parsing bitstream filter sequence '%s': %s\\n\" , bsfs , av_err2str ( ret ) ) ; exit_program ( 1 ) ; } } MATCH_PER_STREAM_OPT ( codec_tags , str , codec_tag , oc , st ) ; if ( codec_tag ) { uint32_t tag = strtol ( codec_tag , & next , 0 ) ; if ( * next ) tag = AV_RL32 ( codec_tag ) ; ost -> st -> codecpar -> codec_tag = tag ; if ( ost -> enc_ctx ) ost -> enc_ctx -> codec_tag = tag ; } MATCH_PER_STREAM_OPT ( qscale , dbl , qscale , oc , st ) ; if ( ost -> enc_ctx && qscale >= 0 ) { ost -> enc_ctx -> flags |= AV_CODEC_FLAG_QSCALE ; ost -> enc_ctx -> global_quality = FF_QP2LAMBDA * qscale ; } ms -> max_muxing_queue_size = 128 ; MATCH_PER_STREAM_OPT ( max_muxing_queue_size , i , ms -> max_muxing_queue_size , oc , st ) ; ms -> muxing_queue_data_threshold = 50 * 1024 * 1024 ; MATCH_PER_STREAM_OPT ( muxing_queue_data_threshold , i , ms -> muxing_queue_data_threshold , oc , st ) ; MATCH_PER_STREAM_OPT ( bits_per_raw_sample , i , ost -> bits_per_raw_sample , oc , st ) ; MATCH_PER_STREAM_OPT ( fix_sub_duration_heartbeat , i , ost -> fix_sub_duration_heartbeat , oc , st ) ; if ( oc -> oformat -> flags & AVFMT_GLOBALHEADER && ost -> enc_ctx ) ost -> enc_ctx -> flags |= AV_CODEC_FLAG_GLOBAL_HEADER ; av_dict_copy ( & ost -> sws_dict , o -> g -> sws_dict , 0 ) ; av_dict_copy ( & ost -> swr_opts , o -> g -> swr_opts , 0 ) ; if ( ost -> enc_ctx && av_get_exact_bits_per_sample ( ost -> enc_ctx -> codec_id ) == 24 ) av_dict_set ( & ost -> swr_opts , \"output_sample_bits\" , \"24\" , 0 ) ; if ( ost -> ist ) { ost -> ist -> discard = 0 ; ost -> ist -> st -> discard = ost -> ist -> user_set_discard ; } ost -> last_mux_dts = AV_NOPTS_VALUE ; ost -> last_filter_pts = AV_NOPTS_VALUE ; MATCH_PER_STREAM_OPT ( copy_initial_nonkeyframes , i , ost -> copy_initial_nonkeyframes , oc , st ) ; return ost ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@get_ost_filters": "static char * get_ost_filters ( const OptionsContext * o , AVFormatContext * oc , OutputStream * ost ) { AVStream * st = ost -> st ; if ( ost -> filters_script && ost -> filters ) { av_log ( ost , AV_LOG_ERROR , \"Both -filter and -filter_script set\\n\" ) ; exit_program ( 1 ) ; } if ( ost -> filters_script ) return file_read ( ost -> filters_script ) ; else if ( ost -> filters ) return av_strdup ( ost -> filters ) ; return av_strdup ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ? \"null\" : \"anull\" ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@check_streamcopy_filters": "static void check_streamcopy_filters ( const OptionsContext * o , AVFormatContext * oc , OutputStream * ost , enum AVMediaType type ) { if ( ost -> filters_script || ost -> filters ) { av_log ( ost , AV_LOG_ERROR , \"%s '%s' was defined, but codec copy was selected.\\n\" \"Filtering and streamcopy cannot be used together.\\n\" , ost -> filters ? \"Filtergraph\" : \"Filtergraph script\" , ost -> filters ? ost -> filters : ost -> filters_script ) ; exit_program ( 1 ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@parse_matrix_coeffs": "static void parse_matrix_coeffs ( void * logctx , uint16_t * dest , const char * str ) { int i ; const char * p = str ; for ( i = 0 ; ; i ++ ) { dest [ i ] = atoi ( p ) ; if ( i == 63 ) break ; p = strchr ( p , ',' ) ; if ( ! p ) { av_log ( logctx , AV_LOG_FATAL , \"Syntax error in matrix \\\"%s\\\" at coeff %d\\n\" , str , i ) ; exit_program ( 1 ) ; } p ++ ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@new_video_stream": "static OutputStream * new_video_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { AVFormatContext * oc = mux -> fc ; AVStream * st ; OutputStream * ost ; char * frame_rate = NULL , * max_frame_rate = NULL , * frame_aspect_ratio = NULL ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_VIDEO , ist ) ; st = ost -> st ; MATCH_PER_STREAM_OPT ( frame_rates , str , frame_rate , oc , st ) ; if ( frame_rate && av_parse_video_rate ( & ost -> frame_rate , frame_rate ) < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid framerate value: %s\\n\" , frame_rate ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( max_frame_rates , str , max_frame_rate , oc , st ) ; if ( max_frame_rate && av_parse_video_rate ( & ost -> max_frame_rate , max_frame_rate ) < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid maximum framerate value: %s\\n\" , max_frame_rate ) ; exit_program ( 1 ) ; } if ( frame_rate && max_frame_rate ) { av_log ( ost , AV_LOG_ERROR , \"Only one of -fpsmax and -r can be set for a stream.\\n\" ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( frame_aspect_ratios , str , frame_aspect_ratio , oc , st ) ; if ( frame_aspect_ratio ) { AVRational q ; if ( av_parse_ratio ( & q , frame_aspect_ratio , 255 , 0 , NULL ) < 0 || q . num <= 0 || q . den <= 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid aspect ratio: %s\\n\" , frame_aspect_ratio ) ; exit_program ( 1 ) ; } ost -> frame_aspect_ratio = q ; } MATCH_PER_STREAM_OPT ( filter_scripts , str , ost -> filters_script , oc , st ) ; MATCH_PER_STREAM_OPT ( filters , str , ost -> filters , oc , st ) ; if ( ost -> enc_ctx ) { AVCodecContext * video_enc = ost -> enc_ctx ; const char * p = NULL , * fps_mode = NULL ; char * frame_size = NULL ; char * frame_pix_fmt = NULL ; char * intra_matrix = NULL , * inter_matrix = NULL ; char * chroma_intra_matrix = NULL ; int do_pass = 0 ; int i ; MATCH_PER_STREAM_OPT ( frame_sizes , str , frame_size , oc , st ) ; if ( frame_size && av_parse_video_size ( & video_enc -> width , & video_enc -> height , frame_size ) < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid frame size: %s.\\n\" , frame_size ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( frame_pix_fmts , str , frame_pix_fmt , oc , st ) ; if ( frame_pix_fmt && * frame_pix_fmt == '+' ) { ost -> keep_pix_fmt = 1 ; if ( ! * ++ frame_pix_fmt ) frame_pix_fmt = NULL ; } if ( frame_pix_fmt && ( video_enc -> pix_fmt = av_get_pix_fmt ( frame_pix_fmt ) ) == AV_PIX_FMT_NONE ) { av_log ( ost , AV_LOG_FATAL , \"Unknown pixel format requested: %s.\\n\" , frame_pix_fmt ) ; exit_program ( 1 ) ; } st -> sample_aspect_ratio = video_enc -> sample_aspect_ratio ; MATCH_PER_STREAM_OPT ( intra_matrices , str , intra_matrix , oc , st ) ; if ( intra_matrix ) { if ( ! ( video_enc -> intra_matrix = av_mallocz ( sizeof ( * video_enc -> intra_matrix ) * 64 ) ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; parse_matrix_coeffs ( ost , video_enc -> intra_matrix , intra_matrix ) ; } MATCH_PER_STREAM_OPT ( chroma_intra_matrices , str , chroma_intra_matrix , oc , st ) ; if ( chroma_intra_matrix ) { uint16_t * p = av_mallocz ( sizeof ( * video_enc -> chroma_intra_matrix ) * 64 ) ; if ( ! p ) report_and_exit ( AVERROR ( ENOMEM ) ) ; video_enc -> chroma_intra_matrix = p ; parse_matrix_coeffs ( ost , p , chroma_intra_matrix ) ; } MATCH_PER_STREAM_OPT ( inter_matrices , str , inter_matrix , oc , st ) ; if ( inter_matrix ) { if ( ! ( video_enc -> inter_matrix = av_mallocz ( sizeof ( * video_enc -> inter_matrix ) * 64 ) ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; parse_matrix_coeffs ( ost , video_enc -> inter_matrix , inter_matrix ) ; } MATCH_PER_STREAM_OPT ( rc_overrides , str , p , oc , st ) ; for ( i = 0 ; p ; i ++ ) { int start , end , q ; int e = sscanf ( p , \"%d,%d,%d\" , & start , & end , & q ) ; if ( e != 3 ) { av_log ( ost , AV_LOG_FATAL , \"error parsing rc_override\\n\" ) ; exit_program ( 1 ) ; } video_enc -> rc_override = av_realloc_array ( video_enc -> rc_override , i + 1 , sizeof ( RcOverride ) ) ; if ( ! video_enc -> rc_override ) { av_log ( ost , AV_LOG_FATAL , \"Could not (re)allocate memory for rc_override.\\n\" ) ; exit_program ( 1 ) ; } video_enc -> rc_override [ i ] . start_frame = start ; video_enc -> rc_override [ i ] . end_frame = end ; if ( q > 0 ) { video_enc -> rc_override [ i ] . qscale = q ; video_enc -> rc_override [ i ] . quality_factor = 1.0 ; } else { video_enc -> rc_override [ i ] . qscale = 0 ; video_enc -> rc_override [ i ] . quality_factor = - q / 100.0 ; } p = strchr ( p , '/' ) ; if ( p ) p ++ ; } video_enc -> rc_override_count = i ; # if FFMPEG_OPT_PSNR if ( do_psnr ) { av_log ( ost , AV_LOG_WARNING , \"The -psnr option is deprecated, use -flags +psnr\\n\" ) ; video_enc -> flags |= AV_CODEC_FLAG_PSNR ; } # endif /* two pass mode */ MATCH_PER_STREAM_OPT ( pass , i , do_pass , oc , st ) ; if ( do_pass ) { if ( do_pass & 1 ) { video_enc -> flags |= AV_CODEC_FLAG_PASS1 ; av_dict_set ( & ost -> encoder_opts , \"flags\" , \"+pass1\" , AV_DICT_APPEND ) ; } if ( do_pass & 2 ) { video_enc -> flags |= AV_CODEC_FLAG_PASS2 ; av_dict_set ( & ost -> encoder_opts , \"flags\" , \"+pass2\" , AV_DICT_APPEND ) ; } } MATCH_PER_STREAM_OPT ( passlogfiles , str , ost -> logfile_prefix , oc , st ) ; if ( ost -> logfile_prefix && ! ( ost -> logfile_prefix = av_strdup ( ost -> logfile_prefix ) ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( do_pass ) { int ost_idx = - 1 ; char logfilename [ 1024 ] ; FILE * f ; /* compute this stream's global index */ for ( int i = 0 ; i <= ost -> file_index ; i ++ ) ost_idx += output_files [ i ] -> nb_streams ; snprintf ( logfilename , sizeof ( logfilename ) , \"%s-%d.log\" , ost -> logfile_prefix ? ost -> logfile_prefix : DEFAULT_PASS_LOGFILENAME_PREFIX , ost_idx ) ; if ( ! strcmp ( ost -> enc_ctx -> codec -> name , \"libx264\" ) ) { av_dict_set ( & ost -> encoder_opts , \"stats\" , logfilename , AV_DICT_DONT_OVERWRITE ) ; } else { if ( video_enc -> flags & AV_CODEC_FLAG_PASS2 ) { char * logbuffer = file_read ( logfilename ) ; if ( ! logbuffer ) { av_log ( ost , AV_LOG_FATAL , \"Error reading log file '%s' for pass-2 encoding\\n\" , logfilename ) ; exit_program ( 1 ) ; } video_enc -> stats_in = logbuffer ; } if ( video_enc -> flags & AV_CODEC_FLAG_PASS1 ) { f = fopen_utf8 ( logfilename , \"wb\" ) ; if ( ! f ) { av_log ( ost , AV_LOG_FATAL , \"Cannot write log file '%s' for pass-1 encoding: %s\\n\" , logfilename , strerror ( errno ) ) ; exit_program ( 1 ) ; } ost -> logfile = f ; } } } MATCH_PER_STREAM_OPT ( force_fps , i , ost -> force_fps , oc , st ) ; ost -> top_field_first = - 1 ; MATCH_PER_STREAM_OPT ( top_field_first , i , ost -> top_field_first , oc , st ) ; ost -> vsync_method = video_sync_method ; MATCH_PER_STREAM_OPT ( fps_mode , str , fps_mode , oc , st ) ; if ( fps_mode ) parse_and_set_vsync ( fps_mode , & ost -> vsync_method , ost -> file_index , ost -> index , 0 ) ; if ( ( ost -> frame_rate . num || ost -> max_frame_rate . num ) && ! ( ost -> vsync_method == VSYNC_AUTO || ost -> vsync_method == VSYNC_CFR || ost -> vsync_method == VSYNC_VSCFR ) ) { av_log ( ost , AV_LOG_FATAL , \"One of -r/-fpsmax was specified \" \"together a non-CFR -vsync/-fps_mode. This is contradictory.\\n\" ) ; exit_program ( 1 ) ; } if ( ost -> vsync_method == VSYNC_AUTO ) { if ( ost -> frame_rate . num || ost -> max_frame_rate . num ) { ost -> vsync_method = VSYNC_CFR ; } else if ( ! strcmp ( oc -> oformat -> name , \"avi\" ) ) { ost -> vsync_method = VSYNC_VFR ; } else { ost -> vsync_method = ( oc -> oformat -> flags & AVFMT_VARIABLE_FPS ) ? ( ( oc -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ? VSYNC_PASSTHROUGH : VSYNC_VFR ) : VSYNC_CFR ; } if ( ost -> ist && ost -> vsync_method == VSYNC_CFR ) { const InputFile * ifile = input_files [ ost -> ist -> file_index ] ; if ( ifile -> nb_streams == 1 && ifile -> input_ts_offset == 0 ) ost -> vsync_method = VSYNC_VSCFR ; } if ( ost -> vsync_method == VSYNC_CFR && copy_ts ) { ost -> vsync_method = VSYNC_VSCFR ; } } ost -> is_cfr = ( ost -> vsync_method == VSYNC_CFR || ost -> vsync_method == VSYNC_VSCFR ) ; ost -> avfilter = get_ost_filters ( o , oc , ost ) ; if ( ! ost -> avfilter ) exit_program ( 1 ) ; ost -> last_frame = av_frame_alloc ( ) ; if ( ! ost -> last_frame ) report_and_exit ( AVERROR ( ENOMEM ) ) ; } else check_streamcopy_filters ( o , oc , ost , AVMEDIA_TYPE_VIDEO ) ; return ost ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@new_audio_stream": "static OutputStream * new_audio_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { AVFormatContext * oc = mux -> fc ; AVStream * st ; OutputStream * ost ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_AUDIO , ist ) ; st = ost -> st ; MATCH_PER_STREAM_OPT ( filter_scripts , str , ost -> filters_script , oc , st ) ; MATCH_PER_STREAM_OPT ( filters , str , ost -> filters , oc , st ) ; if ( ost -> enc_ctx ) { AVCodecContext * audio_enc = ost -> enc_ctx ; int channels = 0 ; char * layout = NULL ; char * sample_fmt = NULL ; MATCH_PER_STREAM_OPT ( audio_channels , i , channels , oc , st ) ; if ( channels ) { audio_enc -> ch_layout . order = AV_CHANNEL_ORDER_UNSPEC ; audio_enc -> ch_layout . nb_channels = channels ; } MATCH_PER_STREAM_OPT ( audio_ch_layouts , str , layout , oc , st ) ; if ( layout ) { if ( av_channel_layout_from_string ( & audio_enc -> ch_layout , layout ) < 0 ) { # if FF_API_OLD_CHANNEL_LAYOUT uint64_t mask ; AV_NOWARN_DEPRECATED ( { mask = av_get_channel_layout ( layout ) ; } ) if ( ! mask ) { # endif av_log ( ost , AV_LOG_FATAL , \"Unknown channel layout: %s\\n\" , layout ) ; exit_program ( 1 ) ; # if FF_API_OLD_CHANNEL_LAYOUT } av_log ( ost , AV_LOG_WARNING , \"Channel layout '%s' uses a deprecated syntax.\\n\" , layout ) ; av_channel_layout_from_mask ( & audio_enc -> ch_layout , mask ) ; # endif } } MATCH_PER_STREAM_OPT ( sample_fmts , str , sample_fmt , oc , st ) ; if ( sample_fmt && ( audio_enc -> sample_fmt = av_get_sample_fmt ( sample_fmt ) ) == AV_SAMPLE_FMT_NONE ) { av_log ( ost , AV_LOG_FATAL , \"Invalid sample format '%s'\\n\" , sample_fmt ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( audio_sample_rate , i , audio_enc -> sample_rate , oc , st ) ; MATCH_PER_STREAM_OPT ( apad , str , ost -> apad , oc , st ) ; ost -> apad = av_strdup ( ost -> apad ) ; ost -> avfilter = get_ost_filters ( o , oc , ost ) ; if ( ! ost -> avfilter ) exit_program ( 1 ) ; # if FFMPEG_OPT_MAP_CHANNEL /* check for channel mapping for this audio stream */ for ( int n = 0 ; n < o -> nb_audio_channel_maps ; n ++ ) { AudioChannelMap * map = & o -> audio_channel_maps [ n ] ; if ( ( map -> ofile_idx == - 1 || ost -> file_index == map -> ofile_idx ) && ( map -> ostream_idx == - 1 || ost -> st -> index == map -> ostream_idx ) ) { InputStream * ist ; if ( map -> channel_idx == - 1 ) { ist = NULL ; } else if ( ! ost -> ist ) { av_log ( ost , AV_LOG_FATAL , \"Cannot determine input stream for channel mapping %d.%d\\n\" , ost -> file_index , ost -> st -> index ) ; continue ; } else { ist = ost -> ist ; } if ( ! ist || ( ist -> file_index == map -> file_idx && ist -> st -> index == map -> stream_idx ) ) { if ( av_reallocp_array ( & ost -> audio_channels_map , ost -> audio_channels_mapped + 1 , sizeof ( * ost -> audio_channels_map ) ) < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ost -> audio_channels_map [ ost -> audio_channels_mapped ++ ] = map -> channel_idx ; } } } # endif } else check_streamcopy_filters ( o , oc , ost , AVMEDIA_TYPE_AUDIO ) ; return ost ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@new_data_stream": "static OutputStream * new_data_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { OutputStream * ost ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_DATA , ist ) ; if ( ost -> enc_ctx ) { av_log ( ost , AV_LOG_FATAL , \"Data stream encoding not supported yet (only streamcopy)\\n\" ) ; exit_program ( 1 ) ; } return ost ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@new_unknown_stream": "static OutputStream * new_unknown_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { OutputStream * ost ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_UNKNOWN , ist ) ; if ( ost -> enc_ctx ) { av_log ( ost , AV_LOG_FATAL , \"Unknown stream encoding not supported yet (only streamcopy)\\n\" ) ; exit_program ( 1 ) ; } return ost ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@new_attachment_stream": "static OutputStream * new_attachment_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { OutputStream * ost = new_output_stream ( mux , o , AVMEDIA_TYPE_ATTACHMENT , ist ) ; ost -> finished = 1 ; return ost ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@new_subtitle_stream": "static OutputStream * new_subtitle_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { AVStream * st ; OutputStream * ost ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_SUBTITLE , ist ) ; st = ost -> st ; if ( ost -> enc_ctx ) { AVCodecContext * subtitle_enc = ost -> enc_ctx ; char * frame_size = NULL ; MATCH_PER_STREAM_OPT ( frame_sizes , str , frame_size , mux -> fc , st ) ; if ( frame_size && av_parse_video_size ( & subtitle_enc -> width , & subtitle_enc -> height , frame_size ) < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid frame size: %s.\\n\" , frame_size ) ; exit_program ( 1 ) ; } } return ost ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@init_output_filter": "static void init_output_filter ( OutputFilter * ofilter , const OptionsContext * o , Muxer * mux ) { OutputStream * ost ; switch ( ofilter -> type ) { case AVMEDIA_TYPE_VIDEO : ost = new_video_stream ( mux , o , NULL ) ; break ; case AVMEDIA_TYPE_AUDIO : ost = new_audio_stream ( mux , o , NULL ) ; break ; default : av_log ( mux , AV_LOG_FATAL , \"Only video and audio filters are supported \" \"currently.\\n\" ) ; exit_program ( 1 ) ; } ost -> filter = ofilter ; ofilter -> ost = ost ; ofilter -> format = - 1 ; if ( ! ost -> enc_ctx ) { av_log ( ost , AV_LOG_ERROR , \"Streamcopy requested for output stream fed \" \"from a complex filtergraph. Filtering and streamcopy \" \"cannot be used together.\\n\" ) ; exit_program ( 1 ) ; } if ( ost -> avfilter && ( ost -> filters || ost -> filters_script ) ) { const char * opt = ost -> filters ? \"-vf/-af/-filter\" : \"-filter_script\" ; av_log ( ost , AV_LOG_ERROR , \"%s '%s' was specified through the %s option \" \"for output stream %d:%d, which is fed from a complex filtergraph.\\n\" \"%s and -filter_complex cannot be used together for the same stream.\\n\" , ost -> filters ? \"Filtergraph\" : \"Filtergraph script\" , ost -> filters ? ost -> filters : ost -> filters_script , opt , ost -> file_index , ost -> index , opt ) ; exit_program ( 1 ) ; } avfilter_inout_free ( & ofilter -> out_tmp ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@map_auto_video": "static void map_auto_video ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; InputStream * best_ist = NULL ; int best_score = 0 ; int qcr ; /* video: highest resolution */ if ( av_guess_codec ( oc -> oformat , NULL , oc -> url , NULL , AVMEDIA_TYPE_VIDEO ) == AV_CODEC_ID_NONE ) return ; qcr = avformat_query_codec ( oc -> oformat , oc -> oformat -> video_codec , 0 ) ; for ( int j = 0 ; j < nb_input_files ; j ++ ) { InputFile * ifile = input_files [ j ] ; InputStream * file_best_ist = NULL ; int file_best_score = 0 ; for ( int i = 0 ; i < ifile -> nb_streams ; i ++ ) { InputStream * ist = ifile -> streams [ i ] ; int score ; if ( ist -> user_set_discard == AVDISCARD_ALL || ist -> st -> codecpar -> codec_type != AVMEDIA_TYPE_VIDEO ) continue ; score = ist -> st -> codecpar -> width * ist -> st -> codecpar -> height + 100000000 * ! ! ( ist -> st -> event_flags & AVSTREAM_EVENT_FLAG_NEW_PACKETS ) + 5000000 * ! ! ( ist -> st -> disposition & AV_DISPOSITION_DEFAULT ) ; if ( ( qcr != MKTAG ( 'A' , 'P' , 'I' , 'C' ) ) && ( ist -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) ) score = 1 ; if ( score > file_best_score ) { if ( ( qcr == MKTAG ( 'A' , 'P' , 'I' , 'C' ) ) && ! ( ist -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) ) continue ; file_best_score = score ; file_best_ist = ist ; } } if ( file_best_ist ) { if ( ( qcr == MKTAG ( 'A' , 'P' , 'I' , 'C' ) ) || ! ( file_best_ist -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) ) file_best_score -= 5000000 * ! ! ( file_best_ist -> st -> disposition & AV_DISPOSITION_DEFAULT ) ; if ( file_best_score > best_score ) { best_score = file_best_score ; best_ist = file_best_ist ; } } } if ( best_ist ) new_video_stream ( mux , o , best_ist ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@map_auto_audio": "static void map_auto_audio ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; InputStream * best_ist = NULL ; int best_score = 0 ; /* audio: most channels */ if ( av_guess_codec ( oc -> oformat , NULL , oc -> url , NULL , AVMEDIA_TYPE_AUDIO ) == AV_CODEC_ID_NONE ) return ; for ( int j = 0 ; j < nb_input_files ; j ++ ) { InputFile * ifile = input_files [ j ] ; InputStream * file_best_ist = NULL ; int file_best_score = 0 ; for ( int i = 0 ; i < ifile -> nb_streams ; i ++ ) { InputStream * ist = ifile -> streams [ i ] ; int score ; if ( ist -> user_set_discard == AVDISCARD_ALL || ist -> st -> codecpar -> codec_type != AVMEDIA_TYPE_AUDIO ) continue ; score = ist -> st -> codecpar -> ch_layout . nb_channels + 100000000 * ! ! ( ist -> st -> event_flags & AVSTREAM_EVENT_FLAG_NEW_PACKETS ) + 5000000 * ! ! ( ist -> st -> disposition & AV_DISPOSITION_DEFAULT ) ; if ( score > file_best_score ) { file_best_score = score ; file_best_ist = ist ; } } if ( file_best_ist ) { file_best_score -= 5000000 * ! ! ( file_best_ist -> st -> disposition & AV_DISPOSITION_DEFAULT ) ; if ( file_best_score > best_score ) { best_score = file_best_score ; best_ist = file_best_ist ; } } } if ( best_ist ) new_audio_stream ( mux , o , best_ist ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@map_auto_subtitle": "static void map_auto_subtitle ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; char * subtitle_codec_name = NULL ; /* subtitles: pick first */ MATCH_PER_TYPE_OPT ( codec_names , str , subtitle_codec_name , oc , \"s\" ) ; if ( ! avcodec_find_encoder ( oc -> oformat -> subtitle_codec ) && ! subtitle_codec_name ) return ; for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) if ( ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { AVCodecDescriptor const * input_descriptor = avcodec_descriptor_get ( ist -> st -> codecpar -> codec_id ) ; AVCodecDescriptor const * output_descriptor = NULL ; AVCodec const * output_codec = avcodec_find_encoder ( oc -> oformat -> subtitle_codec ) ; int input_props = 0 , output_props = 0 ; if ( ist -> user_set_discard == AVDISCARD_ALL ) continue ; if ( output_codec ) output_descriptor = avcodec_descriptor_get ( output_codec -> id ) ; if ( input_descriptor ) input_props = input_descriptor -> props & ( AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB ) ; if ( output_descriptor ) output_props = output_descriptor -> props & ( AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB ) ; if ( subtitle_codec_name || input_props & output_props || // Map dvb teletext which has neither property to any output subtitle encoder ( input_descriptor && output_descriptor && ( ! input_descriptor -> props || ! output_descriptor -> props ) ) ) { new_subtitle_stream ( mux , o , ist ) ; break ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@map_auto_data": "static void map_auto_data ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; /* Data only if codec id match */ enum AVCodecID codec_id = av_guess_codec ( oc -> oformat , NULL , oc -> url , NULL , AVMEDIA_TYPE_DATA ) ; if ( codec_id == AV_CODEC_ID_NONE ) return ; for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) { if ( ist -> user_set_discard == AVDISCARD_ALL ) continue ; if ( ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA && ist -> st -> codecpar -> codec_id == codec_id ) new_data_stream ( mux , o , ist ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@map_manual": "static void map_manual ( Muxer * mux , const OptionsContext * o , const StreamMap * map ) { InputStream * ist ; if ( map -> disabled ) return ; if ( map -> linklabel ) { FilterGraph * fg ; OutputFilter * ofilter = NULL ; int j , k ; for ( j = 0 ; j < nb_filtergraphs ; j ++ ) { fg = filtergraphs [ j ] ; for ( k = 0 ; k < fg -> nb_outputs ; k ++ ) { AVFilterInOut * out = fg -> outputs [ k ] -> out_tmp ; if ( out && ! strcmp ( out -> name , map -> linklabel ) ) { ofilter = fg -> outputs [ k ] ; goto loop_end ; } } } loop_end : if ( ! ofilter ) { av_log ( mux , AV_LOG_FATAL , \"Output with label '%s' does not exist \" \"in any defined filter graph, or was already used elsewhere.\\n\" , map -> linklabel ) ; exit_program ( 1 ) ; } init_output_filter ( ofilter , o , mux ) ; } else { ist = input_files [ map -> file_index ] -> streams [ map -> stream_index ] ; if ( ist -> user_set_discard == AVDISCARD_ALL ) { av_log ( mux , AV_LOG_FATAL , \"Stream #%d:%d is disabled and cannot be mapped.\\n\" , map -> file_index , map -> stream_index ) ; exit_program ( 1 ) ; } if ( o -> subtitle_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_SUBTITLE ) return ; if ( o -> audio_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) return ; if ( o -> video_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) return ; if ( o -> data_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) return ; switch ( ist -> st -> codecpar -> codec_type ) { case AVMEDIA_TYPE_VIDEO : new_video_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_AUDIO : new_audio_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_SUBTITLE : new_subtitle_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_DATA : new_data_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_ATTACHMENT : new_attachment_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_UNKNOWN : if ( copy_unknown_streams ) { new_unknown_stream ( mux , o , ist ) ; break ; } default : av_log ( mux , ignore_unknown_streams ? AV_LOG_WARNING : AV_LOG_FATAL , \"Cannot map stream #%d:%d - unsupported type.\\n\" , map -> file_index , map -> stream_index ) ; if ( ! ignore_unknown_streams ) { av_log ( mux , AV_LOG_FATAL , \"If you want unsupported types ignored instead \" \"of failing, please use the -ignore_unknown option\\n\" \"If you want them copied, please use -copy_unknown\\n\" ) ; exit_program ( 1 ) ; } } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@of_add_attachments": "static void of_add_attachments ( Muxer * mux , const OptionsContext * o ) { OutputStream * ost ; int err ; for ( int i = 0 ; i < o -> nb_attachments ; i ++ ) { AVIOContext * pb ; uint8_t * attachment ; const char * p ; int64_t len ; if ( ( err = avio_open2 ( & pb , o -> attachments [ i ] , AVIO_FLAG_READ , & int_cb , NULL ) ) < 0 ) { av_log ( mux , AV_LOG_FATAL , \"Could not open attachment file %s.\\n\" , o -> attachments [ i ] ) ; exit_program ( 1 ) ; } if ( ( len = avio_size ( pb ) ) <= 0 ) { av_log ( mux , AV_LOG_FATAL , \"Could not get size of the attachment %s.\\n\" , o -> attachments [ i ] ) ; exit_program ( 1 ) ; } if ( len > INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE || ! ( attachment = av_malloc ( len + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { av_log ( mux , AV_LOG_FATAL , \"Attachment %s too large.\\n\" , o -> attachments [ i ] ) ; exit_program ( 1 ) ; } avio_read ( pb , attachment , len ) ; memset ( attachment + len , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; ost = new_attachment_stream ( mux , o , NULL ) ; ost -> attachment_filename = o -> attachments [ i ] ; ost -> st -> codecpar -> extradata = attachment ; ost -> st -> codecpar -> extradata_size = len ; p = strrchr ( o -> attachments [ i ] , '/' ) ; av_dict_set ( & ost -> st -> metadata , \"filename\" , ( p && * p ) ? p + 1 : o -> attachments [ i ] , AV_DICT_DONT_OVERWRITE ) ; avio_closep ( & pb ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@create_streams": "static void create_streams ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; int auto_disable_v = o -> video_disable ; int auto_disable_a = o -> audio_disable ; int auto_disable_s = o -> subtitle_disable ; int auto_disable_d = o -> data_disable ; /* create streams for all unlabeled output pads */ for ( int i = 0 ; i < nb_filtergraphs ; i ++ ) { FilterGraph * fg = filtergraphs [ i ] ; for ( int j = 0 ; j < fg -> nb_outputs ; j ++ ) { OutputFilter * ofilter = fg -> outputs [ j ] ; if ( ! ofilter -> out_tmp || ofilter -> out_tmp -> name ) continue ; switch ( ofilter -> type ) { case AVMEDIA_TYPE_VIDEO : auto_disable_v = 1 ; break ; case AVMEDIA_TYPE_AUDIO : auto_disable_a = 1 ; break ; case AVMEDIA_TYPE_SUBTITLE : auto_disable_s = 1 ; break ; } init_output_filter ( ofilter , o , mux ) ; } } if ( ! o -> nb_stream_maps ) { /* pick the \"best\" stream of each type */ if ( ! auto_disable_v ) map_auto_video ( mux , o ) ; if ( ! auto_disable_a ) map_auto_audio ( mux , o ) ; if ( ! auto_disable_s ) map_auto_subtitle ( mux , o ) ; if ( ! auto_disable_d ) map_auto_data ( mux , o ) ; } else { for ( int i = 0 ; i < o -> nb_stream_maps ; i ++ ) map_manual ( mux , o , & o -> stream_maps [ i ] ) ; } of_add_attachments ( mux , o ) ; if ( ! oc -> nb_streams && ! ( oc -> oformat -> flags & AVFMT_NOSTREAMS ) ) { av_dump_format ( oc , nb_output_files - 1 , oc -> url , 1 ) ; av_log ( mux , AV_LOG_ERROR , \"Output file does not contain any stream\\n\" ) ; exit_program ( 1 ) ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@setup_sync_queues": "static int setup_sync_queues ( Muxer * mux , AVFormatContext * oc , int64_t buf_size_us ) { OutputFile * of = & mux -> of ; int nb_av_enc = 0 , nb_interleaved = 0 ; int limit_frames = 0 , limit_frames_av_enc = 0 ; # define IS_AV_ENC ( ost , type ) ( ost -> enc_ctx && ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO ) ) # define IS_INTERLEAVED ( type ) ( type != AVMEDIA_TYPE_ATTACHMENT ) for ( int i = 0 ; i < oc -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; MuxStream * ms = ms_from_ost ( ost ) ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; ost -> sq_idx_encode = - 1 ; ost -> sq_idx_mux = - 1 ; nb_interleaved += IS_INTERLEAVED ( type ) ; nb_av_enc += IS_AV_ENC ( ost , type ) ; limit_frames |= ms -> max_frames < INT64_MAX ; limit_frames_av_enc |= ( ms -> max_frames < INT64_MAX ) && IS_AV_ENC ( ost , type ) ; } if ( ! ( ( nb_interleaved > 1 && of -> shortest ) || ( nb_interleaved > 0 && limit_frames ) ) ) return 0 ; /* if we have more than one encoded audio/video streams, or at least\n     * one encoded audio/video stream is frame-limited, then we\n     * synchronize them before encoding */ if ( ( of -> shortest && nb_av_enc > 1 ) || limit_frames_av_enc ) { of -> sq_encode = sq_alloc ( SYNC_QUEUE_FRAMES , buf_size_us ) ; if ( ! of -> sq_encode ) return AVERROR ( ENOMEM ) ; for ( int i = 0 ; i < oc -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; MuxStream * ms = ms_from_ost ( ost ) ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; if ( ! IS_AV_ENC ( ost , type ) ) continue ; ost -> sq_idx_encode = sq_add_stream ( of -> sq_encode , of -> shortest || ms -> max_frames < INT64_MAX ) ; if ( ost -> sq_idx_encode < 0 ) return ost -> sq_idx_encode ; ost -> sq_frame = av_frame_alloc ( ) ; if ( ! ost -> sq_frame ) return AVERROR ( ENOMEM ) ; if ( ms -> max_frames != INT64_MAX ) sq_limit_frames ( of -> sq_encode , ost -> sq_idx_encode , ms -> max_frames ) ; } } /* if there are any additional interleaved streams, then ALL the streams\n     * are also synchronized before sending them to the muxer */ if ( nb_interleaved > nb_av_enc ) { mux -> sq_mux = sq_alloc ( SYNC_QUEUE_PACKETS , buf_size_us ) ; if ( ! mux -> sq_mux ) return AVERROR ( ENOMEM ) ; mux -> sq_pkt = av_packet_alloc ( ) ; if ( ! mux -> sq_pkt ) return AVERROR ( ENOMEM ) ; for ( int i = 0 ; i < oc -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; MuxStream * ms = ms_from_ost ( ost ) ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; if ( ! IS_INTERLEAVED ( type ) ) continue ; ost -> sq_idx_mux = sq_add_stream ( mux -> sq_mux , of -> shortest || ms -> max_frames < INT64_MAX ) ; if ( ost -> sq_idx_mux < 0 ) return ost -> sq_idx_mux ; if ( ms -> max_frames != INT64_MAX ) sq_limit_frames ( mux -> sq_mux , ost -> sq_idx_mux , ms -> max_frames ) ; } } # undef IS_AV_ENC # undef IS_INTERLEAVED return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@of_add_programs": "static void of_add_programs ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; /* process manually set programs */ for ( int i = 0 ; i < o -> nb_program ; i ++ ) { const char * p = o -> program [ i ] . u . str ; int progid = i + 1 ; AVProgram * program ; while ( * p ) { const char * p2 = av_get_token ( & p , \":\" ) ; const char * to_dealloc = p2 ; char * key ; if ( ! p2 ) break ; if ( * p ) p ++ ; key = av_get_token ( & p2 , \"=\" ) ; if ( ! key || ! * p2 ) { av_freep ( & to_dealloc ) ; av_freep ( & key ) ; break ; } p2 ++ ; if ( ! strcmp ( key , \"program_num\" ) ) progid = strtol ( p2 , NULL , 0 ) ; av_freep ( & to_dealloc ) ; av_freep ( & key ) ; } program = av_new_program ( oc , progid ) ; if ( ! program ) report_and_exit ( AVERROR ( ENOMEM ) ) ; p = o -> program [ i ] . u . str ; while ( * p ) { const char * p2 = av_get_token ( & p , \":\" ) ; const char * to_dealloc = p2 ; char * key ; if ( ! p2 ) break ; if ( * p ) p ++ ; key = av_get_token ( & p2 , \"=\" ) ; if ( ! key ) { av_log ( mux , AV_LOG_FATAL , \"No '=' character in program string %s.\\n\" , p2 ) ; exit_program ( 1 ) ; } if ( ! * p2 ) exit_program ( 1 ) ; p2 ++ ; if ( ! strcmp ( key , \"title\" ) ) { av_dict_set ( & program -> metadata , \"title\" , p2 , 0 ) ; } else if ( ! strcmp ( key , \"program_num\" ) ) { } else if ( ! strcmp ( key , \"st\" ) ) { int st_num = strtol ( p2 , NULL , 0 ) ; av_program_add_stream_index ( oc , progid , st_num ) ; } else { av_log ( mux , AV_LOG_FATAL , \"Unknown program key %s.\\n\" , key ) ; exit_program ( 1 ) ; } av_freep ( & to_dealloc ) ; av_freep ( & key ) ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@parse_meta_type": "static void parse_meta_type ( void * logctx , const char * arg , char * type , int * index , const char * * stream_spec ) { if ( * arg ) { * type = * arg ; switch ( * arg ) { case 'g' : break ; case 's' : if ( * ( ++ arg ) && * arg != ':' ) { av_log ( logctx , AV_LOG_FATAL , \"Invalid metadata specifier %s.\\n\" , arg ) ; exit_program ( 1 ) ; } * stream_spec = * arg == ':' ? arg + 1 : \"\" ; break ; case 'c' : case 'p' : if ( * ( ++ arg ) == ':' ) * index = strtol ( ++ arg , NULL , 0 ) ; break ; default : av_log ( logctx , AV_LOG_FATAL , \"Invalid metadata type %c.\\n\" , * arg ) ; exit_program ( 1 ) ; } } else * type = 'g' ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@of_add_metadata": "static void of_add_metadata ( OutputFile * of , AVFormatContext * oc , const OptionsContext * o ) { for ( int i = 0 ; i < o -> nb_metadata ; i ++ ) { AVDictionary * * m ; char type , * val ; const char * stream_spec ; int index = 0 , ret = 0 ; val = strchr ( o -> metadata [ i ] . u . str , '=' ) ; if ( ! val ) { av_log ( of , AV_LOG_FATAL , \"No '=' character in metadata string %s.\\n\" , o -> metadata [ i ] . u . str ) ; exit_program ( 1 ) ; } * val ++ = 0 ; parse_meta_type ( of , o -> metadata [ i ] . specifier , & type , & index , & stream_spec ) ; if ( type == 's' ) { for ( int j = 0 ; j < oc -> nb_streams ; j ++ ) { OutputStream * ost = of -> streams [ j ] ; if ( ( ret = check_stream_specifier ( oc , oc -> streams [ j ] , stream_spec ) ) > 0 ) { # if FFMPEG_ROTATION_METADATA if ( ! strcmp ( o -> metadata [ i ] . u . str , \"rotate\" ) ) { char * tail ; double theta = av_strtod ( val , & tail ) ; if ( ! * tail ) { ost -> rotate_overridden = 1 ; ost -> rotate_override_value = theta ; } av_log ( ost , AV_LOG_WARNING , \"Conversion of a 'rotate' metadata key to a \" \"proper display matrix rotation is deprecated. \" \"See -display_rotation for setting rotation \" \"instead.\" ) ; } else { # endif av_dict_set ( & oc -> streams [ j ] -> metadata , o -> metadata [ i ] . u . str , * val ? val : NULL , 0 ) ; # if FFMPEG_ROTATION_METADATA } # endif } else if ( ret < 0 ) exit_program ( 1 ) ; } } else { switch ( type ) { case 'g' : m = & oc -> metadata ; break ; case 'c' : if ( index < 0 || index >= oc -> nb_chapters ) { av_log ( of , AV_LOG_FATAL , \"Invalid chapter index %d in metadata specifier.\\n\" , index ) ; exit_program ( 1 ) ; } m = & oc -> chapters [ index ] -> metadata ; break ; case 'p' : if ( index < 0 || index >= oc -> nb_programs ) { av_log ( of , AV_LOG_FATAL , \"Invalid program index %d in metadata specifier.\\n\" , index ) ; exit_program ( 1 ) ; } m = & oc -> programs [ index ] -> metadata ; break ; default : av_log ( of , AV_LOG_FATAL , \"Invalid metadata specifier %s.\\n\" , o -> metadata [ i ] . specifier ) ; exit_program ( 1 ) ; } av_dict_set ( m , o -> metadata [ i ] . u . str , * val ? val : NULL , 0 ) ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@set_channel_layout": "static void set_channel_layout ( OutputFilter * f , OutputStream * ost ) { const AVCodec * c = ost -> enc_ctx -> codec ; int i , err ; if ( ost -> enc_ctx -> ch_layout . order != AV_CHANNEL_ORDER_UNSPEC ) { /* Pass the layout through for all orders but UNSPEC */ err = av_channel_layout_copy ( & f -> ch_layout , & ost -> enc_ctx -> ch_layout ) ; if ( err < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return ; } /* Requested layout is of order UNSPEC */ if ( ! c -> ch_layouts ) { /* Use the default native layout for the requested amount of channels when the\n           encoder doesn't have a list of supported layouts */ av_channel_layout_default ( & f -> ch_layout , ost -> enc_ctx -> ch_layout . nb_channels ) ; return ; } /* Encoder has a list of supported layouts. Pick the first layout in it with the\n       same amount of channels as the requested layout */ for ( i = 0 ; c -> ch_layouts [ i ] . nb_channels ; i ++ ) { if ( c -> ch_layouts [ i ] . nb_channels == ost -> enc_ctx -> ch_layout . nb_channels ) break ; } if ( c -> ch_layouts [ i ] . nb_channels ) { /* Use it if one is found */ err = av_channel_layout_copy ( & f -> ch_layout , & c -> ch_layouts [ i ] ) ; if ( err < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return ; } /* If no layout for the amount of channels requested was found, use the default\n       native layout for it. */ av_channel_layout_default ( & f -> ch_layout , ost -> enc_ctx -> ch_layout . nb_channels ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@copy_chapters": "static int copy_chapters ( InputFile * ifile , OutputFile * ofile , AVFormatContext * os , int copy_metadata ) { AVFormatContext * is = ifile -> ctx ; AVChapter * * tmp ; int i ; tmp = av_realloc_f ( os -> chapters , is -> nb_chapters + os -> nb_chapters , sizeof ( * os -> chapters ) ) ; if ( ! tmp ) return AVERROR ( ENOMEM ) ; os -> chapters = tmp ; for ( i = 0 ; i < is -> nb_chapters ; i ++ ) { AVChapter * in_ch = is -> chapters [ i ] , * out_ch ; int64_t start_time = ( ofile -> start_time == AV_NOPTS_VALUE ) ? 0 : ofile -> start_time ; int64_t ts_off = av_rescale_q ( start_time - ifile -> ts_offset , AV_TIME_BASE_Q , in_ch -> time_base ) ; int64_t rt = ( ofile -> recording_time == INT64_MAX ) ? INT64_MAX : av_rescale_q ( ofile -> recording_time , AV_TIME_BASE_Q , in_ch -> time_base ) ; if ( in_ch -> end < ts_off ) continue ; if ( rt != INT64_MAX && in_ch -> start > rt + ts_off ) break ; out_ch = av_mallocz ( sizeof ( AVChapter ) ) ; if ( ! out_ch ) return AVERROR ( ENOMEM ) ; out_ch -> id = in_ch -> id ; out_ch -> time_base = in_ch -> time_base ; out_ch -> start = FFMAX ( 0 , in_ch -> start - ts_off ) ; out_ch -> end = FFMIN ( rt , in_ch -> end - ts_off ) ; if ( copy_metadata ) av_dict_copy ( & out_ch -> metadata , in_ch -> metadata , 0 ) ; os -> chapters [ os -> nb_chapters ++ ] = out_ch ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@copy_metadata": "static int copy_metadata ( Muxer * mux , AVFormatContext * ic , const char * outspec , const char * inspec , int * metadata_global_manual , int * metadata_streams_manual , int * metadata_chapters_manual , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; AVDictionary * * meta_in = NULL ; AVDictionary * * meta_out = NULL ; int i , ret = 0 ; char type_in , type_out ; const char * istream_spec = NULL , * ostream_spec = NULL ; int idx_in = 0 , idx_out = 0 ; parse_meta_type ( mux , inspec , & type_in , & idx_in , & istream_spec ) ; parse_meta_type ( mux , outspec , & type_out , & idx_out , & ostream_spec ) ; if ( type_in == 'g' || type_out == 'g' ) * metadata_global_manual = 1 ; if ( type_in == 's' || type_out == 's' ) * metadata_streams_manual = 1 ; if ( type_in == 'c' || type_out == 'c' ) * metadata_chapters_manual = 1 ; /* ic is NULL when just disabling automatic mappings */ if ( ! ic ) return 0 ; # define METADATA_CHECK_INDEX ( index , nb_elems , desc ) if ( ( index ) < 0 || ( index ) >= ( nb_elems ) ) { av_log ( mux , AV_LOG_FATAL , \"Invalid %s index %d while processing metadata maps.\\n\" , ( desc ) , ( index ) ) ; exit_program ( 1 ) ; } # define SET_DICT ( type , meta , context , index ) switch ( type ) { case 'g' : meta = & context -> metadata ; break ; case 'c' : METADATA_CHECK_INDEX ( index , context -> nb_chapters , \"chapter\" ) meta = & context -> chapters [ index ] -> metadata ; break ; case 'p' : METADATA_CHECK_INDEX ( index , context -> nb_programs , \"program\" ) meta = & context -> programs [ index ] -> metadata ; break ; case 's' : break ; /* handled separately below */ default : av_assert0 ( 0 ) ; } SET_DICT ( type_in , meta_in , ic , idx_in ) ; SET_DICT ( type_out , meta_out , oc , idx_out ) ; /* for input streams choose first matching stream */ if ( type_in == 's' ) { for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { if ( ( ret = check_stream_specifier ( ic , ic -> streams [ i ] , istream_spec ) ) > 0 ) { meta_in = & ic -> streams [ i ] -> metadata ; break ; } else if ( ret < 0 ) exit_program ( 1 ) ; } if ( ! meta_in ) { av_log ( mux , AV_LOG_FATAL , \"Stream specifier %s does not match  any streams.\\n\" , istream_spec ) ; exit_program ( 1 ) ; } } if ( type_out == 's' ) { for ( i = 0 ; i < oc -> nb_streams ; i ++ ) { if ( ( ret = check_stream_specifier ( oc , oc -> streams [ i ] , ostream_spec ) ) > 0 ) { meta_out = & oc -> streams [ i ] -> metadata ; av_dict_copy ( meta_out , * meta_in , AV_DICT_DONT_OVERWRITE ) ; } else if ( ret < 0 ) exit_program ( 1 ) ; } } else av_dict_copy ( meta_out , * meta_in , AV_DICT_DONT_OVERWRITE ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@copy_meta": "static void copy_meta ( Muxer * mux , const OptionsContext * o ) { OutputFile * of = & mux -> of ; AVFormatContext * oc = mux -> fc ; int chapters_input_file = o -> chapters_input_file ; int metadata_global_manual = 0 ; int metadata_streams_manual = 0 ; int metadata_chapters_manual = 0 ; /* copy metadata */ for ( int i = 0 ; i < o -> nb_metadata_map ; i ++ ) { char * p ; int in_file_index = strtol ( o -> metadata_map [ i ] . u . str , & p , 0 ) ; if ( in_file_index >= nb_input_files ) { av_log ( mux , AV_LOG_FATAL , \"Invalid input file index %d while \" \"processing metadata maps\\n\" , in_file_index ) ; exit_program ( 1 ) ; } copy_metadata ( mux , in_file_index >= 0 ? input_files [ in_file_index ] -> ctx : NULL , o -> metadata_map [ i ] . specifier , * p ? p + 1 : p , & metadata_global_manual , & metadata_streams_manual , & metadata_chapters_manual , o ) ; } /* copy chapters */ if ( chapters_input_file >= nb_input_files ) { if ( chapters_input_file == INT_MAX ) { /* copy chapters from the first input file that has them*/ chapters_input_file = - 1 ; for ( int i = 0 ; i < nb_input_files ; i ++ ) if ( input_files [ i ] -> ctx -> nb_chapters ) { chapters_input_file = i ; break ; } } else { av_log ( mux , AV_LOG_FATAL , \"Invalid input file index %d in chapter mapping.\\n\" , chapters_input_file ) ; exit_program ( 1 ) ; } } if ( chapters_input_file >= 0 ) copy_chapters ( input_files [ chapters_input_file ] , of , oc , ! metadata_chapters_manual ) ; /* copy global metadata by default */ if ( ! metadata_global_manual && nb_input_files ) { av_dict_copy ( & oc -> metadata , input_files [ 0 ] -> ctx -> metadata , AV_DICT_DONT_OVERWRITE ) ; if ( of -> recording_time != INT64_MAX ) av_dict_set ( & oc -> metadata , \"duration\" , NULL , 0 ) ; av_dict_set ( & oc -> metadata , \"creation_time\" , NULL , 0 ) ; av_dict_set ( & oc -> metadata , \"company_name\" , NULL , 0 ) ; av_dict_set ( & oc -> metadata , \"product_name\" , NULL , 0 ) ; av_dict_set ( & oc -> metadata , \"product_version\" , NULL , 0 ) ; } if ( ! metadata_streams_manual ) for ( int i = 0 ; i < of -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; if ( ! ost -> ist ) /* this is true e.g. for attached files */ continue ; av_dict_copy ( & ost -> st -> metadata , ost -> ist -> st -> metadata , AV_DICT_DONT_OVERWRITE ) ; if ( ost -> enc_ctx ) { av_dict_set ( & ost -> st -> metadata , \"encoder\" , NULL , 0 ) ; } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@set_dispositions": "static int set_dispositions ( Muxer * mux , const OptionsContext * o ) { OutputFile * of = & mux -> of ; AVFormatContext * ctx = mux -> fc ; int nb_streams [ AVMEDIA_TYPE_NB ] = { 0 } ; int have_default [ AVMEDIA_TYPE_NB ] = { 0 } ; int have_manual = 0 ; int ret = 0 ; const char * * dispositions ; dispositions = av_calloc ( ctx -> nb_streams , sizeof ( * dispositions ) ) ; if ( ! dispositions ) return AVERROR ( ENOMEM ) ; // first, copy the input dispositions for ( int i = 0 ; i < ctx -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; nb_streams [ ost -> st -> codecpar -> codec_type ] ++ ; MATCH_PER_STREAM_OPT ( disposition , str , dispositions [ i ] , ctx , ost -> st ) ; have_manual |= ! ! dispositions [ i ] ; if ( ost -> ist ) { ost -> st -> disposition = ost -> ist -> st -> disposition ; if ( ost -> st -> disposition & AV_DISPOSITION_DEFAULT ) have_default [ ost -> st -> codecpar -> codec_type ] = 1 ; } } if ( have_manual ) { // process manually set dispositions - they override the above copy for ( int i = 0 ; i < ctx -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; const char * disp = dispositions [ i ] ; if ( ! disp ) continue ; ret = av_opt_set ( ost -> st , \"disposition\" , disp , 0 ) ; if ( ret < 0 ) goto finish ; } } else { // For each media type with more than one stream, find a suitable stream to // mark as default, unless one is already marked default. // \"Suitable\" means the first of that type, skipping attached pictures. for ( int i = 0 ; i < ctx -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; if ( nb_streams [ type ] < 2 || have_default [ type ] || ost -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) continue ; ost -> st -> disposition |= AV_DISPOSITION_DEFAULT ; have_default [ type ] = 1 ; } } finish : av_freep ( & dispositions ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@compare_int64": "static int compare_int64 ( const void * a , const void * b ) { return FFDIFFSIGN ( * ( const int64_t * ) a , * ( const int64_t * ) b ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@parse_forced_key_frames": "static void parse_forced_key_frames ( KeyframeForceCtx * kf , const Muxer * mux , const char * spec ) { const char * p ; int n = 1 , i , size , index = 0 ; int64_t t , * pts ; for ( p = spec ; * p ; p ++ ) if ( * p == ',' ) n ++ ; size = n ; pts = av_malloc_array ( size , sizeof ( * pts ) ) ; if ( ! pts ) report_and_exit ( AVERROR ( ENOMEM ) ) ; p = spec ; for ( i = 0 ; i < n ; i ++ ) { char * next = strchr ( p , ',' ) ; if ( next ) * next ++ = 0 ; if ( ! memcmp ( p , \"chapters\" , 8 ) ) { AVChapter * const * ch = mux -> fc -> chapters ; unsigned int nb_ch = mux -> fc -> nb_chapters ; int j ; if ( nb_ch > INT_MAX - size || ! ( pts = av_realloc_f ( pts , size += nb_ch - 1 , sizeof ( * pts ) ) ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; t = p [ 8 ] ? parse_time_or_die ( \"force_key_frames\" , p + 8 , 1 ) : 0 ; for ( j = 0 ; j < nb_ch ; j ++ ) { const AVChapter * c = ch [ j ] ; av_assert1 ( index < size ) ; pts [ index ++ ] = av_rescale_q ( c -> start , c -> time_base , AV_TIME_BASE_Q ) + t ; } } else { av_assert1 ( index < size ) ; pts [ index ++ ] = parse_time_or_die ( \"force_key_frames\" , p , 1 ) ; } p = next ; } av_assert0 ( index == size ) ; qsort ( pts , size , sizeof ( * pts ) , compare_int64 ) ; kf -> nb_pts = size ; kf -> pts = pts ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@process_forced_keyframes": "static int process_forced_keyframes ( Muxer * mux , const OptionsContext * o ) { for ( int i = 0 ; i < mux -> of . nb_streams ; i ++ ) { OutputStream * ost = mux -> of . streams [ i ] ; const char * forced_keyframes = NULL ; MATCH_PER_STREAM_OPT ( forced_key_frames , str , forced_keyframes , mux -> fc , ost -> st ) ; if ( ! ( ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && ost -> enc_ctx && forced_keyframes ) ) continue ; if ( ! strncmp ( forced_keyframes , \"expr:\" , 5 ) ) { int ret = av_expr_parse ( & ost -> kf . pexpr , forced_keyframes + 5 , forced_keyframes_const_names , NULL , NULL , NULL , NULL , 0 , NULL ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Invalid force_key_frames expression '%s'\\n\" , forced_keyframes + 5 ) ; return ret ; } ost -> kf . expr_const_values [ FKF_N ] = 0 ; ost -> kf . expr_const_values [ FKF_N_FORCED ] = 0 ; ost -> kf . expr_const_values [ FKF_PREV_FORCED_N ] = NAN ; ost -> kf . expr_const_values [ FKF_PREV_FORCED_T ] = NAN ; // Don't parse the 'forced_keyframes' in case of 'keep-source-keyframes', // parse it only for static kf timings } else if ( ! strcmp ( forced_keyframes , \"source\" ) ) { ost -> kf . type = KF_FORCE_SOURCE ; } else if ( ! strcmp ( forced_keyframes , \"source_no_drop\" ) ) { ost -> kf . type = KF_FORCE_SOURCE_NO_DROP ; } else { parse_forced_key_frames ( & ost -> kf , mux , forced_keyframes ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@validate_enc_avopt": "static void validate_enc_avopt ( Muxer * mux , const AVDictionary * codec_avopt ) { const AVClass * class = avcodec_get_class ( ) ; const AVClass * fclass = avformat_get_class ( ) ; const OutputFile * of = & mux -> of ; AVDictionary * unused_opts ; const AVDictionaryEntry * e ; unused_opts = strip_specifiers ( codec_avopt ) ; for ( int i = 0 ; i < of -> nb_streams ; i ++ ) { e = NULL ; while ( ( e = av_dict_iterate ( of -> streams [ i ] -> encoder_opts , e ) ) ) av_dict_set ( & unused_opts , e -> key , NULL , 0 ) ; } e = NULL ; while ( ( e = av_dict_iterate ( unused_opts , e ) ) ) { const AVOption * option = av_opt_find ( & class , e -> key , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ; const AVOption * foption = av_opt_find ( & fclass , e -> key , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ; if ( ! option || foption ) continue ; if ( ! ( option -> flags & AV_OPT_FLAG_ENCODING_PARAM ) ) { av_log ( mux , AV_LOG_ERROR , \"Codec AVOption %s (%s) is not an \" \"encoding option.\\n\" , e -> key , option -> help ? option -> help : \"\" ) ; exit_program ( 1 ) ; } // gop_timecode is injected by generic code but not always used if ( ! strcmp ( e -> key , \"gop_timecode\" ) ) continue ; av_log ( mux , AV_LOG_WARNING , \"Codec AVOption %s (%s) has not been used \" \"for any stream. The most likely reason is either wrong type \" \"(e.g. a video option with no video streams) or that it is a \" \"private option of some encoder which was not actually used for \" \"any stream.\\n\" , e -> key , option -> help ? option -> help : \"\" ) ; } av_dict_free ( & unused_opts ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@output_file_item_name": "static const char * output_file_item_name ( void * obj ) { const Muxer * mux = obj ; return mux -> log_name ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@mux_alloc": "static Muxer * mux_alloc ( void ) { Muxer * mux = allocate_array_elem ( & output_files , sizeof ( * mux ) , & nb_output_files ) ; mux -> of . clazz = & output_file_class ; mux -> of . index = nb_output_files - 1 ; snprintf ( mux -> log_name , sizeof ( mux -> log_name ) , \"out#%d\" , mux -> of . index ) ; return mux ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux_init.c@of_open": "int of_open ( const OptionsContext * o , const char * filename ) { Muxer * mux ; AVFormatContext * oc ; int err ; OutputFile * of ; int64_t recording_time = o -> recording_time ; int64_t stop_time = o -> stop_time ; mux = mux_alloc ( ) ; of = & mux -> of ; if ( stop_time != INT64_MAX && recording_time != INT64_MAX ) { stop_time = INT64_MAX ; av_log ( mux , AV_LOG_WARNING , \"-t and -to cannot be used together; using -t.\\n\" ) ; } if ( stop_time != INT64_MAX && recording_time == INT64_MAX ) { int64_t start_time = o -> start_time == AV_NOPTS_VALUE ? 0 : o -> start_time ; if ( stop_time <= start_time ) { av_log ( mux , AV_LOG_ERROR , \"-to value smaller than -ss; aborting.\\n\" ) ; exit_program ( 1 ) ; } else { recording_time = stop_time - start_time ; } } of -> recording_time = recording_time ; of -> start_time = o -> start_time ; of -> shortest = o -> shortest ; mux -> thread_queue_size = o -> thread_queue_size > 0 ? o -> thread_queue_size : 8 ; mux -> limit_filesize = o -> limit_filesize ; av_dict_copy ( & mux -> opts , o -> g -> format_opts , 0 ) ; if ( ! strcmp ( filename , \"-\" ) ) filename = \"pipe:\" ; err = avformat_alloc_output_context2 ( & oc , NULL , o -> format , filename ) ; if ( ! oc ) { print_error ( filename , err ) ; exit_program ( 1 ) ; } mux -> fc = oc ; av_strlcat ( mux -> log_name , \"/\" , sizeof ( mux -> log_name ) ) ; av_strlcat ( mux -> log_name , oc -> oformat -> name , sizeof ( mux -> log_name ) ) ; if ( strcmp ( oc -> oformat -> name , \"rtp\" ) ) want_sdp = 0 ; of -> format = oc -> oformat ; if ( recording_time != INT64_MAX ) oc -> duration = recording_time ; oc -> interrupt_callback = int_cb ; if ( o -> bitexact ) { oc -> flags |= AVFMT_FLAG_BITEXACT ; of -> bitexact = 1 ; } else { of -> bitexact = check_opt_bitexact ( oc , mux -> opts , \"fflags\" , AVFMT_FLAG_BITEXACT ) ; } /* create all output streams for this file */ create_streams ( mux , o ) ; /* check if all codec options have been used */ validate_enc_avopt ( mux , o -> g -> codec_opts ) ; /* set the decoding_needed flags and create simple filtergraphs */ for ( int i = 0 ; i < of -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; if ( ost -> enc_ctx && ost -> ist ) { InputStream * ist = ost -> ist ; ist -> decoding_needed |= DECODING_FOR_OST ; ist -> processing_needed = 1 ; if ( ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO || ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { err = init_simple_filtergraph ( ist , ost ) ; if ( err < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error initializing a simple filtergraph\\n\" ) ; exit_program ( 1 ) ; } } } else if ( ost -> ist ) { ost -> ist -> processing_needed = 1 ; } /* set the filter output constraints */ if ( ost -> filter ) { const AVCodec * c = ost -> enc_ctx -> codec ; OutputFilter * f = ost -> filter ; switch ( ost -> enc_ctx -> codec_type ) { case AVMEDIA_TYPE_VIDEO : f -> frame_rate = ost -> frame_rate ; f -> width = ost -> enc_ctx -> width ; f -> height = ost -> enc_ctx -> height ; if ( ost -> enc_ctx -> pix_fmt != AV_PIX_FMT_NONE ) { f -> format = ost -> enc_ctx -> pix_fmt ; } else { f -> formats = c -> pix_fmts ; } break ; case AVMEDIA_TYPE_AUDIO : if ( ost -> enc_ctx -> sample_fmt != AV_SAMPLE_FMT_NONE ) { f -> format = ost -> enc_ctx -> sample_fmt ; } else { f -> formats = c -> sample_fmts ; } if ( ost -> enc_ctx -> sample_rate ) { f -> sample_rate = ost -> enc_ctx -> sample_rate ; } else { f -> sample_rates = c -> supported_samplerates ; } if ( ost -> enc_ctx -> ch_layout . nb_channels ) { set_channel_layout ( f , ost ) ; } else if ( c -> ch_layouts ) { f -> ch_layouts = c -> ch_layouts ; } break ; } } } /* check filename in case of an image number is expected */ if ( oc -> oformat -> flags & AVFMT_NEEDNUMBER ) { if ( ! av_filename_number_test ( oc -> url ) ) { print_error ( oc -> url , AVERROR ( EINVAL ) ) ; exit_program ( 1 ) ; } } if ( ! ( oc -> oformat -> flags & AVFMT_NOFILE ) ) { /* test if it already exists to avoid losing precious files */ assert_file_overwrite ( filename ) ; /* open the file */ if ( ( err = avio_open2 ( & oc -> pb , filename , AVIO_FLAG_WRITE , & oc -> interrupt_callback , & mux -> opts ) ) < 0 ) { print_error ( filename , err ) ; exit_program ( 1 ) ; } } else if ( strcmp ( oc -> oformat -> name , \"image2\" ) == 0 && ! av_filename_number_test ( filename ) ) assert_file_overwrite ( filename ) ; if ( o -> mux_preload ) { av_dict_set_int ( & mux -> opts , \"preload\" , o -> mux_preload * AV_TIME_BASE , 0 ) ; } oc -> max_delay = ( int ) ( o -> mux_max_delay * AV_TIME_BASE ) ; /* copy metadata and chapters from input files */ copy_meta ( mux , o ) ; of_add_programs ( mux , o ) ; of_add_metadata ( of , oc , o ) ; err = set_dispositions ( mux , o ) ; if ( err < 0 ) { av_log ( mux , AV_LOG_FATAL , \"Error setting output stream dispositions\\n\" ) ; exit_program ( 1 ) ; } // parse forced keyframe specifications; // must be done after chapters are created err = process_forced_keyframes ( mux , o ) ; if ( err < 0 ) { av_log ( mux , AV_LOG_FATAL , \"Error processing forced keyframes\\n\" ) ; exit_program ( 1 ) ; } err = setup_sync_queues ( mux , oc , o -> shortest_buf_duration * AV_TIME_BASE ) ; if ( err < 0 ) { av_log ( mux , AV_LOG_FATAL , \"Error setting up output sync queues\\n\" ) ; exit_program ( 1 ) ; } of -> url = filename ; /* write the header for files with no streams */ if ( of -> format -> flags & AVFMT_NOSTREAMS && oc -> nb_streams == 0 ) { int ret = mux_check_init ( mux ) ; if ( ret < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@get_compliance_normal_pix_fmts": "static const enum AVPixelFormat * get_compliance_normal_pix_fmts ( const AVCodec * codec , const enum AVPixelFormat default_formats [ ] ) { static const enum AVPixelFormat mjpeg_formats [ ] = { AV_PIX_FMT_YUVJ420P , AV_PIX_FMT_YUVJ422P , AV_PIX_FMT_YUVJ444P , AV_PIX_FMT_NONE } ; if ( ! strcmp ( codec -> name , \"mjpeg\" ) ) { return mjpeg_formats ; } else { return default_formats ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@choose_pixel_fmt": "enum AVPixelFormat choose_pixel_fmt ( const AVCodec * codec , enum AVPixelFormat target , int strict_std_compliance ) { if ( codec && codec -> pix_fmts ) { const enum AVPixelFormat * p = codec -> pix_fmts ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( target ) ; //FIXME: This should check for AV_PIX_FMT_FLAG_ALPHA after PAL8 pixel format without alpha is implemented int has_alpha = desc ? desc -> nb_components % 2 == 0 : 0 ; enum AVPixelFormat best = AV_PIX_FMT_NONE ; if ( strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL ) { p = get_compliance_normal_pix_fmts ( codec , p ) ; } for ( ; * p != AV_PIX_FMT_NONE ; p ++ ) { best = av_find_best_pix_fmt_of_2 ( best , * p , target , has_alpha , NULL ) ; if ( * p == target ) break ; } if ( * p == AV_PIX_FMT_NONE ) { if ( target != AV_PIX_FMT_NONE ) av_log ( NULL , AV_LOG_WARNING , \"Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\\n\" , av_get_pix_fmt_name ( target ) , codec -> name , av_get_pix_fmt_name ( best ) ) ; return best ; } } return target ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@choose_pix_fmts": "static const char * choose_pix_fmts ( OutputFilter * ofilter , AVBPrint * bprint ) { OutputStream * ost = ofilter -> ost ; AVCodecContext * enc = ost -> enc_ctx ; const AVDictionaryEntry * strict_dict = av_dict_get ( ost -> encoder_opts , \"strict\" , NULL , 0 ) ; if ( strict_dict ) // used by choose_pixel_fmt() and below av_opt_set ( ost -> enc_ctx , \"strict\" , strict_dict -> value , 0 ) ; if ( ost -> keep_pix_fmt ) { avfilter_graph_set_auto_convert ( ofilter -> graph -> graph , AVFILTER_AUTO_CONVERT_NONE ) ; if ( ost -> enc_ctx -> pix_fmt == AV_PIX_FMT_NONE ) return NULL ; return av_get_pix_fmt_name ( ost -> enc_ctx -> pix_fmt ) ; } if ( ost -> enc_ctx -> pix_fmt != AV_PIX_FMT_NONE ) { return av_get_pix_fmt_name ( choose_pixel_fmt ( enc -> codec , enc -> pix_fmt , ost -> enc_ctx -> strict_std_compliance ) ) ; } else if ( enc -> codec -> pix_fmts ) { const enum AVPixelFormat * p ; p = enc -> codec -> pix_fmts ; if ( ost -> enc_ctx -> strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL ) { p = get_compliance_normal_pix_fmts ( enc -> codec , p ) ; } for ( ; * p != AV_PIX_FMT_NONE ; p ++ ) { const char * name = av_get_pix_fmt_name ( * p ) ; av_bprintf ( bprint , \"%s%c\" , name , p [ 1 ] == AV_PIX_FMT_NONE ? '\\0' : '|' ) ; } if ( ! av_bprint_is_complete ( bprint ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return bprint -> str ; } else return NULL ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@choose_sample_fmts": "static void choose_ ## name ( OutputFilter * ofilter , AVBPrint * bprint ) \\\n{ if ( ofilter -> var == none && ! ofilter -> supported_list ) return ; av_bprintf ( bprint , # name \"=\" ) ; if ( ofilter -> var != none ) { av_bprintf ( bprint , printf_format , get_name ( ofilter -> var ) ) ; } else { const type * p ; for ( p = ofilter -> supported_list ; * p != none ; p ++ ) { av_bprintf ( bprint , printf_format \"|\" , get_name ( * p ) ) ; } if ( bprint -> len > 0 ) bprint -> str [ -- bprint -> len ] = '\\0' ; } av_bprint_chars ( bprint , ':' , 1 ) ; \\\n} //DEF_CHOOSE_FORMAT(pix_fmts, enum AVPixelFormat, format, formats, AV_PIX_FMT_NONE, //                  GET_PIX_FMT_NAME) DEF_CHOOSE_FORMAT ( sample_fmts , enum AVSampleFormat , format , formats , AV_SAMPLE_FMT_NONE , \"%s\" , av_get_sample_fmt_name )",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@choose_sample_rates": "static void choose_ ## name ( OutputFilter * ofilter , AVBPrint * bprint ) \\\n{ if ( ofilter -> var == none && ! ofilter -> supported_list ) return ; av_bprintf ( bprint , # name \"=\" ) ; if ( ofilter -> var != none ) { av_bprintf ( bprint , printf_format , get_name ( ofilter -> var ) ) ; } else { const type * p ; for ( p = ofilter -> supported_list ; * p != none ; p ++ ) { av_bprintf ( bprint , printf_format \"|\" , get_name ( * p ) ) ; } if ( bprint -> len > 0 ) bprint -> str [ -- bprint -> len ] = '\\0' ; } av_bprint_chars ( bprint , ':' , 1 ) ; \\\n} //DEF_CHOOSE_FORMAT(pix_fmts, enum AVPixelFormat, format, formats, AV_PIX_FMT_NONE, //                  GET_PIX_FMT_NAME) DEF_CHOOSE_FORMAT ( sample_fmts , enum AVSampleFormat , format , formats , AV_SAMPLE_FMT_NONE , \"%s\" , av_get_sample_fmt_name ) DEF_CHOOSE_FORMAT ( sample_rates , int , sample_rate , sample_rates , 0 , \"%d\" , )",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@choose_channel_layouts": "static void choose_channel_layouts ( OutputFilter * ofilter , AVBPrint * bprint ) { if ( av_channel_layout_check ( & ofilter -> ch_layout ) ) { av_bprintf ( bprint , \"channel_layouts=\" ) ; av_channel_layout_describe_bprint ( & ofilter -> ch_layout , bprint ) ; } else if ( ofilter -> ch_layouts ) { const AVChannelLayout * p ; av_bprintf ( bprint , \"channel_layouts=\" ) ; for ( p = ofilter -> ch_layouts ; p -> nb_channels ; p ++ ) { av_channel_layout_describe_bprint ( p , bprint ) ; av_bprintf ( bprint , \"|\" ) ; } if ( bprint -> len > 0 ) bprint -> str [ -- bprint -> len ] = '\\0' ; } else return ; av_bprint_chars ( bprint , ':' , 1 ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@init_simple_filtergraph": "int init_simple_filtergraph ( InputStream * ist , OutputStream * ost ) { FilterGraph * fg = av_mallocz ( sizeof ( * fg ) ) ; OutputFilter * ofilter ; InputFilter * ifilter ; if ( ! fg ) report_and_exit ( AVERROR ( ENOMEM ) ) ; fg -> index = nb_filtergraphs ; ofilter = ALLOC_ARRAY_ELEM ( fg -> outputs , fg -> nb_outputs ) ; ofilter -> ost = ost ; ofilter -> graph = fg ; ofilter -> format = - 1 ; ost -> filter = ofilter ; ifilter = ALLOC_ARRAY_ELEM ( fg -> inputs , fg -> nb_inputs ) ; ifilter -> ist = ist ; ifilter -> graph = fg ; ifilter -> format = - 1 ; ifilter -> frame_queue = av_fifo_alloc2 ( 8 , sizeof ( AVFrame * ) , AV_FIFO_FLAG_AUTO_GROW ) ; if ( ! ifilter -> frame_queue ) report_and_exit ( AVERROR ( ENOMEM ) ) ; GROW_ARRAY ( ist -> filters , ist -> nb_filters ) ; ist -> filters [ ist -> nb_filters - 1 ] = ifilter ; GROW_ARRAY ( filtergraphs , nb_filtergraphs ) ; filtergraphs [ nb_filtergraphs - 1 ] = fg ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@describe_filter_link": "static char * describe_filter_link ( FilterGraph * fg , AVFilterInOut * inout , int in ) { AVFilterContext * ctx = inout -> filter_ctx ; AVFilterPad * pads = in ? ctx -> input_pads : ctx -> output_pads ; int nb_pads = in ? ctx -> nb_inputs : ctx -> nb_outputs ; char * res ; if ( nb_pads > 1 ) res = av_strdup ( ctx -> filter -> name ) ; else res = av_asprintf ( \"%s:%s\" , ctx -> filter -> name , avfilter_pad_get_name ( pads , inout -> pad_idx ) ) ; if ( ! res ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return res ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@init_input_filter": "static void init_input_filter ( FilterGraph * fg , AVFilterInOut * in ) { InputStream * ist = NULL ; enum AVMediaType type = avfilter_pad_get_type ( in -> filter_ctx -> input_pads , in -> pad_idx ) ; InputFilter * ifilter ; int i ; // TODO: support other filter types if ( type != AVMEDIA_TYPE_VIDEO && type != AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_FATAL , \"Only video and audio filters supported \" \"currently.\\n\" ) ; exit_program ( 1 ) ; } if ( in -> name ) { AVFormatContext * s ; AVStream * st = NULL ; char * p ; int file_idx = strtol ( in -> name , & p , 0 ) ; if ( file_idx < 0 || file_idx >= nb_input_files ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid file index %d in filtergraph description %s.\\n\" , file_idx , fg -> graph_desc ) ; exit_program ( 1 ) ; } s = input_files [ file_idx ] -> ctx ; for ( i = 0 ; i < s -> nb_streams ; i ++ ) { enum AVMediaType stream_type = s -> streams [ i ] -> codecpar -> codec_type ; if ( stream_type != type && ! ( stream_type == AVMEDIA_TYPE_SUBTITLE && type == AVMEDIA_TYPE_VIDEO /* sub2video hack */ ) ) continue ; if ( check_stream_specifier ( s , s -> streams [ i ] , * p == ':' ? p + 1 : p ) == 1 ) { st = s -> streams [ i ] ; break ; } } if ( ! st ) { av_log ( NULL , AV_LOG_FATAL , \"Stream specifier '%s' in filtergraph description %s \" \"matches no streams.\\n\" , p , fg -> graph_desc ) ; exit_program ( 1 ) ; } ist = input_files [ file_idx ] -> streams [ st -> index ] ; if ( ist -> user_set_discard == AVDISCARD_ALL ) { av_log ( NULL , AV_LOG_FATAL , \"Stream specifier '%s' in filtergraph description %s \" \"matches a disabled input stream.\\n\" , p , fg -> graph_desc ) ; exit_program ( 1 ) ; } } else { /* find the first unused stream of corresponding type */ for ( ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) { if ( ist -> user_set_discard == AVDISCARD_ALL ) continue ; if ( ist -> dec_ctx -> codec_type == type && ist -> discard ) break ; } if ( ! ist ) { av_log ( NULL , AV_LOG_FATAL , \"Cannot find a matching stream for \" \"unlabeled input pad %d on filter %s\\n\" , in -> pad_idx , in -> filter_ctx -> name ) ; exit_program ( 1 ) ; } } av_assert0 ( ist ) ; ist -> discard = 0 ; ist -> decoding_needed |= DECODING_FOR_FILTER ; ist -> processing_needed = 1 ; ist -> st -> discard = AVDISCARD_NONE ; ifilter = ALLOC_ARRAY_ELEM ( fg -> inputs , fg -> nb_inputs ) ; ifilter -> ist = ist ; ifilter -> graph = fg ; ifilter -> format = - 1 ; ifilter -> type = ist -> st -> codecpar -> codec_type ; ifilter -> name = describe_filter_link ( fg , in , 1 ) ; ifilter -> frame_queue = av_fifo_alloc2 ( 8 , sizeof ( AVFrame * ) , AV_FIFO_FLAG_AUTO_GROW ) ; if ( ! ifilter -> frame_queue ) report_and_exit ( AVERROR ( ENOMEM ) ) ; GROW_ARRAY ( ist -> filters , ist -> nb_filters ) ; ist -> filters [ ist -> nb_filters - 1 ] = ifilter ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@read_binary": "static int read_binary ( const char * path , uint8_t * * data , int * len ) { AVIOContext * io = NULL ; int64_t fsize ; int ret ; * data = NULL ; * len = 0 ; ret = avio_open2 ( & io , path , AVIO_FLAG_READ , & int_cb , NULL ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot open file '%s': %s\\n\" , path , av_err2str ( ret ) ) ; return ret ; } fsize = avio_size ( io ) ; if ( fsize < 0 || fsize > INT_MAX ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot obtain size of file %s\\n\" , path ) ; ret = AVERROR ( EIO ) ; goto fail ; } * data = av_malloc ( fsize ) ; if ( ! * data ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } ret = avio_read ( io , * data , fsize ) ; if ( ret != fsize ) { av_log ( NULL , AV_LOG_ERROR , \"Error reading file %s\\n\" , path ) ; ret = ret < 0 ? ret : AVERROR ( EIO ) ; goto fail ; } * len = fsize ; return 0 ; fail : avio_close ( io ) ; av_freep ( data ) ; * len = 0 ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@filter_opt_apply": "static int filter_opt_apply ( AVFilterContext * f , const char * key , const char * val ) { const AVOption * o = NULL ; int ret ; ret = av_opt_set ( f , key , val , AV_OPT_SEARCH_CHILDREN ) ; if ( ret >= 0 ) return 0 ; if ( ret == AVERROR_OPTION_NOT_FOUND && key [ 0 ] == '/' ) o = av_opt_find ( f , key + 1 , NULL , 0 , AV_OPT_SEARCH_CHILDREN ) ; if ( ! o ) goto err_apply ; // key is a valid option name prefixed with '/' // interpret value as a path from which to load the actual option value key ++ ; if ( o -> type == AV_OPT_TYPE_BINARY ) { uint8_t * data ; int len ; ret = read_binary ( val , & data , & len ) ; if ( ret < 0 ) goto err_load ; ret = av_opt_set_bin ( f , key , data , len , AV_OPT_SEARCH_CHILDREN ) ; av_freep ( & data ) ; } else { char * data = file_read ( val ) ; if ( ! data ) { ret = AVERROR ( EIO ) ; goto err_load ; } ret = av_opt_set ( f , key , data , AV_OPT_SEARCH_CHILDREN ) ; av_freep ( & data ) ; } if ( ret < 0 ) goto err_apply ; return 0 ; err_apply : av_log ( NULL , AV_LOG_ERROR , \"Error applying option '%s' to filter '%s': %s\\n\" , key , f -> filter -> name , av_err2str ( ret ) ) ; return ret ; err_load : av_log ( NULL , AV_LOG_ERROR , \"Error loading value for option '%s' from file '%s'\\n\" , key , val ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@graph_opts_apply": "static int graph_opts_apply ( AVFilterGraphSegment * seg ) { for ( size_t i = 0 ; i < seg -> nb_chains ; i ++ ) { AVFilterChain * ch = seg -> chains [ i ] ; for ( size_t j = 0 ; j < ch -> nb_filters ; j ++ ) { AVFilterParams * p = ch -> filters [ j ] ; const AVDictionaryEntry * e = NULL ; av_assert0 ( p -> filter ) ; while ( ( e = av_dict_iterate ( p -> opts , e ) ) ) { int ret = filter_opt_apply ( p -> filter , e -> key , e -> value ) ; if ( ret < 0 ) return ret ; } av_dict_free ( & p -> opts ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@graph_parse": "static int graph_parse ( AVFilterGraph * graph , const char * desc , AVFilterInOut * * inputs , AVFilterInOut * * outputs ) { AVFilterGraphSegment * seg ; int ret ; ret = avfilter_graph_segment_parse ( graph , desc , 0 , & seg ) ; if ( ret < 0 ) return ret ; ret = avfilter_graph_segment_create_filters ( seg , 0 ) ; if ( ret < 0 ) goto fail ; ret = graph_opts_apply ( seg ) ; if ( ret < 0 ) goto fail ; ret = avfilter_graph_segment_apply ( seg , 0 , inputs , outputs ) ; fail : avfilter_graph_segment_free ( & seg ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@init_complex_filtergraph": "int init_complex_filtergraph ( FilterGraph * fg ) { AVFilterInOut * inputs , * outputs , * cur ; AVFilterGraph * graph ; int ret = 0 ; /* this graph is only used for determining the kinds of inputs\n     * and outputs we have, and is discarded on exit from this function */ graph = avfilter_graph_alloc ( ) ; if ( ! graph ) return AVERROR ( ENOMEM ) ; graph -> nb_threads = 1 ; ret = graph_parse ( graph , fg -> graph_desc , & inputs , & outputs ) ; if ( ret < 0 ) goto fail ; for ( cur = inputs ; cur ; cur = cur -> next ) init_input_filter ( fg , cur ) ; for ( cur = outputs ; cur ; ) { OutputFilter * const ofilter = ALLOC_ARRAY_ELEM ( fg -> outputs , fg -> nb_outputs ) ; ofilter -> graph = fg ; ofilter -> out_tmp = cur ; ofilter -> type = avfilter_pad_get_type ( cur -> filter_ctx -> output_pads , cur -> pad_idx ) ; ofilter -> name = describe_filter_link ( fg , cur , 0 ) ; cur = cur -> next ; ofilter -> out_tmp -> next = NULL ; } fail : avfilter_inout_free ( & inputs ) ; avfilter_graph_free ( & graph ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@insert_trim": "static int insert_trim ( int64_t start_time , int64_t duration , AVFilterContext * * last_filter , int * pad_idx , const char * filter_name ) { AVFilterGraph * graph = ( * last_filter ) -> graph ; AVFilterContext * ctx ; const AVFilter * trim ; enum AVMediaType type = avfilter_pad_get_type ( ( * last_filter ) -> output_pads , * pad_idx ) ; const char * name = ( type == AVMEDIA_TYPE_VIDEO ) ? \"trim\" : \"atrim\" ; int ret = 0 ; if ( duration == INT64_MAX && start_time == AV_NOPTS_VALUE ) return 0 ; trim = avfilter_get_by_name ( name ) ; if ( ! trim ) { av_log ( NULL , AV_LOG_ERROR , \"%s filter not present, cannot limit \" \"recording time.\\n\" , name ) ; return AVERROR_FILTER_NOT_FOUND ; } ctx = avfilter_graph_alloc_filter ( graph , trim , filter_name ) ; if ( ! ctx ) return AVERROR ( ENOMEM ) ; if ( duration != INT64_MAX ) { ret = av_opt_set_int ( ctx , \"durationi\" , duration , AV_OPT_SEARCH_CHILDREN ) ; } if ( ret >= 0 && start_time != AV_NOPTS_VALUE ) { ret = av_opt_set_int ( ctx , \"starti\" , start_time , AV_OPT_SEARCH_CHILDREN ) ; } if ( ret < 0 ) { av_log ( ctx , AV_LOG_ERROR , \"Error configuring the %s filter\" , name ) ; return ret ; } ret = avfilter_init_str ( ctx , NULL ) ; if ( ret < 0 ) return ret ; ret = avfilter_link ( * last_filter , * pad_idx , ctx , 0 ) ; if ( ret < 0 ) return ret ; * last_filter = ctx ; * pad_idx = 0 ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@insert_filter": "static int insert_filter ( AVFilterContext * * last_filter , int * pad_idx , const char * filter_name , const char * args ) { AVFilterGraph * graph = ( * last_filter ) -> graph ; AVFilterContext * ctx ; int ret ; ret = avfilter_graph_create_filter ( & ctx , avfilter_get_by_name ( filter_name ) , filter_name , args , NULL , graph ) ; if ( ret < 0 ) return ret ; ret = avfilter_link ( * last_filter , * pad_idx , ctx , 0 ) ; if ( ret < 0 ) return ret ; * last_filter = ctx ; * pad_idx = 0 ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@configure_output_video_filter": "static int configure_output_video_filter ( FilterGraph * fg , OutputFilter * ofilter , AVFilterInOut * out ) { OutputStream * ost = ofilter -> ost ; OutputFile * of = output_files [ ost -> file_index ] ; AVFilterContext * last_filter = out -> filter_ctx ; AVBPrint bprint ; int pad_idx = out -> pad_idx ; int ret ; const char * pix_fmts ; char name [ 255 ] ; snprintf ( name , sizeof ( name ) , \"out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = avfilter_graph_create_filter ( & ofilter -> filter , avfilter_get_by_name ( \"buffersink\" ) , name , NULL , NULL , fg -> graph ) ; if ( ret < 0 ) return ret ; if ( ( ofilter -> width || ofilter -> height ) && ofilter -> ost -> autoscale ) { char args [ 255 ] ; AVFilterContext * filter ; const AVDictionaryEntry * e = NULL ; snprintf ( args , sizeof ( args ) , \"%d:%d\" , ofilter -> width , ofilter -> height ) ; while ( ( e = av_dict_iterate ( ost -> sws_dict , e ) ) ) { av_strlcatf ( args , sizeof ( args ) , \":%s=%s\" , e -> key , e -> value ) ; } snprintf ( name , sizeof ( name ) , \"scaler_out_%d_%d\" , ost -> file_index , ost -> index ) ; if ( ( ret = avfilter_graph_create_filter ( & filter , avfilter_get_by_name ( \"scale\" ) , name , args , NULL , fg -> graph ) ) < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , pad_idx , filter , 0 ) ) < 0 ) return ret ; last_filter = filter ; pad_idx = 0 ; } av_bprint_init ( & bprint , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; if ( ( pix_fmts = choose_pix_fmts ( ofilter , & bprint ) ) ) { AVFilterContext * filter ; ret = avfilter_graph_create_filter ( & filter , avfilter_get_by_name ( \"format\" ) , \"format\" , pix_fmts , NULL , fg -> graph ) ; av_bprint_finalize ( & bprint , NULL ) ; if ( ret < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , pad_idx , filter , 0 ) ) < 0 ) return ret ; last_filter = filter ; pad_idx = 0 ; } if ( ost -> frame_rate . num && 0 ) { AVFilterContext * fps ; char args [ 255 ] ; snprintf ( args , sizeof ( args ) , \"fps=%d/%d\" , ost -> frame_rate . num , ost -> frame_rate . den ) ; snprintf ( name , sizeof ( name ) , \"fps_out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = avfilter_graph_create_filter ( & fps , avfilter_get_by_name ( \"fps\" ) , name , args , NULL , fg -> graph ) ; if ( ret < 0 ) return ret ; ret = avfilter_link ( last_filter , pad_idx , fps , 0 ) ; if ( ret < 0 ) return ret ; last_filter = fps ; pad_idx = 0 ; } snprintf ( name , sizeof ( name ) , \"trim_out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = insert_trim ( of -> start_time , of -> recording_time , & last_filter , & pad_idx , name ) ; if ( ret < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , pad_idx , ofilter -> filter , 0 ) ) < 0 ) return ret ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@configure_output_audio_filter": "static int configure_output_audio_filter ( FilterGraph * fg , OutputFilter * ofilter , AVFilterInOut * out ) { OutputStream * ost = ofilter -> ost ; OutputFile * of = output_files [ ost -> file_index ] ; AVCodecContext * codec = ost -> enc_ctx ; AVFilterContext * last_filter = out -> filter_ctx ; int pad_idx = out -> pad_idx ; AVBPrint args ; char name [ 255 ] ; int ret ; snprintf ( name , sizeof ( name ) , \"out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = avfilter_graph_create_filter ( & ofilter -> filter , avfilter_get_by_name ( \"abuffersink\" ) , name , NULL , NULL , fg -> graph ) ; if ( ret < 0 ) return ret ; if ( ( ret = av_opt_set_int ( ofilter -> filter , \"all_channel_counts\" , 1 , AV_OPT_SEARCH_CHILDREN ) ) < 0 ) return ret ; # define AUTO_INSERT_FILTER ( opt_name , filter_name , arg ) do { AVFilterContext * filt_ctx ; av_log ( NULL , AV_LOG_INFO , opt_name \" is forwarded to lavfi \" \"similarly to -af \" filter_name \"=%s.\\n\" , arg ) ; ret = avfilter_graph_create_filter ( & filt_ctx , avfilter_get_by_name ( filter_name ) , filter_name , arg , NULL , fg -> graph ) ; if ( ret < 0 ) goto fail ; ret = avfilter_link ( last_filter , pad_idx , filt_ctx , 0 ) ; if ( ret < 0 ) goto fail ; last_filter = filt_ctx ; pad_idx = 0 ; \\\n} while ( 0 ) av_bprint_init ( & args , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; # if FFMPEG_OPT_MAP_CHANNEL if ( ost -> audio_channels_mapped ) { AVChannelLayout mapped_layout = { 0 } ; int i ; av_channel_layout_default ( & mapped_layout , ost -> audio_channels_mapped ) ; av_channel_layout_describe_bprint ( & mapped_layout , & args ) ; for ( i = 0 ; i < ost -> audio_channels_mapped ; i ++ ) if ( ost -> audio_channels_map [ i ] != - 1 ) av_bprintf ( & args , \"|c%d=c%d\" , i , ost -> audio_channels_map [ i ] ) ; AUTO_INSERT_FILTER ( \"-map_channel\" , \"pan\" , args . str ) ; av_bprint_clear ( & args ) ; } # endif if ( codec -> ch_layout . order == AV_CHANNEL_ORDER_UNSPEC ) av_channel_layout_default ( & codec -> ch_layout , codec -> ch_layout . nb_channels ) ; choose_sample_fmts ( ofilter , & args ) ; choose_sample_rates ( ofilter , & args ) ; choose_channel_layouts ( ofilter , & args ) ; if ( ! av_bprint_is_complete ( & args ) ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } if ( args . len ) { AVFilterContext * format ; snprintf ( name , sizeof ( name ) , \"format_out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = avfilter_graph_create_filter ( & format , avfilter_get_by_name ( \"aformat\" ) , name , args . str , NULL , fg -> graph ) ; if ( ret < 0 ) goto fail ; ret = avfilter_link ( last_filter , pad_idx , format , 0 ) ; if ( ret < 0 ) goto fail ; last_filter = format ; pad_idx = 0 ; } if ( ost -> apad && of -> shortest ) { int i ; for ( i = 0 ; i < of -> nb_streams ; i ++ ) if ( of -> streams [ i ] -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) break ; if ( i < of -> nb_streams ) { AUTO_INSERT_FILTER ( \"-apad\" , \"apad\" , ost -> apad ) ; } } snprintf ( name , sizeof ( name ) , \"trim for output stream %d:%d\" , ost -> file_index , ost -> index ) ; ret = insert_trim ( of -> start_time , of -> recording_time , & last_filter , & pad_idx , name ) ; if ( ret < 0 ) goto fail ; if ( ( ret = avfilter_link ( last_filter , pad_idx , ofilter -> filter , 0 ) ) < 0 ) goto fail ; fail : av_bprint_finalize ( & args , NULL ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@configure_output_filter": "int configure_output_filter ( FilterGraph * fg , OutputFilter * ofilter , AVFilterInOut * out ) { if ( ! ofilter -> ost ) { av_log ( NULL , AV_LOG_FATAL , \"Filter %s has an unconnected output\\n\" , ofilter -> name ) ; exit_program ( 1 ) ; } switch ( avfilter_pad_get_type ( out -> filter_ctx -> output_pads , out -> pad_idx ) ) { case AVMEDIA_TYPE_VIDEO : return configure_output_video_filter ( fg , ofilter , out ) ; case AVMEDIA_TYPE_AUDIO : return configure_output_audio_filter ( fg , ofilter , out ) ; default : av_assert0 ( 0 ) ; return 0 ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@check_filter_outputs": "void check_filter_outputs ( void ) { int i ; for ( i = 0 ; i < nb_filtergraphs ; i ++ ) { int n ; for ( n = 0 ; n < filtergraphs [ i ] -> nb_outputs ; n ++ ) { OutputFilter * output = filtergraphs [ i ] -> outputs [ n ] ; if ( ! output -> ost ) { av_log ( NULL , AV_LOG_FATAL , \"Filter %s has an unconnected output\\n\" , output -> name ) ; exit_program ( 1 ) ; } } } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@sub2video_prepare": "static int sub2video_prepare ( InputStream * ist , InputFilter * ifilter ) { AVFormatContext * avf = input_files [ ist -> file_index ] -> ctx ; int i , w , h ; /* Compute the size of the canvas for the subtitles stream.\n       If the subtitles codecpar has set a size, use it. Otherwise use the\n       maximum dimensions of the video streams in the same file. */ w = ifilter -> width ; h = ifilter -> height ; if ( ! ( w && h ) ) { for ( i = 0 ; i < avf -> nb_streams ; i ++ ) { if ( avf -> streams [ i ] -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { w = FFMAX ( w , avf -> streams [ i ] -> codecpar -> width ) ; h = FFMAX ( h , avf -> streams [ i ] -> codecpar -> height ) ; } } if ( ! ( w && h ) ) { w = FFMAX ( w , 720 ) ; h = FFMAX ( h , 576 ) ; } av_log ( avf , AV_LOG_INFO , \"sub2video: using %dx%d canvas\\n\" , w , h ) ; } ist -> sub2video . w = ifilter -> width = w ; ist -> sub2video . h = ifilter -> height = h ; ifilter -> width = ist -> dec_ctx -> width ? ist -> dec_ctx -> width : ist -> sub2video . w ; ifilter -> height = ist -> dec_ctx -> height ? ist -> dec_ctx -> height : ist -> sub2video . h ; /* rectangles are AV_PIX_FMT_PAL8, but we have no guarantee that the\n       palettes for all rectangles are identical or compatible */ ifilter -> format = AV_PIX_FMT_RGB32 ; ist -> sub2video . frame = av_frame_alloc ( ) ; if ( ! ist -> sub2video . frame ) return AVERROR ( ENOMEM ) ; ist -> sub2video . last_pts = INT64_MIN ; ist -> sub2video . end_pts = INT64_MIN ; /* sub2video structure has been (re-)initialized.\n       Mark it as such so that the system will be\n       initialized with the first received heartbeat. */ ist -> sub2video . initialize = 1 ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@configure_input_video_filter": "static int configure_input_video_filter ( FilterGraph * fg , InputFilter * ifilter , AVFilterInOut * in ) { AVFilterContext * last_filter ; const AVFilter * buffer_filt = avfilter_get_by_name ( \"buffer\" ) ; const AVPixFmtDescriptor * desc ; InputStream * ist = ifilter -> ist ; InputFile * f = input_files [ ist -> file_index ] ; AVRational tb = ist -> framerate . num ? av_inv_q ( ist -> framerate ) : ist -> st -> time_base ; AVRational fr = ist -> framerate ; AVRational sar ; AVBPrint args ; char name [ 255 ] ; int ret , pad_idx = 0 ; int64_t tsoffset = 0 ; AVBufferSrcParameters * par = av_buffersrc_parameters_alloc ( ) ; if ( ! par ) return AVERROR ( ENOMEM ) ; memset ( par , 0 , sizeof ( * par ) ) ; par -> format = AV_PIX_FMT_NONE ; if ( ist -> dec_ctx -> codec_type == AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot connect video filter to audio input\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } if ( ! fr . num ) fr = ist -> framerate_guessed ; if ( ist -> dec_ctx -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { ret = sub2video_prepare ( ist , ifilter ) ; if ( ret < 0 ) goto fail ; } sar = ifilter -> sample_aspect_ratio ; if ( ! sar . den ) sar = ( AVRational ) { 0 , 1 } ; av_bprint_init ( & args , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; av_bprintf ( & args , \"video_size=%dx%d:pix_fmt=%d:time_base=%d/%d:\" \"pixel_aspect=%d/%d\" , ifilter -> width , ifilter -> height , ifilter -> format , tb . num , tb . den , sar . num , sar . den ) ; if ( fr . num && fr . den ) av_bprintf ( & args , \":frame_rate=%d/%d\" , fr . num , fr . den ) ; snprintf ( name , sizeof ( name ) , \"graph %d input from stream %d:%d\" , fg -> index , ist -> file_index , ist -> st -> index ) ; if ( ( ret = avfilter_graph_create_filter ( & ifilter -> filter , buffer_filt , name , args . str , NULL , fg -> graph ) ) < 0 ) goto fail ; par -> hw_frames_ctx = ifilter -> hw_frames_ctx ; ret = av_buffersrc_parameters_set ( ifilter -> filter , par ) ; if ( ret < 0 ) goto fail ; av_freep ( & par ) ; last_filter = ifilter -> filter ; desc = av_pix_fmt_desc_get ( ifilter -> format ) ; av_assert0 ( desc ) ; // TODO: insert hwaccel enabled filters like transpose_vaapi into the graph if ( ist -> autorotate && ! ( desc -> flags & AV_PIX_FMT_FLAG_HWACCEL ) ) { int32_t * displaymatrix = ifilter -> displaymatrix ; double theta ; if ( ! displaymatrix ) displaymatrix = ( int32_t * ) av_stream_get_side_data ( ist -> st , AV_PKT_DATA_DISPLAYMATRIX , NULL ) ; theta = get_rotation ( displaymatrix ) ; if ( fabs ( theta - 90 ) < 1.0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"transpose\" , displaymatrix [ 3 ] > 0 ? \"cclock_flip\" : \"clock\" ) ; } else if ( fabs ( theta - 180 ) < 1.0 ) { if ( displaymatrix [ 0 ] < 0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"hflip\" , NULL ) ; if ( ret < 0 ) return ret ; } if ( displaymatrix [ 4 ] < 0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"vflip\" , NULL ) ; } } else if ( fabs ( theta - 270 ) < 1.0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"transpose\" , displaymatrix [ 3 ] < 0 ? \"clock_flip\" : \"cclock\" ) ; } else if ( fabs ( theta ) > 1.0 ) { char rotate_buf [ 64 ] ; snprintf ( rotate_buf , sizeof ( rotate_buf ) , \"%f*PI/180\" , theta ) ; ret = insert_filter ( & last_filter , & pad_idx , \"rotate\" , rotate_buf ) ; } else if ( fabs ( theta ) < 1.0 ) { if ( displaymatrix && displaymatrix [ 4 ] < 0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"vflip\" , NULL ) ; } } if ( ret < 0 ) return ret ; } snprintf ( name , sizeof ( name ) , \"trim_in_%d_%d\" , ist -> file_index , ist -> st -> index ) ; if ( copy_ts ) { tsoffset = f -> start_time == AV_NOPTS_VALUE ? 0 : f -> start_time ; if ( ! start_at_zero && f -> ctx -> start_time != AV_NOPTS_VALUE ) tsoffset += f -> ctx -> start_time ; } ret = insert_trim ( ( ( f -> start_time == AV_NOPTS_VALUE ) || ! f -> accurate_seek ) ? AV_NOPTS_VALUE : tsoffset , f -> recording_time , & last_filter , & pad_idx , name ) ; if ( ret < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , 0 , in -> filter_ctx , in -> pad_idx ) ) < 0 ) return ret ; return 0 ; fail : av_freep ( & par ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@configure_input_audio_filter": "static int configure_input_audio_filter ( FilterGraph * fg , InputFilter * ifilter , AVFilterInOut * in ) { AVFilterContext * last_filter ; const AVFilter * abuffer_filt = avfilter_get_by_name ( \"abuffer\" ) ; InputStream * ist = ifilter -> ist ; InputFile * f = input_files [ ist -> file_index ] ; AVBPrint args ; char name [ 255 ] ; int ret , pad_idx = 0 ; int64_t tsoffset = 0 ; if ( ist -> dec_ctx -> codec_type != AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot connect audio filter to non audio input\\n\" ) ; return AVERROR ( EINVAL ) ; } av_bprint_init ( & args , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; av_bprintf ( & args , \"time_base=%d/%d:sample_rate=%d:sample_fmt=%s\" , 1 , ifilter -> sample_rate , ifilter -> sample_rate , av_get_sample_fmt_name ( ifilter -> format ) ) ; if ( av_channel_layout_check ( & ifilter -> ch_layout ) && ifilter -> ch_layout . order != AV_CHANNEL_ORDER_UNSPEC ) { av_bprintf ( & args , \":channel_layout=\" ) ; av_channel_layout_describe_bprint ( & ifilter -> ch_layout , & args ) ; } else av_bprintf ( & args , \":channels=%d\" , ifilter -> ch_layout . nb_channels ) ; snprintf ( name , sizeof ( name ) , \"graph_%d_in_%d_%d\" , fg -> index , ist -> file_index , ist -> st -> index ) ; if ( ( ret = avfilter_graph_create_filter ( & ifilter -> filter , abuffer_filt , name , args . str , NULL , fg -> graph ) ) < 0 ) return ret ; last_filter = ifilter -> filter ; # define AUTO_INSERT_FILTER_INPUT ( opt_name , filter_name , arg ) do { AVFilterContext * filt_ctx ; av_log ( NULL , AV_LOG_INFO , opt_name \" is forwarded to lavfi \" \"similarly to -af \" filter_name \"=%s.\\n\" , arg ) ; snprintf ( name , sizeof ( name ) , \"graph_%d_%s_in_%d_%d\" , fg -> index , filter_name , ist -> file_index , ist -> st -> index ) ; ret = avfilter_graph_create_filter ( & filt_ctx , avfilter_get_by_name ( filter_name ) , name , arg , NULL , fg -> graph ) ; if ( ret < 0 ) return ret ; ret = avfilter_link ( last_filter , 0 , filt_ctx , 0 ) ; if ( ret < 0 ) return ret ; last_filter = filt_ctx ; \\\n} while ( 0 ) snprintf ( name , sizeof ( name ) , \"trim for input stream %d:%d\" , ist -> file_index , ist -> st -> index ) ; if ( copy_ts ) { tsoffset = f -> start_time == AV_NOPTS_VALUE ? 0 : f -> start_time ; if ( ! start_at_zero && f -> ctx -> start_time != AV_NOPTS_VALUE ) tsoffset += f -> ctx -> start_time ; } ret = insert_trim ( ( ( f -> start_time == AV_NOPTS_VALUE ) || ! f -> accurate_seek ) ? AV_NOPTS_VALUE : tsoffset , f -> recording_time , & last_filter , & pad_idx , name ) ; if ( ret < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , 0 , in -> filter_ctx , in -> pad_idx ) ) < 0 ) return ret ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@configure_input_filter": "static int configure_input_filter ( FilterGraph * fg , InputFilter * ifilter , AVFilterInOut * in ) { if ( ! ifilter -> ist -> dec ) { av_log ( NULL , AV_LOG_ERROR , \"No decoder for stream #%d:%d, filtering impossible\\n\" , ifilter -> ist -> file_index , ifilter -> ist -> st -> index ) ; return AVERROR_DECODER_NOT_FOUND ; } switch ( avfilter_pad_get_type ( in -> filter_ctx -> input_pads , in -> pad_idx ) ) { case AVMEDIA_TYPE_VIDEO : return configure_input_video_filter ( fg , ifilter , in ) ; case AVMEDIA_TYPE_AUDIO : return configure_input_audio_filter ( fg , ifilter , in ) ; default : av_assert0 ( 0 ) ; return 0 ; } }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@cleanup_filtergraph": "static void cleanup_filtergraph ( FilterGraph * fg ) { int i ; for ( i = 0 ; i < fg -> nb_outputs ; i ++ ) fg -> outputs [ i ] -> filter = ( AVFilterContext * ) NULL ; for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) fg -> inputs [ i ] -> filter = ( AVFilterContext * ) NULL ; avfilter_graph_free ( & fg -> graph ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@filter_is_buffersrc": "static int filter_is_buffersrc ( const AVFilterContext * f ) { return f -> nb_inputs == 0 && ( ! strcmp ( f -> filter -> name , \"buffer\" ) || ! strcmp ( f -> filter -> name , \"abuffer\" ) ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@graph_is_meta": "static int graph_is_meta ( AVFilterGraph * graph ) { for ( unsigned i = 0 ; i < graph -> nb_filters ; i ++ ) { const AVFilterContext * f = graph -> filters [ i ] ; /* in addition to filters flagged as meta, also\n         * disregard sinks and buffersources (but not other sources,\n         * since they introduce data we are not aware of)\n         */ if ( ! ( ( f -> filter -> flags & AVFILTER_FLAG_METADATA_ONLY ) || f -> nb_outputs == 0 || filter_is_buffersrc ( f ) ) ) return 0 ; } return 1 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@configure_filtergraph": "int configure_filtergraph ( FilterGraph * fg ) { AVFilterInOut * inputs , * outputs , * cur ; int ret , i , simple = filtergraph_is_simple ( fg ) ; const char * graph_desc = simple ? fg -> outputs [ 0 ] -> ost -> avfilter : fg -> graph_desc ; cleanup_filtergraph ( fg ) ; if ( ! ( fg -> graph = avfilter_graph_alloc ( ) ) ) return AVERROR ( ENOMEM ) ; if ( simple ) { OutputStream * ost = fg -> outputs [ 0 ] -> ost ; if ( filter_nbthreads ) { ret = av_opt_set ( fg -> graph , \"threads\" , filter_nbthreads , 0 ) ; if ( ret < 0 ) goto fail ; } else { const AVDictionaryEntry * e = NULL ; e = av_dict_get ( ost -> encoder_opts , \"threads\" , NULL , 0 ) ; if ( e ) av_opt_set ( fg -> graph , \"threads\" , e -> value , 0 ) ; } if ( av_dict_count ( ost -> sws_dict ) ) { ret = av_dict_get_string ( ost -> sws_dict , & fg -> graph -> scale_sws_opts , '=' , ':' ) ; if ( ret < 0 ) goto fail ; } if ( av_dict_count ( ost -> swr_opts ) ) { char * args ; ret = av_dict_get_string ( ost -> swr_opts , & args , '=' , ':' ) ; if ( ret < 0 ) goto fail ; av_opt_set ( fg -> graph , \"aresample_swr_opts\" , args , 0 ) ; av_free ( args ) ; } } else { fg -> graph -> nb_threads = filter_complex_nbthreads ; } if ( ( ret = graph_parse ( fg -> graph , graph_desc , & inputs , & outputs ) ) < 0 ) goto fail ; ret = hw_device_setup_for_filter ( fg ) ; if ( ret < 0 ) goto fail ; if ( simple && ( ! inputs || inputs -> next || ! outputs || outputs -> next ) ) { const char * num_inputs ; const char * num_outputs ; if ( ! outputs ) { num_outputs = \"0\" ; } else if ( outputs -> next ) { num_outputs = \">1\" ; } else { num_outputs = \"1\" ; } if ( ! inputs ) { num_inputs = \"0\" ; } else if ( inputs -> next ) { num_inputs = \">1\" ; } else { num_inputs = \"1\" ; } av_log ( NULL , AV_LOG_ERROR , \"Simple filtergraph '%s' was expected \" \"to have exactly 1 input and 1 output.\" \" However, it had %s input(s) and %s output(s).\" \" Please adjust, or use a complex filtergraph (-filter_complex) instead.\\n\" , graph_desc , num_inputs , num_outputs ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } for ( cur = inputs , i = 0 ; cur ; cur = cur -> next , i ++ ) if ( ( ret = configure_input_filter ( fg , fg -> inputs [ i ] , cur ) ) < 0 ) { avfilter_inout_free ( & inputs ) ; avfilter_inout_free ( & outputs ) ; goto fail ; } avfilter_inout_free ( & inputs ) ; for ( cur = outputs , i = 0 ; cur ; cur = cur -> next , i ++ ) configure_output_filter ( fg , fg -> outputs [ i ] , cur ) ; avfilter_inout_free ( & outputs ) ; if ( ! auto_conversion_filters ) avfilter_graph_set_auto_convert ( fg -> graph , AVFILTER_AUTO_CONVERT_NONE ) ; if ( ( ret = avfilter_graph_config ( fg -> graph , NULL ) ) < 0 ) goto fail ; fg -> is_meta = graph_is_meta ( fg -> graph ) ; /* limit the lists of allowed formats to the ones selected, to\n     * make sure they stay the same if the filtergraph is reconfigured later */ for ( i = 0 ; i < fg -> nb_outputs ; i ++ ) { OutputFilter * ofilter = fg -> outputs [ i ] ; AVFilterContext * sink = ofilter -> filter ; ofilter -> format = av_buffersink_get_format ( sink ) ; ofilter -> width = av_buffersink_get_w ( sink ) ; ofilter -> height = av_buffersink_get_h ( sink ) ; ofilter -> sample_rate = av_buffersink_get_sample_rate ( sink ) ; av_channel_layout_uninit ( & ofilter -> ch_layout ) ; ret = av_buffersink_get_ch_layout ( sink , & ofilter -> ch_layout ) ; if ( ret < 0 ) goto fail ; } fg -> reconfiguration = 1 ; for ( i = 0 ; i < fg -> nb_outputs ; i ++ ) { OutputStream * ost = fg -> outputs [ i ] -> ost ; if ( ost -> enc_ctx -> codec_type == AVMEDIA_TYPE_AUDIO && ! ( ost -> enc_ctx -> codec -> capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE ) ) av_buffersink_set_frame_size ( ost -> filter -> filter , ost -> enc_ctx -> frame_size ) ; } for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) { AVFrame * tmp ; while ( av_fifo_read ( fg -> inputs [ i ] -> frame_queue , & tmp , 1 ) >= 0 ) { ret = av_buffersrc_add_frame ( fg -> inputs [ i ] -> filter , tmp ) ; av_frame_free ( & tmp ) ; if ( ret < 0 ) goto fail ; } } /* send the EOFs for the finished inputs */ for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) { if ( fg -> inputs [ i ] -> eof ) { ret = av_buffersrc_add_frame ( fg -> inputs [ i ] -> filter , NULL ) ; if ( ret < 0 ) goto fail ; } } /* process queued up subtitle packets */ for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) { InputStream * ist = fg -> inputs [ i ] -> ist ; if ( ist -> sub2video . sub_queue && ist -> sub2video . frame ) { AVSubtitle tmp ; while ( av_fifo_read ( ist -> sub2video . sub_queue , & tmp , 1 ) >= 0 ) { sub2video_update ( ist , INT64_MIN , & tmp ) ; avsubtitle_free ( & tmp ) ; } } } return 0 ; fail : cleanup_filtergraph ( fg ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@ifilter_parameters_from_frame": "int ifilter_parameters_from_frame ( InputFilter * ifilter , const AVFrame * frame ) { AVFrameSideData * sd ; int ret ; av_buffer_unref ( & ifilter -> hw_frames_ctx ) ; ifilter -> format = frame -> format ; ifilter -> width = frame -> width ; ifilter -> height = frame -> height ; ifilter -> sample_aspect_ratio = frame -> sample_aspect_ratio ; ifilter -> sample_rate = frame -> sample_rate ; ret = av_channel_layout_copy ( & ifilter -> ch_layout , & frame -> ch_layout ) ; if ( ret < 0 ) return ret ; av_freep ( & ifilter -> displaymatrix ) ; sd = av_frame_get_side_data ( frame , AV_FRAME_DATA_DISPLAYMATRIX ) ; if ( sd ) ifilter -> displaymatrix = av_memdup ( sd -> data , sizeof ( int32_t ) * 9 ) ; if ( frame -> hw_frames_ctx ) { ifilter -> hw_frames_ctx = av_buffer_ref ( frame -> hw_frames_ctx ) ; if ( ! ifilter -> hw_frames_ctx ) return AVERROR ( ENOMEM ) ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_filter.c@filtergraph_is_simple": "int filtergraph_is_simple ( FilterGraph * fg ) { return ! fg -> graph_desc ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@ms_from_ost": "MuxStream * ms_from_ost ( OutputStream * ost ) { return ( MuxStream * ) ost ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@mux_from_of": "static Muxer * mux_from_of ( OutputFile * of ) { return ( Muxer * ) of ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@filesize": "static int64_t filesize ( AVIOContext * pb ) { int64_t ret = - 1 ; if ( pb ) { ret = avio_size ( pb ) ; if ( ret <= 0 ) // FIXME improve avio_size() so it works with non seekable output too ret = avio_tell ( pb ) ; } return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@write_packet": "static int write_packet ( Muxer * mux , OutputStream * ost , AVPacket * pkt ) { MuxStream * ms = ms_from_ost ( ost ) ; AVFormatContext * s = mux -> fc ; AVStream * st = ost -> st ; int64_t fs ; uint64_t frame_num ; int ret ; fs = filesize ( s -> pb ) ; atomic_store ( & mux -> last_filesize , fs ) ; if ( fs >= mux -> limit_filesize ) { ret = AVERROR_EOF ; goto fail ; } if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && ost -> vsync_method == VSYNC_DROP ) pkt -> pts = pkt -> dts = AV_NOPTS_VALUE ; if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { if ( ost -> frame_rate . num && ost -> is_cfr ) { if ( pkt -> duration > 0 ) av_log ( ost , AV_LOG_WARNING , \"Overriding packet duration by frame rate, this should not happen\\n\" ) ; pkt -> duration = av_rescale_q ( 1 , av_inv_q ( ost -> frame_rate ) , pkt -> time_base ) ; } } av_packet_rescale_ts ( pkt , pkt -> time_base , ost -> st -> time_base ) ; pkt -> time_base = ost -> st -> time_base ; if ( ! ( s -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ) { if ( pkt -> dts != AV_NOPTS_VALUE && pkt -> pts != AV_NOPTS_VALUE && pkt -> dts > pkt -> pts ) { av_log ( s , AV_LOG_WARNING , \"Invalid DTS: %\" PRId64 \" PTS: %\" PRId64 \" in output stream %d:%d, replacing by guess\\n\" , pkt -> dts , pkt -> pts , ost -> file_index , ost -> st -> index ) ; pkt -> pts = pkt -> dts = pkt -> pts + pkt -> dts + ms -> last_mux_dts + 1 - FFMIN3 ( pkt -> pts , pkt -> dts , ms -> last_mux_dts + 1 ) - FFMAX3 ( pkt -> pts , pkt -> dts , ms -> last_mux_dts + 1 ) ; } if ( ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO || st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO || st -> codecpar -> codec_type == AVMEDIA_TYPE_SUBTITLE ) && pkt -> dts != AV_NOPTS_VALUE && ms -> last_mux_dts != AV_NOPTS_VALUE ) { int64_t max = ms -> last_mux_dts + ! ( s -> oformat -> flags & AVFMT_TS_NONSTRICT ) ; if ( pkt -> dts < max ) { int loglevel = max - pkt -> dts > 2 || st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ? AV_LOG_WARNING : AV_LOG_DEBUG ; if ( exit_on_error ) loglevel = AV_LOG_ERROR ; av_log ( s , loglevel , \"Non-monotonous DTS in output stream \" \"%d:%d; previous: %\" PRId64 \", current: %\" PRId64 \"; \" , ost -> file_index , ost -> st -> index , ms -> last_mux_dts , pkt -> dts ) ; if ( exit_on_error ) { ret = AVERROR ( EINVAL ) ; goto fail ; } av_log ( s , loglevel , \"changing to %\" PRId64 \". This may result \" \"in incorrect timestamps in the output file.\\n\" , max ) ; if ( pkt -> pts >= pkt -> dts ) pkt -> pts = FFMAX ( pkt -> pts , max ) ; pkt -> dts = max ; } } } ms -> last_mux_dts = pkt -> dts ; ost -> data_size_mux += pkt -> size ; frame_num = atomic_fetch_add ( & ost -> packets_written , 1 ) ; pkt -> stream_index = ost -> index ; if ( debug_ts ) { av_log ( ost , AV_LOG_INFO , \"muxer <- type:%s \" \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s size:%d\\n\" , av_get_media_type_string ( st -> codecpar -> codec_type ) , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & ost -> st -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & ost -> st -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & ost -> st -> time_base ) , pkt -> size ) ; } if ( ms -> stats . io ) enc_stats_write ( ost , & ms -> stats , NULL , pkt , frame_num ) ; ret = av_interleaved_write_frame ( s , pkt ) ; if ( ret < 0 ) { print_error ( \"av_interleaved_write_frame()\" , ret ) ; goto fail ; } return 0 ; fail : av_packet_unref ( pkt ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@sync_queue_process": "static int sync_queue_process ( Muxer * mux , OutputStream * ost , AVPacket * pkt , int * stream_eof ) { OutputFile * of = & mux -> of ; if ( ost -> sq_idx_mux >= 0 ) { int ret = sq_send ( mux -> sq_mux , ost -> sq_idx_mux , SQPKT ( pkt ) ) ; if ( ret < 0 ) { if ( ret == AVERROR_EOF ) * stream_eof = 1 ; return ret ; } while ( 1 ) { ret = sq_receive ( mux -> sq_mux , - 1 , SQPKT ( mux -> sq_pkt ) ) ; if ( ret < 0 ) return ( ret == AVERROR_EOF || ret == AVERROR ( EAGAIN ) ) ? 0 : ret ; ret = write_packet ( mux , of -> streams [ ret ] , mux -> sq_pkt ) ; if ( ret < 0 ) return ret ; } } else if ( pkt ) return write_packet ( mux , ost , pkt ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@thread_set_name": "static void thread_set_name ( OutputFile * of ) { char name [ 16 ] ; snprintf ( name , sizeof ( name ) , \"mux%d:%s\" , of -> index , of -> format -> name ) ; ff_thread_setname ( name ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@muxer_thread": "static void * muxer_thread ( void * arg ) { Muxer * mux = arg ; OutputFile * of = & mux -> of ; AVPacket * pkt = NULL ; int ret = 0 ; pkt = av_packet_alloc ( ) ; if ( ! pkt ) { ret = AVERROR ( ENOMEM ) ; goto finish ; } thread_set_name ( of ) ; while ( 1 ) { OutputStream * ost ; int stream_idx , stream_eof = 0 ; ret = tq_receive ( mux -> tq , & stream_idx , pkt ) ; if ( stream_idx < 0 ) { av_log ( mux , AV_LOG_VERBOSE , \"All streams finished\\n\" ) ; ret = 0 ; break ; } ost = of -> streams [ stream_idx ] ; ret = sync_queue_process ( mux , ost , ret < 0 ? NULL : pkt , & stream_eof ) ; av_packet_unref ( pkt ) ; if ( ret == AVERROR_EOF && stream_eof ) tq_receive_finish ( mux -> tq , stream_idx ) ; else if ( ret < 0 ) { av_log ( mux , AV_LOG_ERROR , \"Error muxing a packet\\n\" ) ; break ; } } finish : av_packet_free ( & pkt ) ; for ( unsigned int i = 0 ; i < mux -> fc -> nb_streams ; i ++ ) tq_receive_finish ( mux -> tq , i ) ; av_log ( mux , AV_LOG_VERBOSE , \"Terminating muxer thread\\n\" ) ; return ( void * ) ( intptr_t ) ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@thread_submit_packet": "static int thread_submit_packet ( Muxer * mux , OutputStream * ost , AVPacket * pkt ) { int ret = 0 ; if ( ! pkt || ost -> finished & MUXER_FINISHED ) goto finish ; ret = tq_send ( mux -> tq , ost -> index , pkt ) ; if ( ret < 0 ) goto finish ; return 0 ; finish : if ( pkt ) av_packet_unref ( pkt ) ; ost -> finished |= MUXER_FINISHED ; tq_send_finish ( mux -> tq , ost -> index ) ; return ret == AVERROR_EOF ? 0 : ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@queue_packet": "static int queue_packet ( Muxer * mux , OutputStream * ost , AVPacket * pkt ) { MuxStream * ms = ms_from_ost ( ost ) ; AVPacket * tmp_pkt = NULL ; int ret ; if ( ! av_fifo_can_write ( ms -> muxing_queue ) ) { size_t cur_size = av_fifo_can_read ( ms -> muxing_queue ) ; size_t pkt_size = pkt ? pkt -> size : 0 ; unsigned int are_we_over_size = ( ms -> muxing_queue_data_size + pkt_size ) > ms -> muxing_queue_data_threshold ; size_t limit = are_we_over_size ? ms -> max_muxing_queue_size : SIZE_MAX ; size_t new_size = FFMIN ( 2 * cur_size , limit ) ; if ( new_size <= cur_size ) { av_log ( ost , AV_LOG_ERROR , \"Too many packets buffered for output stream %d:%d.\\n\" , ost -> file_index , ost -> st -> index ) ; return AVERROR ( ENOSPC ) ; } ret = av_fifo_grow2 ( ms -> muxing_queue , new_size - cur_size ) ; if ( ret < 0 ) return ret ; } if ( pkt ) { ret = av_packet_make_refcounted ( pkt ) ; if ( ret < 0 ) return ret ; tmp_pkt = av_packet_alloc ( ) ; if ( ! tmp_pkt ) return AVERROR ( ENOMEM ) ; av_packet_move_ref ( tmp_pkt , pkt ) ; ms -> muxing_queue_data_size += tmp_pkt -> size ; } av_fifo_write ( ms -> muxing_queue , & tmp_pkt , 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@submit_packet": "static int submit_packet ( Muxer * mux , AVPacket * pkt , OutputStream * ost ) { int ret ; if ( mux -> tq ) { return thread_submit_packet ( mux , ost , pkt ) ; } else { /* the muxer is not initialized yet, buffer the packet */ ret = queue_packet ( mux , ost , pkt ) ; if ( ret < 0 ) { if ( pkt ) av_packet_unref ( pkt ) ; return ret ; } } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@of_output_packet": "void of_output_packet ( OutputFile * of , AVPacket * pkt , OutputStream * ost , int eof ) { Muxer * mux = mux_from_of ( of ) ; MuxStream * ms = ms_from_ost ( ost ) ; const char * err_msg ; int ret = 0 ; if ( ! eof && pkt -> dts != AV_NOPTS_VALUE ) ost -> last_mux_dts = av_rescale_q ( pkt -> dts , pkt -> time_base , AV_TIME_BASE_Q ) ; /* apply the output bitstream filters */ if ( ms -> bsf_ctx ) { int bsf_eof = 0 ; ret = av_bsf_send_packet ( ms -> bsf_ctx , eof ? NULL : pkt ) ; if ( ret < 0 ) { err_msg = \"submitting a packet for bitstream filtering\" ; goto fail ; } while ( ! bsf_eof ) { ret = av_bsf_receive_packet ( ms -> bsf_ctx , pkt ) ; if ( ret == AVERROR ( EAGAIN ) ) return ; else if ( ret == AVERROR_EOF ) bsf_eof = 1 ; else if ( ret < 0 ) { err_msg = \"applying bitstream filters to a packet\" ; goto fail ; } ret = submit_packet ( mux , bsf_eof ? NULL : pkt , ost ) ; if ( ret < 0 ) goto mux_fail ; } } else { ret = submit_packet ( mux , eof ? NULL : pkt , ost ) ; if ( ret < 0 ) goto mux_fail ; } return ; mux_fail : err_msg = \"submitting a packet to the muxer\" ; fail : av_log ( ost , AV_LOG_ERROR , \"Error %s\\n\" , err_msg ) ; if ( exit_on_error ) exit_program ( 1 ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@thread_stop": "static int thread_stop ( Muxer * mux ) { void * ret ; if ( ! mux || ! mux -> tq ) return 0 ; for ( unsigned int i = 0 ; i < mux -> fc -> nb_streams ; i ++ ) tq_send_finish ( mux -> tq , i ) ; pthread_join ( mux -> thread , & ret ) ; tq_free ( & mux -> tq ) ; return ( int ) ( intptr_t ) ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@pkt_move": "static void pkt_move ( void * dst , void * src ) { av_packet_move_ref ( dst , src ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@thread_start": "static int thread_start ( Muxer * mux ) { AVFormatContext * fc = mux -> fc ; ObjPool * op ; int ret ; op = objpool_alloc_packets ( ) ; if ( ! op ) return AVERROR ( ENOMEM ) ; mux -> tq = tq_alloc ( fc -> nb_streams , mux -> thread_queue_size , op , pkt_move ) ; if ( ! mux -> tq ) { objpool_free ( & op ) ; return AVERROR ( ENOMEM ) ; } ret = pthread_create ( & mux -> thread , NULL , muxer_thread , ( void * ) mux ) ; if ( ret ) { tq_free ( & mux -> tq ) ; return AVERROR ( ret ) ; } /* flush the muxing queues */ for ( int i = 0 ; i < fc -> nb_streams ; i ++ ) { OutputStream * ost = mux -> of . streams [ i ] ; MuxStream * ms = ms_from_ost ( ost ) ; AVPacket * pkt ; /* try to improve muxing time_base (only possible if nothing has been written yet) */ if ( ! av_fifo_can_read ( ms -> muxing_queue ) ) ost -> mux_timebase = ost -> st -> time_base ; while ( av_fifo_read ( ms -> muxing_queue , & pkt , 1 ) >= 0 ) { ret = thread_submit_packet ( mux , ost , pkt ) ; if ( pkt ) { ms -> muxing_queue_data_size -= pkt -> size ; av_packet_free ( & pkt ) ; } if ( ret < 0 ) return ret ; } } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@print_sdp": "static int print_sdp ( void ) { char sdp [ 16384 ] ; int i ; int j , ret ; AVIOContext * sdp_pb ; AVFormatContext * * avc ; for ( i = 0 ; i < nb_output_files ; i ++ ) { if ( ! mux_from_of ( output_files [ i ] ) -> header_written ) return 0 ; } avc = av_malloc_array ( nb_output_files , sizeof ( * avc ) ) ; if ( ! avc ) return AVERROR ( ENOMEM ) ; for ( i = 0 , j = 0 ; i < nb_output_files ; i ++ ) { if ( ! strcmp ( output_files [ i ] -> format -> name , \"rtp\" ) ) { avc [ j ] = mux_from_of ( output_files [ i ] ) -> fc ; j ++ ; } } if ( ! j ) { av_log ( NULL , AV_LOG_ERROR , \"No output streams in the SDP.\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } ret = av_sdp_create ( avc , j , sdp , sizeof ( sdp ) ) ; if ( ret < 0 ) goto fail ; if ( ! sdp_filename ) { av_log ( NULL , AV_LOG_ERROR , \"SDP:\\n%s\\n\" , sdp ) ; fflush ( stdout ) ; } else { ret = avio_open2 ( & sdp_pb , sdp_filename , AVIO_FLAG_WRITE , & int_cb , NULL ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Failed to open sdp file '%s'\\n\" , sdp_filename ) ; goto fail ; } avio_print ( sdp_pb , sdp ) ; avio_closep ( & sdp_pb ) ; av_freep ( & sdp_filename ) ; } // SDP successfully written, allow muxer threads to start ret = 1 ; fail : av_freep ( & avc ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@mux_check_init": "int mux_check_init ( Muxer * mux ) { OutputFile * of = & mux -> of ; AVFormatContext * fc = mux -> fc ; int ret , i ; for ( i = 0 ; i < fc -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; if ( ! ost -> initialized ) return 0 ; } ret = avformat_write_header ( fc , & mux -> opts ) ; if ( ret < 0 ) { av_log ( mux , AV_LOG_ERROR , \"Could not write header (incorrect codec \" \"parameters ?): %s\\n\" , av_err2str ( ret ) ) ; return ret ; } //assert_avoptions(of->opts); mux -> header_written = 1 ; av_dump_format ( fc , of -> index , fc -> url , 1 ) ; nb_output_dumped ++ ; if ( sdp_filename || want_sdp ) { ret = print_sdp ( ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error writing the SDP.\\n\" ) ; return ret ; } else if ( ret == 1 ) { /* SDP is written only after all the muxers are ready, so now we\n             * start ALL the threads */ for ( i = 0 ; i < nb_output_files ; i ++ ) { ret = thread_start ( mux_from_of ( output_files [ i ] ) ) ; if ( ret < 0 ) return ret ; } } } else { ret = thread_start ( mux_from_of ( of ) ) ; if ( ret < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@bsf_init": "static int bsf_init ( MuxStream * ms ) { OutputStream * ost = & ms -> ost ; AVBSFContext * ctx = ms -> bsf_ctx ; int ret ; if ( ! ctx ) return 0 ; ret = avcodec_parameters_copy ( ctx -> par_in , ost -> st -> codecpar ) ; if ( ret < 0 ) return ret ; ctx -> time_base_in = ost -> st -> time_base ; ret = av_bsf_init ( ctx ) ; if ( ret < 0 ) { av_log ( ms , AV_LOG_ERROR , \"Error initializing bitstream filter: %s\\n\" , ctx -> filter -> name ) ; return ret ; } ret = avcodec_parameters_copy ( ost -> st -> codecpar , ctx -> par_out ) ; if ( ret < 0 ) return ret ; ost -> st -> time_base = ctx -> time_base_out ; return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@of_stream_init": "int of_stream_init ( OutputFile * of , OutputStream * ost ) { Muxer * mux = mux_from_of ( of ) ; MuxStream * ms = ms_from_ost ( ost ) ; int ret ; if ( ost -> sq_idx_mux >= 0 ) sq_set_tb ( mux -> sq_mux , ost -> sq_idx_mux , ost -> mux_timebase ) ; /* initialize bitstream filters for the output stream\n     * needs to be done here, because the codec id for streamcopy is not\n     * known until now */ ret = bsf_init ( ms ) ; if ( ret < 0 ) return ret ; ost -> initialized = 1 ; return mux_check_init ( mux ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@of_write_trailer": "int of_write_trailer ( OutputFile * of ) { Muxer * mux = mux_from_of ( of ) ; AVFormatContext * fc = mux -> fc ; int ret ; if ( ! mux -> tq ) { av_log ( mux , AV_LOG_ERROR , \"Nothing was written into output file, because \" \"at least one of its streams received no packets.\\n\" ) ; return AVERROR ( EINVAL ) ; } ret = thread_stop ( mux ) ; if ( ret < 0 ) main_ffmpeg_return_code = ret ; ret = av_write_trailer ( fc ) ; if ( ret < 0 ) { av_log ( mux , AV_LOG_ERROR , \"Error writing trailer: %s\\n\" , av_err2str ( ret ) ) ; return ret ; } mux -> last_filesize = filesize ( fc -> pb ) ; if ( ! ( of -> format -> flags & AVFMT_NOFILE ) ) { ret = avio_closep ( & fc -> pb ) ; if ( ret < 0 ) { av_log ( mux , AV_LOG_ERROR , \"Error closing file: %s\\n\" , av_err2str ( ret ) ) ; return ret ; } } return 0 ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@ost_free": "static void ost_free ( OutputStream * * post ) { OutputStream * ost = * post ; MuxStream * ms ; if ( ! ost ) return ; ms = ms_from_ost ( ost ) ; if ( ost -> logfile ) { if ( fclose ( ost -> logfile ) ) av_log ( ms , AV_LOG_ERROR , \"Error closing logfile, loss of information possible: %s\\n\" , av_err2str ( AVERROR ( errno ) ) ) ; ost -> logfile = NULL ; } if ( ms -> muxing_queue ) { AVPacket * pkt ; while ( av_fifo_read ( ms -> muxing_queue , & pkt , 1 ) >= 0 ) av_packet_free ( & pkt ) ; av_fifo_freep2 ( & ms -> muxing_queue ) ; } av_bsf_free ( & ms -> bsf_ctx ) ; av_frame_free ( & ost -> filtered_frame ) ; av_frame_free ( & ost -> sq_frame ) ; av_frame_free ( & ost -> last_frame ) ; av_packet_free ( & ost -> pkt ) ; av_dict_free ( & ost -> encoder_opts ) ; av_freep ( & ost -> kf . pts ) ; av_expr_free ( ost -> kf . pexpr ) ; av_freep ( & ost -> avfilter ) ; av_freep ( & ost -> logfile_prefix ) ; av_freep ( & ost -> apad ) ; # if FFMPEG_OPT_MAP_CHANNEL av_freep ( & ost -> audio_channels_map ) ; ost -> audio_channels_mapped = 0 ; # endif av_dict_free ( & ost -> sws_dict ) ; av_dict_free ( & ost -> swr_opts ) ; if ( ost -> enc_ctx ) av_freep ( & ost -> enc_ctx -> stats_in ) ; avcodec_free_context ( & ost -> enc_ctx ) ; for ( int i = 0 ; i < ost -> enc_stats_pre . nb_components ; i ++ ) av_freep ( & ost -> enc_stats_pre . components [ i ] . str ) ; av_freep ( & ost -> enc_stats_pre . components ) ; for ( int i = 0 ; i < ost -> enc_stats_post . nb_components ; i ++ ) av_freep ( & ost -> enc_stats_post . components [ i ] . str ) ; av_freep ( & ost -> enc_stats_post . components ) ; for ( int i = 0 ; i < ms -> stats . nb_components ; i ++ ) av_freep ( & ms -> stats . components [ i ] . str ) ; av_freep ( & ms -> stats . components ) ; av_freep ( post ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@fc_close": "static void fc_close ( AVFormatContext * * pfc ) { AVFormatContext * fc = * pfc ; if ( ! fc ) return ; if ( ! ( fc -> oformat -> flags & AVFMT_NOFILE ) ) avio_closep ( & fc -> pb ) ; avformat_free_context ( fc ) ; * pfc = NULL ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@of_close": "void of_close ( OutputFile * * pof ) { OutputFile * of = * pof ; Muxer * mux ; if ( ! of ) return ; mux = mux_from_of ( of ) ; thread_stop ( mux ) ; sq_free ( & of -> sq_encode ) ; sq_free ( & mux -> sq_mux ) ; for ( int i = 0 ; i < of -> nb_streams ; i ++ ) ost_free ( & of -> streams [ i ] ) ; av_freep ( & of -> streams ) ; av_dict_free ( & mux -> opts ) ; av_packet_free ( & mux -> sq_pkt ) ; fc_close ( & mux -> fc ) ; av_freep ( pof ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_ffmpeg_mux.c@of_filesize": "int64_t of_filesize ( OutputFile * of ) { Muxer * mux = mux_from_of ( of ) ; return atomic_load ( & mux -> last_filesize ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_thread_queue.c@tq_free": "void tq_free ( ThreadQueue * * ptq ) { ThreadQueue * tq = * ptq ; if ( ! tq ) return ; if ( tq -> fifo ) { FifoElem elem ; while ( av_fifo_read ( tq -> fifo , & elem , 1 ) >= 0 ) objpool_release ( tq -> obj_pool , & elem . obj ) ; } av_fifo_freep2 ( & tq -> fifo ) ; objpool_free ( & tq -> obj_pool ) ; av_freep ( & tq -> finished ) ; pthread_cond_destroy ( & tq -> cond ) ; pthread_mutex_destroy ( & tq -> lock ) ; av_freep ( ptq ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_thread_queue.c@tq_alloc": "ThreadQueue * tq_alloc ( unsigned int nb_streams , size_t queue_size , ObjPool * obj_pool , void ( * obj_move ) ( void * dst , void * src ) ) { ThreadQueue * tq ; int ret ; tq = av_mallocz ( sizeof ( * tq ) ) ; if ( ! tq ) return NULL ; ret = pthread_cond_init ( & tq -> cond , NULL ) ; if ( ret ) { av_freep ( & tq ) ; return NULL ; } ret = pthread_mutex_init ( & tq -> lock , NULL ) ; if ( ret ) { pthread_cond_destroy ( & tq -> cond ) ; av_freep ( & tq ) ; return NULL ; } tq -> finished = av_calloc ( nb_streams , sizeof ( * tq -> finished ) ) ; if ( ! tq -> finished ) goto fail ; tq -> nb_streams = nb_streams ; tq -> fifo = av_fifo_alloc2 ( queue_size , sizeof ( FifoElem ) , 0 ) ; if ( ! tq -> fifo ) goto fail ; tq -> obj_pool = obj_pool ; tq -> obj_move = obj_move ; return tq ; fail : tq_free ( & tq ) ; return NULL ; }",
    "resources/ffmpeg-kit/apple/src/fftools_thread_queue.c@tq_send": "int tq_send ( ThreadQueue * tq , unsigned int stream_idx , void * data ) { int * finished ; int ret ; av_assert0 ( stream_idx < tq -> nb_streams ) ; finished = & tq -> finished [ stream_idx ] ; pthread_mutex_lock ( & tq -> lock ) ; if ( * finished & FINISHED_SEND ) { ret = AVERROR ( EINVAL ) ; goto finish ; } while ( ! ( * finished & FINISHED_RECV ) && ! av_fifo_can_write ( tq -> fifo ) ) pthread_cond_wait ( & tq -> cond , & tq -> lock ) ; if ( * finished & FINISHED_RECV ) { ret = AVERROR_EOF ; * finished |= FINISHED_SEND ; } else { FifoElem elem = { . stream_idx = stream_idx } ; ret = objpool_get ( tq -> obj_pool , & elem . obj ) ; if ( ret < 0 ) goto finish ; tq -> obj_move ( elem . obj , data ) ; ret = av_fifo_write ( tq -> fifo , & elem , 1 ) ; av_assert0 ( ret >= 0 ) ; pthread_cond_broadcast ( & tq -> cond ) ; } finish : pthread_mutex_unlock ( & tq -> lock ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_thread_queue.c@receive_locked": "static int receive_locked ( ThreadQueue * tq , int * stream_idx , void * data ) { FifoElem elem ; unsigned int nb_finished = 0 ; if ( av_fifo_read ( tq -> fifo , & elem , 1 ) >= 0 ) { tq -> obj_move ( data , elem . obj ) ; objpool_release ( tq -> obj_pool , & elem . obj ) ; * stream_idx = elem . stream_idx ; return 0 ; } for ( unsigned int i = 0 ; i < tq -> nb_streams ; i ++ ) { if ( ! ( tq -> finished [ i ] & FINISHED_SEND ) ) continue ; /* return EOF to the consumer at most once for each stream */ if ( ! ( tq -> finished [ i ] & FINISHED_RECV ) ) { tq -> finished [ i ] |= FINISHED_RECV ; * stream_idx = i ; return AVERROR_EOF ; } nb_finished ++ ; } return nb_finished == tq -> nb_streams ? AVERROR_EOF : AVERROR ( EAGAIN ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_thread_queue.c@tq_receive": "int tq_receive ( ThreadQueue * tq , int * stream_idx , void * data ) { int ret ; * stream_idx = - 1 ; pthread_mutex_lock ( & tq -> lock ) ; while ( 1 ) { ret = receive_locked ( tq , stream_idx , data ) ; if ( ret == AVERROR ( EAGAIN ) ) { pthread_cond_wait ( & tq -> cond , & tq -> lock ) ; continue ; } break ; } if ( ret == 0 ) pthread_cond_broadcast ( & tq -> cond ) ; pthread_mutex_unlock ( & tq -> lock ) ; return ret ; }",
    "resources/ffmpeg-kit/apple/src/fftools_thread_queue.c@tq_send_finish": "void tq_send_finish ( ThreadQueue * tq , unsigned int stream_idx ) { av_assert0 ( stream_idx < tq -> nb_streams ) ; pthread_mutex_lock ( & tq -> lock ) ; /* mark the stream as send-finished;\n     * next time the consumer thread tries to read this stream it will get\n     * an EOF and recv-finished flag will be set */ tq -> finished [ stream_idx ] |= FINISHED_SEND ; pthread_cond_broadcast ( & tq -> cond ) ; pthread_mutex_unlock ( & tq -> lock ) ; }",
    "resources/ffmpeg-kit/apple/src/fftools_thread_queue.c@tq_receive_finish": "void tq_receive_finish ( ThreadQueue * tq , unsigned int stream_idx ) { av_assert0 ( stream_idx < tq -> nb_streams ) ; pthread_mutex_lock ( & tq -> lock ) ; /* mark the stream as recv-finished;\n     * next time the producer thread tries to send for this stream, it will\n     * get an EOF and send-finished flag will be set */ tq -> finished [ stream_idx ] |= FINISHED_RECV ; pthread_cond_broadcast ( & tq -> cond ) ; pthread_mutex_unlock ( & tq -> lock ) ; }",
    "resources/ffmpeg-kit/tools/protocols/libavformat_file.c@saf_seek": "static int64_t saf_seek ( URLContext * h , int64_t pos , int whence ) { FileContext * c = h -> priv_data ; int64_t ret ; if ( whence == AVSEEK_SIZE ) { struct stat st ; ret = fstat ( c -> fd , & st ) ; return ret < 0 ? AVERROR ( errno ) : ( S_ISFIFO ( st . st_mode ) ? 0 : st . st_size ) ; } ret = lseek ( c -> fd , pos , whence ) ; return ret < 0 ? AVERROR ( errno ) : ret ; }",
    "resources/ffmpeg-kit/tools/protocols/libavformat_file.c@saf_open": "static int saf_open ( URLContext * h , const char * filename , int flags ) { FileContext * c = h -> priv_data ; int saf_id ; struct stat st ; char * final ; char * saveptr = NULL ; char * saf_id_string = NULL ; char filename_backup [ 128 ] ; av_strstart ( filename , \"saf:\" , & filename ) ; av_strlcpy ( filename_backup , filename , FFMIN ( sizeof ( filename ) , sizeof ( filename_backup ) ) ) ; saf_id_string = av_strtok ( filename_backup , \".\" , & saveptr ) ; saf_id = strtol ( saf_id_string , & final , 10 ) ; if ( ( saf_id_string == final ) || * final ) { saf_id = - 1 ; } saf_open_function custom_saf_open = av_get_saf_open ( ) ; if ( custom_saf_open != NULL ) { int rc = custom_saf_open ( saf_id ) ; if ( rc ) { c -> fd = rc ; } else { c -> fd = saf_id ; } } else { c -> fd = saf_id ; } h -> is_streamed = ! fstat ( saf_id , & st ) && S_ISFIFO ( st . st_mode ) ; /* Buffer writes more than the default 32k to improve throughput especially\n     * with networked file systems */ if ( ! h -> is_streamed && flags & AVIO_FLAG_WRITE ) h -> min_packet_size = h -> max_packet_size = 262144 ; if ( c -> seekable >= 0 ) h -> is_streamed = ! c -> seekable ; return 0 ; }",
    "resources/ffmpeg-kit/tools/protocols/libavformat_file.c@saf_check": "static int saf_check ( URLContext * h , int mask ) { int ret = 0 ; const char * filename = h -> filename ; av_strstart ( filename , \"saf:\" , & filename ) ; { # if HAVE_ACCESS && defined ( R_OK ) if ( access ( filename , F_OK ) < 0 ) return AVERROR ( errno ) ; if ( mask & AVIO_FLAG_READ ) if ( access ( filename , R_OK ) >= 0 ) ret |= AVIO_FLAG_READ ; if ( mask & AVIO_FLAG_WRITE ) if ( access ( filename , W_OK ) >= 0 ) ret |= AVIO_FLAG_WRITE ; # else struct stat st ; # ifndef _WIN32 ret = stat ( filename , & st ) ; # else ret = win32_stat ( filename , & st ) ; # endif if ( ret < 0 ) return AVERROR ( errno ) ; ret |= st . st_mode & S_IRUSR ? mask & AVIO_FLAG_READ : 0 ; ret |= st . st_mode & S_IWUSR ? mask & AVIO_FLAG_WRITE : 0 ; # endif } return ret ; }",
    "resources/ffmpeg-kit/tools/protocols/libavformat_file.c@saf_delete": "static int saf_delete ( URLContext * h ) { # if HAVE_UNISTD_H int ret ; const char * filename = h -> filename ; av_strstart ( filename , \"saf:\" , & filename ) ; ret = rmdir ( filename ) ; if ( ret < 0 && ( errno == ENOTDIR # ifdef _WIN32 || errno == EINVAL # endif ) ) ret = unlink ( filename ) ; if ( ret < 0 ) return AVERROR ( errno ) ; return ret ; # else return AVERROR ( ENOSYS ) ; # endif /* HAVE_UNISTD_H */ }",
    "resources/ffmpeg-kit/tools/protocols/libavformat_file.c@saf_move": "static int saf_move ( URLContext * h_src , URLContext * h_dst ) { const char * filename_src = h_src -> filename ; const char * filename_dst = h_dst -> filename ; av_strstart ( filename_src , \"saf:\" , & filename_src ) ; av_strstart ( filename_dst , \"saf:\" , & filename_dst ) ; if ( rename ( filename_src , filename_dst ) < 0 ) return AVERROR ( errno ) ; return 0 ; }",
    "resources/ffmpeg-kit/tools/protocols/libavformat_file.c@saf_close": "static int saf_close ( URLContext * h ) { FileContext * c = h -> priv_data ; saf_close_function custom_saf_close = av_get_saf_close ( ) ; if ( custom_saf_close != NULL ) { return custom_saf_close ( c -> fd ) ; } else { return 0 ; } }",
    "resources/ffmpeg-kit/tools/protocols/libavutil_file.c@av_get_saf_open": "saf_open_function av_get_saf_open ( ) { return _saf_open_function ; }",
    "resources/ffmpeg-kit/tools/protocols/libavutil_file.c@av_get_saf_close": "saf_close_function av_get_saf_close ( ) { return _saf_close_function ; }",
    "resources/ffmpeg-kit/tools/protocols/libavutil_file.c@av_set_saf_open": "void av_set_saf_open ( saf_open_function open_function ) { _saf_open_function = open_function ; }",
    "resources/ffmpeg-kit/tools/protocols/libavutil_file.c@av_set_saf_close": "void av_set_saf_close ( saf_close_function close_function ) { _saf_close_function = close_function ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@fopen_utf8": "static inline FILE * fopen_utf8 ( const char * path , const char * mode ) { return fopen ( path , mode ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@uninit_opts": "void uninit_opts ( void ) { av_dict_free ( & swr_opts ) ; av_dict_free ( & sws_dict ) ; av_dict_free ( & format_opts ) ; av_dict_free ( & codec_opts ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@init_dynload": "void init_dynload ( void ) { # if HAVE_SETDLLDIRECTORY && defined ( _WIN32 ) /* Calling SetDllDirectory with the empty string (but not NULL) removes the\n     * current working directory from the DLL search path as a security pre-caution. */ SetDllDirectory ( \"\" ) ; # endif }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@register_exit": "void register_exit ( void ( * cb ) ( int ret ) ) { program_exit = cb ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@report_and_exit": "void report_and_exit ( int ret ) { av_log ( NULL , AV_LOG_FATAL , \"%s\\n\" , av_err2str ( ret ) ) ; exit_program ( AVUNERROR ( ret ) ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@exit_program": "void exit_program ( int ret ) { if ( program_exit ) program_exit ( ret ) ; // FFmpegKit // exit disabled and replaced with longjmp, exit value stored in longjmp_value // exit(ret); longjmp_value = ret ; longjmp ( ex_buf__ , ret ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@parse_number_or_die": "double parse_number_or_die ( const char * context , const char * numstr , int type , double min , double max ) { char * tail ; const char * error ; double d = av_strtod ( numstr , & tail ) ; if ( * tail ) error = \"Expected number for %s but found: %s\\n\" ; else if ( d < min || d > max ) error = \"The value for %s was %s which is not within %f - %f\\n\" ; else if ( type == OPT_INT64 && ( int64_t ) d != d ) error = \"Expected int64 for %s but found %s\\n\" ; else if ( type == OPT_INT && ( int ) d != d ) error = \"Expected int for %s but found %s\\n\" ; else return d ; av_log ( NULL , AV_LOG_FATAL , error , context , numstr , min , max ) ; exit_program ( 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@parse_time_or_die": "int64_t parse_time_or_die ( const char * context , const char * timestr , int is_duration ) { int64_t us ; if ( av_parse_time ( & us , timestr , is_duration ) < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid %s specification for %s: %s\\n\" , is_duration ? \"duration\" : \"date\" , context , timestr ) ; exit_program ( 1 ) ; } return us ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@show_help_options": "void show_help_options ( const OptionDef * options , const char * msg , int req_flags , int rej_flags , int alt_flags ) { const OptionDef * po ; int first ; first = 1 ; for ( po = options ; po -> name ; po ++ ) { char buf [ 128 ] ; if ( ( ( po -> flags & req_flags ) != req_flags ) || ( alt_flags && ! ( po -> flags & alt_flags ) ) || ( po -> flags & rej_flags ) ) continue ; if ( first ) { av_log ( NULL , AV_LOG_STDERR , \"%s\\n\" , msg ) ; first = 0 ; } av_strlcpy ( buf , po -> name , sizeof ( buf ) ) ; if ( po -> argname ) { av_strlcat ( buf , \" \" , sizeof ( buf ) ) ; av_strlcat ( buf , po -> argname , sizeof ( buf ) ) ; } av_log ( NULL , AV_LOG_STDERR , \"-%-17s  %s\\n\" , buf , po -> help ) ; } av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@show_help_children": "void show_help_children ( const AVClass * class , int flags ) { void * iter = NULL ; const AVClass * child ; if ( class -> option ) { av_opt_show2 ( & class , NULL , flags , 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; } while ( ( child = av_opt_child_class_iterate ( class , & iter ) ) ) show_help_children ( child , flags ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@find_option": "static const OptionDef * find_option ( const OptionDef * po , const char * name ) { while ( po -> name ) { const char * end ; if ( av_strstart ( name , po -> name , & end ) && ( ! * end || * end == ':' ) ) break ; po ++ ; } return po ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@prepare_app_arguments": "static inline void prepare_app_arguments ( int * argc_ptr , char * * * argv_ptr ) { /* nothing to do */ }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@write_option": "static int write_option ( void * optctx , const OptionDef * po , const char * opt , const char * arg ) { /* new-style options contain an offset into optctx, old-style address of\n     * a global var*/ void * dst = po -> flags & ( OPT_OFFSET | OPT_SPEC ) ? ( uint8_t * ) optctx + po -> u . off : po -> u . dst_ptr ; int * dstcount ; if ( po -> flags & OPT_SPEC ) { SpecifierOpt * * so = dst ; char * p = strchr ( opt , ':' ) ; char * str ; dstcount = ( int * ) ( so + 1 ) ; * so = grow_array ( * so , sizeof ( * * so ) , dstcount , * dstcount + 1 ) ; str = av_strdup ( p ? p + 1 : \"\" ) ; if ( ! str ) return AVERROR ( ENOMEM ) ; ( * so ) [ * dstcount - 1 ] . specifier = str ; dst = & ( * so ) [ * dstcount - 1 ] . u ; } if ( po -> flags & OPT_STRING ) { char * str ; str = av_strdup ( arg ) ; av_freep ( dst ) ; if ( ! str ) return AVERROR ( ENOMEM ) ; * ( char * * ) dst = str ; } else if ( po -> flags & OPT_BOOL || po -> flags & OPT_INT ) { * ( int * ) dst = parse_number_or_die ( opt , arg , OPT_INT64 , INT_MIN , INT_MAX ) ; } else if ( po -> flags & OPT_INT64 ) { * ( int64_t * ) dst = parse_number_or_die ( opt , arg , OPT_INT64 , INT64_MIN , ( double ) INT64_MAX ) ; } else if ( po -> flags & OPT_TIME ) { * ( int64_t * ) dst = parse_time_or_die ( opt , arg , 1 ) ; } else if ( po -> flags & OPT_FLOAT ) { * ( float * ) dst = parse_number_or_die ( opt , arg , OPT_FLOAT , - INFINITY , INFINITY ) ; } else if ( po -> flags & OPT_DOUBLE ) { * ( double * ) dst = parse_number_or_die ( opt , arg , OPT_DOUBLE , - INFINITY , INFINITY ) ; } else if ( po -> u . func_arg ) { int ret = po -> u . func_arg ( optctx , opt , arg ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Failed to set value '%s' for option '%s': %s\\n\" , arg , opt , av_err2str ( ret ) ) ; return ret ; } } if ( po -> flags & OPT_EXIT ) exit_program ( 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@parse_option": "int parse_option ( void * optctx , const char * opt , const char * arg , const OptionDef * options ) { static const OptionDef opt_avoptions = { . name = \"AVOption passthrough\" , . flags = HAS_ARG , . u . func_arg = opt_default , } ; const OptionDef * po ; int ret ; po = find_option ( options , opt ) ; if ( ! po -> name && opt [ 0 ] == 'n' && opt [ 1 ] == 'o' ) { /* handle 'no' bool option */ po = find_option ( options , opt + 2 ) ; if ( ( po -> name && ( po -> flags & OPT_BOOL ) ) ) arg = \"0\" ; } else if ( po -> flags & OPT_BOOL ) arg = \"1\" ; if ( ! po -> name ) po = & opt_avoptions ; if ( ! po -> name ) { av_log ( NULL , AV_LOG_ERROR , \"Unrecognized option '%s'\\n\" , opt ) ; return AVERROR ( EINVAL ) ; } if ( po -> flags & HAS_ARG && ! arg ) { av_log ( NULL , AV_LOG_ERROR , \"Missing argument for option '%s'\\n\" , opt ) ; return AVERROR ( EINVAL ) ; } ret = write_option ( optctx , po , opt , arg ) ; if ( ret < 0 ) return ret ; return ! ! ( po -> flags & HAS_ARG ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@parse_options": "void parse_options ( void * optctx , int argc , char * * argv , const OptionDef * options , void ( * parse_arg_function ) ( void * , const char * ) ) { const char * opt ; int optindex , handleoptions = 1 , ret ; /* perform system-dependent conversions for arguments list */ prepare_app_arguments ( & argc , & argv ) ; /* parse options */ optindex = 1 ; while ( optindex < argc ) { opt = argv [ optindex ++ ] ; if ( handleoptions && opt [ 0 ] == '-' && opt [ 1 ] != '\\0' ) { if ( opt [ 1 ] == '-' && opt [ 2 ] == '\\0' ) { handleoptions = 0 ; continue ; } opt ++ ; if ( optindex >= argc ) { if ( ( ret = parse_option ( optctx , opt , NULL , options ) ) < 0 ) exit_program ( 1 ) ; } else { if ( ( ret = parse_option ( optctx , opt , argv [ optindex ] , options ) ) < 0 ) exit_program ( 1 ) ; } optindex += ret ; } else { if ( parse_arg_function ) parse_arg_function ( optctx , opt ) ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@parse_optgroup": "int parse_optgroup ( void * optctx , OptionGroup * g ) { int i , ret ; av_log ( NULL , AV_LOG_DEBUG , \"Parsing a group of options: %s %s.\\n\" , g -> group_def -> name , g -> arg ) ; for ( i = 0 ; i < g -> nb_opts ; i ++ ) { Option * o = & g -> opts [ i ] ; if ( g -> group_def -> flags && ! ( g -> group_def -> flags & o -> opt -> flags ) ) { av_log ( NULL , AV_LOG_ERROR , \"Option %s (%s) cannot be applied to \" \"%s %s -- you are trying to apply an input option to an \" \"output file or vice versa. Move this option before the \" \"file it belongs to.\\n\" , o -> key , o -> opt -> help , g -> group_def -> name , g -> arg ) ; return AVERROR ( EINVAL ) ; } av_log ( NULL , AV_LOG_DEBUG , \"Applying option %s (%s) with argument %s.\\n\" , o -> key , o -> opt -> help , o -> val ) ; ret = write_option ( optctx , o -> opt , o -> key , o -> val ) ; if ( ret < 0 ) return ret ; } av_log ( NULL , AV_LOG_DEBUG , \"Successfully parsed a group of options.\\n\" ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@locate_option": "int locate_option ( int argc , char * * argv , const OptionDef * options , const char * optname ) { const OptionDef * po ; int i ; for ( i = 1 ; i < argc ; i ++ ) { const char * cur_opt = argv [ i ] ; if ( * cur_opt ++ != '-' ) continue ; po = find_option ( options , cur_opt ) ; if ( ! po -> name && cur_opt [ 0 ] == 'n' && cur_opt [ 1 ] == 'o' ) po = find_option ( options , cur_opt + 2 ) ; if ( ( ! po -> name && ! strcmp ( cur_opt , optname ) ) || ( po -> name && ! strcmp ( optname , po -> name ) ) ) return i ; if ( ! po -> name || po -> flags & HAS_ARG ) i ++ ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@dump_argument": "static void dump_argument ( FILE * report_file , const char * a ) { const unsigned char * p ; for ( p = a ; * p ; p ++ ) if ( ! ( ( * p >= '+' && * p <= ':' ) || ( * p >= '@' && * p <= 'Z' ) || * p == '_' || ( * p >= 'a' && * p <= 'z' ) ) ) break ; if ( ! * p ) { fputs ( a , report_file ) ; return ; } fputc ( '\"' , report_file ) ; for ( p = a ; * p ; p ++ ) { if ( * p == '\\\\' || * p == '\"' || * p == '$' || * p == '`' ) fprintf ( report_file , \"\\\\%c\" , * p ) ; else if ( * p < ' ' || * p > '~' ) fprintf ( report_file , \"\\\\x%02x\" , * p ) ; else fputc ( * p , report_file ) ; } fputc ( '\"' , report_file ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@check_options": "static void check_options ( const OptionDef * po ) { while ( po -> name ) { if ( po -> flags & OPT_PERFILE ) av_assert0 ( po -> flags & ( OPT_INPUT | OPT_OUTPUT ) ) ; po ++ ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@parse_loglevel": "void parse_loglevel ( int argc , char * * argv , const OptionDef * options ) { int idx = locate_option ( argc , argv , options , \"loglevel\" ) ; char * env ; check_options ( options ) ; if ( ! idx ) idx = locate_option ( argc , argv , options , \"v\" ) ; if ( idx && ( idx + 1 < argc ) && argv [ idx + 1 ] ) opt_loglevel ( NULL , \"loglevel\" , argv [ idx + 1 ] ) ; idx = locate_option ( argc , argv , options , \"report\" ) ; env = getenv_utf8 ( \"FFREPORT\" ) ; if ( env || idx ) { FILE * report_file = NULL ; init_report ( env , & report_file ) ; if ( report_file ) { int i ; fprintf ( report_file , \"Command line:\\n\" ) ; for ( i = 0 ; i < argc ; i ++ ) { dump_argument ( report_file , argv [ i ] ) ; fputc ( i < argc - 1 ? ' ' : '\\n' , report_file ) ; } fflush ( report_file ) ; } } freeenv_utf8 ( env ) ; idx = locate_option ( argc , argv , options , \"hide_banner\" ) ; if ( idx ) hide_banner = 1 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@opt_find": "static const AVOption * opt_find ( void * obj , const char * name , const char * unit , int opt_flags , int search_flags ) { const AVOption * o = av_opt_find ( obj , name , unit , opt_flags , search_flags ) ; if ( o && ! o -> flags ) return NULL ; return o ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@opt_default": "int opt_default ( void * optctx , const char * opt , const char * arg ) { const AVOption * o ; int consumed = 0 ; char opt_stripped [ 128 ] ; const char * p ; const AVClass * cc = avcodec_get_class ( ) , * fc = avformat_get_class ( ) ; # if CONFIG_SWSCALE const AVClass * sc = sws_get_class ( ) ; # endif # if CONFIG_SWRESAMPLE const AVClass * swr_class = swr_get_class ( ) ; # endif if ( ! strcmp ( opt , \"debug\" ) || ! strcmp ( opt , \"fdebug\" ) ) av_log_set_level ( AV_LOG_DEBUG ) ; if ( ! ( p = strchr ( opt , ':' ) ) ) p = opt + strlen ( opt ) ; av_strlcpy ( opt_stripped , opt , FFMIN ( sizeof ( opt_stripped ) , p - opt + 1 ) ) ; if ( ( o = opt_find ( & cc , opt_stripped , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ) || ( ( opt [ 0 ] == 'v' || opt [ 0 ] == 'a' || opt [ 0 ] == 's' ) && ( o = opt_find ( & cc , opt + 1 , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ) ) ) { av_dict_set ( & codec_opts , opt , arg , FLAGS ) ; consumed = 1 ; } if ( ( o = opt_find ( & fc , opt , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ) ) { av_dict_set ( & format_opts , opt , arg , FLAGS ) ; if ( consumed ) av_log ( NULL , AV_LOG_VERBOSE , \"Routing option %s to both codec and muxer layer\\n\" , opt ) ; consumed = 1 ; } # if CONFIG_SWSCALE if ( ! consumed && ( o = opt_find ( & sc , opt , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ) ) { if ( ! strcmp ( opt , \"srcw\" ) || ! strcmp ( opt , \"srch\" ) || ! strcmp ( opt , \"dstw\" ) || ! strcmp ( opt , \"dsth\" ) || ! strcmp ( opt , \"src_format\" ) || ! strcmp ( opt , \"dst_format\" ) ) { av_log ( NULL , AV_LOG_ERROR , \"Directly using swscale dimensions/format options is not supported, please use the -s or -pix_fmt options\\n\" ) ; return AVERROR ( EINVAL ) ; } av_dict_set ( & sws_dict , opt , arg , FLAGS ) ; consumed = 1 ; } # else if ( ! consumed && ! strcmp ( opt , \"sws_flags\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"Ignoring %s %s, due to disabled swscale\\n\" , opt , arg ) ; consumed = 1 ; } # endif # if CONFIG_SWRESAMPLE if ( ! consumed && ( o = opt_find ( & swr_class , opt , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ) ) { av_dict_set ( & swr_opts , opt , arg , FLAGS ) ; consumed = 1 ; } # endif if ( consumed ) return 0 ; return AVERROR_OPTION_NOT_FOUND ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@match_group_separator": "static int match_group_separator ( const OptionGroupDef * groups , int nb_groups , const char * opt ) { int i ; for ( i = 0 ; i < nb_groups ; i ++ ) { const OptionGroupDef * p = & groups [ i ] ; if ( p -> sep && ! strcmp ( p -> sep , opt ) ) return i ; } return - 1 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@finish_group": "static void finish_group ( OptionParseContext * octx , int group_idx , const char * arg ) { OptionGroupList * l = & octx -> groups [ group_idx ] ; OptionGroup * g ; GROW_ARRAY ( l -> groups , l -> nb_groups ) ; g = & l -> groups [ l -> nb_groups - 1 ] ; * g = octx -> cur_group ; g -> arg = arg ; g -> group_def = l -> group_def ; g -> sws_dict = sws_dict ; g -> swr_opts = swr_opts ; g -> codec_opts = codec_opts ; g -> format_opts = format_opts ; codec_opts = NULL ; format_opts = NULL ; sws_dict = NULL ; swr_opts = NULL ; memset ( & octx -> cur_group , 0 , sizeof ( octx -> cur_group ) ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@add_opt": "static void add_opt ( OptionParseContext * octx , const OptionDef * opt , const char * key , const char * val ) { int global = ! ( opt -> flags & ( OPT_PERFILE | OPT_SPEC | OPT_OFFSET ) ) ; OptionGroup * g = global ? & octx -> global_opts : & octx -> cur_group ; GROW_ARRAY ( g -> opts , g -> nb_opts ) ; g -> opts [ g -> nb_opts - 1 ] . opt = opt ; g -> opts [ g -> nb_opts - 1 ] . key = key ; g -> opts [ g -> nb_opts - 1 ] . val = val ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@init_parse_context": "static void init_parse_context ( OptionParseContext * octx , const OptionGroupDef * groups , int nb_groups ) { static const OptionGroupDef global_group = { \"global\" } ; int i ; memset ( octx , 0 , sizeof ( * octx ) ) ; octx -> nb_groups = nb_groups ; octx -> groups = av_calloc ( octx -> nb_groups , sizeof ( * octx -> groups ) ) ; if ( ! octx -> groups ) report_and_exit ( AVERROR ( ENOMEM ) ) ; for ( i = 0 ; i < octx -> nb_groups ; i ++ ) octx -> groups [ i ] . group_def = & groups [ i ] ; octx -> global_opts . group_def = & global_group ; octx -> global_opts . arg = \"\" ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@uninit_parse_context": "void uninit_parse_context ( OptionParseContext * octx ) { int i , j ; for ( i = 0 ; i < octx -> nb_groups ; i ++ ) { OptionGroupList * l = & octx -> groups [ i ] ; for ( j = 0 ; j < l -> nb_groups ; j ++ ) { av_freep ( & l -> groups [ j ] . opts ) ; av_dict_free ( & l -> groups [ j ] . codec_opts ) ; av_dict_free ( & l -> groups [ j ] . format_opts ) ; av_dict_free ( & l -> groups [ j ] . sws_dict ) ; av_dict_free ( & l -> groups [ j ] . swr_opts ) ; } av_freep ( & l -> groups ) ; } av_freep ( & octx -> groups ) ; av_freep ( & octx -> cur_group . opts ) ; av_freep ( & octx -> global_opts . opts ) ; uninit_opts ( ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@split_commandline": "int split_commandline ( OptionParseContext * octx , int argc , char * argv [ ] , const OptionDef * options , const OptionGroupDef * groups , int nb_groups ) { int optindex = 1 ; int dashdash = - 2 ; /* perform system-dependent conversions for arguments list */ prepare_app_arguments ( & argc , & argv ) ; init_parse_context ( octx , groups , nb_groups ) ; av_log ( NULL , AV_LOG_DEBUG , \"Splitting the commandline.\\n\" ) ; while ( optindex < argc ) { const char * opt = argv [ optindex ++ ] , * arg ; const OptionDef * po ; int ret ; av_log ( NULL , AV_LOG_DEBUG , \"Reading option '%s' ...\" , opt ) ; if ( opt [ 0 ] == '-' && opt [ 1 ] == '-' && ! opt [ 2 ] ) { dashdash = optindex ; continue ; } /* unnamed group separators, e.g. output filename */ if ( opt [ 0 ] != '-' || ! opt [ 1 ] || dashdash + 1 == optindex ) { finish_group ( octx , 0 , opt ) ; av_log ( NULL , AV_LOG_DEBUG , \" matched as %s.\\n\" , groups [ 0 ] . name ) ; continue ; } opt ++ ; # define GET_ARG ( arg ) do { if ( optindex < argc ) { arg = argv [ optindex ++ ] ; } else { av_log ( NULL , AV_LOG_ERROR , \"Missing argument for option '%s'.\\n\" , opt ) ; return AVERROR ( EINVAL ) ; } \\\n} while ( 0 ) /* named group separators, e.g. -i */ if ( ( ret = match_group_separator ( groups , nb_groups , opt ) ) >= 0 ) { GET_ARG ( arg ) ; finish_group ( octx , ret , arg ) ; av_log ( NULL , AV_LOG_DEBUG , \" matched as %s with argument '%s'.\\n\" , groups [ ret ] . name , arg ) ; continue ; } /* normal options */ po = find_option ( options , opt ) ; if ( po -> name ) { if ( po -> flags & OPT_EXIT ) { /* optional argument, e.g. -h */ if ( optindex < argc ) { arg = argv [ optindex ++ ] ; } else { arg = NULL ; } } else if ( po -> flags & HAS_ARG ) { GET_ARG ( arg ) ; } else { arg = \"1\" ; } add_opt ( octx , po , opt , arg ) ; av_log ( NULL , AV_LOG_DEBUG , \" matched as option '%s' (%s) with \" \"argument '%s'.\\n\" , po -> name , po -> help , arg ) ; continue ; } /* AVOptions */ if ( ( optindex < argc ) && argv [ optindex ] ) { ret = opt_default ( NULL , opt , argv [ optindex ] ) ; if ( ret >= 0 ) { av_log ( NULL , AV_LOG_DEBUG , \" matched as AVOption '%s' with \" \"argument '%s'.\\n\" , opt , argv [ optindex ] ) ; optindex ++ ; continue ; } else if ( ret != AVERROR_OPTION_NOT_FOUND ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing option '%s' \" \"with argument '%s'.\\n\" , opt , argv [ optindex ] ) ; return ret ; } } /* boolean -nofoo options */ if ( opt [ 0 ] == 'n' && opt [ 1 ] == 'o' && ( po = find_option ( options , opt + 2 ) ) && po -> name && po -> flags & OPT_BOOL ) { add_opt ( octx , po , opt , \"0\" ) ; av_log ( NULL , AV_LOG_DEBUG , \" matched as option '%s' (%s) with \" \"argument 0.\\n\" , po -> name , po -> help ) ; continue ; } av_log ( NULL , AV_LOG_ERROR , \"Unrecognized option '%s'.\\n\" , opt ) ; return AVERROR_OPTION_NOT_FOUND ; } if ( octx -> cur_group . nb_opts || codec_opts || format_opts ) av_log ( NULL , AV_LOG_WARNING , \"Trailing option(s) found in the \" \"command: may be ignored.\\n\" ) ; av_log ( NULL , AV_LOG_DEBUG , \"Finished splitting the commandline.\\n\" ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@print_error": "void print_error ( const char * filename , int err ) { av_log ( NULL , AV_LOG_ERROR , \"%s: %s\\n\" , filename , av_err2str ( err ) ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@read_yesno": "int read_yesno ( void ) { int c = getchar ( ) ; int yesno = ( av_toupper ( c ) == 'Y' ) ; while ( c != '\\n' && c != EOF ) c = getchar ( ) ; return yesno ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@get_preset_file": "FILE * get_preset_file ( char * filename , size_t filename_size , const char * preset_name , int is_path , const char * codec_name ) { FILE * f = NULL ; int i ; # if HAVE_GETMODULEHANDLE && defined ( _WIN32 ) char * datadir = NULL ; # endif char * env_home = getenv_utf8 ( \"HOME\" ) ; char * env_ffmpeg_datadir = getenv_utf8 ( \"FFMPEG_DATADIR\" ) ; const char * base [ 3 ] = { env_ffmpeg_datadir , env_home , /* index=1(HOME) is special: search in a .ffmpeg subfolder */ FFMPEG_DATADIR , } ; if ( is_path ) { av_strlcpy ( filename , preset_name , filename_size ) ; f = fopen_utf8 ( filename , \"r\" ) ; } else { # if HAVE_GETMODULEHANDLE && defined ( _WIN32 ) wchar_t * datadir_w = get_module_filename ( NULL ) ; base [ 2 ] = NULL ; if ( wchartoutf8 ( datadir_w , & datadir ) ) datadir = NULL ; av_free ( datadir_w ) ; if ( datadir ) { char * ls ; for ( ls = datadir ; * ls ; ls ++ ) if ( * ls == '\\\\' ) * ls = '/' ; if ( ls = strrchr ( datadir , '/' ) ) { ptrdiff_t datadir_len = ls - datadir ; size_t desired_size = datadir_len + strlen ( \"/ffpresets\" ) + 1 ; char * new_datadir = av_realloc_array ( datadir , desired_size , sizeof * datadir ) ; if ( new_datadir ) { datadir = new_datadir ; datadir [ datadir_len ] = 0 ; strncat ( datadir , \"/ffpresets\" , desired_size - 1 - datadir_len ) ; base [ 2 ] = datadir ; } } } # endif for ( i = 0 ; i < 3 && ! f ; i ++ ) { if ( ! base [ i ] ) continue ; snprintf ( filename , filename_size , \"%s%s/%s.ffpreset\" , base [ i ] , i != 1 ? \"\" : \"/.ffmpeg\" , preset_name ) ; f = fopen_utf8 ( filename , \"r\" ) ; if ( ! f && codec_name ) { snprintf ( filename , filename_size , \"%s%s/%s-%s.ffpreset\" , base [ i ] , i != 1 ? \"\" : \"/.ffmpeg\" , codec_name , preset_name ) ; f = fopen_utf8 ( filename , \"r\" ) ; } } } # if HAVE_GETMODULEHANDLE && defined ( _WIN32 ) av_free ( datadir ) ; # endif freeenv_utf8 ( env_ffmpeg_datadir ) ; freeenv_utf8 ( env_home ) ; return f ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@check_stream_specifier": "int check_stream_specifier ( AVFormatContext * s , AVStream * st , const char * spec ) { int ret = avformat_match_stream_specifier ( s , st , spec ) ; if ( ret < 0 ) av_log ( s , AV_LOG_ERROR , \"Invalid stream specifier: %s.\\n\" , spec ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@filter_codec_opts": "AVDictionary * filter_codec_opts ( AVDictionary * opts , enum AVCodecID codec_id , AVFormatContext * s , AVStream * st , const AVCodec * codec ) { AVDictionary * ret = NULL ; const AVDictionaryEntry * t = NULL ; int flags = s -> oformat ? AV_OPT_FLAG_ENCODING_PARAM : AV_OPT_FLAG_DECODING_PARAM ; char prefix = 0 ; const AVClass * cc = avcodec_get_class ( ) ; if ( ! codec ) codec = s -> oformat ? avcodec_find_encoder ( codec_id ) : avcodec_find_decoder ( codec_id ) ; switch ( st -> codecpar -> codec_type ) { case AVMEDIA_TYPE_VIDEO : prefix = 'v' ; flags |= AV_OPT_FLAG_VIDEO_PARAM ; break ; case AVMEDIA_TYPE_AUDIO : prefix = 'a' ; flags |= AV_OPT_FLAG_AUDIO_PARAM ; break ; case AVMEDIA_TYPE_SUBTITLE : prefix = 's' ; flags |= AV_OPT_FLAG_SUBTITLE_PARAM ; break ; } while ( ( t = av_dict_iterate ( opts , t ) ) ) { const AVClass * priv_class ; char * p = strchr ( t -> key , ':' ) ; /* check stream specification in opt name */ if ( p ) switch ( check_stream_specifier ( s , st , p + 1 ) ) { case 1 : * p = 0 ; break ; case 0 : continue ; default : exit_program ( 1 ) ; } if ( av_opt_find ( & cc , t -> key , NULL , flags , AV_OPT_SEARCH_FAKE_OBJ ) || ! codec || ( ( priv_class = codec -> priv_class ) && av_opt_find ( & priv_class , t -> key , NULL , flags , AV_OPT_SEARCH_FAKE_OBJ ) ) ) av_dict_set ( & ret , t -> key , t -> value , 0 ) ; else if ( t -> key [ 0 ] == prefix && av_opt_find ( & cc , t -> key + 1 , NULL , flags , AV_OPT_SEARCH_FAKE_OBJ ) ) av_dict_set ( & ret , t -> key + 1 , t -> value , 0 ) ; if ( p ) * p = ':' ; } return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@setup_find_stream_info_opts": "AVDictionary * * setup_find_stream_info_opts ( AVFormatContext * s , AVDictionary * codec_opts ) { int i ; AVDictionary * * opts ; if ( ! s -> nb_streams ) return NULL ; opts = av_calloc ( s -> nb_streams , sizeof ( * opts ) ) ; if ( ! opts ) report_and_exit ( AVERROR ( ENOMEM ) ) ; for ( i = 0 ; i < s -> nb_streams ; i ++ ) opts [ i ] = filter_codec_opts ( codec_opts , s -> streams [ i ] -> codecpar -> codec_id , s , s -> streams [ i ] , NULL ) ; return opts ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@grow_array": "void * grow_array ( void * array , int elem_size , int * size , int new_size ) { if ( new_size >= INT_MAX / elem_size ) { av_log ( NULL , AV_LOG_ERROR , \"Array too big.\\n\" ) ; exit_program ( 1 ) ; } if ( * size < new_size ) { uint8_t * tmp = av_realloc_array ( array , new_size , elem_size ) ; if ( ! tmp ) report_and_exit ( AVERROR ( ENOMEM ) ) ; memset ( tmp + * size * elem_size , 0 , ( new_size - * size ) * elem_size ) ; * size = new_size ; return tmp ; } return array ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@allocate_array_elem": "void * allocate_array_elem ( void * ptr , size_t elem_size , int * nb_elems ) { void * new_elem ; if ( ! ( new_elem = av_mallocz ( elem_size ) ) || av_dynarray_add_nofree ( ptr , nb_elems , new_elem ) < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return new_elem ; }",
    "resources/ffmpeg-kit/linux/src/fftools_cmdutils.c@get_rotation": "double get_rotation ( int32_t * displaymatrix ) { double theta = 0 ; if ( displaymatrix ) theta = - round ( av_display_rotation_get ( ( int32_t * ) displaymatrix ) ) ; theta -= 360 * floor ( theta / 360 + 0.9 / 360 ) ; if ( fabs ( theta - 90 * round ( theta / 90 ) ) > 2 ) av_log ( NULL , AV_LOG_WARNING , \"Odd rotation angle.\\n\" \"If you want to help, upload a sample \" \"of this file to https://streams.videolan.org/upload/ \" \"and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)\" ) ; return theta ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@frame_move": "static void frame_move ( const SyncQueue * sq , SyncQueueFrame dst , SyncQueueFrame src ) { if ( sq -> type == SYNC_QUEUE_PACKETS ) av_packet_move_ref ( dst . p , src . p ) ; else av_frame_move_ref ( dst . f , src . f ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@frame_ts": "static int64_t frame_ts ( const SyncQueue * sq , SyncQueueFrame frame ) { return ( sq -> type == SYNC_QUEUE_PACKETS ) ? frame . p -> pts + frame . p -> duration : frame . f -> pts + frame . f -> duration ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@frame_null": "static int frame_null ( const SyncQueue * sq , SyncQueueFrame frame ) { return ( sq -> type == SYNC_QUEUE_PACKETS ) ? ( frame . p == NULL ) : ( frame . f == NULL ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@finish_stream": "static void finish_stream ( SyncQueue * sq , unsigned int stream_idx ) { SyncQueueStream * st = & sq -> streams [ stream_idx ] ; st -> finished = 1 ; if ( st -> limiting && st -> head_ts != AV_NOPTS_VALUE ) { /* check if this stream is the new finished head */ if ( sq -> head_finished_stream < 0 || av_compare_ts ( st -> head_ts , st -> tb , sq -> streams [ sq -> head_finished_stream ] . head_ts , sq -> streams [ sq -> head_finished_stream ] . tb ) < 0 ) { sq -> head_finished_stream = stream_idx ; } /* mark as finished all streams that should no longer receive new frames,\n         * due to them being ahead of some finished stream */ st = & sq -> streams [ sq -> head_finished_stream ] ; for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueStream * st1 = & sq -> streams [ i ] ; if ( st != st1 && st1 -> head_ts != AV_NOPTS_VALUE && av_compare_ts ( st -> head_ts , st -> tb , st1 -> head_ts , st1 -> tb ) <= 0 ) st1 -> finished = 1 ; } } /* mark the whole queue as finished if all streams are finished */ for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { if ( ! sq -> streams [ i ] . finished ) return ; } sq -> finished = 1 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@queue_head_update": "static void queue_head_update ( SyncQueue * sq ) { if ( sq -> head_stream < 0 ) { /* wait for one timestamp in each stream before determining\n         * the queue head */ for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueStream * st = & sq -> streams [ i ] ; if ( st -> limiting && st -> head_ts == AV_NOPTS_VALUE ) return ; } // placeholder value, correct one will be found below sq -> head_stream = 0 ; } for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueStream * st_head = & sq -> streams [ sq -> head_stream ] ; SyncQueueStream * st_other = & sq -> streams [ i ] ; if ( st_other -> limiting && st_other -> head_ts != AV_NOPTS_VALUE && av_compare_ts ( st_other -> head_ts , st_other -> tb , st_head -> head_ts , st_head -> tb ) < 0 ) sq -> head_stream = i ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@stream_update_ts": "static void stream_update_ts ( SyncQueue * sq , unsigned int stream_idx , int64_t ts ) { SyncQueueStream * st = & sq -> streams [ stream_idx ] ; if ( ts == AV_NOPTS_VALUE || ( st -> head_ts != AV_NOPTS_VALUE && st -> head_ts >= ts ) ) return ; st -> head_ts = ts ; /* if this stream is now ahead of some finished stream, then\n     * this stream is also finished */ if ( sq -> head_finished_stream >= 0 && av_compare_ts ( sq -> streams [ sq -> head_finished_stream ] . head_ts , sq -> streams [ sq -> head_finished_stream ] . tb , ts , st -> tb ) <= 0 ) finish_stream ( sq , stream_idx ) ; /* update the overall head timestamp if it could have changed */ if ( st -> limiting && ( sq -> head_stream < 0 || sq -> head_stream == stream_idx ) ) queue_head_update ( sq ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@overflow_heartbeat": "static int overflow_heartbeat ( SyncQueue * sq , int stream_idx ) { SyncQueueStream * st ; SyncQueueFrame frame ; int64_t tail_ts = AV_NOPTS_VALUE ; /* if no stream specified, pick the one that is most ahead */ if ( stream_idx < 0 ) { int64_t ts = AV_NOPTS_VALUE ; for ( int i = 0 ; i < sq -> nb_streams ; i ++ ) { st = & sq -> streams [ i ] ; if ( st -> head_ts != AV_NOPTS_VALUE && ( ts == AV_NOPTS_VALUE || av_compare_ts ( ts , sq -> streams [ stream_idx ] . tb , st -> head_ts , st -> tb ) < 0 ) ) { ts = st -> head_ts ; stream_idx = i ; } } /* no stream has a timestamp yet -> nothing to do */ if ( stream_idx < 0 ) return 0 ; } st = & sq -> streams [ stream_idx ] ; /* get the chosen stream's tail timestamp */ for ( size_t i = 0 ; tail_ts == AV_NOPTS_VALUE && av_fifo_peek ( st -> fifo , & frame , 1 , i ) >= 0 ; i ++ ) tail_ts = frame_ts ( sq , frame ) ; /* overflow triggers when the tail is over specified duration behind the head */ if ( tail_ts == AV_NOPTS_VALUE || tail_ts >= st -> head_ts || av_rescale_q ( st -> head_ts - tail_ts , st -> tb , AV_TIME_BASE_Q ) < sq -> buf_size_us ) return 0 ; /* signal a fake timestamp for all streams that prevent tail_ts from being output */ tail_ts ++ ; for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueStream * st1 = & sq -> streams [ i ] ; int64_t ts ; if ( st == st1 || st1 -> finished || ( st1 -> head_ts != AV_NOPTS_VALUE && av_compare_ts ( tail_ts , st -> tb , st1 -> head_ts , st1 -> tb ) <= 0 ) ) continue ; ts = av_rescale_q ( tail_ts , st -> tb , st1 -> tb ) ; if ( st1 -> head_ts != AV_NOPTS_VALUE ) ts = FFMAX ( st1 -> head_ts + 1 , ts ) ; stream_update_ts ( sq , i , ts ) ; } return 1 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@sq_send": "int sq_send ( SyncQueue * sq , unsigned int stream_idx , SyncQueueFrame frame ) { SyncQueueStream * st ; SyncQueueFrame dst ; int64_t ts ; int ret ; av_assert0 ( stream_idx < sq -> nb_streams ) ; st = & sq -> streams [ stream_idx ] ; av_assert0 ( st -> tb . num > 0 && st -> tb . den > 0 ) ; if ( frame_null ( sq , frame ) ) { finish_stream ( sq , stream_idx ) ; return 0 ; } if ( st -> finished ) return AVERROR_EOF ; ret = objpool_get ( sq -> pool , ( void * * ) & dst ) ; if ( ret < 0 ) return ret ; frame_move ( sq , dst , frame ) ; ts = frame_ts ( sq , dst ) ; ret = av_fifo_write ( st -> fifo , & dst , 1 ) ; if ( ret < 0 ) { frame_move ( sq , frame , dst ) ; objpool_release ( sq -> pool , ( void * * ) & dst ) ; return ret ; } stream_update_ts ( sq , stream_idx , ts ) ; st -> frames_sent ++ ; if ( st -> frames_sent >= st -> frames_max ) finish_stream ( sq , stream_idx ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@receive_for_stream": "static int receive_for_stream ( SyncQueue * sq , unsigned int stream_idx , SyncQueueFrame frame ) { SyncQueueStream * st_head = sq -> head_stream >= 0 ? & sq -> streams [ sq -> head_stream ] : NULL ; SyncQueueStream * st ; av_assert0 ( stream_idx < sq -> nb_streams ) ; st = & sq -> streams [ stream_idx ] ; if ( av_fifo_can_read ( st -> fifo ) ) { SyncQueueFrame peek ; int64_t ts ; int cmp = 1 ; av_fifo_peek ( st -> fifo , & peek , 1 , 0 ) ; ts = frame_ts ( sq , peek ) ; /* check if this stream's tail timestamp does not overtake\n         * the overall queue head */ if ( ts != AV_NOPTS_VALUE && st_head ) cmp = av_compare_ts ( ts , st -> tb , st_head -> head_ts , st_head -> tb ) ; /* We can release frames that do not end after the queue head.\n         * Frames with no timestamps are just passed through with no conditions.\n         */ if ( cmp <= 0 || ts == AV_NOPTS_VALUE ) { frame_move ( sq , frame , peek ) ; objpool_release ( sq -> pool , ( void * * ) & peek ) ; av_fifo_drain2 ( st -> fifo , 1 ) ; return 0 ; } } return ( sq -> finished || ( st -> finished && ! av_fifo_can_read ( st -> fifo ) ) ) ? AVERROR_EOF : AVERROR ( EAGAIN ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@receive_internal": "static int receive_internal ( SyncQueue * sq , int stream_idx , SyncQueueFrame frame ) { int nb_eof = 0 ; int ret ; /* read a frame for a specific stream */ if ( stream_idx >= 0 ) { ret = receive_for_stream ( sq , stream_idx , frame ) ; return ( ret < 0 ) ? ret : stream_idx ; } /* read a frame for any stream with available output */ for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { ret = receive_for_stream ( sq , i , frame ) ; if ( ret == AVERROR_EOF || ret == AVERROR ( EAGAIN ) ) { nb_eof += ( ret == AVERROR_EOF ) ; continue ; } return ( ret < 0 ) ? ret : i ; } return ( nb_eof == sq -> nb_streams ) ? AVERROR_EOF : AVERROR ( EAGAIN ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@sq_receive": "int sq_receive ( SyncQueue * sq , int stream_idx , SyncQueueFrame frame ) { int ret = receive_internal ( sq , stream_idx , frame ) ; /* try again if the queue overflowed and triggered a fake heartbeat\n     * for lagging streams */ if ( ret == AVERROR ( EAGAIN ) && overflow_heartbeat ( sq , stream_idx ) ) ret = receive_internal ( sq , stream_idx , frame ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@sq_add_stream": "int sq_add_stream ( SyncQueue * sq , int limiting ) { SyncQueueStream * tmp , * st ; tmp = av_realloc_array ( sq -> streams , sq -> nb_streams + 1 , sizeof ( * sq -> streams ) ) ; if ( ! tmp ) return AVERROR ( ENOMEM ) ; sq -> streams = tmp ; st = & sq -> streams [ sq -> nb_streams ] ; memset ( st , 0 , sizeof ( * st ) ) ; st -> fifo = av_fifo_alloc2 ( 1 , sizeof ( SyncQueueFrame ) , AV_FIFO_FLAG_AUTO_GROW ) ; if ( ! st -> fifo ) return AVERROR ( ENOMEM ) ; /* we set a valid default, so that a pathological stream that never\n     * receives even a real timebase (and no frames) won't stall all other\n     * streams forever; cf. overflow_heartbeat() */ st -> tb = ( AVRational ) { 1 , 1 } ; st -> head_ts = AV_NOPTS_VALUE ; st -> frames_max = UINT64_MAX ; st -> limiting = limiting ; return sq -> nb_streams ++ ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@sq_set_tb": "void sq_set_tb ( SyncQueue * sq , unsigned int stream_idx , AVRational tb ) { SyncQueueStream * st ; av_assert0 ( stream_idx < sq -> nb_streams ) ; st = & sq -> streams [ stream_idx ] ; av_assert0 ( ! av_fifo_can_read ( st -> fifo ) ) ; if ( st -> head_ts != AV_NOPTS_VALUE ) st -> head_ts = av_rescale_q ( st -> head_ts , st -> tb , tb ) ; st -> tb = tb ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@sq_limit_frames": "void sq_limit_frames ( SyncQueue * sq , unsigned int stream_idx , uint64_t frames ) { SyncQueueStream * st ; av_assert0 ( stream_idx < sq -> nb_streams ) ; st = & sq -> streams [ stream_idx ] ; st -> frames_max = frames ; if ( st -> frames_sent >= st -> frames_max ) finish_stream ( sq , stream_idx ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@sq_alloc": "SyncQueue * sq_alloc ( enum SyncQueueType type , int64_t buf_size_us ) { SyncQueue * sq = av_mallocz ( sizeof ( * sq ) ) ; if ( ! sq ) return NULL ; sq -> type = type ; sq -> buf_size_us = buf_size_us ; sq -> head_stream = - 1 ; sq -> head_finished_stream = - 1 ; sq -> pool = ( type == SYNC_QUEUE_PACKETS ) ? objpool_alloc_packets ( ) : objpool_alloc_frames ( ) ; if ( ! sq -> pool ) { av_freep ( & sq ) ; return NULL ; } return sq ; }",
    "resources/ffmpeg-kit/linux/src/fftools_sync_queue.c@sq_free": "void sq_free ( SyncQueue * * psq ) { SyncQueue * sq = * psq ; if ( ! sq ) return ; for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueFrame frame ; while ( av_fifo_read ( sq -> streams [ i ] . fifo , & frame , 1 ) >= 0 ) objpool_release ( sq -> pool , ( void * * ) & frame ) ; av_fifo_freep2 ( & sq -> streams [ i ] . fifo ) ; } av_freep ( & sq -> streams ) ; objpool_free ( & sq -> pool ) ; av_freep ( psq ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@demuxer_from_ifile": "static Demuxer * demuxer_from_ifile ( InputFile * f ) { return ( Demuxer * ) f ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@report_new_stream": "static void report_new_stream ( Demuxer * d , const AVPacket * pkt ) { AVStream * st = d -> f . ctx -> streams [ pkt -> stream_index ] ; if ( pkt -> stream_index < d -> nb_streams_warn ) return ; av_log ( NULL , AV_LOG_WARNING , \"New %s stream %d:%d at pos:%\" PRId64 \" and DTS:%ss\\n\" , av_get_media_type_string ( st -> codecpar -> codec_type ) , d -> f . index , pkt -> stream_index , pkt -> pos , av_ts2timestr ( pkt -> dts , & st -> time_base ) ) ; d -> nb_streams_warn = pkt -> stream_index + 1 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@ifile_duration_update": "static void ifile_duration_update ( Demuxer * d , InputStream * ist , int64_t last_duration ) { /* the total duration of the stream, max_pts - min_pts is\n     * the duration of the stream without the last frame */ if ( ist -> max_pts > ist -> min_pts && ist -> max_pts - ( uint64_t ) ist -> min_pts < INT64_MAX - last_duration ) last_duration += ist -> max_pts - ist -> min_pts ; if ( ! d -> duration || av_compare_ts ( d -> duration , d -> time_base , last_duration , ist -> st -> time_base ) < 0 ) { d -> duration = last_duration ; d -> time_base = ist -> st -> time_base ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@seek_to_start": "static int seek_to_start ( Demuxer * d ) { InputFile * ifile = & d -> f ; AVFormatContext * is = ifile -> ctx ; InputStream * ist ; int ret ; ret = avformat_seek_file ( is , - 1 , INT64_MIN , is -> start_time , is -> start_time , 0 ) ; if ( ret < 0 ) return ret ; if ( ifile -> audio_duration_queue_size ) { /* duration is the length of the last frame in a stream\n         * when audio stream is present we don't care about\n         * last video frame length because it's not defined exactly */ int got_durations = 0 ; while ( got_durations < ifile -> audio_duration_queue_size ) { LastFrameDuration dur ; ret = av_thread_message_queue_recv ( ifile -> audio_duration_queue , & dur , 0 ) ; if ( ret < 0 ) return ret ; got_durations ++ ; ist = ifile -> streams [ dur . stream_idx ] ; ifile_duration_update ( d , ist , dur . duration ) ; } } else { for ( int i = 0 ; i < ifile -> nb_streams ; i ++ ) { int64_t duration = 0 ; ist = ifile -> streams [ i ] ; if ( ist -> framerate . num ) { duration = av_rescale_q ( 1 , av_inv_q ( ist -> framerate ) , ist -> st -> time_base ) ; } else if ( ist -> st -> avg_frame_rate . num ) { duration = av_rescale_q ( 1 , av_inv_q ( ist -> st -> avg_frame_rate ) , ist -> st -> time_base ) ; } else { duration = 1 ; } ifile_duration_update ( d , ist , duration ) ; } } if ( d -> loop > 0 ) d -> loop -- ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@ts_fixup": "static void ts_fixup ( Demuxer * d , AVPacket * pkt , int * repeat_pict ) { InputFile * ifile = & d -> f ; InputStream * ist = ifile -> streams [ pkt -> stream_index ] ; const int64_t start_time = ifile -> start_time_effective ; int64_t duration ; if ( debug_ts ) { av_log ( NULL , AV_LOG_INFO , \"demuxer -> ist_index:%d:%d type:%s \" \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s\\n\" , ifile -> index , pkt -> stream_index , av_get_media_type_string ( ist -> st -> codecpar -> codec_type ) , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & ist -> st -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & ist -> st -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & ist -> st -> time_base ) ) ; } if ( ! ist -> wrap_correction_done && start_time != AV_NOPTS_VALUE && ist -> st -> pts_wrap_bits < 64 ) { int64_t stime , stime2 ; stime = av_rescale_q ( start_time , AV_TIME_BASE_Q , ist -> st -> time_base ) ; stime2 = stime + ( 1ULL << ist -> st -> pts_wrap_bits ) ; ist -> wrap_correction_done = 1 ; if ( stime2 > stime && pkt -> dts != AV_NOPTS_VALUE && pkt -> dts > stime + ( 1LL << ( ist -> st -> pts_wrap_bits - 1 ) ) ) { pkt -> dts -= 1ULL << ist -> st -> pts_wrap_bits ; ist -> wrap_correction_done = 0 ; } if ( stime2 > stime && pkt -> pts != AV_NOPTS_VALUE && pkt -> pts > stime + ( 1LL << ( ist -> st -> pts_wrap_bits - 1 ) ) ) { pkt -> pts -= 1ULL << ist -> st -> pts_wrap_bits ; ist -> wrap_correction_done = 0 ; } } if ( pkt -> dts != AV_NOPTS_VALUE ) pkt -> dts += av_rescale_q ( ifile -> ts_offset , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts += av_rescale_q ( ifile -> ts_offset , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts *= ist -> ts_scale ; if ( pkt -> dts != AV_NOPTS_VALUE ) pkt -> dts *= ist -> ts_scale ; duration = av_rescale_q ( d -> duration , d -> time_base , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) { pkt -> pts += duration ; ist -> max_pts = FFMAX ( pkt -> pts , ist -> max_pts ) ; ist -> min_pts = FFMIN ( pkt -> pts , ist -> min_pts ) ; } if ( pkt -> dts != AV_NOPTS_VALUE ) pkt -> dts += duration ; * repeat_pict = - 1 ; if ( ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && av_stream_get_parser ( ist -> st ) ) * repeat_pict = av_stream_get_parser ( ist -> st ) -> repeat_pict ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@thread_set_name": "static void thread_set_name ( InputFile * f ) { char name [ 16 ] ; snprintf ( name , sizeof ( name ) , \"dmx%d:%s\" , f -> index , f -> ctx -> iformat -> name ) ; ff_thread_setname ( name ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@input_thread": "static void * input_thread ( void * arg ) { Demuxer * d = arg ; InputFile * f = & d -> f ; AVPacket * pkt ; unsigned flags = d -> non_blocking ? AV_THREAD_MESSAGE_NONBLOCK : 0 ; int ret = 0 ; pkt = av_packet_alloc ( ) ; if ( ! pkt ) { ret = AVERROR ( ENOMEM ) ; goto finish ; } thread_set_name ( f ) ; while ( 1 ) { DemuxMsg msg = { NULL } ; ret = av_read_frame ( f -> ctx , pkt ) ; if ( ret == AVERROR ( EAGAIN ) ) { av_usleep ( 10000 ) ; continue ; } if ( ret < 0 ) { if ( d -> loop ) { /* signal looping to the consumer thread */ msg . looping = 1 ; ret = av_thread_message_queue_send ( d -> in_thread_queue , & msg , 0 ) ; if ( ret >= 0 ) ret = seek_to_start ( d ) ; if ( ret >= 0 ) continue ; /* fallthrough to the error path */ } if ( ret == AVERROR_EOF ) av_log ( NULL , AV_LOG_VERBOSE , \"EOF in input file %d\\n\" , f -> index ) ; else av_log ( NULL , AV_LOG_ERROR , \"Error demuxing input file %d: %s\\n\" , f -> index , av_err2str ( ret ) ) ; break ; } if ( do_pkt_dump ) { av_pkt_dump_log2 ( NULL , AV_LOG_INFO , pkt , do_hex_dump , f -> ctx -> streams [ pkt -> stream_index ] ) ; } /* the following test is needed in case new streams appear\n           dynamically in stream : we ignore them */ if ( pkt -> stream_index >= f -> nb_streams ) { report_new_stream ( d , pkt ) ; av_packet_unref ( pkt ) ; continue ; } if ( pkt -> flags & AV_PKT_FLAG_CORRUPT ) { av_log ( NULL , exit_on_error ? AV_LOG_FATAL : AV_LOG_WARNING , \"%s: corrupt input packet in stream %d\\n\" , f -> ctx -> url , pkt -> stream_index ) ; if ( exit_on_error ) { av_packet_unref ( pkt ) ; ret = AVERROR_INVALIDDATA ; break ; } } ts_fixup ( d , pkt , & msg . repeat_pict ) ; msg . pkt = av_packet_alloc ( ) ; if ( ! msg . pkt ) { av_packet_unref ( pkt ) ; ret = AVERROR ( ENOMEM ) ; break ; } av_packet_move_ref ( msg . pkt , pkt ) ; ret = av_thread_message_queue_send ( d -> in_thread_queue , & msg , flags ) ; if ( flags && ret == AVERROR ( EAGAIN ) ) { flags = 0 ; ret = av_thread_message_queue_send ( d -> in_thread_queue , & msg , flags ) ; av_log ( f -> ctx , AV_LOG_WARNING , \"Thread message queue blocking; consider raising the \" \"thread_queue_size option (current value: %d)\\n\" , d -> thread_queue_size ) ; } if ( ret < 0 ) { if ( ret != AVERROR_EOF ) av_log ( f -> ctx , AV_LOG_ERROR , \"Unable to send packet to main thread: %s\\n\" , av_err2str ( ret ) ) ; av_packet_free ( & msg . pkt ) ; break ; } } finish : av_assert0 ( ret < 0 ) ; av_thread_message_queue_set_err_recv ( d -> in_thread_queue , ret ) ; av_packet_free ( & pkt ) ; av_log ( NULL , AV_LOG_VERBOSE , \"Terminating demuxer thread %d\\n\" , f -> index ) ; return NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@thread_stop": "static void thread_stop ( Demuxer * d ) { InputFile * f = & d -> f ; DemuxMsg msg ; if ( ! d -> in_thread_queue ) return ; av_thread_message_queue_set_err_send ( d -> in_thread_queue , AVERROR_EOF ) ; while ( av_thread_message_queue_recv ( d -> in_thread_queue , & msg , 0 ) >= 0 ) av_packet_free ( & msg . pkt ) ; pthread_join ( d -> thread , NULL ) ; av_thread_message_queue_free ( & d -> in_thread_queue ) ; av_thread_message_queue_free ( & f -> audio_duration_queue ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@thread_start": "static int thread_start ( Demuxer * d ) { int ret ; InputFile * f = & d -> f ; if ( d -> thread_queue_size <= 0 ) d -> thread_queue_size = ( nb_input_files > 1 ? 8 : 1 ) ; if ( nb_input_files > 1 && ( f -> ctx -> pb ? ! f -> ctx -> pb -> seekable : strcmp ( f -> ctx -> iformat -> name , \"lavfi\" ) ) ) d -> non_blocking = 1 ; ret = av_thread_message_queue_alloc ( & d -> in_thread_queue , d -> thread_queue_size , sizeof ( DemuxMsg ) ) ; if ( ret < 0 ) return ret ; if ( d -> loop ) { int nb_audio_dec = 0 ; for ( int i = 0 ; i < f -> nb_streams ; i ++ ) { InputStream * ist = f -> streams [ i ] ; nb_audio_dec += ! ! ( ist -> decoding_needed && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) ; } if ( nb_audio_dec ) { ret = av_thread_message_queue_alloc ( & f -> audio_duration_queue , nb_audio_dec , sizeof ( LastFrameDuration ) ) ; if ( ret < 0 ) goto fail ; f -> audio_duration_queue_size = nb_audio_dec ; } } if ( ( ret = pthread_create ( & d -> thread , NULL , input_thread , d ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"pthread_create failed: %s. Try to increase `ulimit -v` or decrease `ulimit -s`.\\n\" , strerror ( ret ) ) ; ret = AVERROR ( ret ) ; goto fail ; } return 0 ; fail : av_thread_message_queue_free ( & d -> in_thread_queue ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@ifile_get_packet": "int ifile_get_packet ( InputFile * f , AVPacket * * pkt ) { Demuxer * d = demuxer_from_ifile ( f ) ; InputStream * ist ; DemuxMsg msg ; int ret ; if ( ! d -> in_thread_queue ) { ret = thread_start ( d ) ; if ( ret < 0 ) return ret ; } if ( f -> readrate || f -> rate_emu ) { int i ; int64_t file_start = copy_ts * ( ( f -> start_time_effective != AV_NOPTS_VALUE ? f -> start_time_effective * ! start_at_zero : 0 ) + ( f -> start_time != AV_NOPTS_VALUE ? f -> start_time : 0 ) ) ; float scale = f -> rate_emu ? 1.0 : f -> readrate ; for ( i = 0 ; i < f -> nb_streams ; i ++ ) { InputStream * ist = f -> streams [ i ] ; int64_t stream_ts_offset , pts , now ; if ( ! ist -> nb_packets || ( ist -> decoding_needed && ! ist -> got_output ) ) continue ; stream_ts_offset = FFMAX ( ist -> first_dts != AV_NOPTS_VALUE ? ist -> first_dts : 0 , file_start ) ; pts = av_rescale ( ist -> dts , 1000000 , AV_TIME_BASE ) ; now = ( av_gettime_relative ( ) - ist -> start ) * scale + stream_ts_offset ; if ( pts > now ) return AVERROR ( EAGAIN ) ; } } ret = av_thread_message_queue_recv ( d -> in_thread_queue , & msg , d -> non_blocking ? AV_THREAD_MESSAGE_NONBLOCK : 0 ) ; if ( ret < 0 ) return ret ; if ( msg . looping ) return 1 ; ist = f -> streams [ msg . pkt -> stream_index ] ; ist -> last_pkt_repeat_pict = msg . repeat_pict ; * pkt = msg . pkt ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@ist_free": "static void ist_free ( InputStream * * pist ) { InputStream * ist = * pist ; if ( ! ist ) return ; av_frame_free ( & ist -> decoded_frame ) ; av_packet_free ( & ist -> pkt ) ; av_dict_free ( & ist -> decoder_opts ) ; avsubtitle_free ( & ist -> prev_sub . subtitle ) ; av_frame_free ( & ist -> sub2video . frame ) ; av_freep ( & ist -> filters ) ; av_freep ( & ist -> hwaccel_device ) ; av_freep ( & ist -> dts_buffer ) ; avcodec_free_context ( & ist -> dec_ctx ) ; avcodec_parameters_free ( & ist -> par ) ; av_freep ( pist ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@ifile_close": "void ifile_close ( InputFile * * pf ) { InputFile * f = * pf ; Demuxer * d = demuxer_from_ifile ( f ) ; if ( ! f ) return ; thread_stop ( d ) ; for ( int i = 0 ; i < f -> nb_streams ; i ++ ) ist_free ( & f -> streams [ i ] ) ; av_freep ( & f -> streams ) ; avformat_close_input ( & f -> ctx ) ; av_freep ( pf ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@choose_decoder": "static const AVCodec * choose_decoder ( const OptionsContext * o , AVFormatContext * s , AVStream * st , enum HWAccelID hwaccel_id , enum AVHWDeviceType hwaccel_device_type ) { char * codec_name = NULL ; MATCH_PER_STREAM_OPT ( codec_names , str , codec_name , s , st ) ; if ( codec_name ) { const AVCodec * codec = find_codec_or_die ( NULL , codec_name , st -> codecpar -> codec_type , 0 ) ; st -> codecpar -> codec_id = codec -> id ; if ( recast_media && st -> codecpar -> codec_type != codec -> type ) st -> codecpar -> codec_type = codec -> type ; return codec ; } else { if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && hwaccel_id == HWACCEL_GENERIC && hwaccel_device_type != AV_HWDEVICE_TYPE_NONE ) { const AVCodec * c ; void * i = NULL ; while ( ( c = av_codec_iterate ( & i ) ) ) { const AVCodecHWConfig * config ; if ( c -> id != st -> codecpar -> codec_id || ! av_codec_is_decoder ( c ) ) continue ; for ( int j = 0 ; ( config = avcodec_get_hw_config ( c , j ) ) ; j ++ ) { if ( config -> device_type == hwaccel_device_type ) { av_log ( NULL , AV_LOG_VERBOSE , \"Selecting decoder '%s' because of requested hwaccel method %s\\n\" , c -> name , av_hwdevice_get_type_name ( hwaccel_device_type ) ) ; return c ; } } } } return avcodec_find_decoder ( st -> codecpar -> codec_id ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@guess_input_channel_layout": "static int guess_input_channel_layout ( InputStream * ist ) { AVCodecContext * dec = ist -> dec_ctx ; if ( dec -> ch_layout . order == AV_CHANNEL_ORDER_UNSPEC ) { char layout_name [ 256 ] ; if ( dec -> ch_layout . nb_channels > ist -> guess_layout_max ) return 0 ; av_channel_layout_default ( & dec -> ch_layout , dec -> ch_layout . nb_channels ) ; if ( dec -> ch_layout . order == AV_CHANNEL_ORDER_UNSPEC ) return 0 ; av_channel_layout_describe ( & dec -> ch_layout , layout_name , sizeof ( layout_name ) ) ; av_log ( NULL , AV_LOG_WARNING , \"Guessed Channel Layout for Input Stream \" \"#%d.%d : %s\\n\" , ist -> file_index , ist -> st -> index , layout_name ) ; } return 1 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@add_display_matrix_to_stream": "static void add_display_matrix_to_stream ( const OptionsContext * o , AVFormatContext * ctx , AVStream * st ) { double rotation = DBL_MAX ; int hflip = - 1 , vflip = - 1 ; int hflip_set = 0 , vflip_set = 0 , rotation_set = 0 ; int32_t * buf ; MATCH_PER_STREAM_OPT ( display_rotations , dbl , rotation , ctx , st ) ; MATCH_PER_STREAM_OPT ( display_hflips , i , hflip , ctx , st ) ; MATCH_PER_STREAM_OPT ( display_vflips , i , vflip , ctx , st ) ; rotation_set = rotation != DBL_MAX ; hflip_set = hflip != - 1 ; vflip_set = vflip != - 1 ; if ( ! rotation_set && ! hflip_set && ! vflip_set ) return ; buf = ( int32_t * ) av_stream_new_side_data ( st , AV_PKT_DATA_DISPLAYMATRIX , sizeof ( int32_t ) * 9 ) ; if ( ! buf ) { av_log ( NULL , AV_LOG_FATAL , \"Failed to generate a display matrix!\\n\" ) ; exit_program ( 1 ) ; } av_display_rotation_set ( buf , rotation_set ? - ( rotation ) : - 0.0f ) ; av_display_matrix_flip ( buf , hflip_set ? hflip : 0 , vflip_set ? vflip : 0 ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@add_input_streams": "static void add_input_streams ( const OptionsContext * o , Demuxer * d ) { InputFile * f = & d -> f ; AVFormatContext * ic = f -> ctx ; int i , ret ; for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { AVStream * st = ic -> streams [ i ] ; AVCodecParameters * par = st -> codecpar ; InputStream * ist ; char * framerate = NULL , * hwaccel_device = NULL ; const char * hwaccel = NULL ; char * hwaccel_output_format = NULL ; char * codec_tag = NULL ; char * next ; char * discard_str = NULL ; const AVClass * cc = avcodec_get_class ( ) ; const AVOption * discard_opt = av_opt_find ( & cc , \"skip_frame\" , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ; ist = ALLOC_ARRAY_ELEM ( f -> streams , f -> nb_streams ) ; ist -> st = st ; ist -> file_index = f -> index ; ist -> discard = 1 ; st -> discard = AVDISCARD_ALL ; ist -> nb_samples = 0 ; ist -> first_dts = AV_NOPTS_VALUE ; ist -> min_pts = INT64_MAX ; ist -> max_pts = INT64_MIN ; ist -> ts_scale = 1.0 ; MATCH_PER_STREAM_OPT ( ts_scale , dbl , ist -> ts_scale , ic , st ) ; ist -> autorotate = 1 ; MATCH_PER_STREAM_OPT ( autorotate , i , ist -> autorotate , ic , st ) ; MATCH_PER_STREAM_OPT ( codec_tags , str , codec_tag , ic , st ) ; if ( codec_tag ) { uint32_t tag = strtol ( codec_tag , & next , 0 ) ; if ( * next ) tag = AV_RL32 ( codec_tag ) ; st -> codecpar -> codec_tag = tag ; } if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { add_display_matrix_to_stream ( o , ic , st ) ; MATCH_PER_STREAM_OPT ( hwaccels , str , hwaccel , ic , st ) ; MATCH_PER_STREAM_OPT ( hwaccel_output_formats , str , hwaccel_output_format , ic , st ) ; if ( ! hwaccel_output_format && hwaccel && ! strcmp ( hwaccel , \"cuvid\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"WARNING: defaulting hwaccel_output_format to cuda for compatibility \" \"with old commandlines. This behaviour is DEPRECATED and will be removed \" \"in the future. Please explicitly set \\\"-hwaccel_output_format cuda\\\".\\n\" ) ; ist -> hwaccel_output_format = AV_PIX_FMT_CUDA ; } else if ( ! hwaccel_output_format && hwaccel && ! strcmp ( hwaccel , \"qsv\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"WARNING: defaulting hwaccel_output_format to qsv for compatibility \" \"with old commandlines. This behaviour is DEPRECATED and will be removed \" \"in the future. Please explicitly set \\\"-hwaccel_output_format qsv\\\".\\n\" ) ; ist -> hwaccel_output_format = AV_PIX_FMT_QSV ; } else if ( ! hwaccel_output_format && hwaccel && ! strcmp ( hwaccel , \"mediacodec\" ) ) { // There is no real AVHWFrameContext implementation. Set // hwaccel_output_format to avoid av_hwframe_transfer_data error. ist -> hwaccel_output_format = AV_PIX_FMT_MEDIACODEC ; } else if ( hwaccel_output_format ) { ist -> hwaccel_output_format = av_get_pix_fmt ( hwaccel_output_format ) ; if ( ist -> hwaccel_output_format == AV_PIX_FMT_NONE ) { av_log ( NULL , AV_LOG_FATAL , \"Unrecognised hwaccel output \" \"format: %s\" , hwaccel_output_format ) ; } } else { ist -> hwaccel_output_format = AV_PIX_FMT_NONE ; } if ( hwaccel ) { // The NVDEC hwaccels use a CUDA device, so remap the name here. if ( ! strcmp ( hwaccel , \"nvdec\" ) || ! strcmp ( hwaccel , \"cuvid\" ) ) hwaccel = \"cuda\" ; if ( ! strcmp ( hwaccel , \"none\" ) ) ist -> hwaccel_id = HWACCEL_NONE ; else if ( ! strcmp ( hwaccel , \"auto\" ) ) ist -> hwaccel_id = HWACCEL_AUTO ; else { enum AVHWDeviceType type = av_hwdevice_find_type_by_name ( hwaccel ) ; if ( type != AV_HWDEVICE_TYPE_NONE ) { ist -> hwaccel_id = HWACCEL_GENERIC ; ist -> hwaccel_device_type = type ; } if ( ! ist -> hwaccel_id ) { av_log ( NULL , AV_LOG_FATAL , \"Unrecognized hwaccel: %s.\\n\" , hwaccel ) ; av_log ( NULL , AV_LOG_FATAL , \"Supported hwaccels: \" ) ; type = AV_HWDEVICE_TYPE_NONE ; while ( ( type = av_hwdevice_iterate_types ( type ) ) != AV_HWDEVICE_TYPE_NONE ) av_log ( NULL , AV_LOG_FATAL , \"%s \" , av_hwdevice_get_type_name ( type ) ) ; av_log ( NULL , AV_LOG_FATAL , \"\\n\" ) ; exit_program ( 1 ) ; } } } MATCH_PER_STREAM_OPT ( hwaccel_devices , str , hwaccel_device , ic , st ) ; if ( hwaccel_device ) { ist -> hwaccel_device = av_strdup ( hwaccel_device ) ; if ( ! ist -> hwaccel_device ) report_and_exit ( AVERROR ( ENOMEM ) ) ; } ist -> hwaccel_pix_fmt = AV_PIX_FMT_NONE ; } ist -> dec = choose_decoder ( o , ic , st , ist -> hwaccel_id , ist -> hwaccel_device_type ) ; ist -> decoder_opts = filter_codec_opts ( o -> g -> codec_opts , ist -> st -> codecpar -> codec_id , ic , st , ist -> dec ) ; ist -> reinit_filters = - 1 ; MATCH_PER_STREAM_OPT ( reinit_filters , i , ist -> reinit_filters , ic , st ) ; MATCH_PER_STREAM_OPT ( discard , str , discard_str , ic , st ) ; ist -> user_set_discard = AVDISCARD_NONE ; if ( ( o -> video_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) || ( o -> audio_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) || ( o -> subtitle_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_SUBTITLE ) || ( o -> data_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) ) ist -> user_set_discard = AVDISCARD_ALL ; if ( discard_str && av_opt_eval_int ( & cc , discard_opt , discard_str , & ist -> user_set_discard ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing discard %s.\\n\" , discard_str ) ; exit_program ( 1 ) ; } ist -> filter_in_rescale_delta_last = AV_NOPTS_VALUE ; ist -> prev_pkt_pts = AV_NOPTS_VALUE ; ist -> dec_ctx = avcodec_alloc_context3 ( ist -> dec ) ; if ( ! ist -> dec_ctx ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ret = avcodec_parameters_to_context ( ist -> dec_ctx , par ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error initializing the decoder context.\\n\" ) ; exit_program ( 1 ) ; } ist -> decoded_frame = av_frame_alloc ( ) ; if ( ! ist -> decoded_frame ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ist -> pkt = av_packet_alloc ( ) ; if ( ! ist -> pkt ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( o -> bitexact ) ist -> dec_ctx -> flags |= AV_CODEC_FLAG_BITEXACT ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : // avformat_find_stream_info() doesn't set this for us anymore. ist -> dec_ctx -> framerate = st -> avg_frame_rate ; MATCH_PER_STREAM_OPT ( frame_rates , str , framerate , ic , st ) ; if ( framerate && av_parse_video_rate ( & ist -> framerate , framerate ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing framerate %s.\\n\" , framerate ) ; exit_program ( 1 ) ; } ist -> top_field_first = - 1 ; MATCH_PER_STREAM_OPT ( top_field_first , i , ist -> top_field_first , ic , st ) ; ist -> framerate_guessed = av_guess_frame_rate ( ic , st , NULL ) ; break ; case AVMEDIA_TYPE_AUDIO : ist -> guess_layout_max = INT_MAX ; MATCH_PER_STREAM_OPT ( guess_layout_max , i , ist -> guess_layout_max , ic , st ) ; guess_input_channel_layout ( ist ) ; break ; case AVMEDIA_TYPE_DATA : case AVMEDIA_TYPE_SUBTITLE : { char * canvas_size = NULL ; MATCH_PER_STREAM_OPT ( fix_sub_duration , i , ist -> fix_sub_duration , ic , st ) ; MATCH_PER_STREAM_OPT ( canvas_sizes , str , canvas_size , ic , st ) ; if ( canvas_size && av_parse_video_size ( & ist -> dec_ctx -> width , & ist -> dec_ctx -> height , canvas_size ) < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid canvas size: %s.\\n\" , canvas_size ) ; exit_program ( 1 ) ; } break ; } case AVMEDIA_TYPE_ATTACHMENT : case AVMEDIA_TYPE_UNKNOWN : break ; default : abort ( ) ; } ist -> par = avcodec_parameters_alloc ( ) ; if ( ! ist -> par ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ret = avcodec_parameters_from_context ( ist -> par , ist -> dec_ctx ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error initializing the decoder context.\\n\" ) ; exit_program ( 1 ) ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@dump_attachment": "static void dump_attachment ( AVStream * st , const char * filename ) { int ret ; AVIOContext * out = NULL ; const AVDictionaryEntry * e ; if ( ! st -> codecpar -> extradata_size ) { av_log ( NULL , AV_LOG_WARNING , \"No extradata to dump in stream #%d:%d.\\n\" , nb_input_files - 1 , st -> index ) ; return ; } if ( ! * filename && ( e = av_dict_get ( st -> metadata , \"filename\" , NULL , 0 ) ) ) filename = e -> value ; if ( ! * filename ) { av_log ( NULL , AV_LOG_FATAL , \"No filename specified and no 'filename' tag\" \"in stream #%d:%d.\\n\" , nb_input_files - 1 , st -> index ) ; exit_program ( 1 ) ; } assert_file_overwrite ( filename ) ; if ( ( ret = avio_open2 ( & out , filename , AVIO_FLAG_WRITE , & int_cb , NULL ) ) < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Could not open file %s for writing.\\n\" , filename ) ; exit_program ( 1 ) ; } avio_write ( out , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ; avio_flush ( out ) ; avio_close ( out ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_demux.c@ifile_open": "int ifile_open ( const OptionsContext * o , const char * filename ) { Demuxer * d ; InputFile * f ; AVFormatContext * ic ; const AVInputFormat * file_iformat = NULL ; int err , i , ret ; int64_t timestamp ; AVDictionary * unused_opts = NULL ; const AVDictionaryEntry * e = NULL ; char * video_codec_name = NULL ; char * audio_codec_name = NULL ; char * subtitle_codec_name = NULL ; char * data_codec_name = NULL ; int scan_all_pmts_set = 0 ; int64_t start_time = o -> start_time ; int64_t start_time_eof = o -> start_time_eof ; int64_t stop_time = o -> stop_time ; int64_t recording_time = o -> recording_time ; if ( stop_time != INT64_MAX && recording_time != INT64_MAX ) { stop_time = INT64_MAX ; av_log ( NULL , AV_LOG_WARNING , \"-t and -to cannot be used together; using -t.\\n\" ) ; } if ( stop_time != INT64_MAX && recording_time == INT64_MAX ) { int64_t start = start_time == AV_NOPTS_VALUE ? 0 : start_time ; if ( stop_time <= start ) { av_log ( NULL , AV_LOG_ERROR , \"-to value smaller than -ss; aborting.\\n\" ) ; exit_program ( 1 ) ; } else { recording_time = stop_time - start ; } } if ( o -> format ) { if ( ! ( file_iformat = av_find_input_format ( o -> format ) ) ) { av_log ( NULL , AV_LOG_FATAL , \"Unknown input format: '%s'\\n\" , o -> format ) ; exit_program ( 1 ) ; } } if ( ! strcmp ( filename , \"-\" ) ) filename = \"fd:\" ; stdin_interaction &= strncmp ( filename , \"pipe:\" , 5 ) && strcmp ( filename , \"fd:\" ) && strcmp ( filename , \"/dev/stdin\" ) ; /* get default parameters from command line */ ic = avformat_alloc_context ( ) ; if ( ! ic ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( o -> nb_audio_sample_rate ) { av_dict_set_int ( & o -> g -> format_opts , \"sample_rate\" , o -> audio_sample_rate [ o -> nb_audio_sample_rate - 1 ] . u . i , 0 ) ; } if ( o -> nb_audio_channels ) { const AVClass * priv_class ; if ( file_iformat && ( priv_class = file_iformat -> priv_class ) && av_opt_find ( & priv_class , \"ch_layout\" , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ) { char buf [ 32 ] ; snprintf ( buf , sizeof ( buf ) , \"%dC\" , o -> audio_channels [ o -> nb_audio_channels - 1 ] . u . i ) ; av_dict_set ( & o -> g -> format_opts , \"ch_layout\" , buf , 0 ) ; } } if ( o -> nb_audio_ch_layouts ) { const AVClass * priv_class ; if ( file_iformat && ( priv_class = file_iformat -> priv_class ) && av_opt_find ( & priv_class , \"ch_layout\" , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ) { av_dict_set ( & o -> g -> format_opts , \"ch_layout\" , o -> audio_ch_layouts [ o -> nb_audio_ch_layouts - 1 ] . u . str , 0 ) ; } } if ( o -> nb_frame_rates ) { const AVClass * priv_class ; /* set the format-level framerate option;\n         * this is important for video grabbers, e.g. x11 */ if ( file_iformat && ( priv_class = file_iformat -> priv_class ) && av_opt_find ( & priv_class , \"framerate\" , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ) { av_dict_set ( & o -> g -> format_opts , \"framerate\" , o -> frame_rates [ o -> nb_frame_rates - 1 ] . u . str , 0 ) ; } } if ( o -> nb_frame_sizes ) { av_dict_set ( & o -> g -> format_opts , \"video_size\" , o -> frame_sizes [ o -> nb_frame_sizes - 1 ] . u . str , 0 ) ; } if ( o -> nb_frame_pix_fmts ) av_dict_set ( & o -> g -> format_opts , \"pixel_format\" , o -> frame_pix_fmts [ o -> nb_frame_pix_fmts - 1 ] . u . str , 0 ) ; MATCH_PER_TYPE_OPT ( codec_names , str , video_codec_name , ic , \"v\" ) ; MATCH_PER_TYPE_OPT ( codec_names , str , audio_codec_name , ic , \"a\" ) ; MATCH_PER_TYPE_OPT ( codec_names , str , subtitle_codec_name , ic , \"s\" ) ; MATCH_PER_TYPE_OPT ( codec_names , str , data_codec_name , ic , \"d\" ) ; if ( video_codec_name ) ic -> video_codec = find_codec_or_die ( NULL , video_codec_name , AVMEDIA_TYPE_VIDEO , 0 ) ; if ( audio_codec_name ) ic -> audio_codec = find_codec_or_die ( NULL , audio_codec_name , AVMEDIA_TYPE_AUDIO , 0 ) ; if ( subtitle_codec_name ) ic -> subtitle_codec = find_codec_or_die ( NULL , subtitle_codec_name , AVMEDIA_TYPE_SUBTITLE , 0 ) ; if ( data_codec_name ) ic -> data_codec = find_codec_or_die ( NULL , data_codec_name , AVMEDIA_TYPE_DATA , 0 ) ; ic -> video_codec_id = video_codec_name ? ic -> video_codec -> id : AV_CODEC_ID_NONE ; ic -> audio_codec_id = audio_codec_name ? ic -> audio_codec -> id : AV_CODEC_ID_NONE ; ic -> subtitle_codec_id = subtitle_codec_name ? ic -> subtitle_codec -> id : AV_CODEC_ID_NONE ; ic -> data_codec_id = data_codec_name ? ic -> data_codec -> id : AV_CODEC_ID_NONE ; ic -> flags |= AVFMT_FLAG_NONBLOCK ; if ( o -> bitexact ) ic -> flags |= AVFMT_FLAG_BITEXACT ; ic -> interrupt_callback = int_cb ; if ( ! av_dict_get ( o -> g -> format_opts , \"scan_all_pmts\" , NULL , AV_DICT_MATCH_CASE ) ) { av_dict_set ( & o -> g -> format_opts , \"scan_all_pmts\" , \"1\" , AV_DICT_DONT_OVERWRITE ) ; scan_all_pmts_set = 1 ; } /* open the input file with generic avformat function */ err = avformat_open_input ( & ic , filename , file_iformat , & o -> g -> format_opts ) ; if ( err < 0 ) { print_error ( filename , err ) ; if ( err == AVERROR_PROTOCOL_NOT_FOUND ) av_log ( NULL , AV_LOG_ERROR , \"Did you mean file:%s?\\n\" , filename ) ; exit_program ( 1 ) ; } if ( scan_all_pmts_set ) av_dict_set ( & o -> g -> format_opts , \"scan_all_pmts\" , NULL , AV_DICT_MATCH_CASE ) ; remove_avoptions ( & o -> g -> format_opts , o -> g -> codec_opts ) ; assert_avoptions ( o -> g -> format_opts ) ; /* apply forced codec ids */ for ( i = 0 ; i < ic -> nb_streams ; i ++ ) choose_decoder ( o , ic , ic -> streams [ i ] , HWACCEL_NONE , AV_HWDEVICE_TYPE_NONE ) ; if ( o -> find_stream_info ) { AVDictionary * * opts = setup_find_stream_info_opts ( ic , o -> g -> codec_opts ) ; int orig_nb_streams = ic -> nb_streams ; /* If not enough info to get the stream parameters, we decode the\n           first frames to get it. (used in mpeg case for example) */ ret = avformat_find_stream_info ( ic , opts ) ; for ( i = 0 ; i < orig_nb_streams ; i ++ ) av_dict_free ( & opts [ i ] ) ; av_freep ( & opts ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"%s: could not find codec parameters\\n\" , filename ) ; if ( ic -> nb_streams == 0 ) { avformat_close_input ( & ic ) ; exit_program ( 1 ) ; } } } if ( start_time != AV_NOPTS_VALUE && start_time_eof != AV_NOPTS_VALUE ) { av_log ( NULL , AV_LOG_WARNING , \"Cannot use -ss and -sseof both, using -ss for %s\\n\" , filename ) ; start_time_eof = AV_NOPTS_VALUE ; } if ( start_time_eof != AV_NOPTS_VALUE ) { if ( start_time_eof >= 0 ) { av_log ( NULL , AV_LOG_ERROR , \"-sseof value must be negative; aborting\\n\" ) ; exit_program ( 1 ) ; } if ( ic -> duration > 0 ) { start_time = start_time_eof + ic -> duration ; if ( start_time < 0 ) { av_log ( NULL , AV_LOG_WARNING , \"-sseof value seeks to before start of file %s; ignored\\n\" , filename ) ; start_time = AV_NOPTS_VALUE ; } } else av_log ( NULL , AV_LOG_WARNING , \"Cannot use -sseof, duration of %s not known\\n\" , filename ) ; } timestamp = ( start_time == AV_NOPTS_VALUE ) ? 0 : start_time ; /* add the stream start time */ if ( ! o -> seek_timestamp && ic -> start_time != AV_NOPTS_VALUE ) timestamp += ic -> start_time ; /* if seeking requested, we execute it */ if ( start_time != AV_NOPTS_VALUE ) { int64_t seek_timestamp = timestamp ; if ( ! ( ic -> iformat -> flags & AVFMT_SEEK_TO_PTS ) ) { int dts_heuristic = 0 ; for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { const AVCodecParameters * par = ic -> streams [ i ] -> codecpar ; if ( par -> video_delay ) { dts_heuristic = 1 ; break ; } } if ( dts_heuristic ) { seek_timestamp -= 3 * AV_TIME_BASE / 23 ; } } ret = avformat_seek_file ( ic , - 1 , INT64_MIN , seek_timestamp , seek_timestamp , 0 ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_WARNING , \"%s: could not seek to position %0.3f\\n\" , filename , ( double ) timestamp / AV_TIME_BASE ) ; } } d = allocate_array_elem ( & input_files , sizeof ( * d ) , & nb_input_files ) ; f = & d -> f ; f -> ctx = ic ; f -> index = nb_input_files - 1 ; f -> start_time = start_time ; f -> recording_time = recording_time ; f -> input_sync_ref = o -> input_sync_ref ; f -> input_ts_offset = o -> input_ts_offset ; f -> ts_offset = o -> input_ts_offset - ( copy_ts ? ( start_at_zero && ic -> start_time != AV_NOPTS_VALUE ? ic -> start_time : 0 ) : timestamp ) ; f -> rate_emu = o -> rate_emu ; f -> accurate_seek = o -> accurate_seek ; d -> loop = o -> loop ; d -> duration = 0 ; d -> time_base = ( AVRational ) { 1 , 1 } ; f -> readrate = o -> readrate ? o -> readrate : 0.0 ; if ( f -> readrate < 0.0f ) { av_log ( NULL , AV_LOG_ERROR , \"Option -readrate for Input #%d is %0.3f; it must be non-negative.\\n\" , f -> index , f -> readrate ) ; exit_program ( 1 ) ; } if ( f -> readrate && f -> rate_emu ) { av_log ( NULL , AV_LOG_WARNING , \"Both -readrate and -re set for Input #%d. Using -readrate %0.3f.\\n\" , f -> index , f -> readrate ) ; f -> rate_emu = 0 ; } d -> thread_queue_size = o -> thread_queue_size ; /* update the current parameters so that they match the one of the input stream */ add_input_streams ( o , d ) ; /* dump the file content */ av_dump_format ( ic , f -> index , filename , 0 ) ; /* check if all codec options have been used */ unused_opts = strip_specifiers ( o -> g -> codec_opts ) ; for ( i = 0 ; i < f -> nb_streams ; i ++ ) { e = NULL ; while ( ( e = av_dict_iterate ( f -> streams [ i ] -> decoder_opts , e ) ) ) av_dict_set ( & unused_opts , e -> key , NULL , 0 ) ; } e = NULL ; while ( ( e = av_dict_iterate ( unused_opts , e ) ) ) { const AVClass * class = avcodec_get_class ( ) ; const AVOption * option = av_opt_find ( & class , e -> key , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ; const AVClass * fclass = avformat_get_class ( ) ; const AVOption * foption = av_opt_find ( & fclass , e -> key , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ; if ( ! option || foption ) continue ; if ( ! ( option -> flags & AV_OPT_FLAG_DECODING_PARAM ) ) { av_log ( NULL , AV_LOG_ERROR , \"Codec AVOption %s (%s) specified for \" \"input file #%d (%s) is not a decoding option.\\n\" , e -> key , option -> help ? option -> help : \"\" , f -> index , filename ) ; exit_program ( 1 ) ; } av_log ( NULL , AV_LOG_WARNING , \"Codec AVOption %s (%s) specified for \" \"input file #%d (%s) has not been used for any stream. The most \" \"likely reason is either wrong type (e.g. a video option with \" \"no video streams) or that it is a private option of some decoder \" \"which was not actually used for any stream.\\n\" , e -> key , option -> help ? option -> help : \"\" , f -> index , filename ) ; } av_dict_free ( & unused_opts ) ; for ( i = 0 ; i < o -> nb_dump_attachment ; i ++ ) { int j ; for ( j = 0 ; j < ic -> nb_streams ; j ++ ) { AVStream * st = ic -> streams [ j ] ; if ( check_stream_specifier ( ic , st , o -> dump_attachment [ i ] . specifier ) == 1 ) dump_attachment ( st , o -> dump_attachment [ i ] . u . str ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/ReturnCode.cpp@operator<<": "std :: ostream & operator << ( std :: ostream & out , const std :: shared_ptr < ffmpegkit :: ReturnCode > & o ) { if ( o == nullptr ) { return out ; } else { return out << o -> _value ; } }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@fs_exists": "static bool fs_exists ( const std :: string & s , const bool isFile , const bool isDirectory ) { struct stat dir_info ; if ( stat ( s . c_str ( ) , & dir_info ) == 0 ) { if ( isFile && S_ISREG ( dir_info . st_mode ) ) { return true ; } if ( isDirectory && S_ISDIR ( dir_info . st_mode ) ) { return true ; } } return false ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@fs_create_dir": "static bool fs_create_dir ( const std :: string & s ) { if ( ! fs_exists ( s , false , true ) ) { if ( mkdir ( s . c_str ( ) , S_IRWXU | S_IRWXG | S_IROTH ) != 0 ) { std :: cout << \"Failed to create directory: \" << s << \". Operation failed with \" << errno << \".\" << std :: endl ; return false ; } } return true ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@deleteExpiredSessions": "void deleteExpiredSessions ( ) { while ( sessionHistoryList . size ( ) > sessionHistorySize ) { auto first = sessionHistoryList . front ( ) ; if ( first != nullptr ) { sessionHistoryList . pop_front ( ) ; sessionHistoryMap . erase ( first -> getSessionId ( ) ) ; } } }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@addSessionToSessionHistory": "void addSessionToSessionHistory ( const std :: shared_ptr < ffmpegkit :: Session > session ) { std :: unique_lock < std :: recursive_mutex > lock ( sessionMutex , std :: defer_lock ) ; const long sessionId = session -> getSessionId ( ) ; lock . lock ( ) ; /*\n     * ASYNC SESSIONS CALL THIS METHOD TWICE\n     * THIS CHECK PREVENTS ADDING THE SAME SESSION AGAIN\n     */ if ( sessionHistoryMap . count ( sessionId ) == 0 ) { sessionHistoryMap . insert ( { sessionId , session } ) ; sessionHistoryList . push_back ( session ) ; deleteExpiredSessions ( ) ; } lock . unlock ( ) ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@callbackWait": "static void callbackWait ( int milliSeconds ) { std :: unique_lock < std :: mutex > callbackLock { callbackMutex } ; callbackMonitor . wait_for ( callbackLock , std :: chrono :: milliseconds ( milliSeconds ) ) ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@callbackNotify": "static void callbackNotify ( ) { callbackMonitor . notify_one ( ) ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@avutil_log_get_level_str": "static const char * avutil_log_get_level_str ( int level ) { switch ( level ) { case AV_LOG_STDERR : return \"stderr\" ; case AV_LOG_QUIET : return \"quiet\" ; case AV_LOG_DEBUG : return \"debug\" ; case AV_LOG_VERBOSE : return \"verbose\" ; case AV_LOG_INFO : return \"info\" ; case AV_LOG_WARNING : return \"warning\" ; case AV_LOG_ERROR : return \"error\" ; case AV_LOG_FATAL : return \"fatal\" ; case AV_LOG_PANIC : return \"panic\" ; default : return \"\" ; } }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@avutil_log_format_line": "static void avutil_log_format_line ( void * avcl , int level , const char * fmt , va_list vl , AVBPrint part [ 4 ] , int * print_prefix ) { int flags = av_log_get_flags ( ) ; AVClass * avc = avcl ? * ( AVClass * * ) avcl : NULL ; av_bprint_init ( part + 0 , 0 , 1 ) ; av_bprint_init ( part + 1 , 0 , 1 ) ; av_bprint_init ( part + 2 , 0 , 1 ) ; av_bprint_init ( part + 3 , 0 , 65536 ) ; if ( * print_prefix && avc ) { if ( avc -> parent_log_context_offset ) { AVClass * * parent = * ( AVClass * * * ) ( ( ( uint8_t * ) avcl ) + avc -> parent_log_context_offset ) ; if ( parent && * parent ) { av_bprintf ( part + 0 , \"[%s @ %p] \" , ( * parent ) -> item_name ( parent ) , parent ) ; } } av_bprintf ( part + 1 , \"[%s @ %p] \" , avc -> item_name ( avcl ) , avcl ) ; } if ( * print_prefix && ( level > AV_LOG_QUIET ) && ( flags & AV_LOG_PRINT_LEVEL ) ) av_bprintf ( part + 2 , \"[%s] \" , avutil_log_get_level_str ( level ) ) ; av_vbprintf ( part + 3 , fmt , vl ) ; if ( * part [ 0 ] . str || * part [ 1 ] . str || * part [ 2 ] . str || * part [ 3 ] . str ) { char lastc = part [ 3 ] . len && part [ 3 ] . len <= part [ 3 ] . size ? part [ 3 ] . str [ part [ 3 ] . len - 1 ] : 0 ; * print_prefix = lastc == '\\n' || lastc == '\\r' ; } }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@avutil_log_sanitize": "static void avutil_log_sanitize ( char * line ) { while ( * line ) { if ( * line < 0x08 || ( * line > 0x0D && * line < 0x20 ) ) * line = '?' ; line ++ ; } }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@logCallbackDataAdd": "static void logCallbackDataAdd ( int level , AVBPrint * data ) { std :: unique_lock < std :: recursive_mutex > lock ( callbackDataMutex , std :: defer_lock ) ; CallbackData * callbackData = new CallbackData ( globalSessionId , level , data ) ; lock . lock ( ) ; callbackDataList . push_back ( callbackData ) ; lock . unlock ( ) ; callbackNotify ( ) ; std :: atomic_fetch_add ( & sessionInTransitMessageCountMap [ globalSessionId % SESSION_MAP_SIZE ] , 1 ) ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@statisticsCallbackDataAdd": "static void statisticsCallbackDataAdd ( int frameNumber , float fps , float quality , int64_t size , int time , double bitrate , double speed ) { std :: unique_lock < std :: recursive_mutex > lock ( callbackDataMutex , std :: defer_lock ) ; CallbackData * callbackData = new CallbackData ( globalSessionId , frameNumber , fps , quality , size , time , bitrate , speed ) ; lock . lock ( ) ; callbackDataList . push_back ( callbackData ) ; lock . unlock ( ) ; callbackNotify ( ) ; std :: atomic_fetch_add ( & sessionInTransitMessageCountMap [ globalSessionId % SESSION_MAP_SIZE ] , 1 ) ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@callbackDataRemove": "static CallbackData * callbackDataRemove ( ) { std :: unique_lock < std :: recursive_mutex > lock ( callbackDataMutex , std :: defer_lock ) ; CallbackData * newData = nullptr ; lock . lock ( ) ; if ( callbackDataList . size ( ) > 0 ) { newData = callbackDataList . front ( ) ; callbackDataList . pop_front ( ) ; } lock . unlock ( ) ; return newData ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@registerSessionId": "static void registerSessionId ( long sessionId ) { std :: atomic_store ( & sessionMap [ sessionId % SESSION_MAP_SIZE ] , ( short ) 1 ) ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@removeSession": "static void removeSession ( long sessionId ) { std :: atomic_store ( & sessionMap [ sessionId % SESSION_MAP_SIZE ] , ( short ) 0 ) ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@cancelSession": "void cancelSession ( long sessionId ) { std :: atomic_store ( & sessionMap [ sessionId % SESSION_MAP_SIZE ] , ( short ) 2 ) ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@cancelRequested": "int cancelRequested ( long sessionId ) { if ( std :: atomic_load ( & sessionMap [ sessionId % SESSION_MAP_SIZE ] ) == 2 ) { return 1 ; } else { return 0 ; } }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@resetMessagesInTransmit": "static void resetMessagesInTransmit ( long sessionId ) { std :: atomic_store ( & sessionInTransitMessageCountMap [ sessionId % SESSION_MAP_SIZE ] , 0 ) ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@ffmpegkit_log_callback_function": "void ffmpegkit_log_callback_function ( void * ptr , int level , const char * format , va_list vargs ) { AVBPrint fullLine ; AVBPrint part [ 4 ] ; int print_prefix = 1 ; // DO NOT PROCESS UNWANTED LOGS if ( level >= 0 ) { level &= 0xff ; } int activeLogLevel = av_log_get_level ( ) ; // LevelAVLogStdErr logs are always redirected if ( ( activeLogLevel == ffmpegkit :: LevelAVLogQuiet && level != ffmpegkit :: LevelAVLogStdErr ) || ( level > activeLogLevel ) ) { return ; } av_bprint_init ( & fullLine , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; avutil_log_format_line ( ptr , level , format , vargs , part , & print_prefix ) ; avutil_log_sanitize ( part [ 0 ] . str ) ; avutil_log_sanitize ( part [ 1 ] . str ) ; avutil_log_sanitize ( part [ 2 ] . str ) ; avutil_log_sanitize ( part [ 3 ] . str ) ; // COMBINE ALL 4 LOG PARTS av_bprintf ( & fullLine , \"%s%s%s%s\" , part [ 0 ] . str , part [ 1 ] . str , part [ 2 ] . str , part [ 3 ] . str ) ; if ( fullLine . len > 0 ) { logCallbackDataAdd ( level , & fullLine ) ; } av_bprint_finalize ( part , NULL ) ; av_bprint_finalize ( part + 1 , NULL ) ; av_bprint_finalize ( part + 2 , NULL ) ; av_bprint_finalize ( part + 3 , NULL ) ; av_bprint_finalize ( & fullLine , NULL ) ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@ffmpegkit_statistics_callback_function": "void ffmpegkit_statistics_callback_function ( int frameNumber , float fps , float quality , int64_t size , double time , double bitrate , double speed ) { statisticsCallbackDataAdd ( frameNumber , fps , quality , size , time , bitrate , speed ) ; }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@process_log": "static void process_log ( long sessionId , int levelValueInt , AVBPrint * logMessage ) { int activeLogLevel = av_log_get_level ( ) ; ffmpegkit :: Level levelValue = static_cast < ffmpegkit :: Level > ( levelValueInt ) ; std :: shared_ptr < ffmpegkit :: Log > log = std :: make_shared < ffmpegkit :: Log > ( sessionId , levelValue , logMessage -> str ) ; bool globalCallbackDefined = false ; bool sessionCallbackDefined = false ; ffmpegkit :: LogRedirectionStrategy activeLogRedirectionStrategy = globalLogRedirectionStrategy ; // LevelAVLogStdErr logs are always redirected if ( ( activeLogLevel == ffmpegkit :: LevelAVLogQuiet && levelValue != ffmpegkit :: LevelAVLogStdErr ) || ( levelValue > activeLogLevel ) ) { // LOG NEITHER PRINTED NOR FORWARDED return ; } auto session = ffmpegkit :: FFmpegKitConfig :: getSession ( sessionId ) ; if ( session != nullptr ) { activeLogRedirectionStrategy = session -> getLogRedirectionStrategy ( ) ; session -> addLog ( log ) ; ffmpegkit :: LogCallback sessionLogCallback = session -> getLogCallback ( ) ; if ( sessionLogCallback != nullptr ) { sessionCallbackDefined = true ; try { // NOTIFY SESSION CALLBACK DEFINED sessionLogCallback ( log ) ; } catch ( const std :: exception & exception ) { std :: cout << \"Exception thrown inside session log callback. \" << exception . what ( ) << std :: endl ; } } } ffmpegkit :: LogCallback globalLogCallback = logCallback ; if ( globalLogCallback != nullptr ) { globalCallbackDefined = true ; try { // NOTIFY GLOBAL CALLBACK DEFINED globalLogCallback ( log ) ; } catch ( const std :: exception & exception ) { std :: cout << \"Exception thrown inside global log callback. \" << exception . what ( ) << std :: endl ; } } // EXECUTE THE LOG STRATEGY switch ( activeLogRedirectionStrategy ) { case ffmpegkit :: LogRedirectionStrategyNeverPrintLogs : { return ; } case ffmpegkit :: LogRedirectionStrategyPrintLogsWhenGlobalCallbackNotDefined : { if ( globalCallbackDefined ) { return ; } } break ; case ffmpegkit :: LogRedirectionStrategyPrintLogsWhenSessionCallbackNotDefined : { if ( sessionCallbackDefined ) { return ; } } break ; case ffmpegkit :: LogRedirectionStrategyPrintLogsWhenNoCallbacksDefined : { if ( globalCallbackDefined || sessionCallbackDefined ) { return ; } } break ; case ffmpegkit :: LogRedirectionStrategyAlwaysPrintLogs : { } break ; } // PRINT LOGS switch ( levelValue ) { case ffmpegkit :: LevelAVLogQuiet : // PRINT NO OUTPUT break ; default : // WRITE TO STDOUT std :: cout << ffmpegkit :: FFmpegKitConfig :: logLevelToString ( levelValue ) << \": \" << logMessage -> str ; break ; } }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@process_statistics": "void process_statistics ( long sessionId , int videoFrameNumber , float videoFps , float videoQuality , long size , double time , double bitrate , double speed ) { std :: shared_ptr < ffmpegkit :: Statistics > statistics = std :: make_shared < ffmpegkit :: Statistics > ( sessionId , videoFrameNumber , videoFps , videoQuality , size , time , bitrate , speed ) ; auto session = ffmpegkit :: FFmpegKitConfig :: getSession ( sessionId ) ; if ( session != nullptr && session -> isFFmpeg ( ) ) { std :: shared_ptr < ffmpegkit :: FFmpegSession > ffmpegSession = std :: static_pointer_cast < ffmpegkit :: FFmpegSession > ( session ) ; ffmpegSession -> addStatistics ( statistics ) ; ffmpegkit :: StatisticsCallback sessionStatisticsCallback = ffmpegSession -> getStatisticsCallback ( ) ; if ( sessionStatisticsCallback != nullptr ) { try { sessionStatisticsCallback ( statistics ) ; } catch ( const std :: exception & exception ) { std :: cout << \"Exception thrown inside session statistics callback. \" << exception . what ( ) << std :: endl ; } } } ffmpegkit :: StatisticsCallback globalStatisticsCallback = statisticsCallback ; if ( globalStatisticsCallback != nullptr ) { try { globalStatisticsCallback ( statistics ) ; } catch ( const std :: exception & exception ) { std :: cout << \"Exception thrown inside global statistics callback. \" << exception . what ( ) << std :: endl ; } } }",
    "resources/ffmpeg-kit/linux/src/FFmpegKitConfig.cpp@callbackThreadFunction": "void * callbackThreadFunction ( void * pointer ) { int activeLogLevel = av_log_get_level ( ) ; if ( ( activeLogLevel != ffmpegkit :: LevelAVLogQuiet ) && ( ffmpegkit :: LevelAVLogDebug <= activeLogLevel ) ) { std :: cout << \"Async callback block started.\" << std :: endl ; } while ( redirectionEnabled ) { try { CallbackData * callbackData = callbackDataRemove ( ) ; if ( callbackData != nullptr ) { if ( callbackData -> getType ( ) == LogType ) { process_log ( callbackData -> getSessionId ( ) , callbackData -> getLogLevel ( ) , callbackData -> getLogData ( ) ) ; av_bprint_finalize ( callbackData -> getLogData ( ) , NULL ) ; } else { process_statistics ( callbackData -> getSessionId ( ) , callbackData -> getStatisticsFrameNumber ( ) , callbackData -> getStatisticsFps ( ) , callbackData -> getStatisticsQuality ( ) , callbackData -> getStatisticsSize ( ) , callbackData -> getStatisticsTime ( ) , callbackData -> getStatisticsBitrate ( ) , callbackData -> getStatisticsSpeed ( ) ) ; } std :: atomic_fetch_sub ( & sessionInTransitMessageCountMap [ callbackData -> getSessionId ( ) % SESSION_MAP_SIZE ] , 1 ) ; } else { callbackWait ( 100 ) ; } } catch ( const std :: exception & exception ) { activeLogLevel = av_log_get_level ( ) ; if ( ( activeLogLevel != ffmpegkit :: LevelAVLogQuiet ) && ( ffmpegkit :: LevelAVLogWarning <= activeLogLevel ) ) { std :: cout << \"Async callback block received error: \" << exception . what ( ) << std :: endl ; } } } activeLogLevel = av_log_get_level ( ) ; if ( ( activeLogLevel != ffmpegkit :: LevelAVLogQuiet ) && ( ffmpegkit :: LevelAVLogDebug <= activeLogLevel ) ) { std :: cout << \"Async callback block stopped.\" << std :: endl ; } return NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_objpool.c@objpool_alloc": "ObjPool * objpool_alloc ( ObjPoolCBAlloc cb_alloc , ObjPoolCBReset cb_reset , ObjPoolCBFree cb_free ) { ObjPool * op = av_mallocz ( sizeof ( * op ) ) ; if ( ! op ) return NULL ; op -> alloc = cb_alloc ; op -> reset = cb_reset ; op -> free = cb_free ; return op ; }",
    "resources/ffmpeg-kit/linux/src/fftools_objpool.c@objpool_free": "void objpool_free ( ObjPool * * pop ) { ObjPool * op = * pop ; if ( ! op ) return ; for ( unsigned int i = 0 ; i < op -> pool_count ; i ++ ) op -> free ( & op -> pool [ i ] ) ; av_freep ( pop ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_objpool.c@objpool_get": "int objpool_get ( ObjPool * op , void * * obj ) { if ( op -> pool_count ) { * obj = op -> pool [ -- op -> pool_count ] ; op -> pool [ op -> pool_count ] = NULL ; } else * obj = op -> alloc ( ) ; return * obj ? 0 : AVERROR ( ENOMEM ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_objpool.c@objpool_release": "void objpool_release ( ObjPool * op , void * * obj ) { if ( ! * obj ) return ; op -> reset ( * obj ) ; if ( op -> pool_count < FF_ARRAY_ELEMS ( op -> pool ) ) op -> pool [ op -> pool_count ++ ] = * obj ; else op -> free ( obj ) ; * obj = NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_objpool.c@alloc_packet": "static void * alloc_packet ( void ) { return av_packet_alloc ( ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_objpool.c@alloc_frame": "static void * alloc_frame ( void ) { return av_frame_alloc ( ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_objpool.c@reset_packet": "static void reset_packet ( void * obj ) { av_packet_unref ( obj ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_objpool.c@reset_frame": "static void reset_frame ( void * obj ) { av_frame_unref ( obj ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_objpool.c@free_packet": "static void free_packet ( void * * obj ) { AVPacket * pkt = * obj ; av_packet_free ( & pkt ) ; * obj = NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_objpool.c@free_frame": "static void free_frame ( void * * obj ) { AVFrame * frame = * obj ; av_frame_free ( & frame ) ; * obj = NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_objpool.c@objpool_alloc_packets": "ObjPool * objpool_alloc_packets ( void ) { return objpool_alloc ( alloc_packet , reset_packet , free_packet ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_objpool.c@objpool_alloc_frames": "ObjPool * objpool_alloc_frames ( void ) { return objpool_alloc ( alloc_frame , reset_frame , free_frame ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@log_callback": "static void log_callback ( void * ptr , int level , const char * fmt , va_list vl ) { AVClass * avc = ptr ? * ( AVClass * * ) ptr : NULL ; va_list vl2 ; char line [ 1024 ] ; static int print_prefix = 1 ; void * new_log_buffer ; va_copy ( vl2 , vl ) ; av_log_default_callback ( ptr , level , fmt , vl ) ; av_log_format_line ( ptr , level , fmt , vl2 , line , sizeof ( line ) , & print_prefix ) ; va_end ( vl2 ) ; # if HAVE_THREADS pthread_mutex_lock ( & log_mutex ) ; new_log_buffer = av_realloc_array ( log_buffer , log_buffer_size + 1 , sizeof ( * log_buffer ) ) ; if ( new_log_buffer ) { char * msg ; int i ; log_buffer = new_log_buffer ; memset ( & log_buffer [ log_buffer_size ] , 0 , sizeof ( log_buffer [ log_buffer_size ] ) ) ; log_buffer [ log_buffer_size ] . context_name = avc ? av_strdup ( avc -> item_name ( ptr ) ) : NULL ; if ( avc ) { if ( avc -> get_category ) log_buffer [ log_buffer_size ] . category = avc -> get_category ( ptr ) ; else log_buffer [ log_buffer_size ] . category = avc -> category ; } log_buffer [ log_buffer_size ] . log_level = level ; msg = log_buffer [ log_buffer_size ] . log_message = av_strdup ( line ) ; for ( i = strlen ( msg ) - 1 ; i >= 0 && msg [ i ] == '\\n' ; i -- ) { msg [ i ] = 0 ; } if ( avc && avc -> parent_log_context_offset ) { AVClass * * parent = * ( AVClass * * * ) ( ( ( uint8_t * ) ptr ) + avc -> parent_log_context_offset ) ; if ( parent && * parent ) { log_buffer [ log_buffer_size ] . parent_name = av_strdup ( ( * parent ) -> item_name ( parent ) ) ; log_buffer [ log_buffer_size ] . parent_category = ( * parent ) -> get_category ? ( * parent ) -> get_category ( parent ) : ( * parent ) -> category ; } } log_buffer_size ++ ; } pthread_mutex_unlock ( & log_mutex ) ; # endif }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@ffprobe_cleanup": "static void ffprobe_cleanup ( int ret ) { int i ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( sections ) ; i ++ ) av_dict_free ( & ( sections [ i ] . entries_to_show ) ) ; # if HAVE_THREADS pthread_mutex_destroy ( & log_mutex ) ; # endif }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@value_string": "static char * value_string ( char * buf , int buf_size , struct unit_value uv ) { double vald ; long long int vali ; int show_float = 0 ; if ( uv . unit == unit_second_str ) { vald = uv . val . d ; show_float = 1 ; } else { vald = vali = uv . val . i ; } if ( uv . unit == unit_second_str && use_value_sexagesimal_format ) { double secs ; int hours , mins ; secs = vald ; mins = ( int ) secs / 60 ; secs = secs - mins * 60 ; hours = mins / 60 ; mins %= 60 ; snprintf ( buf , buf_size , \"%d:%02d:%09.6f\" , hours , mins , secs ) ; } else { const char * prefix_string = \"\" ; if ( use_value_prefix && vald > 1 ) { long long int index ; if ( uv . unit == unit_byte_str && use_byte_value_binary_prefix ) { index = ( long long int ) ( log2 ( vald ) ) / 10 ; index = av_clip ( index , 0 , FF_ARRAY_ELEMS ( si_prefixes ) - 1 ) ; vald /= si_prefixes [ index ] . bin_val ; prefix_string = si_prefixes [ index ] . bin_str ; } else { index = ( long long int ) ( log10 ( vald ) ) / 3 ; index = av_clip ( index , 0 , FF_ARRAY_ELEMS ( si_prefixes ) - 1 ) ; vald /= si_prefixes [ index ] . dec_val ; prefix_string = si_prefixes [ index ] . dec_str ; } vali = vald ; } if ( show_float || ( use_value_prefix && vald != ( long long int ) vald ) ) snprintf ( buf , buf_size , \"%f\" , vald ) ; else snprintf ( buf , buf_size , \"%lld\" , vali ) ; av_strlcatf ( buf , buf_size , \"%s%s%s\" , * prefix_string || show_value_unit ? \" \" : \"\" , prefix_string , show_value_unit ? uv . unit : \"\" ) ; } return buf ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_get_name": "static const char * writer_get_name ( void * p ) { WriterContext * wctx = p ; return wctx -> writer -> name ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_child_next": "static void * writer_child_next ( void * obj , void * prev ) { WriterContext * ctx = obj ; if ( ! prev && ctx -> writer && ctx -> writer -> priv_class && ctx -> priv ) return ctx -> priv ; return NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_close": "static int writer_close ( WriterContext * * wctx ) { int i ; int ret = 0 ; if ( ! * wctx ) return - 1 ; if ( ( * wctx ) -> writer -> uninit ) ( * wctx ) -> writer -> uninit ( * wctx ) ; for ( i = 0 ; i < SECTION_MAX_NB_LEVELS ; i ++ ) av_bprint_finalize ( & ( * wctx ) -> section_pbuf [ i ] , NULL ) ; if ( ( * wctx ) -> writer -> priv_class ) av_opt_free ( ( * wctx ) -> priv ) ; av_freep ( & ( ( * wctx ) -> priv ) ) ; av_opt_free ( * wctx ) ; if ( ( * wctx ) -> avio ) { avio_flush ( ( * wctx ) -> avio ) ; ret = avio_close ( ( * wctx ) -> avio ) ; } av_freep ( wctx ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@bprint_bytes": "static void bprint_bytes ( AVBPrint * bp , const uint8_t * ubuf , size_t ubuf_size ) { int i ; av_bprintf ( bp , \"0X\" ) ; for ( i = 0 ; i < ubuf_size ; i ++ ) av_bprintf ( bp , \"%02X\" , ubuf [ i ] ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_w8_avio": "static inline void writer_w8_avio ( WriterContext * wctx , int b ) { avio_w8 ( wctx -> avio , b ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_put_str_avio": "static inline void writer_put_str_avio ( WriterContext * wctx , const char * str ) { avio_write ( wctx -> avio , str , strlen ( str ) ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_printf_avio": "static inline void writer_printf_avio ( WriterContext * wctx , const char * fmt , ... ) { va_list ap ; va_start ( ap , fmt ) ; avio_vprintf ( wctx -> avio , fmt , ap ) ; va_end ( ap ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_w8_printf": "static inline void writer_w8_printf ( WriterContext * wctx , int b ) { av_log ( NULL , AV_LOG_STDERR , \"%c\" , b ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_put_str_printf": "static inline void writer_put_str_printf ( WriterContext * wctx , const char * str ) { av_log ( NULL , AV_LOG_STDERR , \"%s\" , str ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_printf_printf": "static inline void writer_printf_printf ( WriterContext * wctx , const char * fmt , ... ) { va_list ap ; va_start ( ap , fmt ) ; av_vlog ( NULL , AV_LOG_STDERR , fmt , ap ) ; va_end ( ap ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_open": "static int writer_open ( WriterContext * * wctx , const Writer * writer , const char * args , const struct section * sections , int nb_sections , const char * output ) { int i , ret = 0 ; if ( ! ( * wctx = av_mallocz ( sizeof ( WriterContext ) ) ) ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } if ( ! ( ( * wctx ) -> priv = av_mallocz ( writer -> priv_size ) ) ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } ( * wctx ) -> class = & writer_class ; ( * wctx ) -> writer = writer ; ( * wctx ) -> level = - 1 ; ( * wctx ) -> sections = sections ; ( * wctx ) -> nb_sections = nb_sections ; av_opt_set_defaults ( * wctx ) ; if ( writer -> priv_class ) { void * priv_ctx = ( * wctx ) -> priv ; * ( ( const AVClass * * ) priv_ctx ) = writer -> priv_class ; av_opt_set_defaults ( priv_ctx ) ; } /* convert options to dictionary */ if ( args ) { AVDictionary * opts = NULL ; const AVDictionaryEntry * opt = NULL ; if ( ( ret = av_dict_parse_string ( & opts , args , \"=\" , \":\" , 0 ) ) < 0 ) { av_log ( * wctx , AV_LOG_ERROR , \"Failed to parse option string '%s' provided to writer context\\n\" , args ) ; av_dict_free ( & opts ) ; goto fail ; } while ( ( opt = av_dict_iterate ( opts , opt ) ) ) { if ( ( ret = av_opt_set ( * wctx , opt -> key , opt -> value , AV_OPT_SEARCH_CHILDREN ) ) < 0 ) { av_log ( * wctx , AV_LOG_ERROR , \"Failed to set option '%s' with value '%s' provided to writer context\\n\" , opt -> key , opt -> value ) ; av_dict_free ( & opts ) ; goto fail ; } } av_dict_free ( & opts ) ; } /* validate replace string */ { const uint8_t * p = ( * wctx ) -> string_validation_replacement ; const uint8_t * endp = p + strlen ( p ) ; while ( * p ) { const uint8_t * p0 = p ; int32_t code ; ret = av_utf8_decode ( & code , & p , endp , ( * wctx ) -> string_validation_utf8_flags ) ; if ( ret < 0 ) { AVBPrint bp ; av_bprint_init ( & bp , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; bprint_bytes ( & bp , p0 , p - p0 ) , av_log ( wctx , AV_LOG_ERROR , \"Invalid UTF8 sequence %s found in string validation replace '%s'\\n\" , bp . str , ( * wctx ) -> string_validation_replacement ) ; return ret ; } } } if ( ! output_filename ) { ( * wctx ) -> writer_w8 = writer_w8_printf ; ( * wctx ) -> writer_put_str = writer_put_str_printf ; ( * wctx ) -> writer_printf = writer_printf_printf ; } else { if ( ( ret = avio_open ( & ( * wctx ) -> avio , output , AVIO_FLAG_WRITE ) ) < 0 ) { av_log ( * wctx , AV_LOG_ERROR , \"Failed to open output '%s' with error: %s\\n\" , output , av_err2str ( ret ) ) ; goto fail ; } ( * wctx ) -> writer_w8 = writer_w8_avio ; ( * wctx ) -> writer_put_str = writer_put_str_avio ; ( * wctx ) -> writer_printf = writer_printf_avio ; } for ( i = 0 ; i < SECTION_MAX_NB_LEVELS ; i ++ ) av_bprint_init ( & ( * wctx ) -> section_pbuf [ i ] , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; if ( ( * wctx ) -> writer -> init ) ret = ( * wctx ) -> writer -> init ( * wctx ) ; if ( ret < 0 ) goto fail ; return 0 ; fail : writer_close ( wctx ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_print_section_header": "static inline void writer_print_section_header ( WriterContext * wctx , int section_id ) { int parent_section_id ; wctx -> level ++ ; av_assert0 ( wctx -> level < SECTION_MAX_NB_LEVELS ) ; parent_section_id = wctx -> level ? ( wctx -> section [ wctx -> level - 1 ] ) -> id : SECTION_ID_NONE ; wctx -> nb_item [ wctx -> level ] = 0 ; wctx -> section [ wctx -> level ] = & wctx -> sections [ section_id ] ; if ( section_id == SECTION_ID_PACKETS_AND_FRAMES ) { wctx -> nb_section_packet = wctx -> nb_section_frame = wctx -> nb_section_packet_frame = 0 ; } else if ( parent_section_id == SECTION_ID_PACKETS_AND_FRAMES ) { wctx -> nb_section_packet_frame = section_id == SECTION_ID_PACKET ? wctx -> nb_section_packet : wctx -> nb_section_frame ; } if ( wctx -> writer -> print_section_header ) wctx -> writer -> print_section_header ( wctx ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_print_section_footer": "static inline void writer_print_section_footer ( WriterContext * wctx ) { int section_id = wctx -> section [ wctx -> level ] -> id ; int parent_section_id = wctx -> level ? wctx -> section [ wctx -> level - 1 ] -> id : SECTION_ID_NONE ; if ( parent_section_id != SECTION_ID_NONE ) wctx -> nb_item [ wctx -> level - 1 ] ++ ; if ( parent_section_id == SECTION_ID_PACKETS_AND_FRAMES ) { if ( section_id == SECTION_ID_PACKET ) wctx -> nb_section_packet ++ ; else wctx -> nb_section_frame ++ ; } if ( wctx -> writer -> print_section_footer ) wctx -> writer -> print_section_footer ( wctx ) ; wctx -> level -- ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_print_integer": "static inline void writer_print_integer ( WriterContext * wctx , const char * key , long long int val ) { const struct section * section = wctx -> section [ wctx -> level ] ; if ( section -> show_all_entries || av_dict_get ( section -> entries_to_show , key , NULL , 0 ) ) { wctx -> writer -> print_integer ( wctx , key , val ) ; wctx -> nb_item [ wctx -> level ] ++ ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@validate_string": "static inline int validate_string ( WriterContext * wctx , char * * dstp , const char * src ) { const uint8_t * p , * endp ; AVBPrint dstbuf ; int invalid_chars_nb = 0 , ret = 0 ; av_bprint_init ( & dstbuf , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; endp = src + strlen ( src ) ; for ( p = ( uint8_t * ) src ; * p ; ) { uint32_t code ; int invalid = 0 ; const uint8_t * p0 = p ; if ( av_utf8_decode ( & code , & p , endp , wctx -> string_validation_utf8_flags ) < 0 ) { AVBPrint bp ; av_bprint_init ( & bp , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; bprint_bytes ( & bp , p0 , p - p0 ) ; av_log ( wctx , AV_LOG_DEBUG , \"Invalid UTF-8 sequence %s found in string '%s'\\n\" , bp . str , src ) ; invalid = 1 ; } if ( invalid ) { invalid_chars_nb ++ ; switch ( wctx -> string_validation ) { case WRITER_STRING_VALIDATION_FAIL : av_log ( wctx , AV_LOG_ERROR , \"Invalid UTF-8 sequence found in string '%s'\\n\" , src ) ; ret = AVERROR_INVALIDDATA ; goto end ; break ; case WRITER_STRING_VALIDATION_REPLACE : av_bprintf ( & dstbuf , \"%s\" , wctx -> string_validation_replacement ) ; break ; } } if ( ! invalid || wctx -> string_validation == WRITER_STRING_VALIDATION_IGNORE ) av_bprint_append_data ( & dstbuf , p0 , p - p0 ) ; } if ( invalid_chars_nb && wctx -> string_validation == WRITER_STRING_VALIDATION_REPLACE ) { av_log ( wctx , AV_LOG_WARNING , \"%d invalid UTF-8 sequence(s) found in string '%s', replaced with '%s'\\n\" , invalid_chars_nb , src , wctx -> string_validation_replacement ) ; } end : av_bprint_finalize ( & dstbuf , dstp ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_print_string": "static inline int writer_print_string ( WriterContext * wctx , const char * key , const char * val , int flags ) { const struct section * section = wctx -> section [ wctx -> level ] ; int ret = 0 ; if ( show_optional_fields == SHOW_OPTIONAL_FIELDS_NEVER || ( show_optional_fields == SHOW_OPTIONAL_FIELDS_AUTO && ( flags & PRINT_STRING_OPT ) && ! ( wctx -> writer -> flags & WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS ) ) ) return 0 ; if ( section -> show_all_entries || av_dict_get ( section -> entries_to_show , key , NULL , 0 ) ) { if ( flags & PRINT_STRING_VALIDATE ) { char * key1 = NULL , * val1 = NULL ; ret = validate_string ( wctx , & key1 , key ) ; if ( ret < 0 ) goto end ; ret = validate_string ( wctx , & val1 , val ) ; if ( ret < 0 ) goto end ; wctx -> writer -> print_string ( wctx , key1 , val1 ) ; end : if ( ret < 0 ) { av_log ( wctx , AV_LOG_ERROR , \"Invalid key=value string combination %s=%s in section %s\\n\" , key , val , section -> unique_name ) ; } av_free ( key1 ) ; av_free ( val1 ) ; } else { wctx -> writer -> print_string ( wctx , key , val ) ; } wctx -> nb_item [ wctx -> level ] ++ ; } return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_print_rational": "static inline void writer_print_rational ( WriterContext * wctx , const char * key , AVRational q , char sep ) { AVBPrint buf ; av_bprint_init ( & buf , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; av_bprintf ( & buf , \"%d%c%d\" , q . num , sep , q . den ) ; writer_print_string ( wctx , key , buf . str , 0 ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_print_time": "static void writer_print_time ( WriterContext * wctx , const char * key , int64_t ts , const AVRational * time_base , int is_duration ) { char buf [ 128 ] ; if ( ( ! is_duration && ts == AV_NOPTS_VALUE ) || ( is_duration && ts == 0 ) ) { writer_print_string ( wctx , key , \"N/A\" , PRINT_STRING_OPT ) ; } else { double d = ts * av_q2d ( * time_base ) ; struct unit_value uv ; uv . val . d = d ; uv . unit = unit_second_str ; value_string ( buf , sizeof ( buf ) , uv ) ; writer_print_string ( wctx , key , buf , 0 ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_print_ts": "static void writer_print_ts ( WriterContext * wctx , const char * key , int64_t ts , int is_duration ) { if ( ( ! is_duration && ts == AV_NOPTS_VALUE ) || ( is_duration && ts == 0 ) ) { writer_print_string ( wctx , key , \"N/A\" , PRINT_STRING_OPT ) ; } else { writer_print_integer ( wctx , key , ts ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_print_data": "static void writer_print_data ( WriterContext * wctx , const char * name , const uint8_t * data , int size ) { AVBPrint bp ; int offset = 0 , l , i ; av_bprint_init ( & bp , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; av_bprintf ( & bp , \"\\n\" ) ; while ( size ) { av_bprintf ( & bp , \"%08x: \" , offset ) ; l = FFMIN ( size , 16 ) ; for ( i = 0 ; i < l ; i ++ ) { av_bprintf ( & bp , \"%02x\" , data [ i ] ) ; if ( i & 1 ) av_bprintf ( & bp , \" \" ) ; } av_bprint_chars ( & bp , ' ' , 41 - 2 * i - i / 2 ) ; for ( i = 0 ; i < l ; i ++ ) av_bprint_chars ( & bp , data [ i ] - 32U < 95 ? data [ i ] : '.' , 1 ) ; av_bprintf ( & bp , \"\\n\" ) ; offset += l ; data += l ; size -= l ; } writer_print_string ( wctx , name , bp . str , 0 ) ; av_bprint_finalize ( & bp , NULL ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_print_data_hash": "static void writer_print_data_hash ( WriterContext * wctx , const char * name , const uint8_t * data , int size ) { char * p , buf [ AV_HASH_MAX_SIZE * 2 + 64 ] = { 0 } ; if ( ! hash ) return ; av_hash_init ( hash ) ; av_hash_update ( hash , data , size ) ; snprintf ( buf , sizeof ( buf ) , \"%s:\" , av_hash_get_name ( hash ) ) ; p = buf + strlen ( buf ) ; av_hash_final_hex ( hash , p , buf + sizeof ( buf ) - p ) ; writer_print_string ( wctx , name , buf , 0 ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_print_integers": "static void writer_print_integers ( WriterContext * wctx , const char * name , uint8_t * data , int size , const char * format , int columns , int bytes , int offset_add ) { AVBPrint bp ; int offset = 0 , l , i ; av_bprint_init ( & bp , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; av_bprintf ( & bp , \"\\n\" ) ; while ( size ) { av_bprintf ( & bp , \"%08x: \" , offset ) ; l = FFMIN ( size , columns ) ; for ( i = 0 ; i < l ; i ++ ) { if ( bytes == 1 ) av_bprintf ( & bp , format , * data ) ; else if ( bytes == 2 ) av_bprintf ( & bp , format , AV_RN16 ( data ) ) ; else if ( bytes == 4 ) av_bprintf ( & bp , format , AV_RN32 ( data ) ) ; data += bytes ; size -- ; } av_bprintf ( & bp , \"\\n\" ) ; offset += offset_add ; } writer_print_string ( wctx , name , bp . str , 0 ) ; av_bprint_finalize ( & bp , NULL ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_register": "static int writer_register ( const Writer * writer ) { if ( next_registered_writer_idx == MAX_REGISTERED_WRITERS_NB ) return AVERROR ( ENOMEM ) ; registered_writers [ next_registered_writer_idx ++ ] = writer ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_get_by_name": "static const Writer * writer_get_by_name ( const char * name ) { int i ; for ( i = 0 ; registered_writers [ i ] ; i ++ ) if ( ! strcmp ( registered_writers [ i ] -> name , name ) ) return registered_writers [ i ] ; return NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@default_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@upcase_string": "static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@default_print_section_header": "static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@default_print_section_footer": "static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@default_print_str": "static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@default_print_int": "static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@c_escape_str": "static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@csv_escape_str": "static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@none_escape_str": "static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@compact_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@compact_init": "static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@compact_print_section_header": "static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@compact_print_section_footer": "static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@compact_print_str": "static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@compact_print_int": "static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@csv_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@flat_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv ) ; static const Writer csv_writer = { . name = \"csv\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & csv_class , } ; /* Flat output */ typedef struct FlatContext { const AVClass * class ; const char * sep_str ; char sep ; int hierarchical ; } FlatContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( FlatContext , x ) static const AVOption flat_options [ ] = { { \"sep_char\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"s\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( flat )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@flat_init": "static av_cold int flat_init ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; if ( strlen ( flat -> sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , flat -> sep_str ) ; return AVERROR ( EINVAL ) ; } flat -> sep = flat -> sep_str [ 0 ] ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@flat_escape_key_str": "static const char * flat_escape_key_str ( AVBPrint * dst , const char * src , const char sep ) { const char * p ; for ( p = src ; * p ; p ++ ) { if ( ! ( ( * p >= '0' && * p <= '9' ) || ( * p >= 'a' && * p <= 'z' ) || ( * p >= 'A' && * p <= 'Z' ) ) ) av_bprint_chars ( dst , '_' , 1 ) ; else av_bprint_chars ( dst , * p , 1 ) ; } return dst -> str ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@flat_escape_value_str": "static const char * flat_escape_value_str ( AVBPrint * dst , const char * src ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; case '\"' : av_bprintf ( dst , \"%s\" , \"\\\\\\\"\" ) ; break ; case '`' : av_bprintf ( dst , \"%s\" , \"\\\\`\" ) ; break ; case '$' : av_bprintf ( dst , \"%s\" , \"\\\\$\" ) ; break ; default : av_bprint_chars ( dst , * p , 1 ) ; break ; } } return dst -> str ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@flat_print_section_header": "static void flat_print_section_header ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; /* build section header */ av_bprint_clear ( buf ) ; if ( ! parent_section ) return ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( flat -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , wctx -> section [ wctx -> level ] -> name , flat -> sep_str ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \"%d%s\" , n , flat -> sep_str ) ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@flat_print_int": "static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s%s=%lld\\n\" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@flat_print_str": "static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) { FlatContext * flat = wctx -> priv ; AVBPrint buf ; writer_put_str ( wctx , wctx -> section_pbuf [ wctx -> level ] . str ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"\\\"%s\\\"\\n\" , flat_escape_value_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@ini_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv ) ; static const Writer csv_writer = { . name = \"csv\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & csv_class , } ; /* Flat output */ typedef struct FlatContext { const AVClass * class ; const char * sep_str ; char sep ; int hierarchical ; } FlatContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( FlatContext , x ) static const AVOption flat_options [ ] = { { \"sep_char\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"s\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( flat ) ; static av_cold int flat_init ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; if ( strlen ( flat -> sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , flat -> sep_str ) ; return AVERROR ( EINVAL ) ; } flat -> sep = flat -> sep_str [ 0 ] ; return 0 ; } static const char * flat_escape_key_str ( AVBPrint * dst , const char * src , const char sep ) { const char * p ; for ( p = src ; * p ; p ++ ) { if ( ! ( ( * p >= '0' && * p <= '9' ) || ( * p >= 'a' && * p <= 'z' ) || ( * p >= 'A' && * p <= 'Z' ) ) ) av_bprint_chars ( dst , '_' , 1 ) ; else av_bprint_chars ( dst , * p , 1 ) ; } return dst -> str ; } static const char * flat_escape_value_str ( AVBPrint * dst , const char * src ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; case '\"' : av_bprintf ( dst , \"%s\" , \"\\\\\\\"\" ) ; break ; case '`' : av_bprintf ( dst , \"%s\" , \"\\\\`\" ) ; break ; case '$' : av_bprintf ( dst , \"%s\" , \"\\\\$\" ) ; break ; default : av_bprint_chars ( dst , * p , 1 ) ; break ; } } return dst -> str ; } static void flat_print_section_header ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; /* build section header */ av_bprint_clear ( buf ) ; if ( ! parent_section ) return ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( flat -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , wctx -> section [ wctx -> level ] -> name , flat -> sep_str ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \"%d%s\" , n , flat -> sep_str ) ; } } } static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s%s=%lld\\n\" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ; } static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) { FlatContext * flat = wctx -> priv ; AVBPrint buf ; writer_put_str ( wctx , wctx -> section_pbuf [ wctx -> level ] . str ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"\\\"%s\\\"\\n\" , flat_escape_value_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static const Writer flat_writer = { . name = \"flat\" , . priv_size = sizeof ( FlatContext ) , . init = flat_init , . print_section_header = flat_print_section_header , . print_integer = flat_print_int , . print_string = flat_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & flat_class , } ; /* INI format output */ typedef struct INIContext { const AVClass * class ; int hierarchical ; } INIContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( INIContext , x ) static const AVOption ini_options [ ] = { { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( ini )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@ini_escape_str": "static char * ini_escape_str ( AVBPrint * dst , const char * src ) { int i = 0 ; char c = 0 ; while ( ( c = src [ i ++ ] ) ) { switch ( c ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\t' : av_bprintf ( dst , \"%s\" , \"\\\\t\" ) ; break ; case '\\\\' : case '#' : case '=' : case ':' : av_bprint_chars ( dst , '\\\\' , 1 ) ; default : if ( ( unsigned char ) c < 32 ) av_bprintf ( dst , \"\\\\x00%02x\" , c & 0xff ) ; else av_bprint_chars ( dst , c , 1 ) ; break ; } } return dst -> str ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@ini_print_section_header": "static void ini_print_section_header ( WriterContext * wctx ) { INIContext * ini = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( buf ) ; if ( ! parent_section ) { writer_put_str ( wctx , \"# ffprobe output\\n\\n\" ) ; return ; } if ( wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , '\\n' ) ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( ini -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , buf -> str [ 0 ] ? \".\" : \"\" , wctx -> section [ wctx -> level ] -> name ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \".%d\" , n ) ; } } if ( ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) writer_printf ( wctx , \"[%s]\\n\" , buf -> str ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@ini_print_str": "static void ini_print_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , ini_escape_str ( & buf , key ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"%s\\n\" , ini_escape_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@ini_print_int": "static void ini_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s=%lld\\n\" , key , value ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@json_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv ) ; static const Writer csv_writer = { . name = \"csv\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & csv_class , } ; /* Flat output */ typedef struct FlatContext { const AVClass * class ; const char * sep_str ; char sep ; int hierarchical ; } FlatContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( FlatContext , x ) static const AVOption flat_options [ ] = { { \"sep_char\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"s\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( flat ) ; static av_cold int flat_init ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; if ( strlen ( flat -> sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , flat -> sep_str ) ; return AVERROR ( EINVAL ) ; } flat -> sep = flat -> sep_str [ 0 ] ; return 0 ; } static const char * flat_escape_key_str ( AVBPrint * dst , const char * src , const char sep ) { const char * p ; for ( p = src ; * p ; p ++ ) { if ( ! ( ( * p >= '0' && * p <= '9' ) || ( * p >= 'a' && * p <= 'z' ) || ( * p >= 'A' && * p <= 'Z' ) ) ) av_bprint_chars ( dst , '_' , 1 ) ; else av_bprint_chars ( dst , * p , 1 ) ; } return dst -> str ; } static const char * flat_escape_value_str ( AVBPrint * dst , const char * src ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; case '\"' : av_bprintf ( dst , \"%s\" , \"\\\\\\\"\" ) ; break ; case '`' : av_bprintf ( dst , \"%s\" , \"\\\\`\" ) ; break ; case '$' : av_bprintf ( dst , \"%s\" , \"\\\\$\" ) ; break ; default : av_bprint_chars ( dst , * p , 1 ) ; break ; } } return dst -> str ; } static void flat_print_section_header ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; /* build section header */ av_bprint_clear ( buf ) ; if ( ! parent_section ) return ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( flat -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , wctx -> section [ wctx -> level ] -> name , flat -> sep_str ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \"%d%s\" , n , flat -> sep_str ) ; } } } static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s%s=%lld\\n\" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ; } static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) { FlatContext * flat = wctx -> priv ; AVBPrint buf ; writer_put_str ( wctx , wctx -> section_pbuf [ wctx -> level ] . str ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"\\\"%s\\\"\\n\" , flat_escape_value_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static const Writer flat_writer = { . name = \"flat\" , . priv_size = sizeof ( FlatContext ) , . init = flat_init , . print_section_header = flat_print_section_header , . print_integer = flat_print_int , . print_string = flat_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & flat_class , } ; /* INI format output */ typedef struct INIContext { const AVClass * class ; int hierarchical ; } INIContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( INIContext , x ) static const AVOption ini_options [ ] = { { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( ini ) ; static char * ini_escape_str ( AVBPrint * dst , const char * src ) { int i = 0 ; char c = 0 ; while ( ( c = src [ i ++ ] ) ) { switch ( c ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\t' : av_bprintf ( dst , \"%s\" , \"\\\\t\" ) ; break ; case '\\\\' : case '#' : case '=' : case ':' : av_bprint_chars ( dst , '\\\\' , 1 ) ; default : if ( ( unsigned char ) c < 32 ) av_bprintf ( dst , \"\\\\x00%02x\" , c & 0xff ) ; else av_bprint_chars ( dst , c , 1 ) ; break ; } } return dst -> str ; } static void ini_print_section_header ( WriterContext * wctx ) { INIContext * ini = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( buf ) ; if ( ! parent_section ) { writer_put_str ( wctx , \"# ffprobe output\\n\\n\" ) ; return ; } if ( wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , '\\n' ) ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( ini -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , buf -> str [ 0 ] ? \".\" : \"\" , wctx -> section [ wctx -> level ] -> name ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \".%d\" , n ) ; } } if ( ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) writer_printf ( wctx , \"[%s]\\n\" , buf -> str ) ; } static void ini_print_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , ini_escape_str ( & buf , key ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"%s\\n\" , ini_escape_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void ini_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s=%lld\\n\" , key , value ) ; } static const Writer ini_writer = { . name = \"ini\" , . priv_size = sizeof ( INIContext ) , . print_section_header = ini_print_section_header , . print_integer = ini_print_int , . print_string = ini_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & ini_class , } ; /* JSON output */ typedef struct JSONContext { const AVClass * class ; int indent_level ; int compact ; const char * item_sep , * item_start_end ; } JSONContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( JSONContext , x ) static const AVOption json_options [ ] = { { \"compact\" , \"enable compact output\" , OFFSET ( compact ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"c\" , \"enable compact output\" , OFFSET ( compact ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } } ; DEFINE_WRITER_CLASS ( json )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@json_init": "static av_cold int json_init ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; json -> item_sep = json -> compact ? \", \" : \",\\n\" ; json -> item_start_end = json -> compact ? \" \" : \"\\n\" ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@json_escape_str": "static const char * json_escape_str ( AVBPrint * dst , const char * src , void * log_ctx ) { static const char json_escape [ ] = { '\"' , '\\\\' , '\\b' , '\\f' , '\\n' , '\\r' , '\\t' , 0 } ; static const char json_subst [ ] = { '\"' , '\\\\' , 'b' , 'f' , 'n' , 'r' , 't' , 0 } ; const char * p ; for ( p = src ; * p ; p ++ ) { char * s = strchr ( json_escape , * p ) ; if ( s ) { av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , json_subst [ s - json_escape ] , 1 ) ; } else if ( ( unsigned char ) * p < 32 ) { av_bprintf ( dst , \"\\\\u00%02x\" , * p & 0xff ) ; } else { av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@json_print_section_header": "static void json_print_section_header ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; AVBPrint buf ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_put_str ( wctx , \",\\n\" ) ; if ( section -> flags & SECTION_FLAG_IS_WRAPPER ) { writer_put_str ( wctx , \"{\\n\" ) ; json -> indent_level ++ ; } else { av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; json_escape_str ( & buf , section -> name , wctx ) ; JSON_INDENT ( ) ; json -> indent_level ++ ; if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { writer_printf ( wctx , \"\\\"%s\\\": [\\n\" , buf . str ) ; } else if ( parent_section && ! ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) ) { writer_printf ( wctx , \"\\\"%s\\\": {%s\" , buf . str , json -> item_start_end ) ; } else { writer_printf ( wctx , \"{%s\" , json -> item_start_end ) ; /* this is required so the parser can distinguish between packets and frames */ if ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) { if ( ! json -> compact ) JSON_INDENT ( ) ; writer_printf ( wctx , \"\\\"type\\\": \\\"%s\\\"\" , section -> name ) ; wctx -> nb_item [ wctx -> level ] ++ ; } } av_bprint_finalize ( & buf , NULL ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@json_print_section_footer": "static void json_print_section_footer ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; if ( wctx -> level == 0 ) { json -> indent_level -- ; writer_put_str ( wctx , \"\\n}\\n\" ) ; } else if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { writer_w8 ( wctx , '\\n' ) ; json -> indent_level -- ; JSON_INDENT ( ) ; writer_w8 ( wctx , ']' ) ; } else { writer_put_str ( wctx , json -> item_start_end ) ; json -> indent_level -- ; if ( ! json -> compact ) JSON_INDENT ( ) ; writer_w8 ( wctx , '}' ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@json_print_item_str": "static inline void json_print_item_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"\\\"%s\\\":\" , json_escape_str ( & buf , key , wctx ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \" \\\"%s\\\"\" , json_escape_str ( & buf , value , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@json_print_str": "static void json_print_str ( WriterContext * wctx , const char * key , const char * value ) { JSONContext * json = wctx -> priv ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> nb_item [ wctx -> level ] || ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) ) writer_put_str ( wctx , json -> item_sep ) ; if ( ! json -> compact ) JSON_INDENT ( ) ; json_print_item_str ( wctx , key , value ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@json_print_int": "static void json_print_int ( WriterContext * wctx , const char * key , long long int value ) { JSONContext * json = wctx -> priv ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] || ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) ) writer_put_str ( wctx , json -> item_sep ) ; if ( ! json -> compact ) JSON_INDENT ( ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"\\\"%s\\\": %lld\" , json_escape_str ( & buf , key , wctx ) , value ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@xml_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv ) ; static const Writer csv_writer = { . name = \"csv\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & csv_class , } ; /* Flat output */ typedef struct FlatContext { const AVClass * class ; const char * sep_str ; char sep ; int hierarchical ; } FlatContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( FlatContext , x ) static const AVOption flat_options [ ] = { { \"sep_char\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"s\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( flat ) ; static av_cold int flat_init ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; if ( strlen ( flat -> sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , flat -> sep_str ) ; return AVERROR ( EINVAL ) ; } flat -> sep = flat -> sep_str [ 0 ] ; return 0 ; } static const char * flat_escape_key_str ( AVBPrint * dst , const char * src , const char sep ) { const char * p ; for ( p = src ; * p ; p ++ ) { if ( ! ( ( * p >= '0' && * p <= '9' ) || ( * p >= 'a' && * p <= 'z' ) || ( * p >= 'A' && * p <= 'Z' ) ) ) av_bprint_chars ( dst , '_' , 1 ) ; else av_bprint_chars ( dst , * p , 1 ) ; } return dst -> str ; } static const char * flat_escape_value_str ( AVBPrint * dst , const char * src ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; case '\"' : av_bprintf ( dst , \"%s\" , \"\\\\\\\"\" ) ; break ; case '`' : av_bprintf ( dst , \"%s\" , \"\\\\`\" ) ; break ; case '$' : av_bprintf ( dst , \"%s\" , \"\\\\$\" ) ; break ; default : av_bprint_chars ( dst , * p , 1 ) ; break ; } } return dst -> str ; } static void flat_print_section_header ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; /* build section header */ av_bprint_clear ( buf ) ; if ( ! parent_section ) return ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( flat -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , wctx -> section [ wctx -> level ] -> name , flat -> sep_str ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \"%d%s\" , n , flat -> sep_str ) ; } } } static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s%s=%lld\\n\" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ; } static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) { FlatContext * flat = wctx -> priv ; AVBPrint buf ; writer_put_str ( wctx , wctx -> section_pbuf [ wctx -> level ] . str ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"\\\"%s\\\"\\n\" , flat_escape_value_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static const Writer flat_writer = { . name = \"flat\" , . priv_size = sizeof ( FlatContext ) , . init = flat_init , . print_section_header = flat_print_section_header , . print_integer = flat_print_int , . print_string = flat_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & flat_class , } ; /* INI format output */ typedef struct INIContext { const AVClass * class ; int hierarchical ; } INIContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( INIContext , x ) static const AVOption ini_options [ ] = { { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( ini ) ; static char * ini_escape_str ( AVBPrint * dst , const char * src ) { int i = 0 ; char c = 0 ; while ( ( c = src [ i ++ ] ) ) { switch ( c ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\t' : av_bprintf ( dst , \"%s\" , \"\\\\t\" ) ; break ; case '\\\\' : case '#' : case '=' : case ':' : av_bprint_chars ( dst , '\\\\' , 1 ) ; default : if ( ( unsigned char ) c < 32 ) av_bprintf ( dst , \"\\\\x00%02x\" , c & 0xff ) ; else av_bprint_chars ( dst , c , 1 ) ; break ; } } return dst -> str ; } static void ini_print_section_header ( WriterContext * wctx ) { INIContext * ini = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( buf ) ; if ( ! parent_section ) { writer_put_str ( wctx , \"# ffprobe output\\n\\n\" ) ; return ; } if ( wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , '\\n' ) ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( ini -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , buf -> str [ 0 ] ? \".\" : \"\" , wctx -> section [ wctx -> level ] -> name ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \".%d\" , n ) ; } } if ( ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) writer_printf ( wctx , \"[%s]\\n\" , buf -> str ) ; } static void ini_print_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , ini_escape_str ( & buf , key ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"%s\\n\" , ini_escape_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void ini_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s=%lld\\n\" , key , value ) ; } static const Writer ini_writer = { . name = \"ini\" , . priv_size = sizeof ( INIContext ) , . print_section_header = ini_print_section_header , . print_integer = ini_print_int , . print_string = ini_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & ini_class , } ; /* JSON output */ typedef struct JSONContext { const AVClass * class ; int indent_level ; int compact ; const char * item_sep , * item_start_end ; } JSONContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( JSONContext , x ) static const AVOption json_options [ ] = { { \"compact\" , \"enable compact output\" , OFFSET ( compact ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"c\" , \"enable compact output\" , OFFSET ( compact ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } } ; DEFINE_WRITER_CLASS ( json ) ; static av_cold int json_init ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; json -> item_sep = json -> compact ? \", \" : \",\\n\" ; json -> item_start_end = json -> compact ? \" \" : \"\\n\" ; return 0 ; } static const char * json_escape_str ( AVBPrint * dst , const char * src , void * log_ctx ) { static const char json_escape [ ] = { '\"' , '\\\\' , '\\b' , '\\f' , '\\n' , '\\r' , '\\t' , 0 } ; static const char json_subst [ ] = { '\"' , '\\\\' , 'b' , 'f' , 'n' , 'r' , 't' , 0 } ; const char * p ; for ( p = src ; * p ; p ++ ) { char * s = strchr ( json_escape , * p ) ; if ( s ) { av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , json_subst [ s - json_escape ] , 1 ) ; } else if ( ( unsigned char ) * p < 32 ) { av_bprintf ( dst , \"\\\\u00%02x\" , * p & 0xff ) ; } else { av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } # define JSON_INDENT ( ) writer_printf ( wctx , \"%*c\" , json -> indent_level * 4 , ' ' ) static void json_print_section_header ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; AVBPrint buf ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_put_str ( wctx , \",\\n\" ) ; if ( section -> flags & SECTION_FLAG_IS_WRAPPER ) { writer_put_str ( wctx , \"{\\n\" ) ; json -> indent_level ++ ; } else { av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; json_escape_str ( & buf , section -> name , wctx ) ; JSON_INDENT ( ) ; json -> indent_level ++ ; if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { writer_printf ( wctx , \"\\\"%s\\\": [\\n\" , buf . str ) ; } else if ( parent_section && ! ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) ) { writer_printf ( wctx , \"\\\"%s\\\": {%s\" , buf . str , json -> item_start_end ) ; } else { writer_printf ( wctx , \"{%s\" , json -> item_start_end ) ; /* this is required so the parser can distinguish between packets and frames */ if ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) { if ( ! json -> compact ) JSON_INDENT ( ) ; writer_printf ( wctx , \"\\\"type\\\": \\\"%s\\\"\" , section -> name ) ; wctx -> nb_item [ wctx -> level ] ++ ; } } av_bprint_finalize ( & buf , NULL ) ; } } static void json_print_section_footer ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; if ( wctx -> level == 0 ) { json -> indent_level -- ; writer_put_str ( wctx , \"\\n}\\n\" ) ; } else if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { writer_w8 ( wctx , '\\n' ) ; json -> indent_level -- ; JSON_INDENT ( ) ; writer_w8 ( wctx , ']' ) ; } else { writer_put_str ( wctx , json -> item_start_end ) ; json -> indent_level -- ; if ( ! json -> compact ) JSON_INDENT ( ) ; writer_w8 ( wctx , '}' ) ; } } static inline void json_print_item_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"\\\"%s\\\":\" , json_escape_str ( & buf , key , wctx ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \" \\\"%s\\\"\" , json_escape_str ( & buf , value , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void json_print_str ( WriterContext * wctx , const char * key , const char * value ) { JSONContext * json = wctx -> priv ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> nb_item [ wctx -> level ] || ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) ) writer_put_str ( wctx , json -> item_sep ) ; if ( ! json -> compact ) JSON_INDENT ( ) ; json_print_item_str ( wctx , key , value ) ; } static void json_print_int ( WriterContext * wctx , const char * key , long long int value ) { JSONContext * json = wctx -> priv ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] || ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) ) writer_put_str ( wctx , json -> item_sep ) ; if ( ! json -> compact ) JSON_INDENT ( ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"\\\"%s\\\": %lld\" , json_escape_str ( & buf , key , wctx ) , value ) ; av_bprint_finalize ( & buf , NULL ) ; } static const Writer json_writer = { . name = \"json\" , . priv_size = sizeof ( JSONContext ) , . init = json_init , . print_section_header = json_print_section_header , . print_section_footer = json_print_section_footer , . print_integer = json_print_int , . print_string = json_print_str , . flags = WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & json_class , } ; /* XML output */ typedef struct XMLContext { const AVClass * class ; int within_tag ; int indent_level ; int fully_qualified ; int xsd_strict ; } XMLContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( XMLContext , x ) static const AVOption xml_options [ ] = { { \"fully_qualified\" , \"specify if the output should be fully qualified\" , OFFSET ( fully_qualified ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"q\" , \"specify if the output should be fully qualified\" , OFFSET ( fully_qualified ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"xsd_strict\" , \"ensure that the output is XSD compliant\" , OFFSET ( xsd_strict ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"x\" , \"ensure that the output is XSD compliant\" , OFFSET ( xsd_strict ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( xml )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@xml_init": "static av_cold int xml_init ( WriterContext * wctx ) { XMLContext * xml = wctx -> priv ; if ( xml -> xsd_strict ) { xml -> fully_qualified = 1 ; # define CHECK_COMPLIANCE ( opt , opt_name ) if ( opt ) { av_log ( wctx , AV_LOG_ERROR , \"XSD-compliant output selected but option '%s' was selected, XML output may be non-compliant.\\n\" \"You need to disable such option with '-no%s'\\n\" , opt_name , opt_name ) ; return AVERROR ( EINVAL ) ; } CHECK_COMPLIANCE ( show_private_data , \"private\" ) ; CHECK_COMPLIANCE ( show_value_unit , \"unit\" ) ; CHECK_COMPLIANCE ( use_value_prefix , \"prefix\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@xml_print_section_header": "static void xml_print_section_header ( WriterContext * wctx ) { XMLContext * xml = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> level == 0 ) { const char * qual = \" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" \" \"xmlns:ffprobe=\\\"http://www.ffmpeg.org/schema/ffprobe\\\" \" \"xsi:schemaLocation=\\\"http://www.ffmpeg.org/schema/ffprobe ffprobe.xsd\\\"\" ; writer_put_str ( wctx , \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" ) ; writer_printf ( wctx , \"<%sffprobe%s>\\n\" , xml -> fully_qualified ? \"ffprobe:\" : \"\" , xml -> fully_qualified ? qual : \"\" ) ; return ; } if ( xml -> within_tag ) { xml -> within_tag = 0 ; writer_put_str ( wctx , \">\\n\" ) ; } if ( section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ) { xml -> indent_level ++ ; } else { if ( parent_section && ( parent_section -> flags & SECTION_FLAG_IS_WRAPPER ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , '\\n' ) ; xml -> indent_level ++ ; if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { XML_INDENT ( ) ; writer_printf ( wctx , \"<%s>\\n\" , section -> name ) ; } else { XML_INDENT ( ) ; writer_printf ( wctx , \"<%s \" , section -> name ) ; xml -> within_tag = 1 ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@xml_print_section_footer": "static void xml_print_section_footer ( WriterContext * wctx ) { XMLContext * xml = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; if ( wctx -> level == 0 ) { writer_printf ( wctx , \"</%sffprobe>\\n\" , xml -> fully_qualified ? \"ffprobe:\" : \"\" ) ; } else if ( xml -> within_tag ) { xml -> within_tag = 0 ; writer_put_str ( wctx , \"/>\\n\" ) ; xml -> indent_level -- ; } else if ( section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ) { xml -> indent_level -- ; } else { XML_INDENT ( ) ; writer_printf ( wctx , \"</%s>\\n\" , section -> name ) ; xml -> indent_level -- ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@xml_print_str": "static void xml_print_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; XMLContext * xml = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; if ( section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ) { XML_INDENT ( ) ; av_bprint_escape ( & buf , key , NULL , AV_ESCAPE_MODE_XML , AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES ) ; writer_printf ( wctx , \"<%s key=\\\"%s\\\"\" , section -> element_name , buf . str ) ; av_bprint_clear ( & buf ) ; av_bprint_escape ( & buf , value , NULL , AV_ESCAPE_MODE_XML , AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES ) ; writer_printf ( wctx , \" value=\\\"%s\\\"/>\\n\" , buf . str ) ; } else { if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , ' ' ) ; av_bprint_escape ( & buf , value , NULL , AV_ESCAPE_MODE_XML , AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES ) ; writer_printf ( wctx , \"%s=\\\"%s\\\"\" , key , buf . str ) ; } av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@xml_print_int": "static void xml_print_int ( WriterContext * wctx , const char * key , long long int value ) { if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , ' ' ) ; writer_printf ( wctx , \"%s=\\\"%lld\\\"\" , key , value ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@writer_register_all": "static void writer_register_all ( void ) { writer_register ( & default_writer ) ; writer_register ( & compact_writer ) ; writer_register ( & csv_writer ) ; writer_register ( & flat_writer ) ; writer_register ( & ini_writer ) ; writer_register ( & json_writer ) ; writer_register ( & xml_writer ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_tags": "static inline int show_tags ( WriterContext * w , AVDictionary * tags , int section_id ) { const AVDictionaryEntry * tag = NULL ; int ret = 0 ; if ( ! tags ) return 0 ; writer_print_section_header ( w , section_id ) ; while ( ( tag = av_dict_iterate ( tags , tag ) ) ) { if ( ( ret = print_str_validate ( tag -> key , tag -> value ) ) < 0 ) break ; } writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@print_dovi_metadata": "static void print_dovi_metadata ( WriterContext * w , const AVDOVIMetadata * dovi ) { if ( ! dovi ) return ; { const AVDOVIRpuDataHeader * hdr = av_dovi_get_header ( dovi ) ; const AVDOVIDataMapping * mapping = av_dovi_get_mapping ( dovi ) ; const AVDOVIColorMetadata * color = av_dovi_get_color ( dovi ) ; AVBPrint pbuf ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; // header print_int ( \"rpu_type\" , hdr -> rpu_type ) ; print_int ( \"rpu_format\" , hdr -> rpu_format ) ; print_int ( \"vdr_rpu_profile\" , hdr -> vdr_rpu_profile ) ; print_int ( \"vdr_rpu_level\" , hdr -> vdr_rpu_level ) ; print_int ( \"chroma_resampling_explicit_filter_flag\" , hdr -> chroma_resampling_explicit_filter_flag ) ; print_int ( \"coef_data_type\" , hdr -> coef_data_type ) ; print_int ( \"coef_log2_denom\" , hdr -> coef_log2_denom ) ; print_int ( \"vdr_rpu_normalized_idc\" , hdr -> vdr_rpu_normalized_idc ) ; print_int ( \"bl_video_full_range_flag\" , hdr -> bl_video_full_range_flag ) ; print_int ( \"bl_bit_depth\" , hdr -> bl_bit_depth ) ; print_int ( \"el_bit_depth\" , hdr -> el_bit_depth ) ; print_int ( \"vdr_bit_depth\" , hdr -> vdr_bit_depth ) ; print_int ( \"spatial_resampling_filter_flag\" , hdr -> spatial_resampling_filter_flag ) ; print_int ( \"el_spatial_resampling_filter_flag\" , hdr -> el_spatial_resampling_filter_flag ) ; print_int ( \"disable_residual_flag\" , hdr -> disable_residual_flag ) ; // data mapping values print_int ( \"vdr_rpu_id\" , mapping -> vdr_rpu_id ) ; print_int ( \"mapping_color_space\" , mapping -> mapping_color_space ) ; print_int ( \"mapping_chroma_format_idc\" , mapping -> mapping_chroma_format_idc ) ; print_int ( \"nlq_method_idc\" , mapping -> nlq_method_idc ) ; switch ( mapping -> nlq_method_idc ) { case AV_DOVI_NLQ_NONE : print_str ( \"nlq_method_idc_name\" , \"none\" ) ; break ; case AV_DOVI_NLQ_LINEAR_DZ : print_str ( \"nlq_method_idc_name\" , \"linear_dz\" ) ; break ; default : print_str ( \"nlq_method_idc_name\" , \"unknown\" ) ; break ; } print_int ( \"num_x_partitions\" , mapping -> num_x_partitions ) ; print_int ( \"num_y_partitions\" , mapping -> num_y_partitions ) ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_COMPONENT_LIST ) ; for ( int c = 0 ; c < 3 ; c ++ ) { const AVDOVIReshapingCurve * curve = & mapping -> curves [ c ] ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_COMPONENT ) ; print_list_fmt ( \"pivots\" , \"%\" PRIu16 , curve -> num_pivots , 1 , curve -> pivots [ idx ] ) ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_PIECE_LIST ) ; for ( int i = 0 ; i < curve -> num_pivots - 1 ; i ++ ) { writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_PIECE ) ; print_int ( \"mapping_idc\" , curve -> mapping_idc [ i ] ) ; switch ( curve -> mapping_idc [ i ] ) { case AV_DOVI_MAPPING_POLYNOMIAL : print_str ( \"mapping_idc_name\" , \"polynomial\" ) ; print_int ( \"poly_order\" , curve -> poly_order [ i ] ) ; print_list_fmt ( \"poly_coef\" , \"%\" PRIi64 , curve -> poly_order [ i ] + 1 , 1 , curve -> poly_coef [ i ] [ idx ] ) ; break ; case AV_DOVI_MAPPING_MMR : print_str ( \"mapping_idc_name\" , \"mmr\" ) ; print_int ( \"mmr_order\" , curve -> mmr_order [ i ] ) ; print_int ( \"mmr_constant\" , curve -> mmr_constant [ i ] ) ; print_list_fmt ( \"mmr_coef\" , \"%\" PRIi64 , curve -> mmr_order [ i ] , 7 , curve -> mmr_coef [ i ] [ idx ] [ idx2 ] ) ; break ; default : print_str ( \"mapping_idc_name\" , \"unknown\" ) ; break ; } // SECTION_ID_FRAME_SIDE_DATA_PIECE writer_print_section_footer ( w ) ; } // SECTION_ID_FRAME_SIDE_DATA_PIECE_LIST writer_print_section_footer ( w ) ; if ( mapping -> nlq_method_idc != AV_DOVI_NLQ_NONE ) { const AVDOVINLQParams * nlq = & mapping -> nlq [ c ] ; print_int ( \"nlq_offset\" , nlq -> nlq_offset ) ; print_int ( \"vdr_in_max\" , nlq -> vdr_in_max ) ; switch ( mapping -> nlq_method_idc ) { case AV_DOVI_NLQ_LINEAR_DZ : print_int ( \"linear_deadzone_slope\" , nlq -> linear_deadzone_slope ) ; print_int ( \"linear_deadzone_threshold\" , nlq -> linear_deadzone_threshold ) ; break ; } } // SECTION_ID_FRAME_SIDE_DATA_COMPONENT writer_print_section_footer ( w ) ; } // SECTION_ID_FRAME_SIDE_DATA_COMPONENT_LIST writer_print_section_footer ( w ) ; // color metadata print_int ( \"dm_metadata_id\" , color -> dm_metadata_id ) ; print_int ( \"scene_refresh_flag\" , color -> scene_refresh_flag ) ; print_list_fmt ( \"ycc_to_rgb_matrix\" , \"%d/%d\" , FF_ARRAY_ELEMS ( color -> ycc_to_rgb_matrix ) , 1 , color -> ycc_to_rgb_matrix [ idx ] . num , color -> ycc_to_rgb_matrix [ idx ] . den ) ; print_list_fmt ( \"ycc_to_rgb_offset\" , \"%d/%d\" , FF_ARRAY_ELEMS ( color -> ycc_to_rgb_offset ) , 1 , color -> ycc_to_rgb_offset [ idx ] . num , color -> ycc_to_rgb_offset [ idx ] . den ) ; print_list_fmt ( \"rgb_to_lms_matrix\" , \"%d/%d\" , FF_ARRAY_ELEMS ( color -> rgb_to_lms_matrix ) , 1 , color -> rgb_to_lms_matrix [ idx ] . num , color -> rgb_to_lms_matrix [ idx ] . den ) ; print_int ( \"signal_eotf\" , color -> signal_eotf ) ; print_int ( \"signal_eotf_param0\" , color -> signal_eotf_param0 ) ; print_int ( \"signal_eotf_param1\" , color -> signal_eotf_param1 ) ; print_int ( \"signal_eotf_param2\" , color -> signal_eotf_param2 ) ; print_int ( \"signal_bit_depth\" , color -> signal_bit_depth ) ; print_int ( \"signal_color_space\" , color -> signal_color_space ) ; print_int ( \"signal_chroma_format\" , color -> signal_chroma_format ) ; print_int ( \"signal_full_range_flag\" , color -> signal_full_range_flag ) ; print_int ( \"source_min_pq\" , color -> source_min_pq ) ; print_int ( \"source_max_pq\" , color -> source_max_pq ) ; print_int ( \"source_diagonal\" , color -> source_diagonal ) ; av_bprint_finalize ( & pbuf , NULL ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@print_dynamic_hdr10_plus": "static void print_dynamic_hdr10_plus ( WriterContext * w , const AVDynamicHDRPlus * metadata ) { if ( ! metadata ) return ; print_int ( \"application version\" , metadata -> application_version ) ; print_int ( \"num_windows\" , metadata -> num_windows ) ; for ( int n = 1 ; n < metadata -> num_windows ; n ++ ) { const AVHDRPlusColorTransformParams * params = & metadata -> params [ n ] ; print_q ( \"window_upper_left_corner_x\" , params -> window_upper_left_corner_x , '/' ) ; print_q ( \"window_upper_left_corner_y\" , params -> window_upper_left_corner_y , '/' ) ; print_q ( \"window_lower_right_corner_x\" , params -> window_lower_right_corner_x , '/' ) ; print_q ( \"window_lower_right_corner_y\" , params -> window_lower_right_corner_y , '/' ) ; print_q ( \"window_upper_left_corner_x\" , params -> window_upper_left_corner_x , '/' ) ; print_q ( \"window_upper_left_corner_y\" , params -> window_upper_left_corner_y , '/' ) ; print_int ( \"center_of_ellipse_x\" , params -> center_of_ellipse_x ) ; print_int ( \"center_of_ellipse_y\" , params -> center_of_ellipse_y ) ; print_int ( \"rotation_angle\" , params -> rotation_angle ) ; print_int ( \"semimajor_axis_internal_ellipse\" , params -> semimajor_axis_internal_ellipse ) ; print_int ( \"semimajor_axis_external_ellipse\" , params -> semimajor_axis_external_ellipse ) ; print_int ( \"semiminor_axis_external_ellipse\" , params -> semiminor_axis_external_ellipse ) ; print_int ( \"overlap_process_option\" , params -> overlap_process_option ) ; } print_q ( \"targeted_system_display_maximum_luminance\" , metadata -> targeted_system_display_maximum_luminance , '/' ) ; if ( metadata -> targeted_system_display_actual_peak_luminance_flag ) { print_int ( \"num_rows_targeted_system_display_actual_peak_luminance\" , metadata -> num_rows_targeted_system_display_actual_peak_luminance ) ; print_int ( \"num_cols_targeted_system_display_actual_peak_luminance\" , metadata -> num_cols_targeted_system_display_actual_peak_luminance ) ; for ( int i = 0 ; i < metadata -> num_rows_targeted_system_display_actual_peak_luminance ; i ++ ) { for ( int j = 0 ; j < metadata -> num_cols_targeted_system_display_actual_peak_luminance ; j ++ ) { print_q ( \"targeted_system_display_actual_peak_luminance\" , metadata -> targeted_system_display_actual_peak_luminance [ i ] [ j ] , '/' ) ; } } } for ( int n = 0 ; n < metadata -> num_windows ; n ++ ) { const AVHDRPlusColorTransformParams * params = & metadata -> params [ n ] ; for ( int i = 0 ; i < 3 ; i ++ ) { print_q ( \"maxscl\" , params -> maxscl [ i ] , '/' ) ; } print_q ( \"average_maxrgb\" , params -> average_maxrgb , '/' ) ; print_int ( \"num_distribution_maxrgb_percentiles\" , params -> num_distribution_maxrgb_percentiles ) ; for ( int i = 0 ; i < params -> num_distribution_maxrgb_percentiles ; i ++ ) { print_int ( \"distribution_maxrgb_percentage\" , params -> distribution_maxrgb [ i ] . percentage ) ; print_q ( \"distribution_maxrgb_percentile\" , params -> distribution_maxrgb [ i ] . percentile , '/' ) ; } print_q ( \"fraction_bright_pixels\" , params -> fraction_bright_pixels , '/' ) ; } if ( metadata -> mastering_display_actual_peak_luminance_flag ) { print_int ( \"num_rows_mastering_display_actual_peak_luminance\" , metadata -> num_rows_mastering_display_actual_peak_luminance ) ; print_int ( \"num_cols_mastering_display_actual_peak_luminance\" , metadata -> num_cols_mastering_display_actual_peak_luminance ) ; for ( int i = 0 ; i < metadata -> num_rows_mastering_display_actual_peak_luminance ; i ++ ) { for ( int j = 0 ; j < metadata -> num_cols_mastering_display_actual_peak_luminance ; j ++ ) { print_q ( \"mastering_display_actual_peak_luminance\" , metadata -> mastering_display_actual_peak_luminance [ i ] [ j ] , '/' ) ; } } } for ( int n = 0 ; n < metadata -> num_windows ; n ++ ) { const AVHDRPlusColorTransformParams * params = & metadata -> params [ n ] ; if ( params -> tone_mapping_flag ) { print_q ( \"knee_point_x\" , params -> knee_point_x , '/' ) ; print_q ( \"knee_point_y\" , params -> knee_point_y , '/' ) ; print_int ( \"num_bezier_curve_anchors\" , params -> num_bezier_curve_anchors ) ; for ( int i = 0 ; i < params -> num_bezier_curve_anchors ; i ++ ) { print_q ( \"bezier_curve_anchors\" , params -> bezier_curve_anchors [ i ] , '/' ) ; } } if ( params -> color_saturation_mapping_flag ) { print_q ( \"color_saturation_weight\" , params -> color_saturation_weight , '/' ) ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@print_dynamic_hdr_vivid": "static void print_dynamic_hdr_vivid ( WriterContext * w , const AVDynamicHDRVivid * metadata ) { if ( ! metadata ) return ; print_int ( \"system_start_code\" , metadata -> system_start_code ) ; print_int ( \"num_windows\" , metadata -> num_windows ) ; for ( int n = 0 ; n < metadata -> num_windows ; n ++ ) { const AVHDRVividColorTransformParams * params = & metadata -> params [ n ] ; print_q ( \"minimum_maxrgb\" , params -> minimum_maxrgb , '/' ) ; print_q ( \"average_maxrgb\" , params -> average_maxrgb , '/' ) ; print_q ( \"variance_maxrgb\" , params -> variance_maxrgb , '/' ) ; print_q ( \"maximum_maxrgb\" , params -> maximum_maxrgb , '/' ) ; } for ( int n = 0 ; n < metadata -> num_windows ; n ++ ) { const AVHDRVividColorTransformParams * params = & metadata -> params [ n ] ; print_int ( \"tone_mapping_mode_flag\" , params -> tone_mapping_mode_flag ) ; print_int ( \"tone_mapping_param_num\" , params -> tone_mapping_param_num ) ; if ( params -> tone_mapping_mode_flag ) { for ( int i = 0 ; i < params -> tone_mapping_param_num ; i ++ ) { const AVHDRVividColorToneMappingParams * tm_params = & params -> tm_params [ i ] ; print_q ( \"targeted_system_display_maximum_luminance\" , tm_params -> targeted_system_display_maximum_luminance , '/' ) ; print_int ( \"base_enable_flag\" , tm_params -> base_enable_flag ) ; if ( tm_params -> base_enable_flag ) { print_q ( \"base_param_m_p\" , tm_params -> base_param_m_p , '/' ) ; print_q ( \"base_param_m_m\" , tm_params -> base_param_m_m , '/' ) ; print_q ( \"base_param_m_a\" , tm_params -> base_param_m_a , '/' ) ; print_q ( \"base_param_m_b\" , tm_params -> base_param_m_b , '/' ) ; print_q ( \"base_param_m_n\" , tm_params -> base_param_m_n , '/' ) ; print_int ( \"base_param_k1\" , tm_params -> base_param_k1 ) ; print_int ( \"base_param_k2\" , tm_params -> base_param_k2 ) ; print_int ( \"base_param_k3\" , tm_params -> base_param_k3 ) ; print_int ( \"base_param_Delta_enable_mode\" , tm_params -> base_param_Delta_enable_mode ) ; print_q ( \"base_param_Delta\" , tm_params -> base_param_Delta , '/' ) ; } print_int ( \"3Spline_enable_flag\" , tm_params -> three_Spline_enable_flag ) ; if ( tm_params -> three_Spline_enable_flag ) { print_int ( \"3Spline_num\" , tm_params -> three_Spline_num ) ; print_int ( \"3Spline_TH_mode\" , tm_params -> three_Spline_TH_mode ) ; for ( int j = 0 ; j < tm_params -> three_Spline_num ; j ++ ) { print_q ( \"3Spline_TH_enable_MB\" , tm_params -> three_Spline_TH_enable_MB , '/' ) ; print_q ( \"3Spline_TH_enable\" , tm_params -> three_Spline_TH_enable , '/' ) ; print_q ( \"3Spline_TH_Delta1\" , tm_params -> three_Spline_TH_Delta1 , '/' ) ; print_q ( \"3Spline_TH_Delta2\" , tm_params -> three_Spline_TH_Delta2 , '/' ) ; print_q ( \"3Spline_enable_Strength\" , tm_params -> three_Spline_enable_Strength , '/' ) ; } } } } print_int ( \"color_saturation_mapping_flag\" , params -> color_saturation_mapping_flag ) ; if ( params -> color_saturation_mapping_flag ) { print_int ( \"color_saturation_num\" , params -> color_saturation_num ) ; for ( int i = 0 ; i < params -> color_saturation_num ; i ++ ) { print_q ( \"color_saturation_gain\" , params -> color_saturation_gain [ i ] , '/' ) ; } } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@print_ambient_viewing_environment": "static void print_ambient_viewing_environment ( WriterContext * w , const AVAmbientViewingEnvironment * env ) { if ( ! env ) return ; print_q ( \"ambient_illuminance\" , env -> ambient_illuminance , '/' ) ; print_q ( \"ambient_light_x\" , env -> ambient_light_x , '/' ) ; print_q ( \"ambient_light_y\" , env -> ambient_light_y , '/' ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@print_pkt_side_data": "static void print_pkt_side_data ( WriterContext * w , AVCodecParameters * par , const AVPacketSideData * side_data , int nb_side_data , SectionID id_data_list , SectionID id_data ) { int i ; writer_print_section_header ( w , id_data_list ) ; for ( i = 0 ; i < nb_side_data ; i ++ ) { const AVPacketSideData * sd = & side_data [ i ] ; const char * name = av_packet_side_data_name ( sd -> type ) ; writer_print_section_header ( w , id_data ) ; print_str ( \"side_data_type\" , name ? name : \"unknown\" ) ; if ( sd -> type == AV_PKT_DATA_DISPLAYMATRIX && sd -> size >= 9 * 4 ) { double rotation = av_display_rotation_get ( ( int32_t * ) sd -> data ) ; if ( isnan ( rotation ) ) rotation = 0 ; writer_print_integers ( w , \"displaymatrix\" , sd -> data , 9 , \" %11d\" , 3 , 4 , 1 ) ; print_int ( \"rotation\" , rotation ) ; } else if ( sd -> type == AV_PKT_DATA_STEREO3D ) { const AVStereo3D * stereo = ( AVStereo3D * ) sd -> data ; print_str ( \"type\" , av_stereo3d_type_name ( stereo -> type ) ) ; print_int ( \"inverted\" , ! ! ( stereo -> flags & AV_STEREO3D_FLAG_INVERT ) ) ; } else if ( sd -> type == AV_PKT_DATA_SPHERICAL ) { const AVSphericalMapping * spherical = ( AVSphericalMapping * ) sd -> data ; print_str ( \"projection\" , av_spherical_projection_name ( spherical -> projection ) ) ; if ( spherical -> projection == AV_SPHERICAL_CUBEMAP ) { print_int ( \"padding\" , spherical -> padding ) ; } else if ( spherical -> projection == AV_SPHERICAL_EQUIRECTANGULAR_TILE ) { size_t l , t , r , b ; av_spherical_tile_bounds ( spherical , par -> width , par -> height , & l , & t , & r , & b ) ; print_int ( \"bound_left\" , l ) ; print_int ( \"bound_top\" , t ) ; print_int ( \"bound_right\" , r ) ; print_int ( \"bound_bottom\" , b ) ; } print_int ( \"yaw\" , ( double ) spherical -> yaw / ( 1 << 16 ) ) ; print_int ( \"pitch\" , ( double ) spherical -> pitch / ( 1 << 16 ) ) ; print_int ( \"roll\" , ( double ) spherical -> roll / ( 1 << 16 ) ) ; } else if ( sd -> type == AV_PKT_DATA_SKIP_SAMPLES && sd -> size == 10 ) { print_int ( \"skip_samples\" , AV_RL32 ( sd -> data ) ) ; print_int ( \"discard_padding\" , AV_RL32 ( sd -> data + 4 ) ) ; print_int ( \"skip_reason\" , AV_RL8 ( sd -> data + 8 ) ) ; print_int ( \"discard_reason\" , AV_RL8 ( sd -> data + 9 ) ) ; } else if ( sd -> type == AV_PKT_DATA_MASTERING_DISPLAY_METADATA ) { AVMasteringDisplayMetadata * metadata = ( AVMasteringDisplayMetadata * ) sd -> data ; if ( metadata -> has_primaries ) { print_q ( \"red_x\" , metadata -> display_primaries [ 0 ] [ 0 ] , '/' ) ; print_q ( \"red_y\" , metadata -> display_primaries [ 0 ] [ 1 ] , '/' ) ; print_q ( \"green_x\" , metadata -> display_primaries [ 1 ] [ 0 ] , '/' ) ; print_q ( \"green_y\" , metadata -> display_primaries [ 1 ] [ 1 ] , '/' ) ; print_q ( \"blue_x\" , metadata -> display_primaries [ 2 ] [ 0 ] , '/' ) ; print_q ( \"blue_y\" , metadata -> display_primaries [ 2 ] [ 1 ] , '/' ) ; print_q ( \"white_point_x\" , metadata -> white_point [ 0 ] , '/' ) ; print_q ( \"white_point_y\" , metadata -> white_point [ 1 ] , '/' ) ; } if ( metadata -> has_luminance ) { print_q ( \"min_luminance\" , metadata -> min_luminance , '/' ) ; print_q ( \"max_luminance\" , metadata -> max_luminance , '/' ) ; } } else if ( sd -> type == AV_PKT_DATA_CONTENT_LIGHT_LEVEL ) { AVContentLightMetadata * metadata = ( AVContentLightMetadata * ) sd -> data ; print_int ( \"max_content\" , metadata -> MaxCLL ) ; print_int ( \"max_average\" , metadata -> MaxFALL ) ; } else if ( sd -> type == AV_PKT_DATA_DOVI_CONF ) { AVDOVIDecoderConfigurationRecord * dovi = ( AVDOVIDecoderConfigurationRecord * ) sd -> data ; print_int ( \"dv_version_major\" , dovi -> dv_version_major ) ; print_int ( \"dv_version_minor\" , dovi -> dv_version_minor ) ; print_int ( \"dv_profile\" , dovi -> dv_profile ) ; print_int ( \"dv_level\" , dovi -> dv_level ) ; print_int ( \"rpu_present_flag\" , dovi -> rpu_present_flag ) ; print_int ( \"el_present_flag\" , dovi -> el_present_flag ) ; print_int ( \"bl_present_flag\" , dovi -> bl_present_flag ) ; print_int ( \"dv_bl_signal_compatibility_id\" , dovi -> dv_bl_signal_compatibility_id ) ; } else if ( sd -> type == AV_PKT_DATA_AUDIO_SERVICE_TYPE ) { enum AVAudioServiceType * t = ( enum AVAudioServiceType * ) sd -> data ; print_int ( \"service_type\" , * t ) ; } else if ( sd -> type == AV_PKT_DATA_MPEGTS_STREAM_ID ) { print_int ( \"id\" , * sd -> data ) ; } else if ( sd -> type == AV_PKT_DATA_CPB_PROPERTIES ) { const AVCPBProperties * prop = ( AVCPBProperties * ) sd -> data ; print_int ( \"max_bitrate\" , prop -> max_bitrate ) ; print_int ( \"min_bitrate\" , prop -> min_bitrate ) ; print_int ( \"avg_bitrate\" , prop -> avg_bitrate ) ; print_int ( \"buffer_size\" , prop -> buffer_size ) ; print_int ( \"vbv_delay\" , prop -> vbv_delay ) ; } else if ( sd -> type == AV_PKT_DATA_WEBVTT_IDENTIFIER || sd -> type == AV_PKT_DATA_WEBVTT_SETTINGS ) { if ( do_show_data ) writer_print_data ( w , \"data\" , sd -> data , sd -> size ) ; writer_print_data_hash ( w , \"data_hash\" , sd -> data , sd -> size ) ; } else if ( sd -> type == AV_PKT_DATA_AFD && sd -> size > 0 ) { print_int ( \"active_format\" , * sd -> data ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@print_color_range": "static void print_color_range ( WriterContext * w , enum AVColorRange color_range ) { const char * val = av_color_range_name ( color_range ) ; if ( ! val || color_range == AVCOL_RANGE_UNSPECIFIED ) { print_str_opt ( \"color_range\" , \"unknown\" ) ; } else { print_str ( \"color_range\" , val ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@print_color_space": "static void print_color_space ( WriterContext * w , enum AVColorSpace color_space ) { const char * val = av_color_space_name ( color_space ) ; if ( ! val || color_space == AVCOL_SPC_UNSPECIFIED ) { print_str_opt ( \"color_space\" , \"unknown\" ) ; } else { print_str ( \"color_space\" , val ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@print_primaries": "static void print_primaries ( WriterContext * w , enum AVColorPrimaries color_primaries ) { const char * val = av_color_primaries_name ( color_primaries ) ; if ( ! val || color_primaries == AVCOL_PRI_UNSPECIFIED ) { print_str_opt ( \"color_primaries\" , \"unknown\" ) ; } else { print_str ( \"color_primaries\" , val ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@print_color_trc": "static void print_color_trc ( WriterContext * w , enum AVColorTransferCharacteristic color_trc ) { const char * val = av_color_transfer_name ( color_trc ) ; if ( ! val || color_trc == AVCOL_TRC_UNSPECIFIED ) { print_str_opt ( \"color_transfer\" , \"unknown\" ) ; } else { print_str ( \"color_transfer\" , val ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@print_chroma_location": "static void print_chroma_location ( WriterContext * w , enum AVChromaLocation chroma_location ) { const char * val = av_chroma_location_name ( chroma_location ) ; if ( ! val || chroma_location == AVCHROMA_LOC_UNSPECIFIED ) { print_str_opt ( \"chroma_location\" , \"unspecified\" ) ; } else { print_str ( \"chroma_location\" , val ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@clear_log": "static void clear_log ( int need_lock ) { int i ; if ( need_lock ) pthread_mutex_lock ( & log_mutex ) ; for ( i = 0 ; i < log_buffer_size ; i ++ ) { av_freep ( & log_buffer [ i ] . context_name ) ; av_freep ( & log_buffer [ i ] . parent_name ) ; av_freep ( & log_buffer [ i ] . log_message ) ; } log_buffer_size = 0 ; if ( need_lock ) pthread_mutex_unlock ( & log_mutex ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_log": "static int show_log ( WriterContext * w , int section_ids , int section_id , int log_level ) { int i ; pthread_mutex_lock ( & log_mutex ) ; if ( ! log_buffer_size ) { pthread_mutex_unlock ( & log_mutex ) ; return 0 ; } writer_print_section_header ( w , section_ids ) ; for ( i = 0 ; i < log_buffer_size ; i ++ ) { if ( log_buffer [ i ] . log_level <= log_level ) { writer_print_section_header ( w , section_id ) ; print_str ( \"context\" , log_buffer [ i ] . context_name ) ; print_int ( \"level\" , log_buffer [ i ] . log_level ) ; print_int ( \"category\" , log_buffer [ i ] . category ) ; if ( log_buffer [ i ] . parent_name ) { print_str ( \"parent_context\" , log_buffer [ i ] . parent_name ) ; print_int ( \"parent_category\" , log_buffer [ i ] . parent_category ) ; } else { print_str_opt ( \"parent_context\" , \"N/A\" ) ; print_str_opt ( \"parent_category\" , \"N/A\" ) ; } print_str ( \"message\" , log_buffer [ i ] . log_message ) ; writer_print_section_footer ( w ) ; } } clear_log ( 0 ) ; pthread_mutex_unlock ( & log_mutex ) ; writer_print_section_footer ( w ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_packet": "static void show_packet ( WriterContext * w , InputFile * ifile , AVPacket * pkt , int packet_idx ) { char val_str [ 128 ] ; AVStream * st = ifile -> streams [ pkt -> stream_index ] . st ; AVBPrint pbuf ; const char * s ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_PACKET ) ; s = av_get_media_type_string ( st -> codecpar -> codec_type ) ; if ( s ) print_str ( \"codec_type\" , s ) ; else print_str_opt ( \"codec_type\" , \"unknown\" ) ; print_int ( \"stream_index\" , pkt -> stream_index ) ; print_ts ( \"pts\" , pkt -> pts ) ; print_time ( \"pts_time\" , pkt -> pts , & st -> time_base ) ; print_ts ( \"dts\" , pkt -> dts ) ; print_time ( \"dts_time\" , pkt -> dts , & st -> time_base ) ; print_duration_ts ( \"duration\" , pkt -> duration ) ; print_duration_time ( \"duration_time\" , pkt -> duration , & st -> time_base ) ; print_val ( \"size\" , pkt -> size , unit_byte_str ) ; if ( pkt -> pos != - 1 ) print_fmt ( \"pos\" , \"%\" PRId64 , pkt -> pos ) ; else print_str_opt ( \"pos\" , \"N/A\" ) ; print_fmt ( \"flags\" , \"%c%c%c\" , pkt -> flags & AV_PKT_FLAG_KEY ? 'K' : '_' , pkt -> flags & AV_PKT_FLAG_DISCARD ? 'D' : '_' , pkt -> flags & AV_PKT_FLAG_CORRUPT ? 'C' : '_' ) ; if ( do_show_data ) writer_print_data ( w , \"data\" , pkt -> data , pkt -> size ) ; writer_print_data_hash ( w , \"data_hash\" , pkt -> data , pkt -> size ) ; if ( pkt -> side_data_elems ) { size_t size ; const uint8_t * side_metadata ; side_metadata = av_packet_get_side_data ( pkt , AV_PKT_DATA_STRINGS_METADATA , & size ) ; if ( side_metadata && size && do_show_packet_tags ) { AVDictionary * dict = NULL ; if ( av_packet_unpack_dictionary ( side_metadata , size , & dict ) >= 0 ) show_tags ( w , dict , SECTION_ID_PACKET_TAGS ) ; av_dict_free ( & dict ) ; } print_pkt_side_data ( w , st -> codecpar , pkt -> side_data , pkt -> side_data_elems , SECTION_ID_PACKET_SIDE_DATA_LIST , SECTION_ID_PACKET_SIDE_DATA ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_subtitle": "static void show_subtitle ( WriterContext * w , AVSubtitle * sub , AVStream * stream , AVFormatContext * fmt_ctx ) { AVBPrint pbuf ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_SUBTITLE ) ; print_str ( \"media_type\" , \"subtitle\" ) ; print_ts ( \"pts\" , sub -> pts ) ; print_time ( \"pts_time\" , sub -> pts , & AV_TIME_BASE_Q ) ; print_int ( \"format\" , sub -> format ) ; print_int ( \"start_display_time\" , sub -> start_display_time ) ; print_int ( \"end_display_time\" , sub -> end_display_time ) ; print_int ( \"num_rects\" , sub -> num_rects ) ; writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_frame": "static void show_frame ( WriterContext * w , AVFrame * frame , AVStream * stream , AVFormatContext * fmt_ctx ) { AVBPrint pbuf ; char val_str [ 128 ] ; const char * s ; int i ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_FRAME ) ; s = av_get_media_type_string ( stream -> codecpar -> codec_type ) ; if ( s ) print_str ( \"media_type\" , s ) ; else print_str_opt ( \"media_type\" , \"unknown\" ) ; print_int ( \"stream_index\" , stream -> index ) ; print_int ( \"key_frame\" , frame -> key_frame ) ; print_ts ( \"pts\" , frame -> pts ) ; print_time ( \"pts_time\" , frame -> pts , & stream -> time_base ) ; print_ts ( \"pkt_dts\" , frame -> pkt_dts ) ; print_time ( \"pkt_dts_time\" , frame -> pkt_dts , & stream -> time_base ) ; print_ts ( \"best_effort_timestamp\" , frame -> best_effort_timestamp ) ; print_time ( \"best_effort_timestamp_time\" , frame -> best_effort_timestamp , & stream -> time_base ) ; # if LIBAVUTIL_VERSION_MAJOR < 59 AV_NOWARN_DEPRECATED ( print_duration_ts ( \"pkt_duration\" , frame -> pkt_duration ) ; print_duration_time ( \"pkt_duration_time\" , frame -> pkt_duration , & stream -> time_base ) ; ) # endif print_duration_ts ( \"duration\" , frame -> duration ) ; print_duration_time ( \"duration_time\" , frame -> duration , & stream -> time_base ) ; if ( frame -> pkt_pos != - 1 ) print_fmt ( \"pkt_pos\" , \"%\" PRId64 , frame -> pkt_pos ) ; else print_str_opt ( \"pkt_pos\" , \"N/A\" ) ; if ( frame -> pkt_size != - 1 ) print_val ( \"pkt_size\" , frame -> pkt_size , unit_byte_str ) ; else print_str_opt ( \"pkt_size\" , \"N/A\" ) ; switch ( stream -> codecpar -> codec_type ) { AVRational sar ; case AVMEDIA_TYPE_VIDEO : print_int ( \"width\" , frame -> width ) ; print_int ( \"height\" , frame -> height ) ; s = av_get_pix_fmt_name ( frame -> format ) ; if ( s ) print_str ( \"pix_fmt\" , s ) ; else print_str_opt ( \"pix_fmt\" , \"unknown\" ) ; sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , frame ) ; if ( sar . num ) { print_q ( \"sample_aspect_ratio\" , sar , ':' ) ; } else { print_str_opt ( \"sample_aspect_ratio\" , \"N/A\" ) ; } print_fmt ( \"pict_type\" , \"%c\" , av_get_picture_type_char ( frame -> pict_type ) ) ; # if LIBAVUTIL_VERSION_MAJOR < 59 AV_NOWARN_DEPRECATED ( print_int ( \"coded_picture_number\" , frame -> coded_picture_number ) ; print_int ( \"display_picture_number\" , frame -> display_picture_number ) ; ) # endif print_int ( \"interlaced_frame\" , frame -> interlaced_frame ) ; print_int ( \"top_field_first\" , frame -> top_field_first ) ; print_int ( \"repeat_pict\" , frame -> repeat_pict ) ; print_color_range ( w , frame -> color_range ) ; print_color_space ( w , frame -> colorspace ) ; print_primaries ( w , frame -> color_primaries ) ; print_color_trc ( w , frame -> color_trc ) ; print_chroma_location ( w , frame -> chroma_location ) ; break ; case AVMEDIA_TYPE_AUDIO : s = av_get_sample_fmt_name ( frame -> format ) ; if ( s ) print_str ( \"sample_fmt\" , s ) ; else print_str_opt ( \"sample_fmt\" , \"unknown\" ) ; print_int ( \"nb_samples\" , frame -> nb_samples ) ; print_int ( \"channels\" , frame -> ch_layout . nb_channels ) ; if ( frame -> ch_layout . order != AV_CHANNEL_ORDER_UNSPEC ) { av_channel_layout_describe ( & frame -> ch_layout , val_str , sizeof ( val_str ) ) ; print_str ( \"channel_layout\" , val_str ) ; } else print_str_opt ( \"channel_layout\" , \"unknown\" ) ; break ; } if ( do_show_frame_tags ) show_tags ( w , frame -> metadata , SECTION_ID_FRAME_TAGS ) ; if ( do_show_log ) show_log ( w , SECTION_ID_FRAME_LOGS , SECTION_ID_FRAME_LOG , do_show_log ) ; if ( frame -> nb_side_data ) { writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_LIST ) ; for ( i = 0 ; i < frame -> nb_side_data ; i ++ ) { AVFrameSideData * sd = frame -> side_data [ i ] ; const char * name ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA ) ; name = av_frame_side_data_name ( sd -> type ) ; print_str ( \"side_data_type\" , name ? name : \"unknown\" ) ; if ( sd -> type == AV_FRAME_DATA_DISPLAYMATRIX && sd -> size >= 9 * 4 ) { double rotation = av_display_rotation_get ( ( int32_t * ) sd -> data ) ; if ( isnan ( rotation ) ) rotation = 0 ; writer_print_integers ( w , \"displaymatrix\" , sd -> data , 9 , \" %11d\" , 3 , 4 , 1 ) ; print_int ( \"rotation\" , rotation ) ; } else if ( sd -> type == AV_FRAME_DATA_AFD && sd -> size > 0 ) { print_int ( \"active_format\" , * sd -> data ) ; } else if ( sd -> type == AV_FRAME_DATA_GOP_TIMECODE && sd -> size >= 8 ) { char tcbuf [ AV_TIMECODE_STR_SIZE ] ; av_timecode_make_mpeg_tc_string ( tcbuf , * ( int64_t * ) ( sd -> data ) ) ; print_str ( \"timecode\" , tcbuf ) ; } else if ( sd -> type == AV_FRAME_DATA_S12M_TIMECODE && sd -> size == 16 ) { uint32_t * tc = ( uint32_t * ) sd -> data ; int m = FFMIN ( tc [ 0 ] , 3 ) ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_TIMECODE_LIST ) ; for ( int j = 1 ; j <= m ; j ++ ) { char tcbuf [ AV_TIMECODE_STR_SIZE ] ; av_timecode_make_smpte_tc_string2 ( tcbuf , stream -> avg_frame_rate , tc [ j ] , 0 , 0 ) ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_TIMECODE ) ; print_str ( \"value\" , tcbuf ) ; writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } else if ( sd -> type == AV_FRAME_DATA_MASTERING_DISPLAY_METADATA ) { AVMasteringDisplayMetadata * metadata = ( AVMasteringDisplayMetadata * ) sd -> data ; if ( metadata -> has_primaries ) { print_q ( \"red_x\" , metadata -> display_primaries [ 0 ] [ 0 ] , '/' ) ; print_q ( \"red_y\" , metadata -> display_primaries [ 0 ] [ 1 ] , '/' ) ; print_q ( \"green_x\" , metadata -> display_primaries [ 1 ] [ 0 ] , '/' ) ; print_q ( \"green_y\" , metadata -> display_primaries [ 1 ] [ 1 ] , '/' ) ; print_q ( \"blue_x\" , metadata -> display_primaries [ 2 ] [ 0 ] , '/' ) ; print_q ( \"blue_y\" , metadata -> display_primaries [ 2 ] [ 1 ] , '/' ) ; print_q ( \"white_point_x\" , metadata -> white_point [ 0 ] , '/' ) ; print_q ( \"white_point_y\" , metadata -> white_point [ 1 ] , '/' ) ; } if ( metadata -> has_luminance ) { print_q ( \"min_luminance\" , metadata -> min_luminance , '/' ) ; print_q ( \"max_luminance\" , metadata -> max_luminance , '/' ) ; } } else if ( sd -> type == AV_FRAME_DATA_DYNAMIC_HDR_PLUS ) { AVDynamicHDRPlus * metadata = ( AVDynamicHDRPlus * ) sd -> data ; print_dynamic_hdr10_plus ( w , metadata ) ; } else if ( sd -> type == AV_FRAME_DATA_CONTENT_LIGHT_LEVEL ) { AVContentLightMetadata * metadata = ( AVContentLightMetadata * ) sd -> data ; print_int ( \"max_content\" , metadata -> MaxCLL ) ; print_int ( \"max_average\" , metadata -> MaxFALL ) ; } else if ( sd -> type == AV_FRAME_DATA_ICC_PROFILE ) { const AVDictionaryEntry * tag = av_dict_get ( sd -> metadata , \"name\" , NULL , AV_DICT_MATCH_CASE ) ; if ( tag ) print_str ( tag -> key , tag -> value ) ; print_int ( \"size\" , sd -> size ) ; } else if ( sd -> type == AV_FRAME_DATA_DOVI_METADATA ) { print_dovi_metadata ( w , ( const AVDOVIMetadata * ) sd -> data ) ; } else if ( sd -> type == AV_FRAME_DATA_DYNAMIC_HDR_VIVID ) { AVDynamicHDRVivid * metadata = ( AVDynamicHDRVivid * ) sd -> data ; print_dynamic_hdr_vivid ( w , metadata ) ; } else if ( sd -> type == AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT ) { print_ambient_viewing_environment ( w , ( const AVAmbientViewingEnvironment * ) sd -> data ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@process_frame": "static av_always_inline int process_frame ( WriterContext * w , InputFile * ifile , AVFrame * frame , const AVPacket * pkt , int * packet_new ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; AVCodecContext * dec_ctx = ifile -> streams [ pkt -> stream_index ] . dec_ctx ; AVCodecParameters * par = ifile -> streams [ pkt -> stream_index ] . st -> codecpar ; AVSubtitle sub ; int ret = 0 , got_frame = 0 ; clear_log ( 1 ) ; if ( dec_ctx ) { switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : case AVMEDIA_TYPE_AUDIO : if ( * packet_new ) { ret = avcodec_send_packet ( dec_ctx , pkt ) ; if ( ret == AVERROR ( EAGAIN ) ) { ret = 0 ; } else if ( ret >= 0 || ret == AVERROR_EOF ) { ret = 0 ; * packet_new = 0 ; } } if ( ret >= 0 ) { ret = avcodec_receive_frame ( dec_ctx , frame ) ; if ( ret >= 0 ) { got_frame = 1 ; } else if ( ret == AVERROR ( EAGAIN ) || ret == AVERROR_EOF ) { ret = 0 ; } } break ; case AVMEDIA_TYPE_SUBTITLE : if ( * packet_new ) ret = avcodec_decode_subtitle2 ( dec_ctx , & sub , & got_frame , pkt ) ; * packet_new = 0 ; break ; default : * packet_new = 0 ; } } else { * packet_new = 0 ; } if ( ret < 0 ) return ret ; if ( got_frame ) { int is_sub = ( par -> codec_type == AVMEDIA_TYPE_SUBTITLE ) ; nb_streams_frames [ pkt -> stream_index ] ++ ; if ( do_show_frames ) { if ( is_sub ) { show_subtitle ( w , & sub , ifile -> streams [ pkt -> stream_index ] . st , fmt_ctx ) ; } else { show_frame ( w , frame , ifile -> streams [ pkt -> stream_index ] . st , fmt_ctx ) ; } } if ( is_sub ) { avsubtitle_free ( & sub ) ; } } return got_frame || * packet_new ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@log_read_interval": "static void log_read_interval ( const ReadInterval * interval , void * log_ctx , int log_level ) { av_log ( log_ctx , log_level , \"id:%d\" , interval -> id ) ; if ( interval -> has_start ) { av_log ( log_ctx , log_level , \" start:%s%s\" , interval -> start_is_offset ? \"+\" : \"\" , av_ts2timestr ( interval -> start , & AV_TIME_BASE_Q ) ) ; } else { av_log ( log_ctx , log_level , \" start:N/A\" ) ; } if ( interval -> has_end ) { av_log ( log_ctx , log_level , \" end:%s\" , interval -> end_is_offset ? \"+\" : \"\" ) ; if ( interval -> duration_frames ) av_log ( log_ctx , log_level , \"#%\" PRId64 , interval -> end ) ; else av_log ( log_ctx , log_level , \"%s\" , av_ts2timestr ( interval -> end , & AV_TIME_BASE_Q ) ) ; } else { av_log ( log_ctx , log_level , \" end:N/A\" ) ; } av_log ( log_ctx , log_level , \"\\n\" ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@read_interval_packets": "static int read_interval_packets ( WriterContext * w , InputFile * ifile , const ReadInterval * interval , int64_t * cur_ts ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; AVPacket * pkt = NULL ; AVFrame * frame = NULL ; int ret = 0 , i = 0 , frame_count = 0 ; int64_t start = - INT64_MAX , end = interval -> end ; int has_start = 0 , has_end = interval -> has_end && ! interval -> end_is_offset ; av_log ( NULL , AV_LOG_VERBOSE , \"Processing read interval \" ) ; log_read_interval ( interval , NULL , AV_LOG_VERBOSE ) ; if ( interval -> has_start ) { int64_t target ; if ( interval -> start_is_offset ) { if ( * cur_ts == AV_NOPTS_VALUE ) { av_log ( NULL , AV_LOG_ERROR , \"Could not seek to relative position since current \" \"timestamp is not defined\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto end ; } target = * cur_ts + interval -> start ; } else { target = interval -> start ; } av_log ( NULL , AV_LOG_VERBOSE , \"Seeking to read interval start point %s\\n\" , av_ts2timestr ( target , & AV_TIME_BASE_Q ) ) ; if ( ( ret = avformat_seek_file ( fmt_ctx , - 1 , - INT64_MAX , target , INT64_MAX , 0 ) ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Could not seek to position %\" PRId64 \": %s\\n\" , interval -> start , av_err2str ( ret ) ) ; goto end ; } } frame = av_frame_alloc ( ) ; if ( ! frame ) { ret = AVERROR ( ENOMEM ) ; goto end ; } pkt = av_packet_alloc ( ) ; if ( ! pkt ) { ret = AVERROR ( ENOMEM ) ; goto end ; } while ( ! av_read_frame ( fmt_ctx , pkt ) ) { if ( fmt_ctx -> nb_streams > nb_streams ) { REALLOCZ_ARRAY_STREAM ( nb_streams_frames , nb_streams , fmt_ctx -> nb_streams ) ; REALLOCZ_ARRAY_STREAM ( nb_streams_packets , nb_streams , fmt_ctx -> nb_streams ) ; REALLOCZ_ARRAY_STREAM ( selected_streams , nb_streams , fmt_ctx -> nb_streams ) ; nb_streams = fmt_ctx -> nb_streams ; } if ( selected_streams [ pkt -> stream_index ] ) { AVRational tb = ifile -> streams [ pkt -> stream_index ] . st -> time_base ; int64_t pts = pkt -> pts != AV_NOPTS_VALUE ? pkt -> pts : pkt -> dts ; if ( pts != AV_NOPTS_VALUE ) * cur_ts = av_rescale_q ( pts , tb , AV_TIME_BASE_Q ) ; if ( ! has_start && * cur_ts != AV_NOPTS_VALUE ) { start = * cur_ts ; has_start = 1 ; } if ( has_start && ! has_end && interval -> end_is_offset ) { end = start + interval -> end ; has_end = 1 ; } if ( interval -> end_is_offset && interval -> duration_frames ) { if ( frame_count >= interval -> end ) break ; } else if ( has_end && * cur_ts != AV_NOPTS_VALUE && * cur_ts >= end ) { break ; } frame_count ++ ; if ( do_read_packets ) { if ( do_show_packets ) show_packet ( w , ifile , pkt , i ++ ) ; nb_streams_packets [ pkt -> stream_index ] ++ ; } if ( do_read_frames ) { int packet_new = 1 ; while ( process_frame ( w , ifile , frame , pkt , & packet_new ) > 0 ) ; } } av_packet_unref ( pkt ) ; } av_packet_unref ( pkt ) ; //Flush remaining frames that are cached in the decoder for ( i = 0 ; i < ifile -> nb_streams ; i ++ ) { pkt -> stream_index = i ; if ( do_read_frames ) { while ( process_frame ( w , ifile , frame , pkt , & ( int ) { 1 } ) > 0 ) ; if ( ifile -> streams [ i ] . dec_ctx ) avcodec_flush_buffers ( ifile -> streams [ i ] . dec_ctx ) ; } } end : av_frame_free ( & frame ) ; av_packet_free ( & pkt ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Could not read packets in interval \" ) ; log_read_interval ( interval , NULL , AV_LOG_ERROR ) ; } return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@read_packets": "static int read_packets ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; int64_t cur_ts = fmt_ctx -> start_time ; if ( read_intervals_nb == 0 ) { ReadInterval interval = ( ReadInterval ) { . has_start = 0 , . has_end = 0 } ; ret = read_interval_packets ( w , ifile , & interval , & cur_ts ) ; } else { for ( i = 0 ; i < read_intervals_nb ; i ++ ) { ret = read_interval_packets ( w , ifile , & read_intervals [ i ] , & cur_ts ) ; if ( ret < 0 ) break ; } } return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_stream": "static int show_stream ( WriterContext * w , AVFormatContext * fmt_ctx , int stream_idx , InputStream * ist , int in_program ) { AVStream * stream = ist -> st ; AVCodecParameters * par ; AVCodecContext * dec_ctx ; char val_str [ 128 ] ; const char * s ; AVRational sar , dar ; AVBPrint pbuf ; const AVCodecDescriptor * cd ; int ret = 0 ; const char * profile = NULL ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM ) ; print_int ( \"index\" , stream -> index ) ; par = stream -> codecpar ; dec_ctx = ist -> dec_ctx ; if ( ( cd = avcodec_descriptor_get ( par -> codec_id ) ) ) { print_str ( \"codec_name\" , cd -> name ) ; if ( ! do_bitexact ) { print_str ( \"codec_long_name\" , cd -> long_name ? cd -> long_name : \"unknown\" ) ; } } else { print_str_opt ( \"codec_name\" , \"unknown\" ) ; if ( ! do_bitexact ) { print_str_opt ( \"codec_long_name\" , \"unknown\" ) ; } } if ( ! do_bitexact && ( profile = avcodec_profile_name ( par -> codec_id , par -> profile ) ) ) print_str ( \"profile\" , profile ) ; else { if ( par -> profile != FF_PROFILE_UNKNOWN ) { char profile_num [ 12 ] ; snprintf ( profile_num , sizeof ( profile_num ) , \"%d\" , par -> profile ) ; print_str ( \"profile\" , profile_num ) ; } else print_str_opt ( \"profile\" , \"unknown\" ) ; } s = av_get_media_type_string ( par -> codec_type ) ; if ( s ) print_str ( \"codec_type\" , s ) ; else print_str_opt ( \"codec_type\" , \"unknown\" ) ; /* print AVI/FourCC tag */ print_str ( \"codec_tag_string\" , av_fourcc2str ( par -> codec_tag ) ) ; print_fmt ( \"codec_tag\" , \"0x%04\" PRIx32 , par -> codec_tag ) ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : print_int ( \"width\" , par -> width ) ; print_int ( \"height\" , par -> height ) ; if ( dec_ctx ) { print_int ( \"coded_width\" , dec_ctx -> coded_width ) ; print_int ( \"coded_height\" , dec_ctx -> coded_height ) ; print_int ( \"closed_captions\" , ! ! ( dec_ctx -> properties & FF_CODEC_PROPERTY_CLOSED_CAPTIONS ) ) ; print_int ( \"film_grain\" , ! ! ( dec_ctx -> properties & FF_CODEC_PROPERTY_FILM_GRAIN ) ) ; } print_int ( \"has_b_frames\" , par -> video_delay ) ; sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , NULL ) ; if ( sar . num ) { print_q ( \"sample_aspect_ratio\" , sar , ':' ) ; av_reduce ( & dar . num , & dar . den , par -> width * sar . num , par -> height * sar . den , 1024 * 1024 ) ; print_q ( \"display_aspect_ratio\" , dar , ':' ) ; } else { print_str_opt ( \"sample_aspect_ratio\" , \"N/A\" ) ; print_str_opt ( \"display_aspect_ratio\" , \"N/A\" ) ; } s = av_get_pix_fmt_name ( par -> format ) ; if ( s ) print_str ( \"pix_fmt\" , s ) ; else print_str_opt ( \"pix_fmt\" , \"unknown\" ) ; print_int ( \"level\" , par -> level ) ; print_color_range ( w , par -> color_range ) ; print_color_space ( w , par -> color_space ) ; print_color_trc ( w , par -> color_trc ) ; print_primaries ( w , par -> color_primaries ) ; print_chroma_location ( w , par -> chroma_location ) ; if ( par -> field_order == AV_FIELD_PROGRESSIVE ) print_str ( \"field_order\" , \"progressive\" ) ; else if ( par -> field_order == AV_FIELD_TT ) print_str ( \"field_order\" , \"tt\" ) ; else if ( par -> field_order == AV_FIELD_BB ) print_str ( \"field_order\" , \"bb\" ) ; else if ( par -> field_order == AV_FIELD_TB ) print_str ( \"field_order\" , \"tb\" ) ; else if ( par -> field_order == AV_FIELD_BT ) print_str ( \"field_order\" , \"bt\" ) ; else print_str_opt ( \"field_order\" , \"unknown\" ) ; if ( dec_ctx ) print_int ( \"refs\" , dec_ctx -> refs ) ; break ; case AVMEDIA_TYPE_AUDIO : s = av_get_sample_fmt_name ( par -> format ) ; if ( s ) print_str ( \"sample_fmt\" , s ) ; else print_str_opt ( \"sample_fmt\" , \"unknown\" ) ; print_val ( \"sample_rate\" , par -> sample_rate , unit_hertz_str ) ; print_int ( \"channels\" , par -> ch_layout . nb_channels ) ; if ( par -> ch_layout . order != AV_CHANNEL_ORDER_UNSPEC ) { av_channel_layout_describe ( & par -> ch_layout , val_str , sizeof ( val_str ) ) ; print_str ( \"channel_layout\" , val_str ) ; } else { print_str_opt ( \"channel_layout\" , \"unknown\" ) ; } print_int ( \"bits_per_sample\" , av_get_bits_per_sample ( par -> codec_id ) ) ; print_int ( \"initial_padding\" , par -> initial_padding ) ; break ; case AVMEDIA_TYPE_SUBTITLE : if ( par -> width ) print_int ( \"width\" , par -> width ) ; else print_str_opt ( \"width\" , \"N/A\" ) ; if ( par -> height ) print_int ( \"height\" , par -> height ) ; else print_str_opt ( \"height\" , \"N/A\" ) ; break ; } if ( dec_ctx && dec_ctx -> codec -> priv_class && show_private_data ) { const AVOption * opt = NULL ; while ( ( opt = av_opt_next ( dec_ctx -> priv_data , opt ) ) ) { uint8_t * str ; if ( ! ( opt -> flags & AV_OPT_FLAG_EXPORT ) ) continue ; if ( av_opt_get ( dec_ctx -> priv_data , opt -> name , 0 , & str ) >= 0 ) { print_str ( opt -> name , str ) ; av_free ( str ) ; } } } if ( fmt_ctx -> iformat -> flags & AVFMT_SHOW_IDS ) print_fmt ( \"id\" , \"0x%x\" , stream -> id ) ; else print_str_opt ( \"id\" , \"N/A\" ) ; print_q ( \"r_frame_rate\" , stream -> r_frame_rate , '/' ) ; print_q ( \"avg_frame_rate\" , stream -> avg_frame_rate , '/' ) ; print_q ( \"time_base\" , stream -> time_base , '/' ) ; print_ts ( \"start_pts\" , stream -> start_time ) ; print_time ( \"start_time\" , stream -> start_time , & stream -> time_base ) ; print_ts ( \"duration_ts\" , stream -> duration ) ; print_time ( \"duration\" , stream -> duration , & stream -> time_base ) ; if ( par -> bit_rate > 0 ) print_val ( \"bit_rate\" , par -> bit_rate , unit_bit_per_second_str ) ; else print_str_opt ( \"bit_rate\" , \"N/A\" ) ; if ( dec_ctx && dec_ctx -> rc_max_rate > 0 ) print_val ( \"max_bit_rate\" , dec_ctx -> rc_max_rate , unit_bit_per_second_str ) ; else print_str_opt ( \"max_bit_rate\" , \"N/A\" ) ; if ( dec_ctx && dec_ctx -> bits_per_raw_sample > 0 ) print_fmt ( \"bits_per_raw_sample\" , \"%d\" , dec_ctx -> bits_per_raw_sample ) ; else print_str_opt ( \"bits_per_raw_sample\" , \"N/A\" ) ; if ( stream -> nb_frames ) print_fmt ( \"nb_frames\" , \"%\" PRId64 , stream -> nb_frames ) ; else print_str_opt ( \"nb_frames\" , \"N/A\" ) ; if ( nb_streams_frames [ stream_idx ] ) print_fmt ( \"nb_read_frames\" , \"%\" PRIu64 , nb_streams_frames [ stream_idx ] ) ; else print_str_opt ( \"nb_read_frames\" , \"N/A\" ) ; if ( nb_streams_packets [ stream_idx ] ) print_fmt ( \"nb_read_packets\" , \"%\" PRIu64 , nb_streams_packets [ stream_idx ] ) ; else print_str_opt ( \"nb_read_packets\" , \"N/A\" ) ; if ( do_show_data ) writer_print_data ( w , \"extradata\" , par -> extradata , par -> extradata_size ) ; if ( par -> extradata_size > 0 ) { print_int ( \"extradata_size\" , par -> extradata_size ) ; writer_print_data_hash ( w , \"extradata_hash\" , par -> extradata , par -> extradata_size ) ; } /* Print disposition information */ # define PRINT_DISPOSITION ( flagname , name ) do { print_int ( name , ! ! ( stream -> disposition & AV_DISPOSITION_ ## flagname ) ) ; } while ( 0 ) if ( do_show_stream_disposition ) { writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION ) ; PRINT_DISPOSITION ( DEFAULT , \"default\" ) ; PRINT_DISPOSITION ( DUB , \"dub\" ) ; PRINT_DISPOSITION ( ORIGINAL , \"original\" ) ; PRINT_DISPOSITION ( COMMENT , \"comment\" ) ; PRINT_DISPOSITION ( LYRICS , \"lyrics\" ) ; PRINT_DISPOSITION ( KARAOKE , \"karaoke\" ) ; PRINT_DISPOSITION ( FORCED , \"forced\" ) ; PRINT_DISPOSITION ( HEARING_IMPAIRED , \"hearing_impaired\" ) ; PRINT_DISPOSITION ( VISUAL_IMPAIRED , \"visual_impaired\" ) ; PRINT_DISPOSITION ( CLEAN_EFFECTS , \"clean_effects\" ) ; PRINT_DISPOSITION ( ATTACHED_PIC , \"attached_pic\" ) ; PRINT_DISPOSITION ( TIMED_THUMBNAILS , \"timed_thumbnails\" ) ; PRINT_DISPOSITION ( CAPTIONS , \"captions\" ) ; PRINT_DISPOSITION ( DESCRIPTIONS , \"descriptions\" ) ; PRINT_DISPOSITION ( METADATA , \"metadata\" ) ; PRINT_DISPOSITION ( DEPENDENT , \"dependent\" ) ; PRINT_DISPOSITION ( STILL_IMAGE , \"still_image\" ) ; writer_print_section_footer ( w ) ; } if ( do_show_stream_tags ) ret = show_tags ( w , stream -> metadata , in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS ) ; if ( stream -> nb_side_data ) { print_pkt_side_data ( w , stream -> codecpar , stream -> side_data , stream -> nb_side_data , SECTION_ID_STREAM_SIDE_DATA_LIST , SECTION_ID_STREAM_SIDE_DATA ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_streams": "static int show_streams ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; writer_print_section_header ( w , SECTION_ID_STREAMS ) ; for ( i = 0 ; i < ifile -> nb_streams ; i ++ ) if ( selected_streams [ i ] ) { ret = show_stream ( w , fmt_ctx , i , & ifile -> streams [ i ] , 0 ) ; if ( ret < 0 ) break ; } writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_program": "static int show_program ( WriterContext * w , InputFile * ifile , AVProgram * program ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; writer_print_section_header ( w , SECTION_ID_PROGRAM ) ; print_int ( \"program_id\" , program -> id ) ; print_int ( \"program_num\" , program -> program_num ) ; print_int ( \"nb_streams\" , program -> nb_stream_indexes ) ; print_int ( \"pmt_pid\" , program -> pmt_pid ) ; print_int ( \"pcr_pid\" , program -> pcr_pid ) ; if ( do_show_program_tags ) ret = show_tags ( w , program -> metadata , SECTION_ID_PROGRAM_TAGS ) ; if ( ret < 0 ) goto end ; writer_print_section_header ( w , SECTION_ID_PROGRAM_STREAMS ) ; for ( i = 0 ; i < program -> nb_stream_indexes ; i ++ ) { if ( selected_streams [ program -> stream_index [ i ] ] ) { ret = show_stream ( w , fmt_ctx , program -> stream_index [ i ] , & ifile -> streams [ program -> stream_index [ i ] ] , 1 ) ; if ( ret < 0 ) break ; } } writer_print_section_footer ( w ) ; end : writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_programs": "static int show_programs ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; writer_print_section_header ( w , SECTION_ID_PROGRAMS ) ; for ( i = 0 ; i < fmt_ctx -> nb_programs ; i ++ ) { AVProgram * program = fmt_ctx -> programs [ i ] ; if ( ! program ) continue ; ret = show_program ( w , ifile , program ) ; if ( ret < 0 ) break ; } writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_chapters": "static int show_chapters ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; writer_print_section_header ( w , SECTION_ID_CHAPTERS ) ; for ( i = 0 ; i < fmt_ctx -> nb_chapters ; i ++ ) { AVChapter * chapter = fmt_ctx -> chapters [ i ] ; writer_print_section_header ( w , SECTION_ID_CHAPTER ) ; print_int ( \"id\" , chapter -> id ) ; print_q ( \"time_base\" , chapter -> time_base , '/' ) ; print_int ( \"start\" , chapter -> start ) ; print_time ( \"start_time\" , chapter -> start , & chapter -> time_base ) ; print_int ( \"end\" , chapter -> end ) ; print_time ( \"end_time\" , chapter -> end , & chapter -> time_base ) ; if ( do_show_chapter_tags ) ret = show_tags ( w , chapter -> metadata , SECTION_ID_CHAPTER_TAGS ) ; writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_format": "static int show_format ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; char val_str [ 128 ] ; int64_t size = fmt_ctx -> pb ? avio_size ( fmt_ctx -> pb ) : - 1 ; int ret = 0 ; writer_print_section_header ( w , SECTION_ID_FORMAT ) ; print_str_validate ( \"filename\" , fmt_ctx -> url ) ; print_int ( \"nb_streams\" , fmt_ctx -> nb_streams ) ; print_int ( \"nb_programs\" , fmt_ctx -> nb_programs ) ; print_str ( \"format_name\" , fmt_ctx -> iformat -> name ) ; if ( ! do_bitexact ) { if ( fmt_ctx -> iformat -> long_name ) print_str ( \"format_long_name\" , fmt_ctx -> iformat -> long_name ) ; else print_str_opt ( \"format_long_name\" , \"unknown\" ) ; } print_time ( \"start_time\" , fmt_ctx -> start_time , & AV_TIME_BASE_Q ) ; print_time ( \"duration\" , fmt_ctx -> duration , & AV_TIME_BASE_Q ) ; if ( size >= 0 ) print_val ( \"size\" , size , unit_byte_str ) ; else print_str_opt ( \"size\" , \"N/A\" ) ; if ( fmt_ctx -> bit_rate > 0 ) print_val ( \"bit_rate\" , fmt_ctx -> bit_rate , unit_bit_per_second_str ) ; else print_str_opt ( \"bit_rate\" , \"N/A\" ) ; print_int ( \"probe_score\" , fmt_ctx -> probe_score ) ; if ( do_show_format_tags ) ret = show_tags ( w , fmt_ctx -> metadata , SECTION_ID_FORMAT_TAGS ) ; writer_print_section_footer ( w ) ; fflush ( stdout ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_error": "static void show_error ( WriterContext * w , int err ) { writer_print_section_header ( w , SECTION_ID_ERROR ) ; print_int ( \"code\" , err ) ; print_str ( \"string\" , av_err2str ( err ) ) ; writer_print_section_footer ( w ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@open_input_file": "static int open_input_file ( InputFile * ifile , const char * filename , const char * print_filename ) { int err , i ; AVFormatContext * fmt_ctx = NULL ; const AVDictionaryEntry * t = NULL ; int scan_all_pmts_set = 0 ; fmt_ctx = avformat_alloc_context ( ) ; if ( ! fmt_ctx ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( ! av_dict_get ( format_opts , \"scan_all_pmts\" , NULL , AV_DICT_MATCH_CASE ) ) { av_dict_set ( & format_opts , \"scan_all_pmts\" , \"1\" , AV_DICT_DONT_OVERWRITE ) ; scan_all_pmts_set = 1 ; } if ( ( err = avformat_open_input ( & fmt_ctx , filename , iformat , & format_opts ) ) < 0 ) { print_error ( filename , err ) ; return err ; } if ( print_filename ) { av_freep ( & fmt_ctx -> url ) ; fmt_ctx -> url = av_strdup ( print_filename ) ; } ifile -> fmt_ctx = fmt_ctx ; if ( scan_all_pmts_set ) av_dict_set ( & format_opts , \"scan_all_pmts\" , NULL , AV_DICT_MATCH_CASE ) ; while ( ( t = av_dict_iterate ( format_opts , t ) ) ) av_log ( NULL , AV_LOG_WARNING , \"Option %s skipped - not known to demuxer.\\n\" , t -> key ) ; if ( find_stream_info ) { AVDictionary * * opts = setup_find_stream_info_opts ( fmt_ctx , codec_opts ) ; int orig_nb_streams = fmt_ctx -> nb_streams ; err = avformat_find_stream_info ( fmt_ctx , opts ) ; for ( i = 0 ; i < orig_nb_streams ; i ++ ) av_dict_free ( & opts [ i ] ) ; av_freep ( & opts ) ; if ( err < 0 ) { print_error ( filename , err ) ; return err ; } } av_dump_format ( fmt_ctx , 0 , filename , 0 ) ; ifile -> streams = av_calloc ( fmt_ctx -> nb_streams , sizeof ( * ifile -> streams ) ) ; if ( ! ifile -> streams ) exit ( 1 ) ; ifile -> nb_streams = fmt_ctx -> nb_streams ; /* bind a decoder to each input stream */ for ( i = 0 ; i < fmt_ctx -> nb_streams ; i ++ ) { InputStream * ist = & ifile -> streams [ i ] ; AVStream * stream = fmt_ctx -> streams [ i ] ; const AVCodec * codec ; ist -> st = stream ; if ( stream -> codecpar -> codec_id == AV_CODEC_ID_PROBE ) { av_log ( NULL , AV_LOG_WARNING , \"Failed to probe codec for input stream %d\\n\" , stream -> index ) ; continue ; } codec = avcodec_find_decoder ( stream -> codecpar -> codec_id ) ; if ( ! codec ) { av_log ( NULL , AV_LOG_WARNING , \"Unsupported codec with id %d for input stream %d\\n\" , stream -> codecpar -> codec_id , stream -> index ) ; continue ; } { AVDictionary * opts = filter_codec_opts ( codec_opts , stream -> codecpar -> codec_id , fmt_ctx , stream , codec ) ; ist -> dec_ctx = avcodec_alloc_context3 ( codec ) ; if ( ! ist -> dec_ctx ) exit ( 1 ) ; err = avcodec_parameters_to_context ( ist -> dec_ctx , stream -> codecpar ) ; if ( err < 0 ) exit ( 1 ) ; if ( do_show_log ) { // For loging it is needed to disable at least frame threads as otherwise // the log information would need to be reordered and matches up to contexts and frames // That is in fact possible but not trivial av_dict_set ( & codec_opts , \"threads\" , \"1\" , 0 ) ; } ist -> dec_ctx -> pkt_timebase = stream -> time_base ; if ( avcodec_open2 ( ist -> dec_ctx , codec , & opts ) < 0 ) { av_log ( NULL , AV_LOG_WARNING , \"Could not open codec for input stream %d\\n\" , stream -> index ) ; exit ( 1 ) ; } if ( ( t = av_dict_get ( opts , \"\" , NULL , AV_DICT_IGNORE_SUFFIX ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"Option %s for input stream %d not found\\n\" , t -> key , stream -> index ) ; return AVERROR_OPTION_NOT_FOUND ; } } } ifile -> fmt_ctx = fmt_ctx ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@close_input_file": "static void close_input_file ( InputFile * ifile ) { int i ; /* close decoder for each stream */ for ( i = 0 ; i < ifile -> nb_streams ; i ++ ) avcodec_free_context ( & ifile -> streams [ i ] . dec_ctx ) ; av_freep ( & ifile -> streams ) ; ifile -> nb_streams = 0 ; avformat_close_input ( & ifile -> fmt_ctx ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@probe_file": "static int probe_file ( WriterContext * wctx , const char * filename , const char * print_filename ) { InputFile ifile = { 0 } ; int ret , i ; int section_id ; do_read_frames = do_show_frames || do_count_frames ; do_read_packets = do_show_packets || do_count_packets ; ret = open_input_file ( & ifile , filename , print_filename ) ; if ( ret < 0 ) goto end ; # define CHECK_END if ( ret < 0 ) goto end nb_streams = ifile . fmt_ctx -> nb_streams ; REALLOCZ_ARRAY_STREAM ( nb_streams_frames , 0 , ifile . fmt_ctx -> nb_streams ) ; REALLOCZ_ARRAY_STREAM ( nb_streams_packets , 0 , ifile . fmt_ctx -> nb_streams ) ; REALLOCZ_ARRAY_STREAM ( selected_streams , 0 , ifile . fmt_ctx -> nb_streams ) ; for ( i = 0 ; i < ifile . fmt_ctx -> nb_streams ; i ++ ) { if ( stream_specifier ) { ret = avformat_match_stream_specifier ( ifile . fmt_ctx , ifile . fmt_ctx -> streams [ i ] , stream_specifier ) ; CHECK_END ; else selected_streams [ i ] = ret ; ret = 0 ; } else { selected_streams [ i ] = 1 ; } if ( ! selected_streams [ i ] ) ifile . fmt_ctx -> streams [ i ] -> discard = AVDISCARD_ALL ; } if ( do_read_frames || do_read_packets ) { if ( do_show_frames && do_show_packets && wctx -> writer -> flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER ) section_id = SECTION_ID_PACKETS_AND_FRAMES ; else if ( do_show_packets && ! do_show_frames ) section_id = SECTION_ID_PACKETS ; else // (!do_show_packets && do_show_frames) section_id = SECTION_ID_FRAMES ; if ( do_show_frames || do_show_packets ) writer_print_section_header ( wctx , section_id ) ; ret = read_packets ( wctx , & ifile ) ; if ( do_show_frames || do_show_packets ) writer_print_section_footer ( wctx ) ; CHECK_END ; } if ( do_show_programs ) { ret = show_programs ( wctx , & ifile ) ; CHECK_END ; } if ( do_show_streams ) { ret = show_streams ( wctx , & ifile ) ; CHECK_END ; } if ( do_show_chapters ) { ret = show_chapters ( wctx , & ifile ) ; CHECK_END ; } if ( do_show_format ) { ret = show_format ( wctx , & ifile ) ; CHECK_END ; } end : if ( ifile . fmt_ctx ) close_input_file ( & ifile ) ; av_freep ( & nb_streams_frames ) ; av_freep ( & nb_streams_packets ) ; av_freep ( & selected_streams ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_usage": "static void show_usage ( void ) { av_log ( NULL , AV_LOG_INFO , \"Simple multimedia streams analyzer\\n\" ) ; av_log ( NULL , AV_LOG_INFO , \"usage: %s [OPTIONS] INPUT_FILE\\n\" , program_name ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@ffprobe_show_program_version": "static void ffprobe_show_program_version ( WriterContext * w ) { AVBPrint pbuf ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_PROGRAM_VERSION ) ; print_str ( \"version\" , FFMPEG_VERSION ) ; print_fmt ( \"copyright\" , \"Copyright (c) %d-%d the FFmpeg developers\" , program_birth_year , CONFIG_THIS_YEAR ) ; print_str ( \"compiler_ident\" , CC_IDENT ) ; print_str ( \"configuration\" , FFMPEG_CONFIGURATION ) ; writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@ffprobe_show_library_versions": "static void ffprobe_show_library_versions ( WriterContext * w ) { writer_print_section_header ( w , SECTION_ID_LIBRARY_VERSIONS ) ; SHOW_LIB_VERSION ( avutil , AVUTIL ) ; SHOW_LIB_VERSION ( avcodec , AVCODEC ) ; SHOW_LIB_VERSION ( avformat , AVFORMAT ) ; SHOW_LIB_VERSION ( avdevice , AVDEVICE ) ; SHOW_LIB_VERSION ( avfilter , AVFILTER ) ; SHOW_LIB_VERSION ( swscale , SWSCALE ) ; SHOW_LIB_VERSION ( swresample , SWRESAMPLE ) ; writer_print_section_footer ( w ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@ffprobe_show_pixel_formats": "static void ffprobe_show_pixel_formats ( WriterContext * w ) { const AVPixFmtDescriptor * pixdesc = NULL ; int i , n ; writer_print_section_header ( w , SECTION_ID_PIXEL_FORMATS ) ; while ( ( pixdesc = av_pix_fmt_desc_next ( pixdesc ) ) ) { writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT ) ; print_str ( \"name\" , pixdesc -> name ) ; print_int ( \"nb_components\" , pixdesc -> nb_components ) ; if ( ( pixdesc -> nb_components >= 3 ) && ! ( pixdesc -> flags & AV_PIX_FMT_FLAG_RGB ) ) { print_int ( \"log2_chroma_w\" , pixdesc -> log2_chroma_w ) ; print_int ( \"log2_chroma_h\" , pixdesc -> log2_chroma_h ) ; } else { print_str_opt ( \"log2_chroma_w\" , \"N/A\" ) ; print_str_opt ( \"log2_chroma_h\" , \"N/A\" ) ; } n = av_get_bits_per_pixel ( pixdesc ) ; if ( n ) print_int ( \"bits_per_pixel\" , n ) ; else print_str_opt ( \"bits_per_pixel\" , \"N/A\" ) ; if ( do_show_pixel_format_flags ) { writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_FLAGS ) ; PRINT_PIX_FMT_FLAG ( BE , \"big_endian\" ) ; PRINT_PIX_FMT_FLAG ( PAL , \"palette\" ) ; PRINT_PIX_FMT_FLAG ( BITSTREAM , \"bitstream\" ) ; PRINT_PIX_FMT_FLAG ( HWACCEL , \"hwaccel\" ) ; PRINT_PIX_FMT_FLAG ( PLANAR , \"planar\" ) ; PRINT_PIX_FMT_FLAG ( RGB , \"rgb\" ) ; PRINT_PIX_FMT_FLAG ( ALPHA , \"alpha\" ) ; writer_print_section_footer ( w ) ; } if ( do_show_pixel_format_components && ( pixdesc -> nb_components > 0 ) ) { writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_COMPONENTS ) ; for ( i = 0 ; i < pixdesc -> nb_components ; i ++ ) { writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_COMPONENT ) ; print_int ( \"index\" , i + 1 ) ; print_int ( \"bit_depth\" , pixdesc -> comp [ i ] . depth ) ; writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_show_optional_fields": "static int opt_show_optional_fields ( void * optctx , const char * opt , const char * arg ) { if ( ! av_strcasecmp ( arg , \"always\" ) ) show_optional_fields = SHOW_OPTIONAL_FIELDS_ALWAYS ; else if ( ! av_strcasecmp ( arg , \"never\" ) ) show_optional_fields = SHOW_OPTIONAL_FIELDS_NEVER ; else if ( ! av_strcasecmp ( arg , \"auto\" ) ) show_optional_fields = SHOW_OPTIONAL_FIELDS_AUTO ; if ( show_optional_fields == SHOW_OPTIONAL_FIELDS_AUTO && av_strcasecmp ( arg , \"auto\" ) ) show_optional_fields = parse_number_or_die ( \"show_optional_fields\" , arg , OPT_INT , SHOW_OPTIONAL_FIELDS_AUTO , SHOW_OPTIONAL_FIELDS_ALWAYS ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_format": "static int opt_format ( void * optctx , const char * opt , const char * arg ) { iformat = av_find_input_format ( arg ) ; if ( ! iformat ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown input format: %s\\n\" , arg ) ; return AVERROR ( EINVAL ) ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@mark_section_show_entries": "static inline void mark_section_show_entries ( SectionID section_id , int show_all_entries , AVDictionary * entries ) { struct section * section = & sections [ section_id ] ; section -> show_all_entries = show_all_entries ; if ( show_all_entries ) { SectionID * id ; for ( id = section -> children_ids ; * id != - 1 ; id ++ ) mark_section_show_entries ( * id , show_all_entries , entries ) ; } else { av_dict_copy ( & section -> entries_to_show , entries , 0 ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@match_section": "static int match_section ( const char * section_name , int show_all_entries , AVDictionary * entries ) { int i , ret = 0 ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( sections ) ; i ++ ) { const struct section * section = & sections [ i ] ; if ( ! strcmp ( section_name , section -> name ) || ( section -> unique_name && ! strcmp ( section_name , section -> unique_name ) ) ) { av_log ( NULL , AV_LOG_DEBUG , \"'%s' matches section with unique name '%s'\\n\" , section_name , ( char * ) av_x_if_null ( section -> unique_name , section -> name ) ) ; ret ++ ; mark_section_show_entries ( section -> id , show_all_entries , entries ) ; } } return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_show_entries": "static int opt_show_entries ( void * optctx , const char * opt , const char * arg ) { const char * p = arg ; int ret = 0 ; while ( * p ) { AVDictionary * entries = NULL ; char * section_name = av_get_token ( & p , \"=:\" ) ; int show_all_entries = 0 ; if ( ! section_name ) { av_log ( NULL , AV_LOG_ERROR , \"Missing section name for option '%s'\\n\" , opt ) ; return AVERROR ( EINVAL ) ; } if ( * p == '=' ) { p ++ ; while ( * p && * p != ':' ) { char * entry = av_get_token ( & p , \",:\" ) ; if ( ! entry ) break ; av_log ( NULL , AV_LOG_VERBOSE , \"Adding '%s' to the entries to show in section '%s'\\n\" , entry , section_name ) ; av_dict_set ( & entries , entry , \"\" , AV_DICT_DONT_STRDUP_KEY ) ; if ( * p == ',' ) p ++ ; } } else { show_all_entries = 1 ; } ret = match_section ( section_name , show_all_entries , entries ) ; if ( ret == 0 ) { av_log ( NULL , AV_LOG_ERROR , \"No match for section '%s'\\n\" , section_name ) ; ret = AVERROR ( EINVAL ) ; } av_dict_free ( & entries ) ; av_free ( section_name ) ; if ( ret <= 0 ) break ; if ( * p ) p ++ ; } return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_input_file": "static void opt_input_file ( void * optctx , const char * arg ) { if ( input_filename ) { av_log ( NULL , AV_LOG_ERROR , \"Argument '%s' provided as input filename, but '%s' was already specified.\\n\" , arg , input_filename ) ; exit_program ( 1 ) ; } if ( ! strcmp ( arg , \"-\" ) ) arg = \"fd:\" ; input_filename = arg ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_input_file_i": "static int opt_input_file_i ( void * optctx , const char * opt , const char * arg ) { opt_input_file ( optctx , arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_output_file": "static void opt_output_file ( void * optctx , const char * arg ) { if ( output_filename ) { av_log ( NULL , AV_LOG_ERROR , \"Argument '%s' provided as output filename, but '%s' was already specified.\\n\" , arg , output_filename ) ; exit_program ( 1 ) ; } if ( ! strcmp ( arg , \"-\" ) ) arg = \"fd:\" ; output_filename = arg ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_output_file_o": "static int opt_output_file_o ( void * optctx , const char * opt , const char * arg ) { opt_output_file ( optctx , arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_print_filename": "static int opt_print_filename ( void * optctx , const char * opt , const char * arg ) { print_input_filename = arg ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@show_help_default_ffprobe": "void show_help_default_ffprobe ( const char * opt , const char * arg ) { show_usage ( ) ; show_help_options ( ffprobe_options , \"Main options:\" , 0 , 0 , 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; show_help_children ( avformat_get_class ( ) , AV_OPT_FLAG_DECODING_PARAM ) ; show_help_children ( avcodec_get_class ( ) , AV_OPT_FLAG_DECODING_PARAM ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@parse_read_interval": "static int parse_read_interval ( const char * interval_spec , ReadInterval * interval ) { int ret = 0 ; char * next , * p , * spec = av_strdup ( interval_spec ) ; if ( ! spec ) return AVERROR ( ENOMEM ) ; if ( ! * spec ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid empty interval specification\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto end ; } p = spec ; next = strchr ( spec , '%' ) ; if ( next ) * next ++ = 0 ; /* parse first part */ if ( * p ) { interval -> has_start = 1 ; if ( * p == '+' ) { interval -> start_is_offset = 1 ; p ++ ; } else { interval -> start_is_offset = 0 ; } ret = av_parse_time ( & interval -> start , p , 1 ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid interval start specification '%s'\\n\" , p ) ; goto end ; } } else { interval -> has_start = 0 ; } /* parse second part */ p = next ; if ( p && * p ) { int64_t us ; interval -> has_end = 1 ; if ( * p == '+' ) { interval -> end_is_offset = 1 ; p ++ ; } else { interval -> end_is_offset = 0 ; } if ( interval -> end_is_offset && * p == '#' ) { long long int lli ; char * tail ; interval -> duration_frames = 1 ; p ++ ; lli = strtoll ( p , & tail , 10 ) ; if ( * tail || lli < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid or negative value '%s' for duration number of frames\\n\" , p ) ; goto end ; } interval -> end = lli ; } else { interval -> duration_frames = 0 ; ret = av_parse_time ( & us , p , 1 ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid interval end/duration specification '%s'\\n\" , p ) ; goto end ; } interval -> end = us ; } } else { interval -> has_end = 0 ; } end : av_free ( spec ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@parse_read_intervals": "static int parse_read_intervals ( const char * intervals_spec ) { int ret , n , i ; char * p , * spec = av_strdup ( intervals_spec ) ; if ( ! spec ) return AVERROR ( ENOMEM ) ; /* preparse specification, get number of intervals */ for ( n = 0 , p = spec ; * p ; p ++ ) if ( * p == ',' ) n ++ ; n ++ ; read_intervals = av_malloc_array ( n , sizeof ( * read_intervals ) ) ; if ( ! read_intervals ) { ret = AVERROR ( ENOMEM ) ; goto end ; } read_intervals_nb = n ; /* parse intervals */ p = spec ; for ( i = 0 ; p ; i ++ ) { char * next ; av_assert0 ( i < read_intervals_nb ) ; next = strchr ( p , ',' ) ; if ( next ) * next ++ = 0 ; read_intervals [ i ] . id = i ; ret = parse_read_interval ( p , & read_intervals [ i ] ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing read interval #%d '%s'\\n\" , i , p ) ; goto end ; } av_log ( NULL , AV_LOG_VERBOSE , \"Parsed log interval \" ) ; log_read_interval ( & read_intervals [ i ] , NULL , AV_LOG_VERBOSE ) ; p = next ; } av_assert0 ( i == read_intervals_nb ) ; end : av_free ( spec ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_read_intervals": "static int opt_read_intervals ( void * optctx , const char * opt , const char * arg ) { return parse_read_intervals ( arg ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_pretty": "static int opt_pretty ( void * optctx , const char * opt , const char * arg ) { show_value_unit = 1 ; use_value_prefix = 1 ; use_byte_value_binary_prefix = 1 ; use_value_sexagesimal_format = 1 ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@print_section": "static void print_section ( SectionID id , int level ) { const SectionID * pid ; const struct section * section = & sections [ id ] ; av_log ( NULL , AV_LOG_STDERR , \"%c%c%c\" , section -> flags & SECTION_FLAG_IS_WRAPPER ? 'W' : '.' , section -> flags & SECTION_FLAG_IS_ARRAY ? 'A' : '.' , section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ? 'V' : '.' ) ; av_log ( NULL , AV_LOG_STDERR , \"%*c  %s\" , level * 4 , ' ' , section -> name ) ; if ( section -> unique_name ) av_log ( NULL , AV_LOG_STDERR , \"/%s\" , section -> unique_name ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; for ( pid = section -> children_ids ; * pid != - 1 ; pid ++ ) print_section ( * pid , level + 1 ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_sections": "static int opt_sections ( void * optctx , const char * opt , const char * arg ) { av_log ( NULL , AV_LOG_STDERR , \"Sections:\\n\" \"W.. = Section is a wrapper (contains other sections, no local entries)\\n\" \".A. = Section contains an array of elements of the same type\\n\" \"..V = Section may contain a variable number of fields with variable keys\\n\" \"FLAGS NAME/UNIQUE_NAME\\n\" \"---\\n\" ) ; print_section ( SECTION_ID_ROOT , 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_show_versions": "static int opt_show_versions ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_PROGRAM_VERSION , 1 , NULL ) ; mark_section_show_entries ( SECTION_ID_LIBRARY_VERSION , 1 , NULL ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_show_chapters": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_show_error": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_show_format": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_show_frames": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_show_library_versions": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_show_packets": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_show_pixel_formats": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_show_program_version": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS ) DEFINE_OPT_SHOW_SECTION ( program_version , PROGRAM_VERSION )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_show_streams": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS ) DEFINE_OPT_SHOW_SECTION ( program_version , PROGRAM_VERSION ) DEFINE_OPT_SHOW_SECTION ( streams , STREAMS )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@opt_show_programs": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS ) DEFINE_OPT_SHOW_SECTION ( program_version , PROGRAM_VERSION ) DEFINE_OPT_SHOW_SECTION ( streams , STREAMS ) DEFINE_OPT_SHOW_SECTION ( programs , PROGRAMS )",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@check_section_show_entries": "static inline int check_section_show_entries ( int section_id ) { int * id ; struct section * section = & sections [ section_id ] ; if ( sections [ section_id ] . show_all_entries || sections [ section_id ] . entries_to_show ) return 1 ; for ( id = section -> children_ids ; * id != - 1 ; id ++ ) if ( check_section_show_entries ( * id ) ) return 1 ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@ffprobe_var_cleanup": "void ffprobe_var_cleanup ( ) { main_ffprobe_return_code = 0 ; longjmp_value = 0 ; do_bitexact = 0 ; do_count_frames = 0 ; do_count_packets = 0 ; do_read_frames = 0 ; do_read_packets = 0 ; do_show_chapters = 0 ; do_show_error = 0 ; do_show_format = 0 ; do_show_frames = 0 ; do_show_packets = 0 ; do_show_programs = 0 ; do_show_streams = 0 ; do_show_stream_disposition = 0 ; do_show_data = 0 ; do_show_program_version = 0 ; do_show_library_versions = 0 ; do_show_pixel_formats = 0 ; do_show_pixel_format_flags = 0 ; do_show_pixel_format_components = 0 ; do_show_log = 0 ; do_show_chapter_tags = 0 ; do_show_format_tags = 0 ; do_show_frame_tags = 0 ; do_show_program_tags = 0 ; do_show_stream_tags = 0 ; do_show_packet_tags = 0 ; show_value_unit = 0 ; use_value_prefix = 0 ; use_byte_value_binary_prefix = 0 ; use_value_sexagesimal_format = 0 ; show_private_data = 1 ; print_format = NULL ; stream_specifier = NULL ; show_data_hash = NULL ; read_intervals = NULL ; read_intervals_nb = 0 ; find_stream_info = 1 ; ffprobe_options = NULL ; input_filename = NULL ; print_input_filename = NULL ; iformat = NULL ; hash = NULL ; main_ffprobe_return_code = 0 ; nb_streams = 0 ; nb_streams_packets = NULL ; nb_streams_frames = NULL ; selected_streams = NULL ; log_buffer = NULL ; log_buffer_size = 0 ; for ( int i = 0 ; i < FF_ARRAY_ELEMS ( sections ) ; i ++ ) { sections [ i ] . show_all_entries = 0 ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffprobe.c@ffprobe_execute": "int ffprobe_execute ( int argc , char * * argv ) { char _program_name [ ] = \"ffprobe\" ; program_name = ( char * ) & _program_name ; program_birth_year = 2007 ; OptionDef options [ ] = { { \"L\" , OPT_EXIT , { . func_arg = show_license } , \"show license\" } , { \"h\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"?\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"help\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"-help\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"version\" , OPT_EXIT , { . func_arg = show_version } , \"show version\" } , { \"buildconf\" , OPT_EXIT , { . func_arg = show_buildconf } , \"show build configuration\" } , { \"formats\" , OPT_EXIT , { . func_arg = show_formats } , \"show available formats\" } , { \"muxers\" , OPT_EXIT , { . func_arg = show_muxers } , \"show available muxers\" } , { \"demuxers\" , OPT_EXIT , { . func_arg = show_demuxers } , \"show available demuxers\" } , { \"devices\" , OPT_EXIT , { . func_arg = show_devices } , \"show available devices\" } , { \"codecs\" , OPT_EXIT , { . func_arg = show_codecs } , \"show available codecs\" } , { \"decoders\" , OPT_EXIT , { . func_arg = show_decoders } , \"show available decoders\" } , { \"encoders\" , OPT_EXIT , { . func_arg = show_encoders } , \"show available encoders\" } , { \"bsfs\" , OPT_EXIT , { . func_arg = show_bsfs } , \"show available bit stream filters\" } , { \"protocols\" , OPT_EXIT , { . func_arg = show_protocols } , \"show available protocols\" } , { \"filters\" , OPT_EXIT , { . func_arg = show_filters } , \"show available filters\" } , { \"pix_fmts\" , OPT_EXIT , { . func_arg = show_pix_fmts } , \"show available pixel formats\" } , { \"layouts\" , OPT_EXIT , { . func_arg = show_layouts } , \"show standard channel layouts\" } , { \"sample_fmts\" , OPT_EXIT , { . func_arg = show_sample_fmts } , \"show available audio sample formats\" } , { \"dispositions\" , OPT_EXIT , { . func_arg = show_dispositions } , \"show available stream dispositions\" } , { \"colors\" , OPT_EXIT , { . func_arg = show_colors } , \"show available color names\" } , { \"loglevel\" , HAS_ARG , { . func_arg = opt_loglevel } , \"set logging level\" , \"loglevel\" } , { \"v\" , HAS_ARG , { . func_arg = opt_loglevel } , \"set logging level\" , \"loglevel\" } , { \"report\" , 0 , { . func_arg = opt_report } , \"generate a report\" } , { \"max_alloc\" , HAS_ARG , { . func_arg = opt_max_alloc } , \"set maximum size of a single allocated block\" , \"bytes\" } , { \"cpuflags\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_cpuflags } , \"force specific cpu flags\" , \"flags\" } , { \"cpucount\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_cpucount } , \"force specific cpu count\" , \"count\" } , { \"hide_banner\" , OPT_BOOL | OPT_EXPERT , { & hide_banner } , \"do not show program banner\" , \"hide_banner\" } , # if CONFIG_AVDEVICE { \"sources\" , OPT_EXIT | HAS_ARG , { . func_arg = show_sources } , \"list sources of the input device\" , \"device\" } , { \"sinks\" , OPT_EXIT | HAS_ARG , { . func_arg = show_sinks } , \"list sinks of the output device\" , \"device\" } , # endif { \"f\" , HAS_ARG , { . func_arg = opt_format } , \"force format\" , \"format\" } , { \"unit\" , OPT_BOOL , { & show_value_unit } , \"show unit of the displayed values\" } , { \"prefix\" , OPT_BOOL , { & use_value_prefix } , \"use SI prefixes for the displayed values\" } , { \"byte_binary_prefix\" , OPT_BOOL , { & use_byte_value_binary_prefix } , \"use binary prefixes for byte units\" } , { \"sexagesimal\" , OPT_BOOL , { & use_value_sexagesimal_format } , \"use sexagesimal format HOURS:MM:SS.MICROSECONDS for time units\" } , { \"pretty\" , 0 , { . func_arg = opt_pretty } , \"prettify the format of displayed values, make it more human readable\" } , { \"print_format\" , OPT_STRING | HAS_ARG , { & print_format } , \"set the output printing format (available formats are: default, compact, csv, flat, ini, json, xml)\" , \"format\" } , { \"of\" , OPT_STRING | HAS_ARG , { & print_format } , \"alias for -print_format\" , \"format\" } , { \"select_streams\" , OPT_STRING | HAS_ARG , { & stream_specifier } , \"select the specified streams\" , \"stream_specifier\" } , { \"sections\" , OPT_EXIT , { . func_arg = opt_sections } , \"print sections structure and section information, and exit\" } , { \"show_data\" , OPT_BOOL , { & do_show_data } , \"show packets data\" } , { \"show_data_hash\" , OPT_STRING | HAS_ARG , { & show_data_hash } , \"show packets data hash\" } , { \"show_error\" , 0 , { . func_arg = & opt_show_error } , \"show probing error\" } , { \"show_format\" , 0 , { . func_arg = & opt_show_format } , \"show format/container info\" } , { \"show_frames\" , 0 , { . func_arg = & opt_show_frames } , \"show frames info\" } , { \"show_entries\" , HAS_ARG , { . func_arg = opt_show_entries } , \"show a set of specified entries\" , \"entry_list\" } , # if HAVE_THREADS { \"show_log\" , OPT_INT | HAS_ARG , { & do_show_log } , \"show log\" } , # endif { \"show_packets\" , 0 , { . func_arg = & opt_show_packets } , \"show packets info\" } , { \"show_programs\" , 0 , { . func_arg = & opt_show_programs } , \"show programs info\" } , { \"show_streams\" , 0 , { . func_arg = & opt_show_streams } , \"show streams info\" } , { \"show_chapters\" , 0 , { . func_arg = & opt_show_chapters } , \"show chapters info\" } , { \"count_frames\" , OPT_BOOL , { & do_count_frames } , \"count the number of frames per stream\" } , { \"count_packets\" , OPT_BOOL , { & do_count_packets } , \"count the number of packets per stream\" } , { \"show_program_version\" , 0 , { . func_arg = & opt_show_program_version } , \"show ffprobe version\" } , { \"show_library_versions\" , 0 , { . func_arg = & opt_show_library_versions } , \"show library versions\" } , { \"show_versions\" , 0 , { . func_arg = & opt_show_versions } , \"show program and library versions\" } , { \"show_pixel_formats\" , 0 , { . func_arg = & opt_show_pixel_formats } , \"show pixel format descriptions\" } , { \"show_optional_fields\" , HAS_ARG , { . func_arg = & opt_show_optional_fields } , \"show optional fields\" } , { \"show_private_data\" , OPT_BOOL , { & show_private_data } , \"show private data\" } , { \"private\" , OPT_BOOL , { & show_private_data } , \"same as show_private_data\" } , { \"bitexact\" , OPT_BOOL , { & do_bitexact } , \"force bitexact output\" } , { \"read_intervals\" , HAS_ARG , { . func_arg = opt_read_intervals } , \"set read intervals\" , \"read_intervals\" } , { \"i\" , HAS_ARG , { . func_arg = opt_input_file_i } , \"read specified file\" , \"input_file\" } , { \"o\" , HAS_ARG , { . func_arg = opt_output_file_o } , \"write to specified output\" , \"output_file\" } , { \"print_filename\" , HAS_ARG , { . func_arg = opt_print_filename } , \"override the printed input filename\" , \"print_file\" } , { \"find_stream_info\" , OPT_BOOL | OPT_INPUT | OPT_EXPERT , { & find_stream_info } , \"read and decode the streams to fill missing information with heuristics\" } , { NULL , } , } ; const Writer * w ; WriterContext * wctx ; char * buf ; char * w_name = NULL , * w_args = NULL ; int ret , input_ret , i ; int savedCode = setjmp ( ex_buf__ ) ; if ( savedCode == 0 ) { ffprobe_var_cleanup ( ) ; init_dynload ( ) ; # if HAVE_THREADS ret = pthread_mutex_init ( & log_mutex , NULL ) ; if ( ret != 0 ) { goto end ; } # endif av_log_set_flags ( AV_LOG_SKIP_REPEATED ) ; register_exit ( ffprobe_cleanup ) ; ffprobe_options = options ; parse_loglevel ( argc , argv , options ) ; avformat_network_init ( ) ; # if CONFIG_AVDEVICE avdevice_register_all ( ) ; # endif show_banner ( argc , argv , options ) ; parse_options ( NULL , argc , argv , options , opt_input_file ) ; if ( do_show_log ) av_log_set_callback ( log_callback ) ; /* mark things to show, based on -show_entries */ SET_DO_SHOW ( CHAPTERS , chapters ) ; SET_DO_SHOW ( ERROR , error ) ; SET_DO_SHOW ( FORMAT , format ) ; SET_DO_SHOW ( FRAMES , frames ) ; SET_DO_SHOW ( LIBRARY_VERSIONS , library_versions ) ; SET_DO_SHOW ( PACKETS , packets ) ; SET_DO_SHOW ( PIXEL_FORMATS , pixel_formats ) ; SET_DO_SHOW ( PIXEL_FORMAT_FLAGS , pixel_format_flags ) ; SET_DO_SHOW ( PIXEL_FORMAT_COMPONENTS , pixel_format_components ) ; SET_DO_SHOW ( PROGRAM_VERSION , program_version ) ; SET_DO_SHOW ( PROGRAMS , programs ) ; SET_DO_SHOW ( STREAMS , streams ) ; SET_DO_SHOW ( STREAM_DISPOSITION , stream_disposition ) ; SET_DO_SHOW ( PROGRAM_STREAM_DISPOSITION , stream_disposition ) ; SET_DO_SHOW ( CHAPTER_TAGS , chapter_tags ) ; SET_DO_SHOW ( FORMAT_TAGS , format_tags ) ; SET_DO_SHOW ( FRAME_TAGS , frame_tags ) ; SET_DO_SHOW ( PROGRAM_TAGS , program_tags ) ; SET_DO_SHOW ( STREAM_TAGS , stream_tags ) ; SET_DO_SHOW ( PROGRAM_STREAM_TAGS , stream_tags ) ; SET_DO_SHOW ( PACKET_TAGS , packet_tags ) ; if ( do_bitexact && ( do_show_program_version || do_show_library_versions ) ) { av_log ( NULL , AV_LOG_ERROR , \"-bitexact and -show_program_version or -show_library_versions \" \"options are incompatible\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto end ; } writer_register_all ( ) ; if ( ! print_format ) print_format = av_strdup ( \"default\" ) ; if ( ! print_format ) { ret = AVERROR ( ENOMEM ) ; goto end ; } w_name = av_strtok ( print_format , \"=\" , & buf ) ; if ( ! w_name ) { av_log ( NULL , AV_LOG_ERROR , \"No name specified for the output format\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto end ; } w_args = buf ; if ( show_data_hash ) { if ( ( ret = av_hash_alloc ( & hash , show_data_hash ) ) < 0 ) { if ( ret == AVERROR ( EINVAL ) ) { const char * n ; av_log ( NULL , AV_LOG_ERROR , \"Unknown hash algorithm '%s'\\nKnown algorithms:\" , show_data_hash ) ; for ( i = 0 ; ( n = av_hash_names ( i ) ) ; i ++ ) av_log ( NULL , AV_LOG_ERROR , \" %s\" , n ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } goto end ; } } w = writer_get_by_name ( w_name ) ; if ( ! w ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown output format with name '%s'\\n\" , w_name ) ; ret = AVERROR ( EINVAL ) ; goto end ; } if ( ( ret = writer_open ( & wctx , w , w_args , sections , FF_ARRAY_ELEMS ( sections ) , output_filename ) ) >= 0 ) { if ( w == & xml_writer ) wctx -> string_validation_utf8_flags |= AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES ; writer_print_section_header ( wctx , SECTION_ID_ROOT ) ; if ( do_show_program_version ) ffprobe_show_program_version ( wctx ) ; if ( do_show_library_versions ) ffprobe_show_library_versions ( wctx ) ; if ( do_show_pixel_formats ) ffprobe_show_pixel_formats ( wctx ) ; if ( ! input_filename && ( ( do_show_format || do_show_programs || do_show_streams || do_show_chapters || do_show_packets || do_show_error ) || ( ! do_show_program_version && ! do_show_library_versions && ! do_show_pixel_formats ) ) ) { show_usage ( ) ; av_log ( NULL , AV_LOG_ERROR , \"You have to specify one input file.\\n\" ) ; av_log ( NULL , AV_LOG_ERROR , \"Use -h to get full help or, even better, run 'man %s'.\\n\" , program_name ) ; ret = AVERROR ( EINVAL ) ; } else if ( input_filename ) { ret = probe_file ( wctx , input_filename , print_input_filename ) ; if ( ret < 0 && do_show_error ) show_error ( wctx , ret ) ; } input_ret = ret ; writer_print_section_footer ( wctx ) ; ret = writer_close ( & wctx ) ; if ( ret < 0 ) av_log ( NULL , AV_LOG_ERROR , \"Writing output failed: %s\\n\" , av_err2str ( ret ) ) ; ret = FFMIN ( ret , input_ret ) ; } main_ffprobe_return_code = ret < 0 ; } else { main_ffprobe_return_code = longjmp_value ; } end : av_freep ( & print_format ) ; av_freep ( & read_intervals ) ; av_hash_freep ( & hash ) ; uninit_opts ( ) ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( sections ) ; i ++ ) av_dict_free ( & ( sections [ i ] . entries_to_show ) ) ; avformat_network_deinit ( ) ; return main_ffprobe_return_code ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@uninit_options": "void uninit_options ( OptionsContext * o ) { const OptionDef * po = ffmpeg_options ; int i ; /* all OPT_SPEC and OPT_STRING can be freed in generic way */ while ( po -> name ) { void * dst = ( uint8_t * ) o + po -> u . off ; if ( po -> flags & OPT_SPEC ) { SpecifierOpt * * so = dst ; int i , * count = ( int * ) ( so + 1 ) ; for ( i = 0 ; i < * count ; i ++ ) { av_freep ( & ( * so ) [ i ] . specifier ) ; if ( po -> flags & OPT_STRING ) av_freep ( & ( * so ) [ i ] . u . str ) ; } av_freep ( so ) ; * count = 0 ; } else if ( po -> flags & OPT_OFFSET && po -> flags & OPT_STRING ) av_freep ( dst ) ; po ++ ; } for ( i = 0 ; i < o -> nb_stream_maps ; i ++ ) av_freep ( & o -> stream_maps [ i ] . linklabel ) ; av_freep ( & o -> stream_maps ) ; # if FFMPEG_OPT_MAP_CHANNEL av_freep ( & o -> audio_channel_maps ) ; # endif av_freep ( & o -> streamid_map ) ; av_freep ( & o -> attachments ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@init_options": "void init_options ( OptionsContext * o ) { memset ( o , 0 , sizeof ( * o ) ) ; o -> stop_time = INT64_MAX ; o -> mux_max_delay = 0.7 ; o -> start_time = AV_NOPTS_VALUE ; o -> start_time_eof = AV_NOPTS_VALUE ; o -> recording_time = INT64_MAX ; o -> limit_filesize = INT64_MAX ; o -> chapters_input_file = INT_MAX ; o -> accurate_seek = 1 ; o -> thread_queue_size = - 1 ; o -> input_sync_ref = - 1 ; o -> find_stream_info = 1 ; o -> shortest_buf_duration = 10.f ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@show_hwaccels": "int show_hwaccels ( void * optctx , const char * opt , const char * arg ) { enum AVHWDeviceType type = AV_HWDEVICE_TYPE_NONE ; av_log ( NULL , AV_LOG_STDERR , \"Hardware acceleration methods:\\n\" ) ; while ( ( type = av_hwdevice_iterate_types ( type ) ) != AV_HWDEVICE_TYPE_NONE ) av_log ( NULL , AV_LOG_STDERR , \"%s\\n\" , av_hwdevice_get_type_name ( type ) ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@strip_specifiers": "AVDictionary * strip_specifiers ( const AVDictionary * dict ) { const AVDictionaryEntry * e = NULL ; AVDictionary * ret = NULL ; while ( ( e = av_dict_iterate ( dict , e ) ) ) { char * p = strchr ( e -> key , ':' ) ; if ( p ) * p = 0 ; av_dict_set ( & ret , e -> key , e -> value , 0 ) ; if ( p ) * p = ':' ; } return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@parse_and_set_vsync": "int parse_and_set_vsync ( const char * arg , int * vsync_var , int file_idx , int st_idx , int is_global ) { if ( ! av_strcasecmp ( arg , \"cfr\" ) ) * vsync_var = VSYNC_CFR ; else if ( ! av_strcasecmp ( arg , \"vfr\" ) ) * vsync_var = VSYNC_VFR ; else if ( ! av_strcasecmp ( arg , \"passthrough\" ) ) * vsync_var = VSYNC_PASSTHROUGH ; else if ( ! av_strcasecmp ( arg , \"drop\" ) ) * vsync_var = VSYNC_DROP ; else if ( ! is_global && ! av_strcasecmp ( arg , \"auto\" ) ) * vsync_var = VSYNC_AUTO ; else if ( ! is_global ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid value %s specified for fps_mode of #%d:%d.\\n\" , arg , file_idx , st_idx ) ; exit_program ( 1 ) ; } if ( is_global && * vsync_var == VSYNC_AUTO ) { video_sync_method = parse_number_or_die ( \"vsync\" , arg , OPT_INT , VSYNC_AUTO , VSYNC_VFR ) ; av_log ( NULL , AV_LOG_WARNING , \"Passing a number to -vsync is deprecated,\" \" use a string argument as described in the manual.\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@correct_input_start_times": "void correct_input_start_times ( void ) { for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * ifile = input_files [ i ] ; AVFormatContext * is = ifile -> ctx ; int64_t new_start_time = INT64_MAX , diff , abs_start_seek ; ifile -> start_time_effective = is -> start_time ; if ( is -> start_time == AV_NOPTS_VALUE || ! ( is -> iformat -> flags & AVFMT_TS_DISCONT ) ) continue ; for ( int j = 0 ; j < is -> nb_streams ; j ++ ) { AVStream * st = is -> streams [ j ] ; if ( st -> discard == AVDISCARD_ALL || st -> start_time == AV_NOPTS_VALUE ) continue ; new_start_time = FFMIN ( new_start_time , av_rescale_q ( st -> start_time , st -> time_base , AV_TIME_BASE_Q ) ) ; } diff = new_start_time - is -> start_time ; if ( diff ) { av_log ( NULL , AV_LOG_VERBOSE , \"Correcting start time of Input #%d by %\" PRId64 \" us.\\n\" , i , diff ) ; ifile -> start_time_effective = new_start_time ; if ( copy_ts && start_at_zero ) ifile -> ts_offset = - new_start_time ; else if ( ! copy_ts ) { abs_start_seek = is -> start_time + ( ( ifile -> start_time != AV_NOPTS_VALUE ) ? ifile -> start_time : 0 ) ; ifile -> ts_offset = abs_start_seek > new_start_time ? - abs_start_seek : - new_start_time ; } else if ( copy_ts ) ifile -> ts_offset = 0 ; ifile -> ts_offset += ifile -> input_ts_offset ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@apply_sync_offsets": "int apply_sync_offsets ( void ) { for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * ref , * self = input_files [ i ] ; int64_t adjustment ; int64_t self_start_time , ref_start_time , self_seek_start , ref_seek_start ; int start_times_set = 1 ; if ( self -> input_sync_ref == - 1 || self -> input_sync_ref == i ) continue ; if ( self -> input_sync_ref >= nb_input_files || self -> input_sync_ref < - 1 ) { av_log ( NULL , AV_LOG_FATAL , \"-isync for input %d references non-existent input %d.\\n\" , i , self -> input_sync_ref ) ; exit_program ( 1 ) ; } if ( copy_ts && ! start_at_zero ) { av_log ( NULL , AV_LOG_FATAL , \"Use of -isync requires that start_at_zero be set if copyts is set.\\n\" ) ; exit_program ( 1 ) ; } ref = input_files [ self -> input_sync_ref ] ; if ( ref -> input_sync_ref != - 1 && ref -> input_sync_ref != self -> input_sync_ref ) { av_log ( NULL , AV_LOG_ERROR , \"-isync for input %d references a resynced input %d. Sync not set.\\n\" , i , self -> input_sync_ref ) ; continue ; } if ( self -> ctx -> start_time_realtime != AV_NOPTS_VALUE && ref -> ctx -> start_time_realtime != AV_NOPTS_VALUE ) { self_start_time = self -> ctx -> start_time_realtime ; ref_start_time = ref -> ctx -> start_time_realtime ; } else if ( self -> start_time_effective != AV_NOPTS_VALUE && ref -> start_time_effective != AV_NOPTS_VALUE ) { self_start_time = self -> start_time_effective ; ref_start_time = ref -> start_time_effective ; } else { start_times_set = 0 ; } if ( start_times_set ) { self_seek_start = self -> start_time == AV_NOPTS_VALUE ? 0 : self -> start_time ; ref_seek_start = ref -> start_time == AV_NOPTS_VALUE ? 0 : ref -> start_time ; adjustment = ( self_start_time - ref_start_time ) + ! copy_ts * ( self_seek_start - ref_seek_start ) + ref -> input_ts_offset ; self -> ts_offset += adjustment ; av_log ( NULL , AV_LOG_INFO , \"Adjusted ts offset for Input #%d by %\" PRId64 \" us to sync with Input #%d.\\n\" , i , adjustment , self -> input_sync_ref ) ; } else { av_log ( NULL , AV_LOG_INFO , \"Unable to identify start times for Inputs #%d and %d both. No sync adjustment made.\\n\" , i , self -> input_sync_ref ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_filter_threads": "int opt_filter_threads ( void * optctx , const char * opt , const char * arg ) { av_free ( filter_nbthreads ) ; filter_nbthreads = av_strdup ( arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_abort_on": "int opt_abort_on ( void * optctx , const char * opt , const char * arg ) { static const AVOption opts [ ] = { { \"abort_on\" , NULL , 0 , AV_OPT_TYPE_FLAGS , { . i64 = 0 } , INT64_MIN , ( double ) INT64_MAX , . unit = \"flags\" } , { \"empty_output\" , NULL , 0 , AV_OPT_TYPE_CONST , { . i64 = ABORT_ON_FLAG_EMPTY_OUTPUT } , . unit = \"flags\" } , { \"empty_output_stream\" , NULL , 0 , AV_OPT_TYPE_CONST , { . i64 = ABORT_ON_FLAG_EMPTY_OUTPUT_STREAM } , . unit = \"flags\" } , { NULL } , } ; static const AVClass class = { . class_name = \"\" , . item_name = av_default_item_name , . option = opts , . version = LIBAVUTIL_VERSION_INT , } ; const AVClass * pclass = & class ; return av_opt_eval_flags ( & pclass , & opts [ 0 ] , arg , & abort_on_flags ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_stats_period": "int opt_stats_period ( void * optctx , const char * opt , const char * arg ) { int64_t user_stats_period = parse_time_or_die ( opt , arg , 1 ) ; if ( user_stats_period <= 0 ) { av_log ( NULL , AV_LOG_ERROR , \"stats_period %s must be positive.\\n\" , arg ) ; return AVERROR ( EINVAL ) ; } stats_period = user_stats_period ; av_log ( NULL , AV_LOG_INFO , \"ffmpeg stats and -progress period set to %s.\\n\" , arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_audio_codec": "int opt_audio_codec ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"codec:a\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_video_codec": "int opt_video_codec ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"codec:v\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_subtitle_codec": "int opt_subtitle_codec ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"codec:s\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_data_codec": "int opt_data_codec ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"codec:d\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_map": "int opt_map ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; StreamMap * m = NULL ; int i , negative = 0 , file_idx , disabled = 0 ; # if FFMPEG_OPT_MAP_SYNC char * sync ; # endif char * map , * p ; char * allow_unused ; if ( * arg == '-' ) { negative = 1 ; arg ++ ; } map = av_strdup ( arg ) ; if ( ! map ) return AVERROR ( ENOMEM ) ; # if FFMPEG_OPT_MAP_SYNC /* parse sync stream first, just pick first matching stream */ if ( ( sync = strchr ( map , ',' ) ) ) { * sync = 0 ; av_log ( NULL , AV_LOG_WARNING , \"Specifying a sync stream is deprecated and has no effect\\n\" ) ; } # endif if ( map [ 0 ] == '[' ) { /* this mapping refers to lavfi output */ const char * c = map + 1 ; GROW_ARRAY ( o -> stream_maps , o -> nb_stream_maps ) ; m = & o -> stream_maps [ o -> nb_stream_maps - 1 ] ; m -> linklabel = av_get_token ( & c , \"]\" ) ; if ( ! m -> linklabel ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid output link label: %s.\\n\" , map ) ; exit_program ( 1 ) ; } } else { if ( ( allow_unused = strchr ( map , '?' ) ) ) * allow_unused = 0 ; file_idx = strtol ( map , & p , 0 ) ; if ( file_idx >= nb_input_files || file_idx < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid input file index: %d.\\n\" , file_idx ) ; exit_program ( 1 ) ; } if ( negative ) /* disable some already defined maps */ for ( i = 0 ; i < o -> nb_stream_maps ; i ++ ) { m = & o -> stream_maps [ i ] ; if ( file_idx == m -> file_index && check_stream_specifier ( input_files [ m -> file_index ] -> ctx , input_files [ m -> file_index ] -> ctx -> streams [ m -> stream_index ] , * p == ':' ? p + 1 : p ) > 0 ) m -> disabled = 1 ; } else for ( i = 0 ; i < input_files [ file_idx ] -> nb_streams ; i ++ ) { if ( check_stream_specifier ( input_files [ file_idx ] -> ctx , input_files [ file_idx ] -> ctx -> streams [ i ] , * p == ':' ? p + 1 : p ) <= 0 ) continue ; if ( input_files [ file_idx ] -> streams [ i ] -> user_set_discard == AVDISCARD_ALL ) { disabled = 1 ; continue ; } GROW_ARRAY ( o -> stream_maps , o -> nb_stream_maps ) ; m = & o -> stream_maps [ o -> nb_stream_maps - 1 ] ; m -> file_index = file_idx ; m -> stream_index = i ; } } if ( ! m ) { if ( allow_unused ) { av_log ( NULL , AV_LOG_VERBOSE , \"Stream map '%s' matches no streams; ignoring.\\n\" , arg ) ; } else if ( disabled ) { av_log ( NULL , AV_LOG_FATAL , \"Stream map '%s' matches disabled streams.\\n\" \"To ignore this, add a trailing '?' to the map.\\n\" , arg ) ; exit_program ( 1 ) ; } else { av_log ( NULL , AV_LOG_FATAL , \"Stream map '%s' matches no streams.\\n\" \"To ignore this, add a trailing '?' to the map.\\n\" , arg ) ; exit_program ( 1 ) ; } } av_freep ( & map ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_attach": "int opt_attach ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; GROW_ARRAY ( o -> attachments , o -> nb_attachments ) ; o -> attachments [ o -> nb_attachments - 1 ] = arg ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_map_channel": "int opt_map_channel ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; int n ; AVStream * st ; AudioChannelMap * m ; char * allow_unused ; char * mapchan ; av_log ( NULL , AV_LOG_WARNING , \"The -%s option is deprecated and will be removed. \" \"It can be replaced by the 'pan' filter, or in some cases by \" \"combinations of 'channelsplit', 'channelmap', 'amerge' filters.\\n\" , opt ) ; mapchan = av_strdup ( arg ) ; if ( ! mapchan ) return AVERROR ( ENOMEM ) ; GROW_ARRAY ( o -> audio_channel_maps , o -> nb_audio_channel_maps ) ; m = & o -> audio_channel_maps [ o -> nb_audio_channel_maps - 1 ] ; /* muted channel syntax */ n = sscanf ( arg , \"%d:%d.%d\" , & m -> channel_idx , & m -> ofile_idx , & m -> ostream_idx ) ; if ( ( n == 1 || n == 3 ) && m -> channel_idx == - 1 ) { m -> file_idx = m -> stream_idx = - 1 ; if ( n == 1 ) m -> ofile_idx = m -> ostream_idx = - 1 ; av_free ( mapchan ) ; return 0 ; } /* normal syntax */ n = sscanf ( arg , \"%d.%d.%d:%d.%d\" , & m -> file_idx , & m -> stream_idx , & m -> channel_idx , & m -> ofile_idx , & m -> ostream_idx ) ; if ( n != 3 && n != 5 ) { av_log ( NULL , AV_LOG_FATAL , \"Syntax error, mapchan usage: \" \"[file.stream.channel|-1][:syncfile:syncstream]\\n\" ) ; exit_program ( 1 ) ; } if ( n != 5 ) // only file.stream.channel specified m -> ofile_idx = m -> ostream_idx = - 1 ; /* check input */ if ( m -> file_idx < 0 || m -> file_idx >= nb_input_files ) { av_log ( NULL , AV_LOG_FATAL , \"mapchan: invalid input file index: %d\\n\" , m -> file_idx ) ; exit_program ( 1 ) ; } if ( m -> stream_idx < 0 || m -> stream_idx >= input_files [ m -> file_idx ] -> nb_streams ) { av_log ( NULL , AV_LOG_FATAL , \"mapchan: invalid input file stream index #%d.%d\\n\" , m -> file_idx , m -> stream_idx ) ; exit_program ( 1 ) ; } st = input_files [ m -> file_idx ] -> ctx -> streams [ m -> stream_idx ] ; if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_FATAL , \"mapchan: stream #%d.%d is not an audio stream.\\n\" , m -> file_idx , m -> stream_idx ) ; exit_program ( 1 ) ; } /* allow trailing ? to map_channel */ if ( ( allow_unused = strchr ( mapchan , '?' ) ) ) * allow_unused = 0 ; if ( m -> channel_idx < 0 || m -> channel_idx >= st -> codecpar -> ch_layout . nb_channels || input_files [ m -> file_idx ] -> streams [ m -> stream_idx ] -> user_set_discard == AVDISCARD_ALL ) { if ( allow_unused ) { av_log ( NULL , AV_LOG_VERBOSE , \"mapchan: invalid audio channel #%d.%d.%d\\n\" , m -> file_idx , m -> stream_idx , m -> channel_idx ) ; } else { av_log ( NULL , AV_LOG_FATAL , \"mapchan: invalid audio channel #%d.%d.%d\\n\" \"To ignore this, add a trailing '?' to the map_channel.\\n\" , m -> file_idx , m -> stream_idx , m -> channel_idx ) ; exit_program ( 1 ) ; } } av_free ( mapchan ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_sdp_file": "int opt_sdp_file ( void * optctx , const char * opt , const char * arg ) { av_free ( sdp_filename ) ; sdp_filename = av_strdup ( arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_init_hw_device": "int opt_init_hw_device ( void * optctx , const char * opt , const char * arg ) { if ( ! strcmp ( arg , \"list\" ) ) { enum AVHWDeviceType type = AV_HWDEVICE_TYPE_NONE ; av_log ( NULL , AV_LOG_STDERR , \"Supported hardware device types:\\n\" ) ; while ( ( type = av_hwdevice_iterate_types ( type ) ) != AV_HWDEVICE_TYPE_NONE ) av_log ( NULL , AV_LOG_STDERR , \"%s\\n\" , av_hwdevice_get_type_name ( type ) ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; exit_program ( 0 ) ; } else { return hw_device_init_from_string ( arg , NULL ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_filter_hw_device": "int opt_filter_hw_device ( void * optctx , const char * opt , const char * arg ) { if ( filter_hw_device ) { av_log ( NULL , AV_LOG_ERROR , \"Only one filter device can be used.\\n\" ) ; return AVERROR ( EINVAL ) ; } filter_hw_device = hw_device_get_by_name ( arg ) ; if ( ! filter_hw_device ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid filter device %s.\\n\" , arg ) ; return AVERROR ( EINVAL ) ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_recording_timestamp": "int opt_recording_timestamp ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; char buf [ 128 ] ; int64_t recording_timestamp = parse_time_or_die ( opt , arg , 0 ) / 1E6 ; struct tm time = * gmtime ( ( time_t * ) & recording_timestamp ) ; if ( ! strftime ( buf , sizeof ( buf ) , \"creation_time=%Y-%m-%dT%H:%M:%S%z\" , & time ) ) return - 1 ; parse_option ( o , \"metadata\" , buf , ffmpeg_options ) ; av_log ( NULL , AV_LOG_WARNING , \"%s is deprecated, set the 'creation_time' metadata \" \"tag instead.\\n\" , opt ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@find_codec_or_die": "const AVCodec * find_codec_or_die ( void * logctx , const char * name , enum AVMediaType type , int encoder ) { const AVCodecDescriptor * desc ; const char * codec_string = encoder ? \"encoder\" : \"decoder\" ; const AVCodec * codec ; codec = encoder ? avcodec_find_encoder_by_name ( name ) : avcodec_find_decoder_by_name ( name ) ; if ( ! codec && ( desc = avcodec_descriptor_get_by_name ( name ) ) ) { codec = encoder ? avcodec_find_encoder ( desc -> id ) : avcodec_find_decoder ( desc -> id ) ; if ( codec ) av_log ( logctx , AV_LOG_VERBOSE , \"Matched %s '%s' for codec '%s'.\\n\" , codec_string , codec -> name , desc -> name ) ; } if ( ! codec ) { av_log ( logctx , AV_LOG_FATAL , \"Unknown %s '%s'\\n\" , codec_string , name ) ; exit_program ( 1 ) ; } if ( codec -> type != type && ! recast_media ) { av_log ( logctx , AV_LOG_FATAL , \"Invalid %s type '%s'\\n\" , codec_string , name ) ; exit_program ( 1 ) ; } return codec ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@assert_file_overwrite": "void assert_file_overwrite ( const char * filename ) { const char * proto_name = avio_find_protocol_name ( filename ) ; if ( file_overwrite && no_file_overwrite ) { av_log ( NULL , AV_LOG_FATAL , \"Error, both -y and -n supplied. Exiting.\\n\" ) ; exit_program ( 1 ) ; } if ( ! file_overwrite ) { if ( proto_name && ! strcmp ( proto_name , \"file\" ) && avio_check ( filename , 0 ) == 0 ) { if ( stdin_interaction && ! no_file_overwrite ) { av_log ( NULL , AV_LOG_FATAL , \"File '%s' already exists. Overwrite? [y/N] \" , filename ) ; term_exit ( ) ; signal ( SIGINT , SIG_DFL ) ; if ( ! read_yesno ( ) ) { av_log ( NULL , AV_LOG_FATAL , \"Not overwriting - exiting\\n\" ) ; exit_program ( 1 ) ; } term_init ( ) ; } else { av_log ( NULL , AV_LOG_FATAL , \"File '%s' already exists. Exiting.\\n\" , filename ) ; exit_program ( 1 ) ; } } } if ( proto_name && ! strcmp ( proto_name , \"file\" ) ) { for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * file = input_files [ i ] ; if ( file -> ctx -> iformat -> flags & AVFMT_NOFILE ) continue ; if ( ! strcmp ( filename , file -> ctx -> url ) ) { av_log ( NULL , AV_LOG_FATAL , \"Output %s same as Input #%d - exiting\\n\" , filename , i ) ; av_log ( NULL , AV_LOG_WARNING , \"FFmpeg cannot edit existing files in-place.\\n\" ) ; exit_program ( 1 ) ; } } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@file_read": "char * file_read ( const char * filename ) { AVIOContext * pb = NULL ; int ret = avio_open ( & pb , filename , AVIO_FLAG_READ ) ; AVBPrint bprint ; char * str ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error opening file %s.\\n\" , filename ) ; return NULL ; } av_bprint_init ( & bprint , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; ret = avio_read_to_bprint ( pb , & bprint , SIZE_MAX ) ; avio_closep ( & pb ) ; if ( ret < 0 ) { av_bprint_finalize ( & bprint , NULL ) ; return NULL ; } ret = av_bprint_finalize ( & bprint , & str ) ; if ( ret < 0 ) return NULL ; return str ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_streamid": "int opt_streamid ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; int idx ; char * p ; char idx_str [ 16 ] ; av_strlcpy ( idx_str , arg , sizeof ( idx_str ) ) ; p = strchr ( idx_str , ':' ) ; if ( ! p ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid value '%s' for option '%s', required syntax is 'index:value'\\n\" , arg , opt ) ; exit_program ( 1 ) ; } * p ++ = '\\0' ; idx = parse_number_or_die ( opt , idx_str , OPT_INT , 0 , MAX_STREAMS - 1 ) ; o -> streamid_map = grow_array ( o -> streamid_map , sizeof ( * o -> streamid_map ) , & o -> nb_streamid_map , idx + 1 ) ; o -> streamid_map [ idx ] = parse_number_or_die ( opt , p , OPT_INT , 0 , INT_MAX ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@init_complex_filters": "int init_complex_filters ( void ) { int i , ret = 0 ; for ( i = 0 ; i < nb_filtergraphs ; i ++ ) { ret = init_complex_filtergraph ( filtergraphs [ i ] ) ; if ( ret < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_target": "int opt_target ( void * optctx , const char * opt , const char * arg ) { const OptionDef * options = ffmpeg_options ; OptionsContext * o = optctx ; enum { PAL , NTSC , FILM , UNKNOWN } norm = UNKNOWN ; static const char * const frame_rates [ ] = { \"25\" , \"30000/1001\" , \"24000/1001\" } ; if ( ! strncmp ( arg , \"pal-\" , 4 ) ) { norm = PAL ; arg += 4 ; } else if ( ! strncmp ( arg , \"ntsc-\" , 5 ) ) { norm = NTSC ; arg += 5 ; } else if ( ! strncmp ( arg , \"film-\" , 5 ) ) { norm = FILM ; arg += 5 ; } else { /* Try to determine PAL/NTSC by peeking in the input files */ if ( nb_input_files ) { int i , j ; for ( j = 0 ; j < nb_input_files ; j ++ ) { for ( i = 0 ; i < input_files [ j ] -> nb_streams ; i ++ ) { AVStream * st = input_files [ j ] -> ctx -> streams [ i ] ; int64_t fr ; if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_VIDEO ) continue ; fr = st -> time_base . den * 1000LL / st -> time_base . num ; if ( fr == 25000 ) { norm = PAL ; break ; } else if ( ( fr == 29970 ) || ( fr == 23976 ) ) { norm = NTSC ; break ; } } if ( norm != UNKNOWN ) break ; } } if ( norm != UNKNOWN ) av_log ( NULL , AV_LOG_INFO , \"Assuming %s for target.\\n\" , norm == PAL ? \"PAL\" : \"NTSC\" ) ; } if ( norm == UNKNOWN ) { av_log ( NULL , AV_LOG_FATAL , \"Could not determine norm (PAL/NTSC/NTSC-Film) for target.\\n\" ) ; av_log ( NULL , AV_LOG_FATAL , \"Please prefix target with \\\"pal-\\\", \\\"ntsc-\\\" or \\\"film-\\\",\\n\" ) ; av_log ( NULL , AV_LOG_FATAL , \"or set a framerate with \\\"-r xxx\\\".\\n\" ) ; exit_program ( 1 ) ; } if ( ! strcmp ( arg , \"vcd\" ) ) { opt_video_codec ( o , \"c:v\" , \"mpeg1video\" ) ; opt_audio_codec ( o , \"c:a\" , \"mp2\" ) ; parse_option ( o , \"f\" , \"vcd\" , options ) ; parse_option ( o , \"s\" , norm == PAL ? \"352x288\" : \"352x240\" , options ) ; parse_option ( o , \"r\" , frame_rates [ norm ] , options ) ; opt_default ( NULL , \"g\" , norm == PAL ? \"15\" : \"18\" ) ; opt_default ( NULL , \"b:v\" , \"1150000\" ) ; opt_default ( NULL , \"maxrate:v\" , \"1150000\" ) ; opt_default ( NULL , \"minrate:v\" , \"1150000\" ) ; opt_default ( NULL , \"bufsize:v\" , \"327680\" ) ; // 40*1024*8; opt_default ( NULL , \"b:a\" , \"224000\" ) ; parse_option ( o , \"ar\" , \"44100\" , options ) ; parse_option ( o , \"ac\" , \"2\" , options ) ; opt_default ( NULL , \"packetsize\" , \"2324\" ) ; opt_default ( NULL , \"muxrate\" , \"1411200\" ) ; // 2352 * 75 * 8; /* We have to offset the PTS, so that it is consistent with the SCR.\n           SCR starts at 36000, but the first two packs contain only padding\n           and the first pack from the other stream, respectively, may also have\n           been written before.\n           So the real data starts at SCR 36000+3*1200. */ o -> mux_preload = ( 36000 + 3 * 1200 ) / 90000.0 ; // 0.44 } else if ( ! strcmp ( arg , \"svcd\" ) ) { opt_video_codec ( o , \"c:v\" , \"mpeg2video\" ) ; opt_audio_codec ( o , \"c:a\" , \"mp2\" ) ; parse_option ( o , \"f\" , \"svcd\" , options ) ; parse_option ( o , \"s\" , norm == PAL ? \"480x576\" : \"480x480\" , options ) ; parse_option ( o , \"r\" , frame_rates [ norm ] , options ) ; parse_option ( o , \"pix_fmt\" , \"yuv420p\" , options ) ; opt_default ( NULL , \"g\" , norm == PAL ? \"15\" : \"18\" ) ; opt_default ( NULL , \"b:v\" , \"2040000\" ) ; opt_default ( NULL , \"maxrate:v\" , \"2516000\" ) ; opt_default ( NULL , \"minrate:v\" , \"0\" ) ; // 1145000; opt_default ( NULL , \"bufsize:v\" , \"1835008\" ) ; // 224*1024*8; opt_default ( NULL , \"scan_offset\" , \"1\" ) ; opt_default ( NULL , \"b:a\" , \"224000\" ) ; parse_option ( o , \"ar\" , \"44100\" , options ) ; opt_default ( NULL , \"packetsize\" , \"2324\" ) ; } else if ( ! strcmp ( arg , \"dvd\" ) ) { opt_video_codec ( o , \"c:v\" , \"mpeg2video\" ) ; opt_audio_codec ( o , \"c:a\" , \"ac3\" ) ; parse_option ( o , \"f\" , \"dvd\" , options ) ; parse_option ( o , \"s\" , norm == PAL ? \"720x576\" : \"720x480\" , options ) ; parse_option ( o , \"r\" , frame_rates [ norm ] , options ) ; parse_option ( o , \"pix_fmt\" , \"yuv420p\" , options ) ; opt_default ( NULL , \"g\" , norm == PAL ? \"15\" : \"18\" ) ; opt_default ( NULL , \"b:v\" , \"6000000\" ) ; opt_default ( NULL , \"maxrate:v\" , \"9000000\" ) ; opt_default ( NULL , \"minrate:v\" , \"0\" ) ; // 1500000; opt_default ( NULL , \"bufsize:v\" , \"1835008\" ) ; // 224*1024*8; opt_default ( NULL , \"packetsize\" , \"2048\" ) ; // from www.mpucoder.com: DVD sectors contain 2048 bytes of data, this is also the size of one pack. opt_default ( NULL , \"muxrate\" , \"10080000\" ) ; // from mplex project: data_rate = 1260000. mux_rate = data_rate * 8 opt_default ( NULL , \"b:a\" , \"448000\" ) ; parse_option ( o , \"ar\" , \"48000\" , options ) ; } else if ( ! strncmp ( arg , \"dv\" , 2 ) ) { parse_option ( o , \"f\" , \"dv\" , options ) ; parse_option ( o , \"s\" , norm == PAL ? \"720x576\" : \"720x480\" , options ) ; parse_option ( o , \"pix_fmt\" , ! strncmp ( arg , \"dv50\" , 4 ) ? \"yuv422p\" : norm == PAL ? \"yuv420p\" : \"yuv411p\" , options ) ; parse_option ( o , \"r\" , frame_rates [ norm ] , options ) ; parse_option ( o , \"ar\" , \"48000\" , options ) ; parse_option ( o , \"ac\" , \"2\" , options ) ; } else { av_log ( NULL , AV_LOG_ERROR , \"Unknown target: %s\\n\" , arg ) ; return AVERROR ( EINVAL ) ; } av_dict_copy ( & o -> g -> codec_opts , codec_opts , AV_DICT_DONT_OVERWRITE ) ; av_dict_copy ( & o -> g -> format_opts , format_opts , AV_DICT_DONT_OVERWRITE ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_vstats_file": "int opt_vstats_file ( void * optctx , const char * opt , const char * arg ) { av_free ( vstats_filename ) ; vstats_filename = av_strdup ( arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_vstats": "int opt_vstats ( void * optctx , const char * opt , const char * arg ) { char filename [ 40 ] ; time_t today2 = time ( NULL ) ; struct tm * today = localtime ( & today2 ) ; if ( ! today ) { // maybe tomorrow av_log ( NULL , AV_LOG_FATAL , \"Unable to get current time: %s\\n\" , strerror ( errno ) ) ; exit_program ( 1 ) ; } snprintf ( filename , sizeof ( filename ) , \"vstats_%02d%02d%02d.log\" , today -> tm_hour , today -> tm_min , today -> tm_sec ) ; return opt_vstats_file ( NULL , opt , filename ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_video_frames": "int opt_video_frames ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"frames:v\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_audio_frames": "int opt_audio_frames ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"frames:a\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_data_frames": "int opt_data_frames ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"frames:d\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_default_new": "int opt_default_new ( OptionsContext * o , const char * opt , const char * arg ) { int ret ; AVDictionary * cbak = codec_opts ; AVDictionary * fbak = format_opts ; codec_opts = NULL ; format_opts = NULL ; ret = opt_default ( NULL , opt , arg ) ; av_dict_copy ( & o -> g -> codec_opts , codec_opts , 0 ) ; av_dict_copy ( & o -> g -> format_opts , format_opts , 0 ) ; av_dict_free ( & codec_opts ) ; av_dict_free ( & format_opts ) ; codec_opts = cbak ; format_opts = fbak ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_preset": "int opt_preset ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; FILE * f = NULL ; char filename [ 1000 ] , line [ 1000 ] , tmp_line [ 1000 ] ; const char * codec_name = NULL ; tmp_line [ 0 ] = * opt ; tmp_line [ 1 ] = 0 ; MATCH_PER_TYPE_OPT ( codec_names , str , codec_name , NULL , tmp_line ) ; if ( ! ( f = get_preset_file ( filename , sizeof ( filename ) , arg , * opt == 'f' , codec_name ) ) ) { if ( ! strncmp ( arg , \"libx264-lossless\" , strlen ( \"libx264-lossless\" ) ) ) { av_log ( NULL , AV_LOG_FATAL , \"Please use -preset <speed> -qp 0\\n\" ) ; } else av_log ( NULL , AV_LOG_FATAL , \"File for preset '%s' not found\\n\" , arg ) ; exit_program ( 1 ) ; } while ( fgets ( line , sizeof ( line ) , f ) ) { char * key = tmp_line , * value , * endptr ; if ( strcspn ( line , \"#\\n\\r\" ) == 0 ) continue ; av_strlcpy ( tmp_line , line , sizeof ( tmp_line ) ) ; if ( ! av_strtok ( key , \"=\" , & value ) || ! av_strtok ( value , \"\\r\\n\" , & endptr ) ) { av_log ( NULL , AV_LOG_FATAL , \"%s: Invalid syntax: '%s'\\n\" , filename , line ) ; exit_program ( 1 ) ; } av_log ( NULL , AV_LOG_DEBUG , \"ffpreset[%s]: set '%s' = '%s'\\n\" , filename , key , value ) ; if ( ! strcmp ( key , \"acodec\" ) ) opt_audio_codec ( o , key , value ) ; else if ( ! strcmp ( key , \"vcodec\" ) ) opt_video_codec ( o , key , value ) ; else if ( ! strcmp ( key , \"scodec\" ) ) opt_subtitle_codec ( o , key , value ) ; else if ( ! strcmp ( key , \"dcodec\" ) ) opt_data_codec ( o , key , value ) ; else if ( opt_default_new ( o , key , value ) < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"%s: Invalid option or argument: '%s', parsed as '%s' = '%s'\\n\" , filename , line , key , value ) ; exit_program ( 1 ) ; } } fclose ( f ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_old2new": "int opt_old2new ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; int ret ; char * s = av_asprintf ( \"%s:%c\" , opt + 1 , * opt ) ; if ( ! s ) return AVERROR ( ENOMEM ) ; ret = parse_option ( o , s , arg , ffmpeg_options ) ; av_free ( s ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_bitrate": "int opt_bitrate ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; if ( ! strcmp ( opt , \"ab\" ) ) { av_dict_set ( & o -> g -> codec_opts , \"b:a\" , arg , 0 ) ; return 0 ; } else if ( ! strcmp ( opt , \"b\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"Please use -b:a or -b:v, -b is ambiguous\\n\" ) ; av_dict_set ( & o -> g -> codec_opts , \"b:v\" , arg , 0 ) ; return 0 ; } av_dict_set ( & o -> g -> codec_opts , opt , arg , 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_qscale": "int opt_qscale ( void * optctx , const char * opt , const char * arg ) { OptionDef * options = ffmpeg_options ; OptionsContext * o = optctx ; char * s ; int ret ; if ( ! strcmp ( opt , \"qscale\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"Please use -q:a or -q:v, -qscale is ambiguous\\n\" ) ; return parse_option ( o , \"q:v\" , arg , options ) ; } s = av_asprintf ( \"q%s\" , opt + 6 ) ; if ( ! s ) return AVERROR ( ENOMEM ) ; ret = parse_option ( o , s , arg , options ) ; av_free ( s ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_profile": "int opt_profile ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; if ( ! strcmp ( opt , \"profile\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"Please use -profile:a or -profile:v, -profile is ambiguous\\n\" ) ; av_dict_set ( & o -> g -> codec_opts , \"profile:v\" , arg , 0 ) ; return 0 ; } av_dict_set ( & o -> g -> codec_opts , opt , arg , 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_video_filters": "int opt_video_filters ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"filter:v\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_audio_filters": "int opt_audio_filters ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"filter:a\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_vsync": "int opt_vsync ( void * optctx , const char * opt , const char * arg ) { av_log ( NULL , AV_LOG_WARNING , \"-vsync is deprecated. Use -fps_mode\\n\" ) ; parse_and_set_vsync ( arg , & video_sync_method , - 1 , - 1 , 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_timecode": "int opt_timecode ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; int ret ; char * tcr = av_asprintf ( \"timecode=%s\" , arg ) ; if ( ! tcr ) return AVERROR ( ENOMEM ) ; ret = parse_option ( o , \"metadata:g\" , tcr , ffmpeg_options ) ; if ( ret >= 0 ) ret = av_dict_set ( & o -> g -> codec_opts , \"gop_timecode\" , arg , 0 ) ; av_free ( tcr ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_audio_qscale": "int opt_audio_qscale ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"q:a\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_filter_complex": "int opt_filter_complex ( void * optctx , const char * opt , const char * arg ) { FilterGraph * fg = ALLOC_ARRAY_ELEM ( filtergraphs , nb_filtergraphs ) ; fg -> index = nb_filtergraphs - 1 ; fg -> graph_desc = av_strdup ( arg ) ; if ( ! fg -> graph_desc ) return AVERROR ( ENOMEM ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_filter_complex_script": "int opt_filter_complex_script ( void * optctx , const char * opt , const char * arg ) { FilterGraph * fg ; char * graph_desc = file_read ( arg ) ; if ( ! graph_desc ) return AVERROR ( EINVAL ) ; fg = ALLOC_ARRAY_ELEM ( filtergraphs , nb_filtergraphs ) ; fg -> index = nb_filtergraphs - 1 ; fg -> graph_desc = graph_desc ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@show_help_default_ffmpeg": "void show_help_default_ffmpeg ( const char * opt , const char * arg ) { OptionDef * options = ffmpeg_options ; /* per-file options have at least one of those set */ const int per_file = OPT_SPEC | OPT_OFFSET | OPT_PERFILE ; int show_advanced = 0 , show_avoptions = 0 ; if ( opt && * opt ) { if ( ! strcmp ( opt , \"long\" ) ) show_advanced = 1 ; else if ( ! strcmp ( opt , \"full\" ) ) show_advanced = show_avoptions = 1 ; else av_log ( NULL , AV_LOG_ERROR , \"Unknown help option '%s'.\\n\" , opt ) ; } show_usage ( ) ; av_log ( NULL , AV_LOG_STDERR , \"Getting help:\\n\" \"    -h      -- print basic options\\n\" \"    -h long -- print more options\\n\" \"    -h full -- print all options (including all format and codec specific options, very long)\\n\" \"    -h type=name -- print all options for the named decoder/encoder/demuxer/muxer/filter/bsf/protocol\\n\" \"    See man %s for detailed description of the options.\\n\" \"\\n\" , program_name ) ; show_help_options ( options , \"Print help / information / capabilities:\" , OPT_EXIT , 0 , 0 ) ; show_help_options ( options , \"Global options (affect whole program \" \"instead of just one file):\" , 0 , per_file | OPT_EXIT | OPT_EXPERT , 0 ) ; if ( show_advanced ) show_help_options ( options , \"Advanced global options:\" , OPT_EXPERT , per_file | OPT_EXIT , 0 ) ; show_help_options ( options , \"Per-file main options:\" , 0 , OPT_EXPERT | OPT_AUDIO | OPT_VIDEO | OPT_SUBTITLE | OPT_EXIT , per_file ) ; if ( show_advanced ) show_help_options ( options , \"Advanced per-file options:\" , OPT_EXPERT , OPT_AUDIO | OPT_VIDEO | OPT_SUBTITLE , per_file ) ; show_help_options ( options , \"Video options:\" , OPT_VIDEO , OPT_EXPERT | OPT_AUDIO , 0 ) ; if ( show_advanced ) show_help_options ( options , \"Advanced Video options:\" , OPT_EXPERT | OPT_VIDEO , OPT_AUDIO , 0 ) ; show_help_options ( options , \"Audio options:\" , OPT_AUDIO , OPT_EXPERT | OPT_VIDEO , 0 ) ; if ( show_advanced ) show_help_options ( options , \"Advanced Audio options:\" , OPT_EXPERT | OPT_AUDIO , OPT_VIDEO , 0 ) ; show_help_options ( options , \"Subtitle options:\" , OPT_SUBTITLE , 0 , 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; if ( show_avoptions ) { int flags = AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_ENCODING_PARAM ; show_help_children ( avcodec_get_class ( ) , flags ) ; show_help_children ( avformat_get_class ( ) , flags ) ; # if CONFIG_SWSCALE show_help_children ( sws_get_class ( ) , flags ) ; # endif # if CONFIG_SWRESAMPLE show_help_children ( swr_get_class ( ) , AV_OPT_FLAG_AUDIO_PARAM ) ; # endif show_help_children ( avfilter_get_class ( ) , AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM ) ; show_help_children ( av_bsf_get_class ( ) , AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_BSF_PARAM ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@show_usage": "void show_usage ( void ) { av_log ( NULL , AV_LOG_INFO , \"Hyper fast Audio and Video encoder\\n\" ) ; av_log ( NULL , AV_LOG_INFO , \"usage: %s [options] [[infile options] -i infile]... {[outfile options] outfile}...\\n\" , program_name ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@open_files": "int open_files ( OptionGroupList * l , const char * inout , int ( * open_file ) ( const OptionsContext * , const char * ) ) { int i , ret ; for ( i = 0 ; i < l -> nb_groups ; i ++ ) { OptionGroup * g = & l -> groups [ i ] ; OptionsContext o ; init_options ( & o ) ; o . g = g ; ret = parse_optgroup ( & o , g ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing options for %s file \" \"%s.\\n\" , inout , g -> arg ) ; uninit_options ( & o ) ; return ret ; } av_log ( NULL , AV_LOG_DEBUG , \"Opening an %s file: %s.\\n\" , inout , g -> arg ) ; ret = open_file ( & o , g -> arg ) ; uninit_options ( & o ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error opening %s file %s.\\n\" , inout , g -> arg ) ; return ret ; } av_log ( NULL , AV_LOG_DEBUG , \"Successfully opened the file.\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@ffmpeg_parse_options": "int ffmpeg_parse_options ( int argc , char * * argv ) { OptionParseContext octx ; int ret ; memset ( & octx , 0 , sizeof ( octx ) ) ; /* split the commandline into an internal representation */ ret = split_commandline ( & octx , argc , argv , ffmpeg_options , groups , FF_ARRAY_ELEMS ( groups ) ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error splitting the argument list: \" ) ; goto fail ; } /* apply global options */ ret = parse_optgroup ( NULL , & octx . global_opts ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error parsing global options: \" ) ; goto fail ; } /* configure terminal and setup signal handlers */ term_init ( ) ; /* open input files */ ret = open_files ( & octx . groups [ GROUP_INFILE ] , \"input\" , ifile_open ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error opening input files: \" ) ; goto fail ; } /* create the complex filtergraphs */ ret = init_complex_filters ( ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error initializing complex filters.\\n\" ) ; goto fail ; } /* open output files */ ret = open_files ( & octx . groups [ GROUP_OUTFILE ] , \"output\" , of_open ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error opening output files: \" ) ; goto fail ; } correct_input_start_times ( ) ; apply_sync_offsets ( ) ; check_filter_outputs ( ) ; fail : uninit_parse_context ( & octx ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"%s\\n\" , av_err2str ( ret ) ) ; } return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_progress": "int opt_progress ( void * optctx , const char * opt , const char * arg ) { AVIOContext * avio = NULL ; int ret ; if ( ! strcmp ( arg , \"-\" ) ) arg = \"pipe:\" ; ret = avio_open2 ( & avio , arg , AVIO_FLAG_WRITE , & int_cb , NULL ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Failed to open progress URL \\\"%s\\\": %s\\n\" , arg , av_err2str ( ret ) ) ; return ret ; } progress_avio = avio ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_opt.c@opt_timelimit": "int opt_timelimit ( void * optctx , const char * opt , const char * arg ) { # if HAVE_SETRLIMIT int lim = parse_number_or_die ( opt , arg , OPT_INT64 , 0 , INT_MAX ) ; struct rlimit rl = { lim , lim + 1 } ; if ( setrlimit ( RLIMIT_CPU , & rl ) ) perror ( \"setrlimit\" ) ; # else av_log ( NULL , AV_LOG_WARNING , \"-%s not implemented on this OS\\n\" , opt ) ; # endif return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_license": "int show_license ( void * optctx , const char * opt , const char * arg ) { # if CONFIG_NONFREE av_log ( NULL , AV_LOG_ERROR , \"This version of %s has nonfree parts compiled in.\\n\" \"Therefore it is not legally redistributable.\\n\" , program_name ) ; # elif CONFIG_GPLV3 av_log ( NULL , AV_LOG_ERROR , \"%s is free software; you can redistribute it and/or modify\\n\" \"it under the terms of the GNU General Public License as published by\\n\" \"the Free Software Foundation; either version 3 of the License, or\\n\" \"(at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\" \"GNU General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU General Public License\\n\" \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\" , program_name , program_name , program_name ) ; # elif CONFIG_GPL av_log ( NULL , AV_LOG_ERROR , \"%s is free software; you can redistribute it and/or modify\\n\" \"it under the terms of the GNU General Public License as published by\\n\" \"the Free Software Foundation; either version 2 of the License, or\\n\" \"(at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\" \"GNU General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU General Public License\\n\" \"along with %s; if not, write to the Free Software\\n\" \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\" , program_name , program_name , program_name ) ; # elif CONFIG_LGPLV3 av_log ( NULL , AV_LOG_ERROR , \"%s is free software; you can redistribute it and/or modify\\n\" \"it under the terms of the GNU Lesser General Public License as published by\\n\" \"the Free Software Foundation; either version 3 of the License, or\\n\" \"(at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\" \"GNU Lesser General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU Lesser General Public License\\n\" \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\" , program_name , program_name , program_name ) ; # else av_log ( NULL , AV_LOG_ERROR , \"%s is free software; you can redistribute it and/or\\n\" \"modify it under the terms of the GNU Lesser General Public\\n\" \"License as published by the Free Software Foundation; either\\n\" \"version 2.1 of the License, or (at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\n\" \"Lesser General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU Lesser General Public\\n\" \"License along with %s; if not, write to the Free Software\\n\" \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\" , program_name , program_name , program_name ) ; # endif return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@print_all_libs_info": "static void print_all_libs_info ( int flags , int level ) { PRINT_LIB_INFO ( avutil , AVUTIL , flags , level ) ; PRINT_LIB_INFO ( avcodec , AVCODEC , flags , level ) ; PRINT_LIB_INFO ( avformat , AVFORMAT , flags , level ) ; PRINT_LIB_INFO ( avdevice , AVDEVICE , flags , level ) ; PRINT_LIB_INFO ( avfilter , AVFILTER , flags , level ) ; PRINT_LIB_INFO ( swscale , SWSCALE , flags , level ) ; PRINT_LIB_INFO ( swresample , SWRESAMPLE , flags , level ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@print_program_info": "static void print_program_info ( int flags , int level ) { const char * indent = flags & INDENT ? \"  \" : \"\" ; av_log ( NULL , level , \"%s version \" FFMPEG_VERSION , program_name ) ; if ( flags & SHOW_COPYRIGHT ) av_log ( NULL , level , \" Copyright (c) %d-%d the FFmpeg developers\" , program_birth_year , CONFIG_THIS_YEAR ) ; av_log ( NULL , level , \"\\n\" ) ; av_log ( NULL , level , \"%sbuilt with %s\\n\" , indent , CC_IDENT ) ; av_log ( NULL , level , \"%sconfiguration: \" FFMPEG_CONFIGURATION \"\\n\" , indent ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@print_buildconf": "static void print_buildconf ( int flags , int level ) { const char * indent = flags & INDENT ? \"  \" : \"\" ; char str [ ] = { FFMPEG_CONFIGURATION } ; char * conflist , * remove_tilde , * splitconf ; // Change all the ' --' strings to '~--' so that // they can be identified as tokens. while ( ( conflist = strstr ( str , \" --\" ) ) != NULL ) { conflist [ 0 ] = '~' ; } // Compensate for the weirdness this would cause // when passing 'pkg-config --static'. while ( ( remove_tilde = strstr ( str , \"pkg-config~\" ) ) != NULL ) { remove_tilde [ sizeof ( \"pkg-config~\" ) - 2 ] = ' ' ; } splitconf = strtok ( str , \"~\" ) ; av_log ( NULL , level , \"\\n%sconfiguration:\\n\" , indent ) ; while ( splitconf != NULL ) { av_log ( NULL , level , \"%s%s%s\\n\" , indent , indent , splitconf ) ; splitconf = strtok ( NULL , \"~\" ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_banner": "void show_banner ( int argc , char * * argv , const OptionDef * options ) { int idx = locate_option ( argc , argv , options , \"version\" ) ; if ( hide_banner || idx ) return ; print_program_info ( INDENT | SHOW_COPYRIGHT , AV_LOG_INFO ) ; print_all_libs_info ( INDENT | SHOW_CONFIG , AV_LOG_INFO ) ; print_all_libs_info ( INDENT | SHOW_VERSION , AV_LOG_INFO ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_version": "int show_version ( void * optctx , const char * opt , const char * arg ) { print_program_info ( SHOW_COPYRIGHT , AV_LOG_INFO ) ; print_all_libs_info ( SHOW_VERSION , AV_LOG_INFO ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_buildconf": "int show_buildconf ( void * optctx , const char * opt , const char * arg ) { print_buildconf ( INDENT | 0 , AV_LOG_INFO ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@print_codec": "static void print_codec ( const AVCodec * c ) { int encoder = av_codec_is_encoder ( c ) ; av_log ( NULL , AV_LOG_ERROR , \"%s %s [%s]:\\n\" , encoder ? \"Encoder\" : \"Decoder\" , c -> name , c -> long_name ? c -> long_name : \"\" ) ; av_log ( NULL , AV_LOG_ERROR , \"    General capabilities: \" ) ; if ( c -> capabilities & AV_CODEC_CAP_DRAW_HORIZ_BAND ) av_log ( NULL , AV_LOG_ERROR , \"horizband \" ) ; if ( c -> capabilities & AV_CODEC_CAP_DR1 ) av_log ( NULL , AV_LOG_ERROR , \"dr1 \" ) ; if ( c -> capabilities & AV_CODEC_CAP_DELAY ) av_log ( NULL , AV_LOG_ERROR , \"delay \" ) ; if ( c -> capabilities & AV_CODEC_CAP_SMALL_LAST_FRAME ) av_log ( NULL , AV_LOG_ERROR , \"small \" ) ; if ( c -> capabilities & AV_CODEC_CAP_SUBFRAMES ) av_log ( NULL , AV_LOG_ERROR , \"subframes \" ) ; if ( c -> capabilities & AV_CODEC_CAP_EXPERIMENTAL ) av_log ( NULL , AV_LOG_ERROR , \"exp \" ) ; if ( c -> capabilities & AV_CODEC_CAP_CHANNEL_CONF ) av_log ( NULL , AV_LOG_ERROR , \"chconf \" ) ; if ( c -> capabilities & AV_CODEC_CAP_PARAM_CHANGE ) av_log ( NULL , AV_LOG_ERROR , \"paramchange \" ) ; if ( c -> capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE ) av_log ( NULL , AV_LOG_ERROR , \"variable \" ) ; if ( c -> capabilities & ( AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_OTHER_THREADS ) ) av_log ( NULL , AV_LOG_ERROR , \"threads \" ) ; if ( c -> capabilities & AV_CODEC_CAP_AVOID_PROBING ) av_log ( NULL , AV_LOG_ERROR , \"avoidprobe \" ) ; if ( c -> capabilities & AV_CODEC_CAP_HARDWARE ) av_log ( NULL , AV_LOG_ERROR , \"hardware \" ) ; if ( c -> capabilities & AV_CODEC_CAP_HYBRID ) av_log ( NULL , AV_LOG_ERROR , \"hybrid \" ) ; if ( ! c -> capabilities ) av_log ( NULL , AV_LOG_ERROR , \"none\" ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; if ( c -> type == AVMEDIA_TYPE_VIDEO || c -> type == AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_ERROR , \"    Threading capabilities: \" ) ; switch ( c -> capabilities & ( AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_OTHER_THREADS ) ) { case AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS : av_log ( NULL , AV_LOG_ERROR , \"frame and slice\" ) ; break ; case AV_CODEC_CAP_FRAME_THREADS : av_log ( NULL , AV_LOG_ERROR , \"frame\" ) ; break ; case AV_CODEC_CAP_SLICE_THREADS : av_log ( NULL , AV_LOG_ERROR , \"slice\" ) ; break ; case AV_CODEC_CAP_OTHER_THREADS : av_log ( NULL , AV_LOG_ERROR , \"other\" ) ; break ; default : av_log ( NULL , AV_LOG_ERROR , \"none\" ) ; break ; } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } if ( avcodec_get_hw_config ( c , 0 ) ) { av_log ( NULL , AV_LOG_ERROR , \"    Supported hardware devices: \" ) ; for ( int i = 0 ; ; i ++ ) { const AVCodecHWConfig * config = avcodec_get_hw_config ( c , i ) ; if ( ! config ) break ; av_log ( NULL , AV_LOG_ERROR , \"%s \" , av_hwdevice_get_type_name ( config -> device_type ) ) ; } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } if ( c -> supported_framerates ) { const AVRational * fps = c -> supported_framerates ; av_log ( NULL , AV_LOG_ERROR , \"    Supported framerates:\" ) ; while ( fps -> num ) { av_log ( NULL , AV_LOG_ERROR , \" %d/%d\" , fps -> num , fps -> den ) ; fps ++ ; } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } PRINT_CODEC_SUPPORTED ( c , pix_fmts , enum AVPixelFormat , \"pixel formats\" , AV_PIX_FMT_NONE , GET_PIX_FMT_NAME ) ; PRINT_CODEC_SUPPORTED ( c , supported_samplerates , int , \"sample rates\" , 0 , GET_SAMPLE_RATE_NAME ) ; PRINT_CODEC_SUPPORTED ( c , sample_fmts , enum AVSampleFormat , \"sample formats\" , AV_SAMPLE_FMT_NONE , GET_SAMPLE_FMT_NAME ) ; if ( c -> ch_layouts ) { const AVChannelLayout * p = c -> ch_layouts ; av_log ( NULL , AV_LOG_ERROR , \"    Supported channel layouts:\" ) ; while ( p -> nb_channels ) { char name [ 128 ] ; av_channel_layout_describe ( p , name , sizeof ( name ) ) ; av_log ( NULL , AV_LOG_ERROR , \" %s\" , name ) ; p ++ ; } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } if ( c -> priv_class ) { show_help_children ( c -> priv_class , AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_DECODING_PARAM ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@next_codec_for_id": "static const AVCodec * next_codec_for_id ( enum AVCodecID id , void * * iter , int encoder ) { const AVCodec * c ; while ( ( c = av_codec_iterate ( iter ) ) ) { if ( c -> id == id && ( encoder ? av_codec_is_encoder ( c ) : av_codec_is_decoder ( c ) ) ) return c ; } return NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_help_codec": "static void show_help_codec ( const char * name , int encoder ) { const AVCodecDescriptor * desc ; const AVCodec * codec ; if ( ! name ) { av_log ( NULL , AV_LOG_ERROR , \"No codec name specified.\\n\" ) ; return ; } codec = encoder ? avcodec_find_encoder_by_name ( name ) : avcodec_find_decoder_by_name ( name ) ; if ( codec ) print_codec ( codec ) ; else if ( ( desc = avcodec_descriptor_get_by_name ( name ) ) ) { void * iter = NULL ; int printed = 0 ; while ( ( codec = next_codec_for_id ( desc -> id , & iter , encoder ) ) ) { printed = 1 ; print_codec ( codec ) ; } if ( ! printed ) { av_log ( NULL , AV_LOG_ERROR , \"Codec '%s' is known to FFmpeg, \" \"but no %s for it are available. FFmpeg might need to be \" \"recompiled with additional external libraries.\\n\" , name , encoder ? \"encoders\" : \"decoders\" ) ; } } else { av_log ( NULL , AV_LOG_ERROR , \"Codec '%s' is not recognized by FFmpeg.\\n\" , name ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_help_demuxer": "static void show_help_demuxer ( const char * name ) { const AVInputFormat * fmt = av_find_input_format ( name ) ; if ( ! fmt ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown format '%s'.\\n\" , name ) ; return ; } av_log ( NULL , AV_LOG_ERROR , \"Demuxer %s [%s]:\\n\" , fmt -> name , fmt -> long_name ) ; if ( fmt -> extensions ) av_log ( NULL , AV_LOG_ERROR , \"    Common extensions: %s.\\n\" , fmt -> extensions ) ; if ( fmt -> priv_class ) show_help_children ( fmt -> priv_class , AV_OPT_FLAG_DECODING_PARAM ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_help_protocol": "static void show_help_protocol ( const char * name ) { const AVClass * proto_class ; if ( ! name ) { av_log ( NULL , AV_LOG_ERROR , \"No protocol name specified.\\n\" ) ; return ; } proto_class = avio_protocol_get_class ( name ) ; if ( ! proto_class ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown protocol '%s'.\\n\" , name ) ; return ; } show_help_children ( proto_class , AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_ENCODING_PARAM ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_help_muxer": "static void show_help_muxer ( const char * name ) { const AVCodecDescriptor * desc ; const AVOutputFormat * fmt = av_guess_format ( name , NULL , NULL ) ; if ( ! fmt ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown format '%s'.\\n\" , name ) ; return ; } av_log ( NULL , AV_LOG_ERROR , \"Muxer %s [%s]:\\n\" , fmt -> name , fmt -> long_name ) ; if ( fmt -> extensions ) av_log ( NULL , AV_LOG_ERROR , \"    Common extensions: %s.\\n\" , fmt -> extensions ) ; if ( fmt -> mime_type ) av_log ( NULL , AV_LOG_ERROR , \"    Mime type: %s.\\n\" , fmt -> mime_type ) ; if ( fmt -> video_codec != AV_CODEC_ID_NONE && ( desc = avcodec_descriptor_get ( fmt -> video_codec ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"    Default video codec: %s.\\n\" , desc -> name ) ; } if ( fmt -> audio_codec != AV_CODEC_ID_NONE && ( desc = avcodec_descriptor_get ( fmt -> audio_codec ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"    Default audio codec: %s.\\n\" , desc -> name ) ; } if ( fmt -> subtitle_codec != AV_CODEC_ID_NONE && ( desc = avcodec_descriptor_get ( fmt -> subtitle_codec ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"    Default subtitle codec: %s.\\n\" , desc -> name ) ; } if ( fmt -> priv_class ) show_help_children ( fmt -> priv_class , AV_OPT_FLAG_ENCODING_PARAM ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_help_bsf": "static void show_help_bsf ( const char * name ) { const AVBitStreamFilter * bsf = av_bsf_get_by_name ( name ) ; if ( ! name ) { av_log ( NULL , AV_LOG_ERROR , \"No bitstream filter name specified.\\n\" ) ; return ; } else if ( ! bsf ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown bit stream filter '%s'.\\n\" , name ) ; return ; } av_log ( NULL , AV_LOG_ERROR , \"Bit stream filter %s\\n\" , bsf -> name ) ; PRINT_CODEC_SUPPORTED ( bsf , codec_ids , enum AVCodecID , \"codecs\" , AV_CODEC_ID_NONE , GET_CODEC_NAME ) ; if ( bsf -> priv_class ) show_help_children ( bsf -> priv_class , AV_OPT_FLAG_BSF_PARAM ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_help": "int show_help ( void * optctx , const char * opt , const char * arg ) { char * topic , * par ; topic = av_strdup ( arg ? arg : \"\" ) ; if ( ! topic ) return AVERROR ( ENOMEM ) ; par = strchr ( topic , '=' ) ; if ( par ) * par ++ = 0 ; if ( ! * topic ) { if ( program_name && ! strcmp ( program_name , \"ffmpeg\" ) ) { show_help_default_ffmpeg ( topic , par ) ; } else { show_help_default_ffprobe ( topic , par ) ; } } else if ( ! strcmp ( topic , \"decoder\" ) ) { show_help_codec ( par , 0 ) ; } else if ( ! strcmp ( topic , \"encoder\" ) ) { show_help_codec ( par , 1 ) ; } else if ( ! strcmp ( topic , \"demuxer\" ) ) { show_help_demuxer ( par ) ; } else if ( ! strcmp ( topic , \"muxer\" ) ) { show_help_muxer ( par ) ; } else if ( ! strcmp ( topic , \"protocol\" ) ) { show_help_protocol ( par ) ; # if CONFIG_AVFILTER } else if ( ! strcmp ( topic , \"filter\" ) ) { show_help_filter ( par ) ; # endif } else if ( ! strcmp ( topic , \"bsf\" ) ) { show_help_bsf ( par ) ; } else { if ( program_name && ! strcmp ( program_name , \"ffmpeg\" ) ) { show_help_default_ffmpeg ( topic , par ) ; } else { show_help_default_ffprobe ( topic , par ) ; } } av_freep ( & topic ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@print_codecs_for_id": "static void print_codecs_for_id ( enum AVCodecID id , int encoder ) { void * iter = NULL ; const AVCodec * codec ; av_log ( NULL , AV_LOG_ERROR , \" (%s: \" , encoder ? \"encoders\" : \"decoders\" ) ; while ( ( codec = next_codec_for_id ( id , & iter , encoder ) ) ) av_log ( NULL , AV_LOG_ERROR , \"%s \" , codec -> name ) ; av_log ( NULL , AV_LOG_ERROR , \")\" ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@compare_codec_desc": "static int compare_codec_desc ( const void * a , const void * b ) { const AVCodecDescriptor * const * da = a ; const AVCodecDescriptor * const * db = b ; return ( * da ) -> type != ( * db ) -> type ? FFDIFFSIGN ( ( * da ) -> type , ( * db ) -> type ) : strcmp ( ( * da ) -> name , ( * db ) -> name ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@get_codecs_sorted": "static unsigned get_codecs_sorted ( const AVCodecDescriptor * * * rcodecs ) { const AVCodecDescriptor * desc = NULL ; const AVCodecDescriptor * * codecs ; unsigned nb_codecs = 0 , i = 0 ; while ( ( desc = avcodec_descriptor_next ( desc ) ) ) nb_codecs ++ ; if ( ! ( codecs = av_calloc ( nb_codecs , sizeof ( * codecs ) ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"Out of memory\\n\" ) ; exit_program ( 1 ) ; } desc = NULL ; while ( ( desc = avcodec_descriptor_next ( desc ) ) ) codecs [ i ++ ] = desc ; av_assert0 ( i == nb_codecs ) ; qsort ( codecs , nb_codecs , sizeof ( * codecs ) , compare_codec_desc ) ; * rcodecs = codecs ; return nb_codecs ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@get_media_type_char": "static char get_media_type_char ( enum AVMediaType type ) { switch ( type ) { case AVMEDIA_TYPE_VIDEO : return 'V' ; case AVMEDIA_TYPE_AUDIO : return 'A' ; case AVMEDIA_TYPE_DATA : return 'D' ; case AVMEDIA_TYPE_SUBTITLE : return 'S' ; case AVMEDIA_TYPE_ATTACHMENT : return 'T' ; default : return '?' ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_codecs": "int show_codecs ( void * optctx , const char * opt , const char * arg ) { const AVCodecDescriptor * * codecs ; unsigned i , nb_codecs = get_codecs_sorted ( & codecs ) ; av_log ( NULL , AV_LOG_ERROR , \"Codecs:\\n\" \" D..... = Decoding supported\\n\" \" .E.... = Encoding supported\\n\" \" ..V... = Video codec\\n\" \" ..A... = Audio codec\\n\" \" ..S... = Subtitle codec\\n\" \" ..D... = Data codec\\n\" \" ..T... = Attachment codec\\n\" \" ...I.. = Intra frame-only codec\\n\" \" ....L. = Lossy compression\\n\" \" .....S = Lossless compression\\n\" \" -------\\n\" ) ; for ( i = 0 ; i < nb_codecs ; i ++ ) { const AVCodecDescriptor * desc = codecs [ i ] ; const AVCodec * codec ; void * iter = NULL ; if ( strstr ( desc -> name , \"_deprecated\" ) ) continue ; av_log ( NULL , AV_LOG_ERROR , \" \" ) ; av_log ( NULL , AV_LOG_ERROR , avcodec_find_decoder ( desc -> id ) ? \"D\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , avcodec_find_encoder ( desc -> id ) ? \"E\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , \"%c\" , get_media_type_char ( desc -> type ) ) ; av_log ( NULL , AV_LOG_ERROR , ( desc -> props & AV_CODEC_PROP_INTRA_ONLY ) ? \"I\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( desc -> props & AV_CODEC_PROP_LOSSY ) ? \"L\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( desc -> props & AV_CODEC_PROP_LOSSLESS ) ? \"S\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , \" %-20s %s\" , desc -> name , desc -> long_name ? desc -> long_name : \"\" ) ; /* print decoders/encoders when there's more than one or their\n         * names are different from codec name */ while ( ( codec = next_codec_for_id ( desc -> id , & iter , 0 ) ) ) { if ( strcmp ( codec -> name , desc -> name ) ) { print_codecs_for_id ( desc -> id , 0 ) ; break ; } } iter = NULL ; while ( ( codec = next_codec_for_id ( desc -> id , & iter , 1 ) ) ) { if ( strcmp ( codec -> name , desc -> name ) ) { print_codecs_for_id ( desc -> id , 1 ) ; break ; } } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } av_free ( codecs ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@print_codecs": "static void print_codecs ( int encoder ) { const AVCodecDescriptor * * codecs ; unsigned i , nb_codecs = get_codecs_sorted ( & codecs ) ; av_log ( NULL , AV_LOG_ERROR , \"%s:\\n\" \" V..... = Video\\n\" \" A..... = Audio\\n\" \" S..... = Subtitle\\n\" \" .F.... = Frame-level multithreading\\n\" \" ..S... = Slice-level multithreading\\n\" \" ...X.. = Codec is experimental\\n\" \" ....B. = Supports draw_horiz_band\\n\" \" .....D = Supports direct rendering method 1\\n\" \" ------\\n\" , encoder ? \"Encoders\" : \"Decoders\" ) ; for ( i = 0 ; i < nb_codecs ; i ++ ) { const AVCodecDescriptor * desc = codecs [ i ] ; const AVCodec * codec ; void * iter = NULL ; while ( ( codec = next_codec_for_id ( desc -> id , & iter , encoder ) ) ) { av_log ( NULL , AV_LOG_ERROR , \" %c\" , get_media_type_char ( desc -> type ) ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_FRAME_THREADS ) ? \"F\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_SLICE_THREADS ) ? \"S\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_EXPERIMENTAL ) ? \"X\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_DRAW_HORIZ_BAND ) ? \"B\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_DR1 ) ? \"D\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , \" %-20s %s\" , codec -> name , codec -> long_name ? codec -> long_name : \"\" ) ; if ( strcmp ( codec -> name , desc -> name ) ) av_log ( NULL , AV_LOG_ERROR , \" (codec %s)\" , desc -> name ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } } av_free ( codecs ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_decoders": "int show_decoders ( void * optctx , const char * opt , const char * arg ) { print_codecs ( 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_encoders": "int show_encoders ( void * optctx , const char * opt , const char * arg ) { print_codecs ( 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_bsfs": "int show_bsfs ( void * optctx , const char * opt , const char * arg ) { const AVBitStreamFilter * bsf = NULL ; void * opaque = NULL ; av_log ( NULL , AV_LOG_ERROR , \"Bitstream filters:\\n\" ) ; while ( ( bsf = av_bsf_iterate ( & opaque ) ) ) av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" , bsf -> name ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_filters": "int show_filters ( void * optctx , const char * opt , const char * arg ) { # if CONFIG_AVFILTER const AVFilter * filter = NULL ; char descr [ 64 ] , * descr_cur ; void * opaque = NULL ; int i , j ; const AVFilterPad * pad ; av_log ( NULL , AV_LOG_ERROR , \"Filters:\\n\" \"  T.. = Timeline support\\n\" \"  .S. = Slice threading\\n\" \"  ..C = Command support\\n\" \"  A = Audio input/output\\n\" \"  V = Video input/output\\n\" \"  N = Dynamic number and/or type of input/output\\n\" \"  | = Source or sink filter\\n\" ) ; while ( ( filter = av_filter_iterate ( & opaque ) ) ) { descr_cur = descr ; for ( i = 0 ; i < 2 ; i ++ ) { unsigned nb_pads ; if ( i ) { * ( descr_cur ++ ) = '-' ; * ( descr_cur ++ ) = '>' ; } pad = i ? filter -> outputs : filter -> inputs ; nb_pads = avfilter_filter_pad_count ( filter , i ) ; for ( j = 0 ; j < nb_pads ; j ++ ) { if ( descr_cur >= descr + sizeof ( descr ) - 4 ) break ; * ( descr_cur ++ ) = get_media_type_char ( avfilter_pad_get_type ( pad , j ) ) ; } if ( ! j ) * ( descr_cur ++ ) = ( ( ! i && ( filter -> flags & AVFILTER_FLAG_DYNAMIC_INPUTS ) ) || ( i && ( filter -> flags & AVFILTER_FLAG_DYNAMIC_OUTPUTS ) ) ) ? 'N' : '|' ; } * descr_cur = 0 ; av_log ( NULL , AV_LOG_ERROR , \" %c%c%c %-17s %-10s %s\\n\" , filter -> flags & AVFILTER_FLAG_SUPPORT_TIMELINE ? 'T' : '.' , filter -> flags & AVFILTER_FLAG_SLICE_THREADS ? 'S' : '.' , filter -> process_command ? 'C' : '.' , filter -> name , descr , filter -> description ) ; } # else av_log ( NULL , AV_LOG_ERROR , \"No filters available: libavfilter disabled\\n\" ) ; # endif return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@is_device": "static int is_device ( const AVClass * avclass ) { if ( ! avclass ) return 0 ; return AV_IS_INPUT_DEVICE ( avclass -> category ) || AV_IS_OUTPUT_DEVICE ( avclass -> category ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_formats_devices": "static int show_formats_devices ( void * optctx , const char * opt , const char * arg , int device_only , int muxdemuxers ) { void * ifmt_opaque = NULL ; const AVInputFormat * ifmt = NULL ; void * ofmt_opaque = NULL ; const AVOutputFormat * ofmt = NULL ; const char * last_name ; int is_dev ; av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" \" D. = Demuxing supported\\n\" \" .E = Muxing supported\\n\" \" --\\n\" , device_only ? \"Devices:\" : \"File formats:\" ) ; last_name = \"000\" ; for ( ; ; ) { int decode = 0 ; int encode = 0 ; const char * name = NULL ; const char * long_name = NULL ; if ( muxdemuxers != SHOW_DEMUXERS ) { ofmt_opaque = NULL ; while ( ( ofmt = av_muxer_iterate ( & ofmt_opaque ) ) ) { is_dev = is_device ( ofmt -> priv_class ) ; if ( ! is_dev && device_only ) continue ; if ( ( ! name || strcmp ( ofmt -> name , name ) < 0 ) && strcmp ( ofmt -> name , last_name ) > 0 ) { name = ofmt -> name ; long_name = ofmt -> long_name ; encode = 1 ; } } } if ( muxdemuxers != SHOW_MUXERS ) { ifmt_opaque = NULL ; while ( ( ifmt = av_demuxer_iterate ( & ifmt_opaque ) ) ) { is_dev = is_device ( ifmt -> priv_class ) ; if ( ! is_dev && device_only ) continue ; if ( ( ! name || strcmp ( ifmt -> name , name ) < 0 ) && strcmp ( ifmt -> name , last_name ) > 0 ) { name = ifmt -> name ; long_name = ifmt -> long_name ; encode = 0 ; } if ( name && strcmp ( ifmt -> name , name ) == 0 ) decode = 1 ; } } if ( ! name ) break ; last_name = name ; av_log ( NULL , AV_LOG_ERROR , \" %c%c %-15s %s\\n\" , decode ? 'D' : ' ' , encode ? 'E' : ' ' , name , long_name ? long_name : \" \" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_formats": "int show_formats ( void * optctx , const char * opt , const char * arg ) { return show_formats_devices ( optctx , opt , arg , 0 , SHOW_DEFAULT ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_muxers": "int show_muxers ( void * optctx , const char * opt , const char * arg ) { return show_formats_devices ( optctx , opt , arg , 0 , SHOW_MUXERS ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_demuxers": "int show_demuxers ( void * optctx , const char * opt , const char * arg ) { return show_formats_devices ( optctx , opt , arg , 0 , SHOW_DEMUXERS ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_devices": "int show_devices ( void * optctx , const char * opt , const char * arg ) { return show_formats_devices ( optctx , opt , arg , 1 , SHOW_DEFAULT ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_protocols": "int show_protocols ( void * optctx , const char * opt , const char * arg ) { void * opaque = NULL ; const char * name ; av_log ( NULL , AV_LOG_ERROR , \"Supported file protocols:\\n\" \"Input:\\n\" ) ; while ( ( name = avio_enum_protocols ( & opaque , 0 ) ) ) av_log ( NULL , AV_LOG_ERROR , \"  %s\\n\" , name ) ; av_log ( NULL , AV_LOG_ERROR , \"Output:\\n\" ) ; while ( ( name = avio_enum_protocols ( & opaque , 1 ) ) ) av_log ( NULL , AV_LOG_ERROR , \"  %s\\n\" , name ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_colors": "int show_colors ( void * optctx , const char * opt , const char * arg ) { const char * name ; const uint8_t * rgb ; int i ; av_log ( NULL , AV_LOG_ERROR , \"%-32s #RRGGBB\\n\" , \"name\" ) ; for ( i = 0 ; ( name = av_get_known_color_name ( i , & rgb ) ) ; i ++ ) av_log ( NULL , AV_LOG_ERROR , \"%-32s #%02x%02x%02x\\n\" , name , rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_pix_fmts": "int show_pix_fmts ( void * optctx , const char * opt , const char * arg ) { const AVPixFmtDescriptor * pix_desc = NULL ; av_log ( NULL , AV_LOG_ERROR , \"Pixel formats:\\n\" \"I.... = Supported Input  format for conversion\\n\" \".O... = Supported Output format for conversion\\n\" \"..H.. = Hardware accelerated format\\n\" \"...P. = Paletted format\\n\" \"....B = Bitstream format\\n\" \"FLAGS NAME            NB_COMPONENTS BITS_PER_PIXEL BIT_DEPTHS\\n\" \"-----\\n\" ) ; # if ! CONFIG_SWSCALE # define sws_isSupportedInput ( x ) 0 # define sws_isSupportedOutput ( x ) 0 # endif while ( ( pix_desc = av_pix_fmt_desc_next ( pix_desc ) ) ) { enum AVPixelFormat av_unused pix_fmt = av_pix_fmt_desc_get_id ( pix_desc ) ; av_log ( NULL , AV_LOG_ERROR , \"%c%c%c%c%c %-16s       %d            %3d      %d\" , sws_isSupportedInput ( pix_fmt ) ? 'I' : '.' , sws_isSupportedOutput ( pix_fmt ) ? 'O' : '.' , pix_desc -> flags & AV_PIX_FMT_FLAG_HWACCEL ? 'H' : '.' , pix_desc -> flags & AV_PIX_FMT_FLAG_PAL ? 'P' : '.' , pix_desc -> flags & AV_PIX_FMT_FLAG_BITSTREAM ? 'B' : '.' , pix_desc -> name , pix_desc -> nb_components , av_get_bits_per_pixel ( pix_desc ) , pix_desc -> comp [ 0 ] . depth ) ; for ( unsigned i = 1 ; i < pix_desc -> nb_components ; i ++ ) av_log ( NULL , AV_LOG_ERROR , \"-%d\" , pix_desc -> comp [ i ] . depth ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_layouts": "int show_layouts ( void * optctx , const char * opt , const char * arg ) { const AVChannelLayout * ch_layout ; void * iter = NULL ; char buf [ 128 ] , buf2 [ 128 ] ; int i = 0 ; av_log ( NULL , AV_LOG_ERROR , \"Individual channels:\\n\" \"NAME           DESCRIPTION\\n\" ) ; for ( i = 0 ; i < 63 ; i ++ ) { av_channel_name ( buf , sizeof ( buf ) , i ) ; if ( strstr ( buf , \"USR\" ) ) continue ; av_channel_description ( buf2 , sizeof ( buf2 ) , i ) ; av_log ( NULL , AV_LOG_ERROR , \"%-14s %s\\n\" , buf , buf2 ) ; } av_log ( NULL , AV_LOG_ERROR , \"\\nStandard channel layouts:\\n\" \"NAME           DECOMPOSITION\\n\" ) ; while ( ( ch_layout = av_channel_layout_standard ( & iter ) ) ) { av_channel_layout_describe ( ch_layout , buf , sizeof ( buf ) ) ; av_log ( NULL , AV_LOG_ERROR , \"%-14s \" , buf ) ; for ( i = 0 ; i < 63 ; i ++ ) { int idx = av_channel_layout_index_from_channel ( ch_layout , i ) ; if ( idx >= 0 ) { av_channel_name ( buf2 , sizeof ( buf2 ) , i ) ; av_log ( NULL , AV_LOG_ERROR , \"%s%s\" , idx ? \"+\" : \"\" , buf2 ) ; } } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_sample_fmts": "int show_sample_fmts ( void * optctx , const char * opt , const char * arg ) { int i ; char fmt_str [ 128 ] ; for ( i = - 1 ; i < AV_SAMPLE_FMT_NB ; i ++ ) av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" , av_get_sample_fmt_string ( fmt_str , sizeof ( fmt_str ) , i ) ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@show_dispositions": "int show_dispositions ( void * optctx , const char * opt , const char * arg ) { for ( int i = 0 ; i < 32 ; i ++ ) { const char * str = av_disposition_to_string ( 1U << i ) ; if ( str ) av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" , str ) ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@opt_cpuflags": "int opt_cpuflags ( void * optctx , const char * opt , const char * arg ) { int ret ; unsigned flags = av_get_cpu_flags ( ) ; if ( ( ret = av_parse_cpu_caps ( & flags , arg ) ) < 0 ) return ret ; av_force_cpu_flags ( flags ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@opt_cpucount": "int opt_cpucount ( void * optctx , const char * opt , const char * arg ) { int ret ; int count ; static const AVOption opts [ ] = { { \"count\" , NULL , 0 , AV_OPT_TYPE_INT , { . i64 = - 1 } , - 1 , INT_MAX } , { NULL } , } ; static const AVClass class = { . class_name = \"cpucount\" , . item_name = av_default_item_name , . option = opts , . version = LIBAVUTIL_VERSION_INT , } ; const AVClass * pclass = & class ; ret = av_opt_eval_int ( & pclass , opts , arg , & count ) ; if ( ! ret ) { av_cpu_force_count ( count ) ; } return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@expand_filename_template": "static void expand_filename_template ( AVBPrint * bp , const char * template , struct tm * tm ) { int c ; while ( ( c = * ( template ++ ) ) ) { if ( c == '%' ) { if ( ! ( c = * ( template ++ ) ) ) break ; switch ( c ) { case 'p' : av_bprintf ( bp , \"%s\" , program_name ) ; break ; case 't' : av_bprintf ( bp , \"%04d%02d%02d-%02d%02d%02d\" , tm -> tm_year + 1900 , tm -> tm_mon + 1 , tm -> tm_mday , tm -> tm_hour , tm -> tm_min , tm -> tm_sec ) ; break ; case '%' : av_bprint_chars ( bp , c , 1 ) ; break ; } } else { av_bprint_chars ( bp , c , 1 ) ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@log_callback_report": "static void log_callback_report ( void * ptr , int level , const char * fmt , va_list vl ) { va_list vl2 ; char line [ 1024 ] ; static int print_prefix = 1 ; va_copy ( vl2 , vl ) ; if ( report_callback == NULL ) { av_log_default_callback ( ptr , level , fmt , vl ) ; } else { ffmpegkit_log_callback_function ( ptr , level , fmt , vl ) ; } av_log_format_line ( ptr , level , fmt , vl2 , line , sizeof ( line ) , & print_prefix ) ; va_end ( vl2 ) ; if ( report_file && report_file_level >= level ) { fputs ( line , report_file ) ; fflush ( report_file ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@init_report": "int init_report ( const char * env , FILE * * file ) { char * filename_template = NULL ; char * key , * val ; int ret , count = 0 ; int prog_loglevel , envlevel = 0 ; time_t now ; struct tm * tm ; AVBPrint filename ; if ( report_file ) /* already opened */ return 0 ; time ( & now ) ; tm = localtime ( & now ) ; while ( env && * env ) { if ( ( ret = av_opt_get_key_value ( & env , \"=\" , \":\" , 0 , & key , & val ) ) < 0 ) { if ( count ) av_log ( NULL , AV_LOG_ERROR , \"Failed to parse FFREPORT environment variable: %s\\n\" , av_err2str ( ret ) ) ; break ; } if ( * env ) env ++ ; count ++ ; if ( ! strcmp ( key , \"file\" ) ) { av_free ( filename_template ) ; filename_template = val ; val = NULL ; } else if ( ! strcmp ( key , \"level\" ) ) { char * tail ; report_file_level = strtol ( val , & tail , 10 ) ; if ( * tail ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid report file level\\n\" ) ; exit_program ( 1 ) ; } envlevel = 1 ; } else { av_log ( NULL , AV_LOG_ERROR , \"Unknown key '%s' in FFREPORT\\n\" , key ) ; } av_free ( val ) ; av_free ( key ) ; } av_bprint_init ( & filename , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; expand_filename_template ( & filename , av_x_if_null ( filename_template , \"%p-%t.log\" ) , tm ) ; av_free ( filename_template ) ; if ( ! av_bprint_is_complete ( & filename ) ) { av_log ( NULL , AV_LOG_ERROR , \"Out of memory building report file name\\n\" ) ; return AVERROR ( ENOMEM ) ; } prog_loglevel = av_log_get_level ( ) ; if ( ! envlevel ) report_file_level = FFMAX ( report_file_level , prog_loglevel ) ; report_file = fopen ( filename . str , \"w\" ) ; if ( ! report_file ) { int ret = AVERROR ( errno ) ; av_log ( NULL , AV_LOG_ERROR , \"Failed to open report \\\"%s\\\": %s\\n\" , filename . str , strerror ( errno ) ) ; return ret ; } av_log_set_callback ( log_callback_report ) ; av_log ( NULL , AV_LOG_INFO , \"%s started on %04d-%02d-%02d at %02d:%02d:%02d\\n\" \"Report written to \\\"%s\\\"\\n\" \"Log level: %d\\n\" , program_name , tm -> tm_year + 1900 , tm -> tm_mon + 1 , tm -> tm_mday , tm -> tm_hour , tm -> tm_min , tm -> tm_sec , filename . str , report_file_level ) ; av_bprint_finalize ( & filename , NULL ) ; if ( file ) * file = report_file ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@opt_report": "int opt_report ( void * optctx , const char * opt , const char * arg ) { return init_report ( NULL , NULL ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@opt_max_alloc": "int opt_max_alloc ( void * optctx , const char * opt , const char * arg ) { char * tail ; size_t max ; max = strtol ( arg , & tail , 10 ) ; if ( * tail ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid max_alloc \\\"%s\\\".\\n\" , arg ) ; exit_program ( 1 ) ; } av_max_alloc ( max ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_opt_common.c@opt_loglevel": "int opt_loglevel ( void * optctx , const char * opt , const char * arg ) { const struct { const char * name ; int level ; } log_levels [ ] = { { \"quiet\" , AV_LOG_QUIET } , { \"panic\" , AV_LOG_PANIC } , { \"fatal\" , AV_LOG_FATAL } , { \"error\" , AV_LOG_ERROR } , { \"warning\" , AV_LOG_WARNING } , { \"info\" , AV_LOG_INFO } , { \"verbose\" , AV_LOG_VERBOSE } , { \"debug\" , AV_LOG_DEBUG } , { \"trace\" , AV_LOG_TRACE } , } ; const char * token ; char * tail ; int flags = av_log_get_flags ( ) ; int level = av_log_get_level ( ) ; int cmd , i = 0 ; av_assert0 ( arg ) ; while ( * arg ) { token = arg ; if ( * token == '+' || * token == '-' ) { cmd = * token ++ ; } else { cmd = 0 ; } if ( ! i && ! cmd ) { flags = 0 ; /* missing relative prefix, build absolute value */ } if ( av_strstart ( token , \"repeat\" , & arg ) ) { if ( cmd == '-' ) { flags |= AV_LOG_SKIP_REPEATED ; } else { flags &= ~ AV_LOG_SKIP_REPEATED ; } } else if ( av_strstart ( token , \"level\" , & arg ) ) { if ( cmd == '-' ) { flags &= ~ AV_LOG_PRINT_LEVEL ; } else { flags |= AV_LOG_PRINT_LEVEL ; } } else { break ; } i ++ ; } if ( ! * arg ) { goto end ; } else if ( * arg == '+' ) { arg ++ ; } else if ( ! i ) { flags = av_log_get_flags ( ) ; /* level value without prefix, reset flags */ } for ( i = 0 ; i < FF_ARRAY_ELEMS ( log_levels ) ; i ++ ) { if ( ! strcmp ( log_levels [ i ] . name , arg ) ) { level = log_levels [ i ] . level ; goto end ; } } level = strtol ( arg , & tail , 10 ) ; if ( * tail ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid loglevel \\\"%s\\\". \" \"Possible levels are numbers or:\\n\" , arg ) ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( log_levels ) ; i ++ ) av_log ( NULL , AV_LOG_FATAL , \"\\\"%s\\\"\\n\" , log_levels [ i ] . name ) ; exit_program ( 1 ) ; } end : av_log_set_flags ( flags ) ; av_log_set_level ( level ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@sub2video_get_blank_frame": "static int sub2video_get_blank_frame ( InputStream * ist ) { int ret ; AVFrame * frame = ist -> sub2video . frame ; av_frame_unref ( frame ) ; ist -> sub2video . frame -> width = ist -> dec_ctx -> width ? ist -> dec_ctx -> width : ist -> sub2video . w ; ist -> sub2video . frame -> height = ist -> dec_ctx -> height ? ist -> dec_ctx -> height : ist -> sub2video . h ; ist -> sub2video . frame -> format = AV_PIX_FMT_RGB32 ; if ( ( ret = av_frame_get_buffer ( frame , 0 ) ) < 0 ) return ret ; memset ( frame -> data [ 0 ] , 0 , frame -> height * frame -> linesize [ 0 ] ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@sub2video_copy_rect": "static void sub2video_copy_rect ( uint8_t * dst , int dst_linesize , int w , int h , AVSubtitleRect * r ) { uint32_t * pal , * dst2 ; uint8_t * src , * src2 ; int x , y ; if ( r -> type != SUBTITLE_BITMAP ) { av_log ( NULL , AV_LOG_WARNING , \"sub2video: non-bitmap subtitle\\n\" ) ; return ; } if ( r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h ) { av_log ( NULL , AV_LOG_WARNING , \"sub2video: rectangle (%d %d %d %d) overflowing %d %d\\n\" , r -> x , r -> y , r -> w , r -> h , w , h ) ; return ; } dst += r -> y * dst_linesize + r -> x * 4 ; src = r -> data [ 0 ] ; pal = ( uint32_t * ) r -> data [ 1 ] ; for ( y = 0 ; y < r -> h ; y ++ ) { dst2 = ( uint32_t * ) dst ; src2 = src ; for ( x = 0 ; x < r -> w ; x ++ ) * ( dst2 ++ ) = pal [ * ( src2 ++ ) ] ; dst += dst_linesize ; src += r -> linesize [ 0 ] ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@sub2video_push_ref": "static void sub2video_push_ref ( InputStream * ist , int64_t pts ) { AVFrame * frame = ist -> sub2video . frame ; int i ; int ret ; av_assert1 ( frame -> data [ 0 ] ) ; ist -> sub2video . last_pts = frame -> pts = pts ; for ( i = 0 ; i < ist -> nb_filters ; i ++ ) { ret = av_buffersrc_add_frame_flags ( ist -> filters [ i ] -> filter , frame , AV_BUFFERSRC_FLAG_KEEP_REF | AV_BUFFERSRC_FLAG_PUSH ) ; if ( ret != AVERROR_EOF && ret < 0 ) av_log ( NULL , AV_LOG_WARNING , \"Error while add the frame to buffer source(%s).\\n\" , av_err2str ( ret ) ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@sub2video_update": "void sub2video_update ( InputStream * ist , int64_t heartbeat_pts , AVSubtitle * sub ) { AVFrame * frame = ist -> sub2video . frame ; int8_t * dst ; int dst_linesize ; int num_rects , i ; int64_t pts , end_pts ; if ( ! frame ) return ; if ( sub ) { pts = av_rescale_q ( sub -> pts + sub -> start_display_time * 1000LL , AV_TIME_BASE_Q , ist -> st -> time_base ) ; end_pts = av_rescale_q ( sub -> pts + sub -> end_display_time * 1000LL , AV_TIME_BASE_Q , ist -> st -> time_base ) ; num_rects = sub -> num_rects ; } else { /* If we are initializing the system, utilize current heartbeat\n           PTS as the start time, and show until the following subpicture\n           is received. Otherwise, utilize the previous subpicture's end time\n           as the fall-back value. */ pts = ist -> sub2video . initialize ? heartbeat_pts : ist -> sub2video . end_pts ; end_pts = INT64_MAX ; num_rects = 0 ; } if ( sub2video_get_blank_frame ( ist ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Impossible to get a blank canvas.\\n\" ) ; return ; } dst = frame -> data [ 0 ] ; dst_linesize = frame -> linesize [ 0 ] ; for ( i = 0 ; i < num_rects ; i ++ ) sub2video_copy_rect ( dst , dst_linesize , frame -> width , frame -> height , sub -> rects [ i ] ) ; sub2video_push_ref ( ist , pts ) ; ist -> sub2video . end_pts = end_pts ; ist -> sub2video . initialize = 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@sub2video_heartbeat": "static void sub2video_heartbeat ( InputStream * ist , int64_t pts ) { InputFile * infile = input_files [ ist -> file_index ] ; int i , j , nb_reqs ; int64_t pts2 ; /* When a frame is read from a file, examine all sub2video streams in\n       the same file and send the sub2video frame again. Otherwise, decoded\n       video frames could be accumulating in the filter graph while a filter\n       (possibly overlay) is desperately waiting for a subtitle frame. */ for ( i = 0 ; i < infile -> nb_streams ; i ++ ) { InputStream * ist2 = infile -> streams [ i ] ; if ( ! ist2 -> sub2video . frame ) continue ; /* subtitles seem to be usually muxed ahead of other streams;\n           if not, subtracting a larger time here is necessary */ pts2 = av_rescale_q ( pts , ist -> st -> time_base , ist2 -> st -> time_base ) - 1 ; /* do not send the heartbeat frame if the subtitle is already ahead */ if ( pts2 <= ist2 -> sub2video . last_pts ) continue ; if ( pts2 >= ist2 -> sub2video . end_pts || ist2 -> sub2video . initialize ) /* if we have hit the end of the current displayed subpicture,\n               or if we need to initialize the system, update the\n               overlayed subpicture and its start/end times */ sub2video_update ( ist2 , pts2 + 1 , NULL ) ; for ( j = 0 , nb_reqs = 0 ; j < ist2 -> nb_filters ; j ++ ) nb_reqs += av_buffersrc_get_nb_failed_requests ( ist2 -> filters [ j ] -> filter ) ; if ( nb_reqs ) sub2video_push_ref ( ist2 , pts2 ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@sub2video_flush": "static void sub2video_flush ( InputStream * ist ) { int i ; int ret ; if ( ist -> sub2video . end_pts < INT64_MAX ) sub2video_update ( ist , INT64_MAX , NULL ) ; for ( i = 0 ; i < ist -> nb_filters ; i ++ ) { ret = av_buffersrc_add_frame ( ist -> filters [ i ] -> filter , NULL ) ; if ( ret != AVERROR_EOF && ret < 0 ) av_log ( NULL , AV_LOG_WARNING , \"Flush the frame error.\\n\" ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@term_exit_sigsafe": "static void term_exit_sigsafe ( void ) { # if HAVE_TERMIOS_H if ( restore_tty ) tcsetattr ( 0 , TCSANOW , & oldtty ) ; # endif }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@term_exit": "void term_exit ( void ) { av_log ( NULL , AV_LOG_QUIET , \"%s\" , \"\" ) ; term_exit_sigsafe ( ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@sigterm_handler": "static void sigterm_handler ( int sig ) { // int ret; received_sigterm = sig ; received_nb_signals ++ ; term_exit_sigsafe ( ) ; // FFmpegKit - Hard Exit Disabled // if(received_nb_signals > 3) { //     ret = write(2/*STDERR_FILENO*/, \"Received > 3 system signals, hard exiting\\n\", //                 strlen(\"Received > 3 system signals, hard exiting\\n\")); //     if (ret < 0) { /* Do nothing */ }; //     exit(123); // } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@term_init": "void term_init ( void ) { # if defined __linux__ # if defined __aarch64__ || defined __amd64__ || defined __x86_64__ struct sigaction action = { 0 } ; # else struct sigaction action = { { 0 } } ; # endif action . sa_handler = sigterm_handler ; /* block other interrupts while processing this one */ sigfillset ( & action . sa_mask ) ; /* restart interruptible functions (i.e. don't fail with EINTR)  */ action . sa_flags = SA_RESTART ; # endif # if HAVE_TERMIOS_H if ( stdin_interaction ) { struct termios tty ; if ( tcgetattr ( 0 , & tty ) == 0 ) { oldtty = tty ; restore_tty = 1 ; tty . c_iflag &= ~ ( IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL | IXON ) ; tty . c_oflag |= OPOST ; tty . c_lflag &= ~ ( ECHO | ECHONL | ICANON | IEXTEN ) ; tty . c_cflag &= ~ ( CSIZE | PARENB ) ; tty . c_cflag |= CS8 ; tty . c_cc [ VMIN ] = 1 ; tty . c_cc [ VTIME ] = 0 ; tcsetattr ( 0 , TCSANOW , & tty ) ; } if ( handleSIGQUIT == 1 ) { SIGNAL ( SIGQUIT , sigterm_handler ) ; /* Quit (POSIX).  */ } } # endif if ( handleSIGINT == 1 ) { SIGNAL ( SIGINT , sigterm_handler ) ; /* Interrupt (ANSI).    */ } if ( handleSIGTERM == 1 ) { SIGNAL ( SIGTERM , sigterm_handler ) ; /* Termination (ANSI).  */ } # ifdef SIGXCPU if ( handleSIGXCPU == 1 ) { SIGNAL ( SIGXCPU , sigterm_handler ) ; } # endif # ifdef SIGPIPE if ( handleSIGPIPE == 1 ) { SIGNAL ( SIGPIPE , SIG_IGN ) ; /* Broken pipe (POSIX). */ } # endif # if HAVE_SETCONSOLECTRLHANDLER SetConsoleCtrlHandler ( ( PHANDLER_ROUTINE ) CtrlHandler , TRUE ) ; # endif }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@read_key": "static int read_key ( void ) { unsigned char ch ; # if HAVE_TERMIOS_H int n = 1 ; struct timeval tv ; fd_set rfds ; FD_ZERO ( & rfds ) ; FD_SET ( 0 , & rfds ) ; tv . tv_sec = 0 ; tv . tv_usec = 0 ; n = select ( 1 , & rfds , NULL , NULL , & tv ) ; if ( n > 0 ) { n = read ( 0 , & ch , 1 ) ; if ( n == 1 ) return ch ; return n ; } # elif HAVE_KBHIT # if HAVE_PEEKNAMEDPIPE static int is_pipe ; static HANDLE input_handle ; DWORD dw , nchars ; if ( ! input_handle ) { input_handle = GetStdHandle ( STD_INPUT_HANDLE ) ; is_pipe = ! GetConsoleMode ( input_handle , & dw ) ; } if ( is_pipe ) { /* When running under a GUI, you will end here. */ if ( ! PeekNamedPipe ( input_handle , NULL , 0 , NULL , & nchars , NULL ) ) { // input pipe may have been closed by the program that ran ffmpeg return - 1 ; } //Read it if ( nchars != 0 ) { read ( 0 , & ch , 1 ) ; return ch ; } else { return - 1 ; } } # endif if ( kbhit ( ) ) return ( getch ( ) ) ; # endif return - 1 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@decode_interrupt_cb": "int decode_interrupt_cb ( void * ctx ) { return received_nb_signals > atomic_load ( & transcode_init_done ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@ffmpeg_cleanup": "static void ffmpeg_cleanup ( int ret ) { int i , j ; if ( do_benchmark ) { int maxrss = getmaxrss ( ) / 1024 ; av_log ( NULL , AV_LOG_INFO , \"bench: maxrss=%ikB\\n\" , maxrss ) ; } for ( i = 0 ; i < nb_filtergraphs ; i ++ ) { FilterGraph * fg = filtergraphs [ i ] ; avfilter_graph_free ( & fg -> graph ) ; for ( j = 0 ; j < fg -> nb_inputs ; j ++ ) { InputFilter * ifilter = fg -> inputs [ j ] ; struct InputStream * ist = ifilter -> ist ; if ( ifilter -> frame_queue ) { AVFrame * frame ; while ( av_fifo_read ( ifilter -> frame_queue , & frame , 1 ) >= 0 ) av_frame_free ( & frame ) ; av_fifo_freep2 ( & ifilter -> frame_queue ) ; } av_freep ( & ifilter -> displaymatrix ) ; if ( ist -> sub2video . sub_queue ) { AVSubtitle sub ; while ( av_fifo_read ( ist -> sub2video . sub_queue , & sub , 1 ) >= 0 ) avsubtitle_free ( & sub ) ; av_fifo_freep2 ( & ist -> sub2video . sub_queue ) ; } av_buffer_unref ( & ifilter -> hw_frames_ctx ) ; av_freep ( & ifilter -> name ) ; av_freep ( & fg -> inputs [ j ] ) ; } av_freep ( & fg -> inputs ) ; for ( j = 0 ; j < fg -> nb_outputs ; j ++ ) { OutputFilter * ofilter = fg -> outputs [ j ] ; avfilter_inout_free ( & ofilter -> out_tmp ) ; av_freep ( & ofilter -> name ) ; av_channel_layout_uninit ( & ofilter -> ch_layout ) ; av_freep ( & fg -> outputs [ j ] ) ; } av_freep ( & fg -> outputs ) ; av_freep ( & fg -> graph_desc ) ; av_freep ( & filtergraphs [ i ] ) ; } av_freep ( & filtergraphs ) ; /* close files */ for ( i = 0 ; i < nb_output_files ; i ++ ) of_close ( & output_files [ i ] ) ; for ( i = 0 ; i < nb_input_files ; i ++ ) ifile_close ( & input_files [ i ] ) ; if ( vstats_file ) { if ( fclose ( vstats_file ) ) av_log ( NULL , AV_LOG_ERROR , \"Error closing vstats file, loss of information possible: %s\\n\" , av_err2str ( AVERROR ( errno ) ) ) ; } av_freep ( & vstats_filename ) ; of_enc_stats_close ( ) ; av_freep ( & filter_nbthreads ) ; av_freep ( & input_files ) ; av_freep ( & output_files ) ; uninit_opts ( ) ; avformat_network_deinit ( ) ; if ( received_sigterm ) { av_log ( NULL , AV_LOG_INFO , \"Exiting normally, received signal %d.\\n\" , ( int ) received_sigterm ) ; } else if ( cancelRequested ( globalSessionId ) ) { av_log ( NULL , AV_LOG_INFO , \"Exiting normally, received cancel request.\\n\" ) ; } else if ( ret && atomic_load ( & transcode_init_done ) ) { av_log ( NULL , AV_LOG_INFO , \"Conversion failed!\\n\" ) ; } term_exit ( ) ; ffmpeg_exited = 1 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@ost_iter": "static OutputStream * ost_iter ( OutputStream * prev ) { int of_idx = prev ? prev -> file_index : 0 ; int ost_idx = prev ? prev -> index + 1 : 0 ; for ( ; of_idx < nb_output_files ; of_idx ++ ) { OutputFile * of = output_files [ of_idx ] ; if ( ost_idx < of -> nb_streams ) return of -> streams [ ost_idx ] ; ost_idx = 0 ; } return NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@ist_iter": "InputStream * ist_iter ( InputStream * prev ) { int if_idx = prev ? prev -> file_index : 0 ; int ist_idx = prev ? prev -> st -> index + 1 : 0 ; for ( ; if_idx < nb_input_files ; if_idx ++ ) { InputFile * f = input_files [ if_idx ] ; if ( ist_idx < f -> nb_streams ) return f -> streams [ ist_idx ] ; ist_idx = 0 ; } return NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@remove_avoptions": "void remove_avoptions ( AVDictionary * * a , AVDictionary * b ) { const AVDictionaryEntry * t = NULL ; while ( ( t = av_dict_iterate ( b , t ) ) ) { av_dict_set ( a , t -> key , NULL , AV_DICT_MATCH_CASE ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@assert_avoptions": "void assert_avoptions ( AVDictionary * m ) { const AVDictionaryEntry * t ; if ( ( t = av_dict_get ( m , \"\" , NULL , AV_DICT_IGNORE_SUFFIX ) ) ) { av_log ( NULL , AV_LOG_FATAL , \"Option %s not found.\\n\" , t -> key ) ; exit_program ( 1 ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@abort_codec_experimental": "static void abort_codec_experimental ( const AVCodec * c , int encoder ) { exit_program ( 1 ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@update_benchmark": "static void update_benchmark ( const char * fmt , ... ) { if ( do_benchmark_all ) { BenchmarkTimeStamps t = get_benchmark_time_stamps ( ) ; va_list va ; char buf [ 1024 ] ; if ( fmt ) { va_start ( va , fmt ) ; vsnprintf ( buf , sizeof ( buf ) , fmt , va ) ; va_end ( va ) ; av_log ( NULL , AV_LOG_INFO , \"bench: %8\" PRIu64 \" user %8\" PRIu64 \" sys %8\" PRIu64 \" real %s \\n\" , t . user_usec - current_time . user_usec , t . sys_usec - current_time . sys_usec , t . real_usec - current_time . real_usec , buf ) ; } current_time = t ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@close_output_stream": "static void close_output_stream ( OutputStream * ost ) { OutputFile * of = output_files [ ost -> file_index ] ; ost -> finished |= ENCODER_FINISHED ; if ( ost -> sq_idx_encode >= 0 ) sq_send ( of -> sq_encode , ost -> sq_idx_encode , SQFRAME ( NULL ) ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@check_recording_time": "static int check_recording_time ( OutputStream * ost , int64_t ts , AVRational tb ) { OutputFile * of = output_files [ ost -> file_index ] ; if ( of -> recording_time != INT64_MAX && av_compare_ts ( ts , tb , of -> recording_time , AV_TIME_BASE_Q ) >= 0 ) { close_output_stream ( ost ) ; return 0 ; } return 1 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@adjust_frame_pts_to_encoder_tb": "static double adjust_frame_pts_to_encoder_tb ( OutputFile * of , OutputStream * ost , AVFrame * frame ) { double float_pts = AV_NOPTS_VALUE ; // this is identical to frame.pts but with higher precision const int64_t start_time = ( of -> start_time == AV_NOPTS_VALUE ) ? 0 : of -> start_time ; AVCodecContext * const enc = ost -> enc_ctx ; AVRational tb = enc -> time_base ; AVRational filter_tb = frame -> time_base ; const int extra_bits = av_clip ( 29 - av_log2 ( tb . den ) , 0 , 16 ) ; if ( frame -> pts == AV_NOPTS_VALUE ) goto early_exit ; tb . den <<= extra_bits ; float_pts = av_rescale_q ( frame -> pts , filter_tb , tb ) - av_rescale_q ( start_time , AV_TIME_BASE_Q , tb ) ; float_pts /= 1 << extra_bits ; // avoid exact midoints to reduce the chance of rounding differences, this // can be removed in case the fps code is changed to work with integers float_pts += FFSIGN ( float_pts ) * 1.0 / ( 1 << 17 ) ; frame -> pts = av_rescale_q ( frame -> pts , filter_tb , enc -> time_base ) - av_rescale_q ( start_time , AV_TIME_BASE_Q , enc -> time_base ) ; frame -> time_base = enc -> time_base ; early_exit : if ( debug_ts ) { av_log ( NULL , AV_LOG_INFO , \"filter -> pts:%s pts_time:%s exact:%f time_base:%d/%d\\n\" , frame ? av_ts2str ( frame -> pts ) : \"NULL\" , ( enc && frame ) ? av_ts2timestr ( frame -> pts , & enc -> time_base ) : \"NULL\" , float_pts , enc ? enc -> time_base . num : - 1 , enc ? enc -> time_base . den : - 1 ) ; } return float_pts ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@init_output_stream_wrapper": "static int init_output_stream_wrapper ( OutputStream * ost , AVFrame * frame , unsigned int fatal ) { int ret = AVERROR_BUG ; char error [ 1024 ] = { 0 } ; if ( ost -> initialized ) return 0 ; ret = init_output_stream ( ost , frame , error , sizeof ( error ) ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error initializing output stream: %s\\n\" , error ) ; if ( fatal ) exit_program ( 1 ) ; } return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@psnr": "static double psnr ( double d ) { return - 10.0 * log10 ( d ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@update_video_stats": "static void update_video_stats ( OutputStream * ost , const AVPacket * pkt , int write_vstats ) { const uint8_t * sd = av_packet_get_side_data ( pkt , AV_PKT_DATA_QUALITY_STATS , NULL ) ; AVCodecContext * enc = ost -> enc_ctx ; int64_t frame_number ; double ti1 , bitrate , avg_bitrate ; ost -> quality = sd ? AV_RL32 ( sd ) : - 1 ; ost -> pict_type = sd ? sd [ 4 ] : AV_PICTURE_TYPE_NONE ; for ( int i = 0 ; i < FF_ARRAY_ELEMS ( ost -> error ) ; i ++ ) { if ( sd && i < sd [ 5 ] ) ost -> error [ i ] = AV_RL64 ( sd + 8 + 8 * i ) ; else ost -> error [ i ] = - 1 ; } if ( ! write_vstats ) return ; /* this is executed just the first time update_video_stats is called */ if ( ! vstats_file ) { vstats_file = fopen ( vstats_filename , \"w\" ) ; if ( ! vstats_file ) { perror ( \"fopen\" ) ; exit_program ( 1 ) ; } } frame_number = ost -> packets_encoded ; if ( vstats_version <= 1 ) { fprintf ( vstats_file , \"frame= %5\" PRId64 \" q= %2.1f \" , frame_number , ost -> quality / ( float ) FF_QP2LAMBDA ) ; } else { fprintf ( vstats_file , \"out= %2d st= %2d frame= %5\" PRId64 \" q= %2.1f \" , ost -> file_index , ost -> index , frame_number , ost -> quality / ( float ) FF_QP2LAMBDA ) ; } if ( ost -> error [ 0 ] >= 0 && ( enc -> flags & AV_CODEC_FLAG_PSNR ) ) fprintf ( vstats_file , \"PSNR= %6.2f \" , psnr ( ost -> error [ 0 ] / ( enc -> width * enc -> height * 255.0 * 255.0 ) ) ) ; fprintf ( vstats_file , \"f_size= %6d \" , pkt -> size ) ; /* compute pts value */ ti1 = pkt -> dts * av_q2d ( pkt -> time_base ) ; if ( ti1 < 0.01 ) ti1 = 0.01 ; bitrate = ( pkt -> size * 8 ) / av_q2d ( enc -> time_base ) / 1000.0 ; avg_bitrate = ( double ) ( ost -> data_size_enc * 8 ) / ti1 / 1000.0 ; fprintf ( vstats_file , \"s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s \" , ( double ) ost -> data_size_enc / 1024 , ti1 , bitrate , avg_bitrate ) ; fprintf ( vstats_file , \"type= %c\\n\" , av_get_picture_type_char ( ost -> pict_type ) ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@enc_stats_write": "void enc_stats_write ( OutputStream * ost , EncStats * es , const AVFrame * frame , const AVPacket * pkt , uint64_t frame_num ) { AVIOContext * io = es -> io ; AVRational tb = frame ? frame -> time_base : pkt -> time_base ; int64_t pts = frame ? frame -> pts : pkt -> pts ; AVRational tbi = ( AVRational ) { 0 , 1 } ; int64_t ptsi = INT64_MAX ; const FrameData * fd ; if ( ( frame && frame -> opaque_ref ) || ( pkt && pkt -> opaque_ref ) ) { fd = ( const FrameData * ) ( frame ? frame -> opaque_ref -> data : pkt -> opaque_ref -> data ) ; tbi = fd -> tb ; ptsi = fd -> pts ; } for ( size_t i = 0 ; i < es -> nb_components ; i ++ ) { const EncStatsComponent * c = & es -> components [ i ] ; switch ( c -> type ) { case ENC_STATS_LITERAL : avio_write ( io , c -> str , c -> str_len ) ; continue ; case ENC_STATS_FILE_IDX : avio_printf ( io , \"%d\" , ost -> file_index ) ; continue ; case ENC_STATS_STREAM_IDX : avio_printf ( io , \"%d\" , ost -> index ) ; continue ; case ENC_STATS_TIMEBASE : avio_printf ( io , \"%d/%d\" , tb . num , tb . den ) ; continue ; case ENC_STATS_TIMEBASE_IN : avio_printf ( io , \"%d/%d\" , tbi . num , tbi . den ) ; continue ; case ENC_STATS_PTS : avio_printf ( io , \"%\" PRId64 , pts ) ; continue ; case ENC_STATS_PTS_IN : avio_printf ( io , \"%\" PRId64 , ptsi ) ; continue ; case ENC_STATS_PTS_TIME : avio_printf ( io , \"%g\" , pts * av_q2d ( tb ) ) ; continue ; case ENC_STATS_PTS_TIME_IN : avio_printf ( io , \"%g\" , ptsi == INT64_MAX ? INFINITY : ptsi * av_q2d ( tbi ) ) ; continue ; case ENC_STATS_FRAME_NUM : avio_printf ( io , \"%\" PRIu64 , frame_num ) ; continue ; case ENC_STATS_FRAME_NUM_IN : avio_printf ( io , \"%\" PRIu64 , fd ? fd -> idx : - 1 ) ; continue ; } if ( frame ) { switch ( c -> type ) { case ENC_STATS_SAMPLE_NUM : avio_printf ( io , \"%\" PRIu64 , ost -> samples_encoded ) ; continue ; case ENC_STATS_NB_SAMPLES : avio_printf ( io , \"%d\" , frame -> nb_samples ) ; continue ; default : av_assert0 ( 0 ) ; } } else { switch ( c -> type ) { case ENC_STATS_DTS : avio_printf ( io , \"%\" PRId64 , pkt -> dts ) ; continue ; case ENC_STATS_DTS_TIME : avio_printf ( io , \"%g\" , pkt -> dts * av_q2d ( tb ) ) ; continue ; case ENC_STATS_PKT_SIZE : avio_printf ( io , \"%d\" , pkt -> size ) ; continue ; case ENC_STATS_BITRATE : { double duration = FFMAX ( pkt -> duration , 1 ) * av_q2d ( tb ) ; avio_printf ( io , \"%g\" , 8.0 * pkt -> size / duration ) ; continue ; } case ENC_STATS_AVG_BITRATE : { double duration = pkt -> dts * av_q2d ( tb ) ; avio_printf ( io , \"%g\" , duration > 0 ? 8.0 * ost -> data_size_enc / duration : - 1. ) ; continue ; } default : av_assert0 ( 0 ) ; } } } avio_w8 ( io , '\\n' ) ; avio_flush ( io ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@encode_frame": "static int encode_frame ( OutputFile * of , OutputStream * ost , AVFrame * frame ) { AVCodecContext * enc = ost -> enc_ctx ; AVPacket * pkt = ost -> pkt ; const char * type_desc = av_get_media_type_string ( enc -> codec_type ) ; const char * action = frame ? \"encode\" : \"flush\" ; int ret ; if ( frame ) { if ( ost -> enc_stats_pre . io ) enc_stats_write ( ost , & ost -> enc_stats_pre , frame , NULL , ost -> frames_encoded ) ; ost -> frames_encoded ++ ; ost -> samples_encoded += frame -> nb_samples ; if ( debug_ts ) { av_log ( ost , AV_LOG_INFO , \"encoder <- type:%s \" \"frame_pts:%s frame_pts_time:%s time_base:%d/%d\\n\" , type_desc , av_ts2str ( frame -> pts ) , av_ts2timestr ( frame -> pts , & enc -> time_base ) , enc -> time_base . num , enc -> time_base . den ) ; } } update_benchmark ( NULL ) ; ret = avcodec_send_frame ( enc , frame ) ; if ( ret < 0 && ! ( ret == AVERROR_EOF && ! frame ) ) { av_log ( ost , AV_LOG_ERROR , \"Error submitting %s frame to the encoder\\n\" , type_desc ) ; return ret ; } while ( 1 ) { ret = avcodec_receive_packet ( enc , pkt ) ; update_benchmark ( \"%s_%s %d.%d\" , action , type_desc , ost -> file_index , ost -> index ) ; pkt -> time_base = enc -> time_base ; /* if two pass, output log on success and EOF */ if ( ( ret >= 0 || ret == AVERROR_EOF ) && ost -> logfile && enc -> stats_out ) fprintf ( ost -> logfile , \"%s\" , enc -> stats_out ) ; if ( ret == AVERROR ( EAGAIN ) ) { av_assert0 ( frame ) ; // should never happen during flushing return 0 ; } else if ( ret == AVERROR_EOF ) { of_output_packet ( of , pkt , ost , 1 ) ; return ret ; } else if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"%s encoding failed\\n\" , type_desc ) ; return ret ; } if ( enc -> codec_type == AVMEDIA_TYPE_VIDEO ) update_video_stats ( ost , pkt , ! ! vstats_filename ) ; if ( ost -> enc_stats_post . io ) enc_stats_write ( ost , & ost -> enc_stats_post , NULL , pkt , ost -> packets_encoded ) ; if ( debug_ts ) { av_log ( ost , AV_LOG_INFO , \"encoder -> type:%s \" \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s \" \"duration:%s duration_time:%s\\n\" , type_desc , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & enc -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & enc -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & enc -> time_base ) ) ; } av_packet_rescale_ts ( pkt , pkt -> time_base , ost -> mux_timebase ) ; pkt -> time_base = ost -> mux_timebase ; if ( debug_ts ) { av_log ( ost , AV_LOG_INFO , \"encoder -> type:%s \" \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s \" \"duration:%s duration_time:%s\\n\" , type_desc , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & enc -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & enc -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & enc -> time_base ) ) ; } if ( ( ret = trigger_fix_sub_duration_heartbeat ( ost , pkt ) ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Subtitle heartbeat logic failed in %s! (%s)\\n\" , __func__ , av_err2str ( ret ) ) ; exit_program ( 1 ) ; } ost -> data_size_enc += pkt -> size ; ost -> packets_encoded ++ ; of_output_packet ( of , pkt , ost , 0 ) ; } av_assert0 ( 0 ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@submit_encode_frame": "static int submit_encode_frame ( OutputFile * of , OutputStream * ost , AVFrame * frame ) { int ret ; if ( ost -> sq_idx_encode < 0 ) return encode_frame ( of , ost , frame ) ; if ( frame ) { ret = av_frame_ref ( ost -> sq_frame , frame ) ; if ( ret < 0 ) return ret ; frame = ost -> sq_frame ; } ret = sq_send ( of -> sq_encode , ost -> sq_idx_encode , SQFRAME ( frame ) ) ; if ( ret < 0 ) { if ( frame ) av_frame_unref ( frame ) ; if ( ret != AVERROR_EOF ) return ret ; } while ( 1 ) { AVFrame * enc_frame = ost -> sq_frame ; ret = sq_receive ( of -> sq_encode , ost -> sq_idx_encode , SQFRAME ( enc_frame ) ) ; if ( ret == AVERROR_EOF ) { enc_frame = NULL ; } else if ( ret < 0 ) { return ( ret == AVERROR ( EAGAIN ) ) ? 0 : ret ; } ret = encode_frame ( of , ost , enc_frame ) ; if ( enc_frame ) av_frame_unref ( enc_frame ) ; if ( ret < 0 ) { if ( ret == AVERROR_EOF ) close_output_stream ( ost ) ; return ret ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@do_audio_out": "static void do_audio_out ( OutputFile * of , OutputStream * ost , AVFrame * frame ) { AVCodecContext * enc = ost -> enc_ctx ; int ret ; if ( frame -> pts == AV_NOPTS_VALUE ) frame -> pts = ost -> next_pts ; else { int64_t start_time = ( of -> start_time == AV_NOPTS_VALUE ) ? 0 : of -> start_time ; frame -> pts = av_rescale_q ( frame -> pts , frame -> time_base , enc -> time_base ) - av_rescale_q ( start_time , AV_TIME_BASE_Q , enc -> time_base ) ; } frame -> time_base = enc -> time_base ; if ( ! check_recording_time ( ost , frame -> pts , frame -> time_base ) ) return ; ost -> next_pts = frame -> pts + frame -> nb_samples ; ret = submit_encode_frame ( of , ost , frame ) ; if ( ret < 0 && ret != AVERROR_EOF ) exit_program ( 1 ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@do_subtitle_out": "static void do_subtitle_out ( OutputFile * of , OutputStream * ost , AVSubtitle * sub ) { int subtitle_out_max_size = 1024 * 1024 ; int subtitle_out_size , nb , i , ret ; AVCodecContext * enc ; AVPacket * pkt = ost -> pkt ; int64_t pts ; if ( sub -> pts == AV_NOPTS_VALUE ) { av_log ( ost , AV_LOG_ERROR , \"Subtitle packets must have a pts\\n\" ) ; if ( exit_on_error ) exit_program ( 1 ) ; return ; } enc = ost -> enc_ctx ; /* Note: DVB subtitle need one packet to draw them and one other\n       packet to clear them */ /* XXX: signal it in the codec context ? */ if ( enc -> codec_id == AV_CODEC_ID_DVB_SUBTITLE ) nb = 2 ; else nb = 1 ; /* shift timestamp to honor -ss and make check_recording_time() work with -t */ pts = sub -> pts ; if ( output_files [ ost -> file_index ] -> start_time != AV_NOPTS_VALUE ) pts -= output_files [ ost -> file_index ] -> start_time ; for ( i = 0 ; i < nb ; i ++ ) { unsigned save_num_rects = sub -> num_rects ; if ( ! check_recording_time ( ost , pts , AV_TIME_BASE_Q ) ) return ; ret = av_new_packet ( pkt , subtitle_out_max_size ) ; if ( ret < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; sub -> pts = pts ; // start_display_time is required to be 0 sub -> pts += av_rescale_q ( sub -> start_display_time , ( AVRational ) { 1 , 1000 } , AV_TIME_BASE_Q ) ; sub -> end_display_time -= sub -> start_display_time ; sub -> start_display_time = 0 ; if ( i == 1 ) sub -> num_rects = 0 ; ost -> frames_encoded ++ ; subtitle_out_size = avcodec_encode_subtitle ( enc , pkt -> data , pkt -> size , sub ) ; if ( i == 1 ) sub -> num_rects = save_num_rects ; if ( subtitle_out_size < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Subtitle encoding failed\\n\" ) ; exit_program ( 1 ) ; } av_shrink_packet ( pkt , subtitle_out_size ) ; pkt -> time_base = ost -> mux_timebase ; pkt -> pts = av_rescale_q ( sub -> pts , AV_TIME_BASE_Q , pkt -> time_base ) ; pkt -> duration = av_rescale_q ( sub -> end_display_time , ( AVRational ) { 1 , 1000 } , pkt -> time_base ) ; if ( enc -> codec_id == AV_CODEC_ID_DVB_SUBTITLE ) { /* XXX: the pts correction is handled here. Maybe handling\n               it in the codec would be better */ if ( i == 0 ) pkt -> pts += av_rescale_q ( sub -> start_display_time , ( AVRational ) { 1 , 1000 } , pkt -> time_base ) ; else pkt -> pts += av_rescale_q ( sub -> end_display_time , ( AVRational ) { 1 , 1000 } , pkt -> time_base ) ; } pkt -> dts = pkt -> pts ; of_output_packet ( of , pkt , ost , 0 ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@video_sync_process": "static void video_sync_process ( OutputFile * of , OutputStream * ost , AVFrame * next_picture , double duration , int64_t * nb_frames , int64_t * nb_frames_prev ) { double delta0 , delta ; double sync_ipts = adjust_frame_pts_to_encoder_tb ( of , ost , next_picture ) ; /* delta0 is the \"drift\" between the input frame (next_picture) and\n     * where it would fall in the output. */ delta0 = sync_ipts - ost -> next_pts ; delta = delta0 + duration ; // tracks the number of times the PREVIOUS frame should be duplicated, // mostly for variable framerate (VFR) * nb_frames_prev = 0 ; /* by default, we output a single frame */ * nb_frames = 1 ; if ( delta0 < 0 && delta > 0 && ost -> vsync_method != VSYNC_PASSTHROUGH && ost -> vsync_method != VSYNC_DROP ) { if ( delta0 < - 0.6 ) { av_log ( ost , AV_LOG_VERBOSE , \"Past duration %f too large\\n\" , - delta0 ) ; } else av_log ( ost , AV_LOG_DEBUG , \"Clipping frame in rate conversion by %f\\n\" , - delta0 ) ; sync_ipts = ost -> next_pts ; duration += delta0 ; delta0 = 0 ; } switch ( ost -> vsync_method ) { case VSYNC_VSCFR : if ( ost -> vsync_frame_number == 0 && delta0 >= 0.5 ) { av_log ( ost , AV_LOG_DEBUG , \"Not duplicating %d initial frames\\n\" , ( int ) lrintf ( delta0 ) ) ; delta = duration ; delta0 = 0 ; ost -> next_pts = llrint ( sync_ipts ) ; } case VSYNC_CFR : // FIXME set to 0.5 after we fix some dts/pts bugs like in avidec.c if ( frame_drop_threshold && delta < frame_drop_threshold && ost -> vsync_frame_number ) { * nb_frames = 0 ; } else if ( delta < - 1.1 ) * nb_frames = 0 ; else if ( delta > 1.1 ) { * nb_frames = llrintf ( delta ) ; if ( delta0 > 1.1 ) * nb_frames_prev = llrintf ( delta0 - 0.6 ) ; } next_picture -> duration = 1 ; break ; case VSYNC_VFR : if ( delta <= - 0.6 ) * nb_frames = 0 ; else if ( delta > 0.6 ) ost -> next_pts = llrint ( sync_ipts ) ; next_picture -> duration = duration ; break ; case VSYNC_DROP : case VSYNC_PASSTHROUGH : next_picture -> duration = duration ; ost -> next_pts = llrint ( sync_ipts ) ; break ; default : av_assert0 ( 0 ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@forced_kf_apply": "enum AVPictureType forced_kf_apply ( void * logctx , KeyframeForceCtx * kf , AVRational tb , const AVFrame * in_picture , int dup_idx ) { double pts_time ; if ( kf -> ref_pts == AV_NOPTS_VALUE ) kf -> ref_pts = in_picture -> pts ; pts_time = ( in_picture -> pts - kf -> ref_pts ) * av_q2d ( tb ) ; if ( kf -> index < kf -> nb_pts && av_compare_ts ( in_picture -> pts , tb , kf -> pts [ kf -> index ] , AV_TIME_BASE_Q ) >= 0 ) { kf -> index ++ ; goto force_keyframe ; } else if ( kf -> pexpr ) { double res ; kf -> expr_const_values [ FKF_T ] = pts_time ; res = av_expr_eval ( kf -> pexpr , kf -> expr_const_values , NULL ) ; ff_dlog ( NULL , \"force_key_frame: n:%f n_forced:%f prev_forced_n:%f t:%f prev_forced_t:%f -> res:%f\\n\" , kf -> expr_const_values [ FKF_N ] , kf -> expr_const_values [ FKF_N_FORCED ] , kf -> expr_const_values [ FKF_PREV_FORCED_N ] , kf -> expr_const_values [ FKF_T ] , kf -> expr_const_values [ FKF_PREV_FORCED_T ] , res ) ; kf -> expr_const_values [ FKF_N ] += 1 ; if ( res ) { kf -> expr_const_values [ FKF_PREV_FORCED_N ] = kf -> expr_const_values [ FKF_N ] - 1 ; kf -> expr_const_values [ FKF_PREV_FORCED_T ] = kf -> expr_const_values [ FKF_T ] ; kf -> expr_const_values [ FKF_N_FORCED ] += 1 ; goto force_keyframe ; } } else if ( kf -> type == KF_FORCE_SOURCE && in_picture -> key_frame == 1 && ! dup_idx ) { goto force_keyframe ; } else if ( kf -> type == KF_FORCE_SOURCE_NO_DROP && ! dup_idx ) { kf -> dropped_keyframe = 0 ; if ( ( in_picture -> key_frame == 1 ) || kf -> dropped_keyframe ) goto force_keyframe ; } return AV_PICTURE_TYPE_NONE ; force_keyframe : av_log ( logctx , AV_LOG_DEBUG , \"Forced keyframe at time %f\\n\" , pts_time ) ; return AV_PICTURE_TYPE_I ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@do_video_out": "static void do_video_out ( OutputFile * of , OutputStream * ost , AVFrame * next_picture ) { int ret ; AVCodecContext * enc = ost -> enc_ctx ; AVRational frame_rate ; int64_t nb_frames , nb_frames_prev , i ; double duration = 0 ; InputStream * ist = ost -> ist ; AVFilterContext * filter = ost -> filter -> filter ; init_output_stream_wrapper ( ost , next_picture , 1 ) ; frame_rate = av_buffersink_get_frame_rate ( filter ) ; if ( frame_rate . num > 0 && frame_rate . den > 0 ) duration = 1 / ( av_q2d ( frame_rate ) * av_q2d ( enc -> time_base ) ) ; if ( ist && ist -> st -> start_time != AV_NOPTS_VALUE && ist -> first_dts != AV_NOPTS_VALUE && ost -> frame_rate . num ) duration = FFMIN ( duration , 1 / ( av_q2d ( ost -> frame_rate ) * av_q2d ( enc -> time_base ) ) ) ; if ( ! ost -> filters_script && ! ost -> filters && ( nb_filtergraphs == 0 || ! filtergraphs [ 0 ] -> graph_desc ) && next_picture && ist && lrintf ( next_picture -> duration * av_q2d ( ist -> st -> time_base ) / av_q2d ( enc -> time_base ) ) > 0 ) { duration = lrintf ( next_picture -> duration * av_q2d ( ist -> st -> time_base ) / av_q2d ( enc -> time_base ) ) ; } if ( ! next_picture ) { //end, flushing nb_frames_prev = nb_frames = mid_pred ( ost -> last_nb0_frames [ 0 ] , ost -> last_nb0_frames [ 1 ] , ost -> last_nb0_frames [ 2 ] ) ; } else { video_sync_process ( of , ost , next_picture , duration , & nb_frames , & nb_frames_prev ) ; } memmove ( ost -> last_nb0_frames + 1 , ost -> last_nb0_frames , sizeof ( ost -> last_nb0_frames [ 0 ] ) * ( FF_ARRAY_ELEMS ( ost -> last_nb0_frames ) - 1 ) ) ; ost -> last_nb0_frames [ 0 ] = nb_frames_prev ; if ( nb_frames_prev == 0 && ost -> last_dropped ) { nb_frames_drop ++ ; av_log ( ost , AV_LOG_VERBOSE , \"*** dropping frame %\" PRId64 \" at ts %\" PRId64 \"\\n\" , ost -> vsync_frame_number , ost -> last_frame -> pts ) ; } if ( nb_frames > ( nb_frames_prev && ost -> last_dropped ) + ( nb_frames > nb_frames_prev ) ) { if ( nb_frames > dts_error_threshold * 30 ) { av_log ( ost , AV_LOG_ERROR , \"%\" PRId64 \" frame duplication too large, skipping\\n\" , nb_frames - 1 ) ; nb_frames_drop ++ ; return ; } nb_frames_dup += nb_frames - ( nb_frames_prev && ost -> last_dropped ) - ( nb_frames > nb_frames_prev ) ; av_log ( ost , AV_LOG_VERBOSE , \"*** %\" PRId64 \" dup!\\n\" , nb_frames - 1 ) ; if ( nb_frames_dup > dup_warning ) { av_log ( ost , AV_LOG_WARNING , \"More than %\" PRIu64 \" frames duplicated\\n\" , dup_warning ) ; dup_warning *= 10 ; } } ost -> last_dropped = nb_frames == nb_frames_prev && next_picture ; ost -> kf . dropped_keyframe = ost -> last_dropped && next_picture && next_picture -> key_frame ; /* duplicates frame if needed */ for ( i = 0 ; i < nb_frames ; i ++ ) { AVFrame * in_picture ; if ( i < nb_frames_prev && ost -> last_frame -> buf [ 0 ] ) { in_picture = ost -> last_frame ; } else in_picture = next_picture ; if ( ! in_picture ) return ; in_picture -> pts = ost -> next_pts ; if ( ! check_recording_time ( ost , in_picture -> pts , ost -> enc_ctx -> time_base ) ) return ; in_picture -> quality = enc -> global_quality ; in_picture -> pict_type = forced_kf_apply ( ost , & ost -> kf , enc -> time_base , in_picture , i ) ; ret = submit_encode_frame ( of , ost , in_picture ) ; if ( ret == AVERROR_EOF ) break ; else if ( ret < 0 ) exit_program ( 1 ) ; ost -> next_pts ++ ; ost -> vsync_frame_number ++ ; } av_frame_unref ( ost -> last_frame ) ; if ( next_picture ) av_frame_move_ref ( ost -> last_frame , next_picture ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@reap_filters": "static int reap_filters ( int flush ) { AVFrame * filtered_frame = NULL ; /* Reap all buffers present in the buffer sinks */ for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { OutputFile * of = output_files [ ost -> file_index ] ; AVFilterContext * filter ; AVCodecContext * enc = ost -> enc_ctx ; int ret = 0 ; if ( ! ost -> filter || ! ost -> filter -> graph -> graph ) continue ; filter = ost -> filter -> filter ; /*\n         * Unlike video, with audio the audio frame size matters.\n         * Currently we are fully reliant on the lavfi filter chain to\n         * do the buffering deed for us, and thus the frame size parameter\n         * needs to be set accordingly. Where does one get the required\n         * frame size? From the initialized AVCodecContext of an audio\n         * encoder. Thus, if we have gotten to an audio stream, initialize\n         * the encoder earlier than receiving the first AVFrame.\n         */ if ( av_buffersink_get_type ( filter ) == AVMEDIA_TYPE_AUDIO ) init_output_stream_wrapper ( ost , NULL , 1 ) ; filtered_frame = ost -> filtered_frame ; while ( 1 ) { ret = av_buffersink_get_frame_flags ( filter , filtered_frame , AV_BUFFERSINK_FLAG_NO_REQUEST ) ; if ( ret < 0 ) { if ( ret != AVERROR ( EAGAIN ) && ret != AVERROR_EOF ) { av_log ( NULL , AV_LOG_WARNING , \"Error in av_buffersink_get_frame_flags(): %s\\n\" , av_err2str ( ret ) ) ; } else if ( flush && ret == AVERROR_EOF ) { if ( av_buffersink_get_type ( filter ) == AVMEDIA_TYPE_VIDEO ) do_video_out ( of , ost , NULL ) ; } break ; } if ( ost -> finished ) { av_frame_unref ( filtered_frame ) ; continue ; } if ( filtered_frame -> pts != AV_NOPTS_VALUE ) { AVRational tb = av_buffersink_get_time_base ( filter ) ; ost -> last_filter_pts = av_rescale_q ( filtered_frame -> pts , tb , AV_TIME_BASE_Q ) ; filtered_frame -> time_base = tb ; if ( debug_ts ) av_log ( NULL , AV_LOG_INFO , \"filter_raw -> pts:%s pts_time:%s time_base:%d/%d\\n\" , av_ts2str ( filtered_frame -> pts ) , av_ts2timestr ( filtered_frame -> pts , & tb ) , tb . num , tb . den ) ; } switch ( av_buffersink_get_type ( filter ) ) { case AVMEDIA_TYPE_VIDEO : if ( ! ost -> frame_aspect_ratio . num ) enc -> sample_aspect_ratio = filtered_frame -> sample_aspect_ratio ; do_video_out ( of , ost , filtered_frame ) ; break ; case AVMEDIA_TYPE_AUDIO : if ( ! ( enc -> codec -> capabilities & AV_CODEC_CAP_PARAM_CHANGE ) && enc -> ch_layout . nb_channels != filtered_frame -> ch_layout . nb_channels ) { av_log ( NULL , AV_LOG_ERROR , \"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\" ) ; break ; } do_audio_out ( of , ost , filtered_frame ) ; break ; default : // TODO support subtitle filters av_assert0 ( 0 ) ; } av_frame_unref ( filtered_frame ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@print_final_stats": "static void print_final_stats ( int64_t total_size ) { uint64_t video_size = 0 , audio_size = 0 , extra_size = 0 , other_size = 0 ; uint64_t subtitle_size = 0 ; uint64_t data_size = 0 ; float percent = - 1.0 ; int i , j ; int pass1_used = 1 ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { AVCodecParameters * par = ost -> st -> codecpar ; const uint64_t s = ost -> data_size_mux ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : video_size += s ; break ; case AVMEDIA_TYPE_AUDIO : audio_size += s ; break ; case AVMEDIA_TYPE_SUBTITLE : subtitle_size += s ; break ; default : other_size += s ; break ; } extra_size += par -> extradata_size ; data_size += s ; if ( ost -> enc_ctx && ( ost -> enc_ctx -> flags & ( AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2 ) ) != AV_CODEC_FLAG_PASS1 ) pass1_used = 0 ; } if ( data_size && total_size > 0 && total_size >= data_size ) percent = 100.0 * ( total_size - data_size ) / data_size ; av_log ( NULL , AV_LOG_INFO , \"video:%1.0fkB audio:%1.0fkB subtitle:%1.0fkB other streams:%1.0fkB global headers:%1.0fkB muxing overhead: \" , video_size / 1024.0 , audio_size / 1024.0 , subtitle_size / 1024.0 , other_size / 1024.0 , extra_size / 1024.0 ) ; if ( percent >= 0.0 ) av_log ( NULL , AV_LOG_INFO , \"%f%%\" , percent ) ; else av_log ( NULL , AV_LOG_INFO , \"unknown\" ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; /* print verbose per-stream stats */ for ( i = 0 ; i < nb_input_files ; i ++ ) { InputFile * f = input_files [ i ] ; uint64_t total_packets = 0 , total_size = 0 ; av_log ( NULL , AV_LOG_VERBOSE , \"Input file #%d (%s):\\n\" , i , f -> ctx -> url ) ; for ( j = 0 ; j < f -> nb_streams ; j ++ ) { InputStream * ist = f -> streams [ j ] ; enum AVMediaType type = ist -> par -> codec_type ; total_size += ist -> data_size ; total_packets += ist -> nb_packets ; av_log ( NULL , AV_LOG_VERBOSE , \"  Input stream #%d:%d (%s): \" , i , j , av_get_media_type_string ( type ) ) ; av_log ( NULL , AV_LOG_VERBOSE , \"%\" PRIu64 \" packets read (%\" PRIu64 \" bytes); \" , ist -> nb_packets , ist -> data_size ) ; if ( ist -> decoding_needed ) { av_log ( NULL , AV_LOG_VERBOSE , \"%\" PRIu64 \" frames decoded\" , ist -> frames_decoded ) ; if ( type == AVMEDIA_TYPE_AUDIO ) av_log ( NULL , AV_LOG_VERBOSE , \" (%\" PRIu64 \" samples)\" , ist -> samples_decoded ) ; av_log ( NULL , AV_LOG_VERBOSE , \"; \" ) ; } av_log ( NULL , AV_LOG_VERBOSE , \"\\n\" ) ; } av_log ( NULL , AV_LOG_VERBOSE , \"  Total: %\" PRIu64 \" packets (%\" PRIu64 \" bytes) demuxed\\n\" , total_packets , total_size ) ; } for ( i = 0 ; i < nb_output_files ; i ++ ) { OutputFile * of = output_files [ i ] ; uint64_t total_packets = 0 , total_size = 0 ; av_log ( NULL , AV_LOG_VERBOSE , \"Output file #%d (%s):\\n\" , i , of -> url ) ; for ( j = 0 ; j < of -> nb_streams ; j ++ ) { OutputStream * ost = of -> streams [ j ] ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; total_size += ost -> data_size_mux ; total_packets += atomic_load ( & ost -> packets_written ) ; av_log ( NULL , AV_LOG_VERBOSE , \"  Output stream #%d:%d (%s): \" , i , j , av_get_media_type_string ( type ) ) ; if ( ost -> enc_ctx ) { av_log ( NULL , AV_LOG_VERBOSE , \"%\" PRIu64 \" frames encoded\" , ost -> frames_encoded ) ; if ( type == AVMEDIA_TYPE_AUDIO ) av_log ( NULL , AV_LOG_VERBOSE , \" (%\" PRIu64 \" samples)\" , ost -> samples_encoded ) ; av_log ( NULL , AV_LOG_VERBOSE , \"; \" ) ; } av_log ( NULL , AV_LOG_VERBOSE , \"%\" PRIu64 \" packets muxed (%\" PRIu64 \" bytes); \" , atomic_load ( & ost -> packets_written ) , ost -> data_size_mux ) ; av_log ( NULL , AV_LOG_VERBOSE , \"\\n\" ) ; } av_log ( NULL , AV_LOG_VERBOSE , \"  Total: %\" PRIu64 \" packets (%\" PRIu64 \" bytes) muxed\\n\" , total_packets , total_size ) ; } if ( video_size + data_size + audio_size + subtitle_size + extra_size == 0 ) { av_log ( NULL , AV_LOG_WARNING , \"Output file is empty, nothing was encoded \" ) ; if ( pass1_used ) { av_log ( NULL , AV_LOG_WARNING , \"\\n\" ) ; } else { av_log ( NULL , AV_LOG_WARNING , \"(check -ss / -t / -frames parameters if used)\\n\" ) ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@forward_report": "static void forward_report ( uint64_t frame_number , float fps , float quality , int64_t total_size , int64_t pts , double bitrate , double speed ) { // FORWARD DATA if ( report_callback != NULL ) { double milliseconds = 0 ; if ( pts != AV_NOPTS_VALUE ) { milliseconds = ( ( double ) FFABS64U ( pts ) ) / 1000 ; } if ( pts < 0 ) { report_callback ( frame_number , fps , quality , total_size , 0 - milliseconds , bitrate , speed ) ; } else { report_callback ( frame_number , fps , quality , total_size , milliseconds , bitrate , speed ) ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@print_report": "static void print_report ( int is_last_report , int64_t timer_start , int64_t cur_time ) { AVBPrint buf , buf_script ; int64_t total_size = of_filesize ( output_files [ 0 ] ) ; int vid ; double bitrate ; double speed ; int64_t pts = AV_NOPTS_VALUE ; int mins , secs , us ; int64_t hours ; const char * hours_sign ; int ret ; float t ; // FFmpegKit field declarations int local_print_stats = 1 ; uint64_t frame_number = 0 ; float fps = 0 ; float q = 0 ; if ( ! print_stats && ! is_last_report && ! progress_avio ) local_print_stats = 0 ; if ( ! is_last_report ) { if ( last_time == - 1 ) { last_time = cur_time ; } if ( ( ( cur_time - last_time ) < stats_period && ! first_report ) || ( first_report && nb_output_dumped < nb_output_files ) ) return ; last_time = cur_time ; } t = ( cur_time - timer_start ) / 1000000.0 ; vid = 0 ; if ( local_print_stats ) { av_bprint_init ( & buf , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; av_bprint_init ( & buf_script , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; } for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { const AVCodecContext * const enc = ost -> enc_ctx ; q = enc ? ost -> quality / ( float ) FF_QP2LAMBDA : - 1 ; if ( local_print_stats && vid && ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { av_bprintf ( & buf , \"q=%2.1f \" , q ) ; av_bprintf ( & buf_script , \"stream_%d_%d_q=%.1f\\n\" , ost -> file_index , ost -> index , q ) ; } if ( ! vid && ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { frame_number = atomic_load ( & ost -> packets_written ) ; fps = t > 1 ? frame_number / t : 0 ; if ( local_print_stats ) { av_bprintf ( & buf , \"frame=%5\" PRId64 \" fps=%3.*f q=%3.1f \" , frame_number , fps < 9.95 , fps , q ) ; av_bprintf ( & buf_script , \"frame=%\" PRId64 \"\\n\" , frame_number ) ; av_bprintf ( & buf_script , \"fps=%.2f\\n\" , fps ) ; av_bprintf ( & buf_script , \"stream_%d_%d_q=%.1f\\n\" , ost -> file_index , ost -> index , q ) ; } if ( local_print_stats && is_last_report ) av_bprintf ( & buf , \"L\" ) ; if ( qp_hist ) { int j ; int qp = lrintf ( q ) ; if ( qp >= 0 && qp < FF_ARRAY_ELEMS ( qp_histogram ) ) qp_histogram [ qp ] ++ ; if ( local_print_stats ) { for ( j = 0 ; j < 32 ; j ++ ) av_bprintf ( & buf , \"%X\" , av_log2 ( qp_histogram [ j ] + 1 ) ) ; } } if ( local_print_stats && enc && ( enc -> flags & AV_CODEC_FLAG_PSNR ) && ( ost -> pict_type != AV_PICTURE_TYPE_NONE || is_last_report ) ) { int j ; double error , error_sum = 0 ; double scale , scale_sum = 0 ; double p ; char type [ 3 ] = { 'Y' , 'U' , 'V' } ; av_bprintf ( & buf , \"PSNR=\" ) ; for ( j = 0 ; j < 3 ; j ++ ) { if ( is_last_report ) { error = enc -> error [ j ] ; scale = enc -> width * enc -> height * 255.0 * 255.0 * frame_number ; } else { error = ost -> error [ j ] ; scale = enc -> width * enc -> height * 255.0 * 255.0 ; } if ( j ) scale /= 4 ; error_sum += error ; scale_sum += scale ; p = psnr ( error / scale ) ; av_bprintf ( & buf , \"%c:%2.2f \" , type [ j ] , p ) ; av_bprintf ( & buf_script , \"stream_%d_%d_psnr_%c=%2.2f\\n\" , ost -> file_index , ost -> index , type [ j ] | 32 , p ) ; } p = psnr ( error_sum / scale_sum ) ; av_bprintf ( & buf , \"*:%2.2f \" , psnr ( error_sum / scale_sum ) ) ; av_bprintf ( & buf_script , \"stream_%d_%d_psnr_all=%2.2f\\n\" , ost -> file_index , ost -> index , p ) ; } vid = 1 ; } /* compute min output value */ if ( ost -> last_mux_dts != AV_NOPTS_VALUE ) { if ( pts == AV_NOPTS_VALUE || ost -> last_mux_dts > pts ) pts = ost -> last_mux_dts ; if ( copy_ts ) { if ( copy_ts_first_pts == AV_NOPTS_VALUE && pts > 1 ) copy_ts_first_pts = pts ; if ( copy_ts_first_pts != AV_NOPTS_VALUE ) pts -= copy_ts_first_pts ; } } if ( is_last_report ) nb_frames_drop += ost -> last_dropped ; } us = FFABS64U ( pts ) % AV_TIME_BASE ; secs = FFABS64U ( pts ) / AV_TIME_BASE % 60 ; mins = FFABS64U ( pts ) / AV_TIME_BASE / 60 % 60 ; hours = FFABS64U ( pts ) / AV_TIME_BASE / 3600 ; hours_sign = ( pts < 0 ) ? \"-\" : \"\" ; bitrate = pts != AV_NOPTS_VALUE && pts && total_size >= 0 ? total_size * 8 / ( pts / 1000.0 ) : - 1 ; speed = pts != AV_NOPTS_VALUE && t != 0.0 ? ( double ) pts / AV_TIME_BASE / t : - 1 ; // FFmpegKit forward report forward_report ( frame_number , fps , q , total_size , pts , bitrate , speed ) ; if ( local_print_stats ) { if ( total_size < 0 ) av_bprintf ( & buf , \"size=N/A time=\" ) ; else av_bprintf ( & buf , \"size=%8.0fkB time=\" , total_size / 1024.0 ) ; if ( pts == AV_NOPTS_VALUE ) { av_bprintf ( & buf , \"N/A \" ) ; } else { av_bprintf ( & buf , \"%s%02\" PRId64 \":%02d:%02d.%02d \" , hours_sign , hours , mins , secs , ( 100 * us ) / AV_TIME_BASE ) ; } if ( bitrate < 0 ) { av_bprintf ( & buf , \"bitrate=N/A\" ) ; av_bprintf ( & buf_script , \"bitrate=N/A\\n\" ) ; } else { av_bprintf ( & buf , \"bitrate=%6.1fkbits/s\" , bitrate ) ; av_bprintf ( & buf_script , \"bitrate=%6.1fkbits/s\\n\" , bitrate ) ; } if ( total_size < 0 ) av_bprintf ( & buf_script , \"total_size=N/A\\n\" ) ; else av_bprintf ( & buf_script , \"total_size=%\" PRId64 \"\\n\" , total_size ) ; if ( pts == AV_NOPTS_VALUE ) { av_bprintf ( & buf_script , \"out_time_us=N/A\\n\" ) ; av_bprintf ( & buf_script , \"out_time_ms=N/A\\n\" ) ; av_bprintf ( & buf_script , \"out_time=N/A\\n\" ) ; } else { av_bprintf ( & buf_script , \"out_time_us=%\" PRId64 \"\\n\" , pts ) ; av_bprintf ( & buf_script , \"out_time_ms=%\" PRId64 \"\\n\" , pts ) ; av_bprintf ( & buf_script , \"out_time=%s%02\" PRId64 \":%02d:%02d.%06d\\n\" , hours_sign , hours , mins , secs , us ) ; } if ( nb_frames_dup || nb_frames_drop ) av_bprintf ( & buf , \" dup=%\" PRId64 \" drop=%\" PRId64 , nb_frames_dup , nb_frames_drop ) ; av_bprintf ( & buf_script , \"dup_frames=%\" PRId64 \"\\n\" , nb_frames_dup ) ; av_bprintf ( & buf_script , \"drop_frames=%\" PRId64 \"\\n\" , nb_frames_drop ) ; if ( speed < 0 ) { av_bprintf ( & buf , \" speed=N/A\" ) ; av_bprintf ( & buf_script , \"speed=N/A\\n\" ) ; } else { av_bprintf ( & buf , \" speed=%4.3gx\" , speed ) ; av_bprintf ( & buf_script , \"speed=%4.3gx\\n\" , speed ) ; } if ( print_stats || is_last_report ) { const char end = is_last_report ? '\\n' : '\\r' ; if ( print_stats == 1 && AV_LOG_INFO > av_log_get_level ( ) ) { av_log ( NULL , AV_LOG_STDERR , \"%s    %c\" , buf . str , end ) ; } else av_log ( NULL , AV_LOG_INFO , \"%s    %c\" , buf . str , end ) ; } av_bprint_finalize ( & buf , NULL ) ; if ( progress_avio ) { av_bprintf ( & buf_script , \"progress=%s\\n\" , is_last_report ? \"end\" : \"continue\" ) ; avio_write ( progress_avio , buf_script . str , FFMIN ( buf_script . len , buf_script . size - 1 ) ) ; avio_flush ( progress_avio ) ; av_bprint_finalize ( & buf_script , NULL ) ; if ( is_last_report ) { if ( ( ret = avio_closep ( & progress_avio ) ) < 0 ) av_log ( NULL , AV_LOG_ERROR , \"Error closing progress log, loss of information possible: %s\\n\" , av_err2str ( ret ) ) ; } } first_report = 0 ; if ( is_last_report ) print_final_stats ( total_size ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@ifilter_parameters_from_codecpar": "static int ifilter_parameters_from_codecpar ( InputFilter * ifilter , AVCodecParameters * par ) { int ret ; // We never got any input. Set a fake format, which will // come from libavformat. ifilter -> format = par -> format ; ifilter -> sample_rate = par -> sample_rate ; ifilter -> width = par -> width ; ifilter -> height = par -> height ; ifilter -> sample_aspect_ratio = par -> sample_aspect_ratio ; ret = av_channel_layout_copy ( & ifilter -> ch_layout , & par -> ch_layout ) ; if ( ret < 0 ) return ret ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@flush_encoders": "static void flush_encoders ( void ) { int ret ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { OutputFile * of = output_files [ ost -> file_index ] ; if ( ost -> sq_idx_encode >= 0 ) sq_send ( of -> sq_encode , ost -> sq_idx_encode , SQFRAME ( NULL ) ) ; } for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { AVCodecContext * enc = ost -> enc_ctx ; OutputFile * of = output_files [ ost -> file_index ] ; if ( ! enc ) continue ; // Try to enable encoding with no input frames. // Maybe we should just let encoding fail instead. if ( ! ost -> initialized ) { FilterGraph * fg = ost -> filter -> graph ; av_log ( ost , AV_LOG_WARNING , \"Finishing stream without any data written to it.\\n\" ) ; if ( ost -> filter && ! fg -> graph ) { int x ; for ( x = 0 ; x < fg -> nb_inputs ; x ++ ) { InputFilter * ifilter = fg -> inputs [ x ] ; if ( ifilter -> format < 0 && ifilter_parameters_from_codecpar ( ifilter , ifilter -> ist -> par ) < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error copying paramerets from input stream\\n\" ) ; exit_program ( 1 ) ; } } if ( ! ifilter_has_all_input_formats ( fg ) ) continue ; ret = configure_filtergraph ( fg ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error configuring filter graph\\n\" ) ; exit_program ( 1 ) ; } of_output_packet ( of , ost -> pkt , ost , 1 ) ; } init_output_stream_wrapper ( ost , NULL , 1 ) ; } if ( enc -> codec_type != AVMEDIA_TYPE_VIDEO && enc -> codec_type != AVMEDIA_TYPE_AUDIO ) continue ; ret = submit_encode_frame ( of , ost , NULL ) ; if ( ret != AVERROR_EOF ) exit_program ( 1 ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@check_output_constraints": "static int check_output_constraints ( InputStream * ist , OutputStream * ost ) { OutputFile * of = output_files [ ost -> file_index ] ; if ( ost -> ist != ist ) return 0 ; if ( ost -> finished & MUXER_FINISHED ) return 0 ; if ( of -> start_time != AV_NOPTS_VALUE && ist -> pts < of -> start_time ) return 0 ; return 1 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@do_streamcopy": "static void do_streamcopy ( InputStream * ist , OutputStream * ost , const AVPacket * pkt ) { OutputFile * of = output_files [ ost -> file_index ] ; InputFile * f = input_files [ ist -> file_index ] ; int64_t start_time = ( of -> start_time == AV_NOPTS_VALUE ) ? 0 : of -> start_time ; int64_t ost_tb_start_time = av_rescale_q ( start_time , AV_TIME_BASE_Q , ost -> mux_timebase ) ; AVPacket * opkt = ost -> pkt ; av_packet_unref ( opkt ) ; // EOF: flush output bitstream filters. if ( ! pkt ) { of_output_packet ( of , opkt , ost , 1 ) ; return ; } if ( ! ost -> streamcopy_started && ! ( pkt -> flags & AV_PKT_FLAG_KEY ) && ! ost -> copy_initial_nonkeyframes ) return ; if ( ! ost -> streamcopy_started && ! ost -> copy_prior_start ) { if ( pkt -> pts == AV_NOPTS_VALUE ? ist -> pts < ost -> ts_copy_start : pkt -> pts < av_rescale_q ( ost -> ts_copy_start , AV_TIME_BASE_Q , ist -> st -> time_base ) ) return ; } if ( of -> recording_time != INT64_MAX && ist -> pts >= of -> recording_time + start_time ) { close_output_stream ( ost ) ; return ; } if ( f -> recording_time != INT64_MAX ) { start_time = 0 ; if ( copy_ts ) { start_time += f -> start_time != AV_NOPTS_VALUE ? f -> start_time : 0 ; start_time += start_at_zero ? 0 : f -> start_time_effective ; } if ( ist -> pts >= f -> recording_time + start_time ) { close_output_stream ( ost ) ; return ; } } if ( av_packet_ref ( opkt , pkt ) < 0 ) exit_program ( 1 ) ; opkt -> time_base = ost -> mux_timebase ; if ( pkt -> pts != AV_NOPTS_VALUE ) opkt -> pts = av_rescale_q ( pkt -> pts , ist -> st -> time_base , opkt -> time_base ) - ost_tb_start_time ; if ( pkt -> dts == AV_NOPTS_VALUE ) { opkt -> dts = av_rescale_q ( ist -> dts , AV_TIME_BASE_Q , opkt -> time_base ) ; } else if ( ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { int duration = av_get_audio_frame_duration2 ( ist -> par , pkt -> size ) ; if ( ! duration ) duration = ist -> par -> frame_size ; opkt -> dts = av_rescale_delta ( ist -> st -> time_base , pkt -> dts , ( AVRational ) { 1 , ist -> par -> sample_rate } , duration , & ist -> filter_in_rescale_delta_last , opkt -> time_base ) ; /* dts will be set immediately afterwards to what pts is now */ opkt -> pts = opkt -> dts - ost_tb_start_time ; } else opkt -> dts = av_rescale_q ( pkt -> dts , ist -> st -> time_base , opkt -> time_base ) ; opkt -> dts -= ost_tb_start_time ; opkt -> duration = av_rescale_q ( pkt -> duration , ist -> st -> time_base , opkt -> time_base ) ; { int ret = trigger_fix_sub_duration_heartbeat ( ost , pkt ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Subtitle heartbeat logic failed in %s! (%s)\\n\" , __func__ , av_err2str ( ret ) ) ; exit_program ( 1 ) ; } } of_output_packet ( of , opkt , ost , 0 ) ; ost -> streamcopy_started = 1 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@check_decode_result": "static void check_decode_result ( InputStream * ist , int * got_output , int ret ) { if ( * got_output || ret < 0 ) decode_error_stat [ ret < 0 ] ++ ; if ( ret < 0 && exit_on_error ) exit_program ( 1 ) ; if ( * got_output && ist ) { if ( ist -> decoded_frame -> decode_error_flags || ( ist -> decoded_frame -> flags & AV_FRAME_FLAG_CORRUPT ) ) { av_log ( NULL , exit_on_error ? AV_LOG_FATAL : AV_LOG_WARNING , \"%s: corrupt decoded frame in stream %d\\n\" , input_files [ ist -> file_index ] -> ctx -> url , ist -> st -> index ) ; if ( exit_on_error ) exit_program ( 1 ) ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@ifilter_has_all_input_formats": "static int ifilter_has_all_input_formats ( FilterGraph * fg ) { int i ; for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) { if ( fg -> inputs [ i ] -> format < 0 && ( fg -> inputs [ i ] -> type == AVMEDIA_TYPE_AUDIO || fg -> inputs [ i ] -> type == AVMEDIA_TYPE_VIDEO ) ) return 0 ; } return 1 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@ifilter_send_frame": "static int ifilter_send_frame ( InputFilter * ifilter , AVFrame * frame , int keep_reference ) { FilterGraph * fg = ifilter -> graph ; AVFrameSideData * sd ; int need_reinit , ret ; int buffersrc_flags = AV_BUFFERSRC_FLAG_PUSH ; if ( keep_reference ) buffersrc_flags |= AV_BUFFERSRC_FLAG_KEEP_REF ; /* determine if the parameters for this input changed */ need_reinit = ifilter -> format != frame -> format ; switch ( ifilter -> ist -> par -> codec_type ) { case AVMEDIA_TYPE_AUDIO : need_reinit |= ifilter -> sample_rate != frame -> sample_rate || av_channel_layout_compare ( & ifilter -> ch_layout , & frame -> ch_layout ) ; break ; case AVMEDIA_TYPE_VIDEO : need_reinit |= ifilter -> width != frame -> width || ifilter -> height != frame -> height ; break ; } if ( ! ifilter -> ist -> reinit_filters && fg -> graph ) need_reinit = 0 ; if ( ! ! ifilter -> hw_frames_ctx != ! ! frame -> hw_frames_ctx || ( ifilter -> hw_frames_ctx && ifilter -> hw_frames_ctx -> data != frame -> hw_frames_ctx -> data ) ) need_reinit = 1 ; if ( ( sd = av_frame_get_side_data ( frame , AV_FRAME_DATA_DISPLAYMATRIX ) ) ) { if ( ! ifilter -> displaymatrix || memcmp ( sd -> data , ifilter -> displaymatrix , sizeof ( int32_t ) * 9 ) ) need_reinit = 1 ; } else if ( ifilter -> displaymatrix ) need_reinit = 1 ; if ( need_reinit ) { ret = ifilter_parameters_from_frame ( ifilter , frame ) ; if ( ret < 0 ) return ret ; } /* (re)init the graph if possible, otherwise buffer the frame and return */ if ( need_reinit || ! fg -> graph ) { if ( ! ifilter_has_all_input_formats ( fg ) ) { AVFrame * tmp = av_frame_clone ( frame ) ; if ( ! tmp ) return AVERROR ( ENOMEM ) ; ret = av_fifo_write ( ifilter -> frame_queue , & tmp , 1 ) ; if ( ret < 0 ) av_frame_free ( & tmp ) ; return ret ; } ret = reap_filters ( 1 ) ; if ( ret < 0 && ret != AVERROR_EOF ) { av_log ( NULL , AV_LOG_ERROR , \"Error while filtering: %s\\n\" , av_err2str ( ret ) ) ; return ret ; } ret = configure_filtergraph ( fg ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error reinitializing filters!\\n\" ) ; return ret ; } } ret = av_buffersrc_add_frame_flags ( ifilter -> filter , frame , buffersrc_flags ) ; if ( ret < 0 ) { if ( ret != AVERROR_EOF ) av_log ( NULL , AV_LOG_ERROR , \"Error while filtering: %s\\n\" , av_err2str ( ret ) ) ; return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@ifilter_send_eof": "static int ifilter_send_eof ( InputFilter * ifilter , int64_t pts ) { int ret = 0 ; ifilter -> eof = 1 ; if ( ifilter -> filter ) { /* THIS VALIDATION IS REQUIRED TO COMPLETE CANCELLATION */ if ( ! received_sigterm && ! cancelRequested ( globalSessionId ) ) { ret = av_buffersrc_close ( ifilter -> filter , pts , AV_BUFFERSRC_FLAG_PUSH ) ; } if ( ret < 0 ) return ret ; } else { // the filtergraph was never configured if ( ifilter -> format < 0 ) { ret = ifilter_parameters_from_codecpar ( ifilter , ifilter -> ist -> par ) ; if ( ret < 0 ) return ret ; } if ( ifilter -> format < 0 && ( ifilter -> type == AVMEDIA_TYPE_AUDIO || ifilter -> type == AVMEDIA_TYPE_VIDEO ) ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot determine format of input stream %d:%d after EOF\\n\" , ifilter -> ist -> file_index , ifilter -> ist -> st -> index ) ; return AVERROR_INVALIDDATA ; } } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@decode": "static int decode ( InputStream * ist , AVCodecContext * avctx , AVFrame * frame , int * got_frame , AVPacket * pkt ) { int ret ; * got_frame = 0 ; if ( pkt ) { ret = avcodec_send_packet ( avctx , pkt ) ; // In particular, we don't expect AVERROR(EAGAIN), because we read all // decoded frames with avcodec_receive_frame() until done. if ( ret < 0 && ret != AVERROR_EOF ) return ret ; } ret = avcodec_receive_frame ( avctx , frame ) ; if ( ret < 0 && ret != AVERROR ( EAGAIN ) ) return ret ; if ( ret >= 0 ) { if ( ist -> want_frame_data ) { FrameData * fd ; av_assert0 ( ! frame -> opaque_ref ) ; frame -> opaque_ref = av_buffer_allocz ( sizeof ( * fd ) ) ; if ( ! frame -> opaque_ref ) { av_frame_unref ( frame ) ; return AVERROR ( ENOMEM ) ; } fd = ( FrameData * ) frame -> opaque_ref -> data ; fd -> pts = frame -> pts ; fd -> tb = avctx -> pkt_timebase ; fd -> idx = avctx -> frame_num - 1 ; } * got_frame = 1 ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@send_frame_to_filters": "static int send_frame_to_filters ( InputStream * ist , AVFrame * decoded_frame ) { int i , ret ; av_assert1 ( ist -> nb_filters > 0 ) ; /* ensure ret is initialized */ for ( i = 0 ; i < ist -> nb_filters ; i ++ ) { ret = ifilter_send_frame ( ist -> filters [ i ] , decoded_frame , i < ist -> nb_filters - 1 ) ; if ( ret == AVERROR_EOF ) ret = 0 ; /* ignore */ if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Failed to inject frame into filter network: %s\\n\" , av_err2str ( ret ) ) ; break ; } } return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@decode_audio": "static int decode_audio ( InputStream * ist , AVPacket * pkt , int * got_output , int * decode_failed ) { AVFrame * decoded_frame = ist -> decoded_frame ; AVCodecContext * avctx = ist -> dec_ctx ; int ret , err = 0 ; AVRational decoded_frame_tb ; update_benchmark ( NULL ) ; ret = decode ( ist , avctx , decoded_frame , got_output , pkt ) ; update_benchmark ( \"decode_audio %d.%d\" , ist -> file_index , ist -> st -> index ) ; if ( ret < 0 ) * decode_failed = 1 ; if ( ret != AVERROR_EOF ) check_decode_result ( ist , got_output , ret ) ; if ( ! * got_output || ret < 0 ) return ret ; ist -> samples_decoded += decoded_frame -> nb_samples ; ist -> frames_decoded ++ ; /* increment next_dts to use for the case where the input stream does not\n       have timestamps or there are multiple frames in the packet */ ist -> next_pts += ( ( int64_t ) AV_TIME_BASE * decoded_frame -> nb_samples ) / decoded_frame -> sample_rate ; ist -> next_dts += ( ( int64_t ) AV_TIME_BASE * decoded_frame -> nb_samples ) / decoded_frame -> sample_rate ; if ( decoded_frame -> pts != AV_NOPTS_VALUE ) { decoded_frame_tb = ist -> st -> time_base ; } else if ( pkt && pkt -> pts != AV_NOPTS_VALUE ) { decoded_frame -> pts = pkt -> pts ; decoded_frame_tb = ist -> st -> time_base ; } else { decoded_frame -> pts = ist -> dts ; decoded_frame_tb = AV_TIME_BASE_Q ; } if ( pkt && pkt -> duration && ist -> prev_pkt_pts != AV_NOPTS_VALUE && pkt -> pts != AV_NOPTS_VALUE && pkt -> pts - ist -> prev_pkt_pts > pkt -> duration ) ist -> filter_in_rescale_delta_last = AV_NOPTS_VALUE ; if ( pkt ) ist -> prev_pkt_pts = pkt -> pts ; if ( decoded_frame -> pts != AV_NOPTS_VALUE ) decoded_frame -> pts = av_rescale_delta ( decoded_frame_tb , decoded_frame -> pts , ( AVRational ) { 1 , decoded_frame -> sample_rate } , decoded_frame -> nb_samples , & ist -> filter_in_rescale_delta_last , ( AVRational ) { 1 , decoded_frame -> sample_rate } ) ; ist -> nb_samples = decoded_frame -> nb_samples ; err = send_frame_to_filters ( ist , decoded_frame ) ; av_frame_unref ( decoded_frame ) ; return err < 0 ? err : ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@decode_video": "static int decode_video ( InputStream * ist , AVPacket * pkt , int * got_output , int64_t * duration_pts , int eof , int * decode_failed ) { AVFrame * decoded_frame = ist -> decoded_frame ; int i , ret = 0 , err = 0 ; int64_t best_effort_timestamp ; int64_t dts = AV_NOPTS_VALUE ; // With fate-indeo3-2, we're getting 0-sized packets before EOF for some // reason. This seems like a semi-critical bug. Don't trigger EOF, and // skip the packet. if ( ! eof && pkt && pkt -> size == 0 ) return 0 ; if ( ist -> dts != AV_NOPTS_VALUE ) dts = av_rescale_q ( ist -> dts , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt ) { pkt -> dts = dts ; // ffmpeg.c probably shouldn't do this } // The old code used to set dts on the drain packet, which does not work // with the new API anymore. if ( eof ) { void * new = av_realloc_array ( ist -> dts_buffer , ist -> nb_dts_buffer + 1 , sizeof ( ist -> dts_buffer [ 0 ] ) ) ; if ( ! new ) return AVERROR ( ENOMEM ) ; ist -> dts_buffer = new ; ist -> dts_buffer [ ist -> nb_dts_buffer ++ ] = dts ; } update_benchmark ( NULL ) ; ret = decode ( ist , ist -> dec_ctx , decoded_frame , got_output , pkt ) ; update_benchmark ( \"decode_video %d.%d\" , ist -> file_index , ist -> st -> index ) ; if ( ret < 0 ) * decode_failed = 1 ; // The following line may be required in some cases where there is no parser // or the parser does not has_b_frames correctly if ( ist -> par -> video_delay < ist -> dec_ctx -> has_b_frames ) { if ( ist -> dec_ctx -> codec_id == AV_CODEC_ID_H264 ) { ist -> par -> video_delay = ist -> dec_ctx -> has_b_frames ; } else av_log ( ist -> dec_ctx , AV_LOG_WARNING , \"video_delay is larger in decoder than demuxer %d > %d.\\n\" \"If you want to help, upload a sample \" \"of this file to https://streams.videolan.org/upload/ \" \"and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)\\n\" , ist -> dec_ctx -> has_b_frames , ist -> par -> video_delay ) ; } if ( ret != AVERROR_EOF ) check_decode_result ( ist , got_output , ret ) ; if ( * got_output && ret >= 0 ) { if ( ist -> dec_ctx -> width != decoded_frame -> width || ist -> dec_ctx -> height != decoded_frame -> height || ist -> dec_ctx -> pix_fmt != decoded_frame -> format ) { av_log ( NULL , AV_LOG_DEBUG , \"Frame parameters mismatch context %d,%d,%d != %d,%d,%d\\n\" , decoded_frame -> width , decoded_frame -> height , decoded_frame -> format , ist -> dec_ctx -> width , ist -> dec_ctx -> height , ist -> dec_ctx -> pix_fmt ) ; } } if ( ! * got_output || ret < 0 ) return ret ; if ( ist -> top_field_first >= 0 ) decoded_frame -> top_field_first = ist -> top_field_first ; ist -> frames_decoded ++ ; if ( ist -> hwaccel_retrieve_data && decoded_frame -> format == ist -> hwaccel_pix_fmt ) { err = ist -> hwaccel_retrieve_data ( ist -> dec_ctx , decoded_frame ) ; if ( err < 0 ) goto fail ; } best_effort_timestamp = decoded_frame -> best_effort_timestamp ; * duration_pts = decoded_frame -> duration ; if ( ist -> framerate . num ) best_effort_timestamp = ist -> cfr_next_pts ++ ; if ( eof && best_effort_timestamp == AV_NOPTS_VALUE && ist -> nb_dts_buffer > 0 ) { best_effort_timestamp = ist -> dts_buffer [ 0 ] ; for ( i = 0 ; i < ist -> nb_dts_buffer - 1 ; i ++ ) ist -> dts_buffer [ i ] = ist -> dts_buffer [ i + 1 ] ; ist -> nb_dts_buffer -- ; } if ( best_effort_timestamp != AV_NOPTS_VALUE ) { int64_t ts = av_rescale_q ( decoded_frame -> pts = best_effort_timestamp , ist -> st -> time_base , AV_TIME_BASE_Q ) ; if ( ts != AV_NOPTS_VALUE ) ist -> next_pts = ist -> pts = ts ; } if ( debug_ts ) { av_log ( NULL , AV_LOG_INFO , \"decoder -> ist_index:%d type:video \" \"frame_pts:%s frame_pts_time:%s best_effort_ts:%\" PRId64 \" best_effort_ts_time:%s keyframe:%d frame_type:%d time_base:%d/%d\\n\" , ist -> st -> index , av_ts2str ( decoded_frame -> pts ) , av_ts2timestr ( decoded_frame -> pts , & ist -> st -> time_base ) , best_effort_timestamp , av_ts2timestr ( best_effort_timestamp , & ist -> st -> time_base ) , decoded_frame -> key_frame , decoded_frame -> pict_type , ist -> st -> time_base . num , ist -> st -> time_base . den ) ; } if ( ist -> st -> sample_aspect_ratio . num ) decoded_frame -> sample_aspect_ratio = ist -> st -> sample_aspect_ratio ; err = send_frame_to_filters ( ist , decoded_frame ) ; fail : av_frame_unref ( decoded_frame ) ; return err < 0 ? err : ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@process_subtitle": "static int process_subtitle ( InputStream * ist , AVSubtitle * subtitle , int * got_output ) { int ret = 0 ; int free_sub = 1 ; if ( ist -> fix_sub_duration ) { int end = 1 ; if ( ist -> prev_sub . got_output ) { end = av_rescale ( subtitle -> pts - ist -> prev_sub . subtitle . pts , 1000 , AV_TIME_BASE ) ; if ( end < ist -> prev_sub . subtitle . end_display_time ) { av_log ( NULL , AV_LOG_DEBUG , \"Subtitle duration reduced from %\" PRId32 \" to %d%s\\n\" , ist -> prev_sub . subtitle . end_display_time , end , end <= 0 ? \", dropping it\" : \"\" ) ; ist -> prev_sub . subtitle . end_display_time = end ; } } FFSWAP ( int , * got_output , ist -> prev_sub . got_output ) ; FFSWAP ( int , ret , ist -> prev_sub . ret ) ; FFSWAP ( AVSubtitle , * subtitle , ist -> prev_sub . subtitle ) ; if ( end <= 0 ) goto out ; } if ( ! * got_output ) return ret ; if ( ist -> sub2video . frame ) { sub2video_update ( ist , INT64_MIN , subtitle ) ; } else if ( ist -> nb_filters ) { if ( ! ist -> sub2video . sub_queue ) ist -> sub2video . sub_queue = av_fifo_alloc2 ( 8 , sizeof ( AVSubtitle ) , AV_FIFO_FLAG_AUTO_GROW ) ; if ( ! ist -> sub2video . sub_queue ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ret = av_fifo_write ( ist -> sub2video . sub_queue , subtitle , 1 ) ; if ( ret < 0 ) exit_program ( 1 ) ; free_sub = 0 ; } if ( ! subtitle -> num_rects ) goto out ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ! check_output_constraints ( ist , ost ) || ! ost -> enc_ctx || ost -> enc_ctx -> codec_type != AVMEDIA_TYPE_SUBTITLE ) continue ; do_subtitle_out ( output_files [ ost -> file_index ] , ost , subtitle ) ; } out : if ( free_sub ) avsubtitle_free ( subtitle ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@copy_av_subtitle": "static int copy_av_subtitle ( AVSubtitle * dst , AVSubtitle * src ) { int ret = AVERROR_BUG ; AVSubtitle tmp = { . format = src -> format , . start_display_time = src -> start_display_time , . end_display_time = src -> end_display_time , . num_rects = 0 , . rects = NULL , . pts = src -> pts } ; if ( ! src -> num_rects ) goto success ; if ( ! ( tmp . rects = av_calloc ( src -> num_rects , sizeof ( * tmp . rects ) ) ) ) return AVERROR ( ENOMEM ) ; for ( int i = 0 ; i < src -> num_rects ; i ++ ) { AVSubtitleRect * src_rect = src -> rects [ i ] ; AVSubtitleRect * dst_rect ; if ( ! ( dst_rect = tmp . rects [ i ] = av_mallocz ( sizeof ( * tmp . rects [ 0 ] ) ) ) ) { ret = AVERROR ( ENOMEM ) ; goto cleanup ; } tmp . num_rects ++ ; dst_rect -> type = src_rect -> type ; dst_rect -> flags = src_rect -> flags ; dst_rect -> x = src_rect -> x ; dst_rect -> y = src_rect -> y ; dst_rect -> w = src_rect -> w ; dst_rect -> h = src_rect -> h ; dst_rect -> nb_colors = src_rect -> nb_colors ; if ( src_rect -> text ) if ( ! ( dst_rect -> text = av_strdup ( src_rect -> text ) ) ) { ret = AVERROR ( ENOMEM ) ; goto cleanup ; } if ( src_rect -> ass ) if ( ! ( dst_rect -> ass = av_strdup ( src_rect -> ass ) ) ) { ret = AVERROR ( ENOMEM ) ; goto cleanup ; } for ( int j = 0 ; j < 4 ; j ++ ) { // SUBTITLE_BITMAP images are special in the sense that they // are like PAL8 images. first pointer to data, second to // palette. This makes the size calculation match this. size_t buf_size = src_rect -> type == SUBTITLE_BITMAP && j == 1 ? AVPALETTE_SIZE : src_rect -> h * src_rect -> linesize [ j ] ; if ( ! src_rect -> data [ j ] ) continue ; if ( ! ( dst_rect -> data [ j ] = av_memdup ( src_rect -> data [ j ] , buf_size ) ) ) { ret = AVERROR ( ENOMEM ) ; goto cleanup ; } dst_rect -> linesize [ j ] = src_rect -> linesize [ j ] ; } } success : * dst = tmp ; return 0 ; cleanup : avsubtitle_free ( & tmp ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@fix_sub_duration_heartbeat": "static int fix_sub_duration_heartbeat ( InputStream * ist , int64_t signal_pts ) { int ret = AVERROR_BUG ; int got_output = 1 ; AVSubtitle * prev_subtitle = & ist -> prev_sub . subtitle ; AVSubtitle subtitle ; if ( ! ist -> fix_sub_duration || ! prev_subtitle -> num_rects || signal_pts <= prev_subtitle -> pts ) return 0 ; if ( ( ret = copy_av_subtitle ( & subtitle , prev_subtitle ) ) < 0 ) return ret ; subtitle . pts = signal_pts ; return process_subtitle ( ist , & subtitle , & got_output ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@trigger_fix_sub_duration_heartbeat": "static int trigger_fix_sub_duration_heartbeat ( OutputStream * ost , const AVPacket * pkt ) { OutputFile * of = output_files [ ost -> file_index ] ; int64_t signal_pts = av_rescale_q ( pkt -> pts , pkt -> time_base , AV_TIME_BASE_Q ) ; if ( ! ost -> fix_sub_duration_heartbeat || ! ( pkt -> flags & AV_PKT_FLAG_KEY ) ) // we are only interested in heartbeats on streams configured, and // only on random access points. return 0 ; for ( int i = 0 ; i < of -> nb_streams ; i ++ ) { OutputStream * iter_ost = of -> streams [ i ] ; InputStream * ist = iter_ost -> ist ; int ret = AVERROR_BUG ; if ( iter_ost == ost || ! ist || ! ist -> decoding_needed || ist -> dec_ctx -> codec_type != AVMEDIA_TYPE_SUBTITLE ) // We wish to skip the stream that causes the heartbeat, // output streams without an input stream, streams not decoded // (as fix_sub_duration is only done for decoded subtitles) as // well as non-subtitle streams. continue ; if ( ( ret = fix_sub_duration_heartbeat ( ist , signal_pts ) ) < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@transcode_subtitles": "static int transcode_subtitles ( InputStream * ist , const AVPacket * pkt , int * got_output , int * decode_failed ) { AVSubtitle subtitle ; int ret = avcodec_decode_subtitle2 ( ist -> dec_ctx , & subtitle , got_output , pkt ) ; check_decode_result ( NULL , got_output , ret ) ; if ( ret < 0 || ! * got_output ) { * decode_failed = 1 ; if ( ! pkt -> size ) sub2video_flush ( ist ) ; return ret ; } ist -> frames_decoded ++ ; return process_subtitle ( ist , & subtitle , got_output ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@send_filter_eof": "static int send_filter_eof ( InputStream * ist ) { int i , ret ; /* TODO keep pts also in stream time base to avoid converting back */ int64_t pts = av_rescale_q_rnd ( ist -> pts , AV_TIME_BASE_Q , ist -> st -> time_base , AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX ) ; for ( i = 0 ; i < ist -> nb_filters ; i ++ ) { ret = ifilter_send_eof ( ist -> filters [ i ] , pts ) ; if ( ret < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@process_input_packet": "static int process_input_packet ( InputStream * ist , const AVPacket * pkt , int no_eof ) { const AVCodecParameters * par = ist -> par ; int ret = 0 ; int repeating = 0 ; int eof_reached = 0 ; AVPacket * avpkt = ist -> pkt ; if ( ! ist -> saw_first_ts ) { ist -> first_dts = ist -> dts = ist -> st -> avg_frame_rate . num ? - ist -> dec_ctx -> has_b_frames * AV_TIME_BASE / av_q2d ( ist -> st -> avg_frame_rate ) : 0 ; ist -> pts = 0 ; if ( pkt && pkt -> pts != AV_NOPTS_VALUE && ! ist -> decoding_needed ) { ist -> first_dts = ist -> dts += av_rescale_q ( pkt -> pts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; ist -> pts = ist -> dts ; //unused but better to set it to a value thats not totally wrong } ist -> saw_first_ts = 1 ; } if ( ist -> next_dts == AV_NOPTS_VALUE ) ist -> next_dts = ist -> dts ; if ( ist -> next_pts == AV_NOPTS_VALUE ) ist -> next_pts = ist -> pts ; if ( pkt ) { av_packet_unref ( avpkt ) ; ret = av_packet_ref ( avpkt , pkt ) ; if ( ret < 0 ) return ret ; } if ( pkt && pkt -> dts != AV_NOPTS_VALUE ) { ist -> next_dts = ist -> dts = av_rescale_q ( pkt -> dts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; if ( par -> codec_type != AVMEDIA_TYPE_VIDEO || ! ist -> decoding_needed ) ist -> next_pts = ist -> pts = ist -> dts ; } // while we have more to decode or while the decoder did output something on EOF while ( ist -> decoding_needed ) { int64_t duration_dts = 0 ; int64_t duration_pts = 0 ; int got_output = 0 ; int decode_failed = 0 ; ist -> pts = ist -> next_pts ; ist -> dts = ist -> next_dts ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_AUDIO : ret = decode_audio ( ist , repeating ? NULL : avpkt , & got_output , & decode_failed ) ; av_packet_unref ( avpkt ) ; break ; case AVMEDIA_TYPE_VIDEO : ret = decode_video ( ist , repeating ? NULL : avpkt , & got_output , & duration_pts , ! pkt , & decode_failed ) ; if ( ! repeating || ! pkt || got_output ) { if ( pkt && pkt -> duration ) { duration_dts = av_rescale_q ( pkt -> duration , ist -> st -> time_base , AV_TIME_BASE_Q ) ; } else if ( ist -> dec_ctx -> framerate . num != 0 && ist -> dec_ctx -> framerate . den != 0 ) { int ticks = ist -> last_pkt_repeat_pict >= 0 ? ist -> last_pkt_repeat_pict + 1 : ist -> dec_ctx -> ticks_per_frame ; duration_dts = ( ( int64_t ) AV_TIME_BASE * ist -> dec_ctx -> framerate . den * ticks ) / ist -> dec_ctx -> framerate . num / ist -> dec_ctx -> ticks_per_frame ; } if ( ist -> dts != AV_NOPTS_VALUE && duration_dts ) { ist -> next_dts += duration_dts ; } else ist -> next_dts = AV_NOPTS_VALUE ; } if ( got_output ) { if ( duration_pts > 0 ) { ist -> next_pts += av_rescale_q ( duration_pts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; } else { ist -> next_pts += duration_dts ; } } av_packet_unref ( avpkt ) ; break ; case AVMEDIA_TYPE_SUBTITLE : if ( repeating ) break ; ret = transcode_subtitles ( ist , avpkt , & got_output , & decode_failed ) ; if ( ! pkt && ret >= 0 ) ret = AVERROR_EOF ; av_packet_unref ( avpkt ) ; break ; default : return - 1 ; } if ( ret == AVERROR_EOF ) { eof_reached = 1 ; break ; } if ( ret < 0 ) { if ( decode_failed ) { av_log ( NULL , AV_LOG_ERROR , \"Error while decoding stream #%d:%d: %s\\n\" , ist -> file_index , ist -> st -> index , av_err2str ( ret ) ) ; } else { av_log ( NULL , AV_LOG_FATAL , \"Error while processing the decoded \" \"data for stream #%d:%d\\n\" , ist -> file_index , ist -> st -> index ) ; } if ( ! decode_failed || exit_on_error ) exit_program ( 1 ) ; break ; } if ( got_output ) ist -> got_output = 1 ; if ( ! got_output ) break ; // During draining, we might get multiple output frames in this loop. // ffmpeg.c does not drain the filter chain on configuration changes, // which means if we send multiple frames at once to the filters, and // one of those frames changes configuration, the buffered frames will // be lost. This can upset certain FATE tests. // Decode only 1 frame per call on EOF to appease these FATE tests. // The ideal solution would be to rewrite decoding to use the new // decoding API in a better way. if ( ! pkt ) break ; repeating = 1 ; } /* after flushing, send an EOF on all the filter inputs attached to the stream */ /* except when looping we need to flush but not to send an EOF */ if ( ! pkt && ist -> decoding_needed && eof_reached && ! no_eof ) { int ret = send_filter_eof ( ist ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error marking filters as finished\\n\" ) ; exit_program ( 1 ) ; } } /* handle stream copy */ if ( ! ist -> decoding_needed && pkt ) { ist -> dts = ist -> next_dts ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_AUDIO : av_assert1 ( pkt -> duration >= 0 ) ; if ( par -> sample_rate ) { ist -> next_dts += ( ( int64_t ) AV_TIME_BASE * par -> frame_size ) / par -> sample_rate ; } else { ist -> next_dts += av_rescale_q ( pkt -> duration , ist -> st -> time_base , AV_TIME_BASE_Q ) ; } break ; case AVMEDIA_TYPE_VIDEO : if ( ist -> framerate . num ) { // TODO: Remove work-around for c99-to-c89 issue 7 AVRational time_base_q = AV_TIME_BASE_Q ; int64_t next_dts = av_rescale_q ( ist -> next_dts , time_base_q , av_inv_q ( ist -> framerate ) ) ; ist -> next_dts = av_rescale_q ( next_dts + 1 , av_inv_q ( ist -> framerate ) , time_base_q ) ; } else if ( pkt -> duration ) { ist -> next_dts += av_rescale_q ( pkt -> duration , ist -> st -> time_base , AV_TIME_BASE_Q ) ; } else if ( ist -> dec_ctx -> framerate . num != 0 ) { int ticks = ist -> last_pkt_repeat_pict >= 0 ? ist -> last_pkt_repeat_pict + 1 : ist -> dec_ctx -> ticks_per_frame ; ist -> next_dts += ( ( int64_t ) AV_TIME_BASE * ist -> dec_ctx -> framerate . den * ticks ) / ist -> dec_ctx -> framerate . num / ist -> dec_ctx -> ticks_per_frame ; } break ; } ist -> pts = ist -> dts ; ist -> next_pts = ist -> next_dts ; } else if ( ! ist -> decoding_needed ) eof_reached = 1 ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ! check_output_constraints ( ist , ost ) || ost -> enc_ctx || ( ! pkt && no_eof ) ) continue ; do_streamcopy ( ist , ost , pkt ) ; } return ! eof_reached ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@get_format": "static enum AVPixelFormat get_format ( AVCodecContext * s , const enum AVPixelFormat * pix_fmts ) { InputStream * ist = s -> opaque ; const enum AVPixelFormat * p ; int ret ; for ( p = pix_fmts ; * p != AV_PIX_FMT_NONE ; p ++ ) { const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( * p ) ; const AVCodecHWConfig * config = NULL ; int i ; if ( ! ( desc -> flags & AV_PIX_FMT_FLAG_HWACCEL ) ) break ; if ( ist -> hwaccel_id == HWACCEL_GENERIC || ist -> hwaccel_id == HWACCEL_AUTO ) { for ( i = 0 ; ; i ++ ) { config = avcodec_get_hw_config ( s -> codec , i ) ; if ( ! config ) break ; if ( ! ( config -> methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX ) ) continue ; if ( config -> pix_fmt == * p ) break ; } } if ( config && config -> device_type == ist -> hwaccel_device_type ) { ret = hwaccel_decode_init ( s ) ; if ( ret < 0 ) { if ( ist -> hwaccel_id == HWACCEL_GENERIC ) { av_log ( NULL , AV_LOG_FATAL , \"%s hwaccel requested for input stream #%d:%d, \" \"but cannot be initialized.\\n\" , av_hwdevice_get_type_name ( config -> device_type ) , ist -> file_index , ist -> st -> index ) ; return AV_PIX_FMT_NONE ; } continue ; } ist -> hwaccel_pix_fmt = * p ; break ; } } return * p ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@init_input_stream": "static int init_input_stream ( InputStream * ist , char * error , int error_len ) { int ret ; if ( ist -> decoding_needed ) { const AVCodec * codec = ist -> dec ; if ( ! codec ) { snprintf ( error , error_len , \"Decoder (codec %s) not found for input stream #%d:%d\" , avcodec_get_name ( ist -> dec_ctx -> codec_id ) , ist -> file_index , ist -> st -> index ) ; return AVERROR ( EINVAL ) ; } ist -> dec_ctx -> opaque = ist ; ist -> dec_ctx -> get_format = get_format ; if ( ist -> dec_ctx -> codec_id == AV_CODEC_ID_DVB_SUBTITLE && ( ist -> decoding_needed & DECODING_FOR_OST ) ) { av_dict_set ( & ist -> decoder_opts , \"compute_edt\" , \"1\" , AV_DICT_DONT_OVERWRITE ) ; if ( ist -> decoding_needed & DECODING_FOR_FILTER ) av_log ( NULL , AV_LOG_WARNING , \"Warning using DVB subtitles for filtering and output at the same time is not fully supported, also see -compute_edt [0|1]\\n\" ) ; } /* Useful for subtitles retiming by lavf (FIXME), skipping samples in\n         * audio, and video decoders such as cuvid or mediacodec */ ist -> dec_ctx -> pkt_timebase = ist -> st -> time_base ; if ( ! av_dict_get ( ist -> decoder_opts , \"threads\" , NULL , 0 ) ) av_dict_set ( & ist -> decoder_opts , \"threads\" , \"auto\" , 0 ) ; /* Attached pics are sparse, therefore we would not want to delay their decoding till EOF. */ if ( ist -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) av_dict_set ( & ist -> decoder_opts , \"threads\" , \"1\" , 0 ) ; ret = hw_device_setup_for_decode ( ist ) ; if ( ret < 0 ) { snprintf ( error , error_len , \"Device setup failed for \" \"decoder on input stream #%d:%d : %s\" , ist -> file_index , ist -> st -> index , av_err2str ( ret ) ) ; return ret ; } if ( ( ret = avcodec_open2 ( ist -> dec_ctx , codec , & ist -> decoder_opts ) ) < 0 ) { if ( ret == AVERROR_EXPERIMENTAL ) abort_codec_experimental ( codec , 0 ) ; snprintf ( error , error_len , \"Error while opening decoder for input stream \" \"#%d:%d : %s\" , ist -> file_index , ist -> st -> index , av_err2str ( ret ) ) ; return ret ; } assert_avoptions ( ist -> decoder_opts ) ; } ist -> next_pts = AV_NOPTS_VALUE ; ist -> next_dts = AV_NOPTS_VALUE ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@init_output_stream_streamcopy": "static int init_output_stream_streamcopy ( OutputStream * ost ) { OutputFile * of = output_files [ ost -> file_index ] ; InputStream * ist = ost -> ist ; InputFile * ifile = input_files [ ist -> file_index ] ; AVCodecParameters * par = ost -> st -> codecpar ; AVCodecContext * codec_ctx ; AVRational sar ; int i , ret ; uint32_t codec_tag = par -> codec_tag ; av_assert0 ( ist && ! ost -> filter ) ; codec_ctx = avcodec_alloc_context3 ( NULL ) ; if ( ! codec_ctx ) return AVERROR ( ENOMEM ) ; ret = avcodec_parameters_to_context ( codec_ctx , ist -> par ) ; if ( ret >= 0 ) ret = av_opt_set_dict ( codec_ctx , & ost -> encoder_opts ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Error setting up codec context options.\\n\" ) ; avcodec_free_context ( & codec_ctx ) ; return ret ; } ret = avcodec_parameters_from_context ( par , codec_ctx ) ; avcodec_free_context ( & codec_ctx ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Error getting reference codec parameters.\\n\" ) ; return ret ; } if ( ! codec_tag ) { unsigned int codec_tag_tmp ; if ( ! of -> format -> codec_tag || av_codec_get_id ( of -> format -> codec_tag , par -> codec_tag ) == par -> codec_id || ! av_codec_get_tag2 ( of -> format -> codec_tag , par -> codec_id , & codec_tag_tmp ) ) codec_tag = par -> codec_tag ; } par -> codec_tag = codec_tag ; if ( ! ost -> frame_rate . num ) ost -> frame_rate = ist -> framerate ; if ( ost -> frame_rate . num ) ost -> st -> avg_frame_rate = ost -> frame_rate ; else ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate ; ret = avformat_transfer_internal_stream_timing_info ( of -> format , ost -> st , ist -> st , copy_tb ) ; if ( ret < 0 ) return ret ; // copy timebase while removing common factors if ( ost -> st -> time_base . num <= 0 || ost -> st -> time_base . den <= 0 ) { if ( ost -> frame_rate . num ) ost -> st -> time_base = av_inv_q ( ost -> frame_rate ) ; else ost -> st -> time_base = av_add_q ( av_stream_get_codec_timebase ( ost -> st ) , ( AVRational ) { 0 , 1 } ) ; } // copy estimated duration as a hint to the muxer if ( ost -> st -> duration <= 0 && ist -> st -> duration > 0 ) ost -> st -> duration = av_rescale_q ( ist -> st -> duration , ist -> st -> time_base , ost -> st -> time_base ) ; if ( ! ost -> copy_prior_start ) { ost -> ts_copy_start = ( of -> start_time == AV_NOPTS_VALUE ) ? 0 : of -> start_time ; if ( copy_ts && ifile -> start_time != AV_NOPTS_VALUE ) { ost -> ts_copy_start = FFMAX ( ost -> ts_copy_start , ifile -> start_time + ifile -> ts_offset ) ; } } if ( ist -> st -> nb_side_data ) { for ( i = 0 ; i < ist -> st -> nb_side_data ; i ++ ) { const AVPacketSideData * sd_src = & ist -> st -> side_data [ i ] ; uint8_t * dst_data ; dst_data = av_stream_new_side_data ( ost -> st , sd_src -> type , sd_src -> size ) ; if ( ! dst_data ) return AVERROR ( ENOMEM ) ; memcpy ( dst_data , sd_src -> data , sd_src -> size ) ; } } # if FFMPEG_ROTATION_METADATA if ( ost -> rotate_overridden ) { uint8_t * sd = av_stream_new_side_data ( ost -> st , AV_PKT_DATA_DISPLAYMATRIX , sizeof ( int32_t ) * 9 ) ; if ( sd ) av_display_rotation_set ( ( int32_t * ) sd , - ost -> rotate_override_value ) ; } # endif switch ( par -> codec_type ) { case AVMEDIA_TYPE_AUDIO : if ( ( par -> block_align == 1 || par -> block_align == 1152 || par -> block_align == 576 ) && par -> codec_id == AV_CODEC_ID_MP3 ) par -> block_align = 0 ; if ( par -> codec_id == AV_CODEC_ID_AC3 ) par -> block_align = 0 ; break ; case AVMEDIA_TYPE_VIDEO : if ( ost -> frame_aspect_ratio . num ) { // overridden by the -aspect cli option sar = av_mul_q ( ost -> frame_aspect_ratio , ( AVRational ) { par -> height , par -> width } ) ; av_log ( ost , AV_LOG_WARNING , \"Overriding aspect ratio \" \"with stream copy may produce invalid files\\n\" ) ; } else if ( ist -> st -> sample_aspect_ratio . num ) sar = ist -> st -> sample_aspect_ratio ; else sar = par -> sample_aspect_ratio ; ost -> st -> sample_aspect_ratio = par -> sample_aspect_ratio = sar ; ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate ; ost -> st -> r_frame_rate = ist -> st -> r_frame_rate ; break ; } ost -> mux_timebase = ist -> st -> time_base ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@set_encoder_id": "static void set_encoder_id ( OutputFile * of , OutputStream * ost ) { const char * cname = ost -> enc_ctx -> codec -> name ; uint8_t * encoder_string ; int encoder_string_len ; if ( av_dict_get ( ost -> st -> metadata , \"encoder\" , NULL , 0 ) ) return ; encoder_string_len = sizeof ( LIBAVCODEC_IDENT ) + strlen ( cname ) + 2 ; encoder_string = av_mallocz ( encoder_string_len ) ; if ( ! encoder_string ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( ! of -> bitexact && ! ost -> bitexact ) av_strlcpy ( encoder_string , LIBAVCODEC_IDENT \" \" , encoder_string_len ) ; else av_strlcpy ( encoder_string , \"Lavc \" , encoder_string_len ) ; av_strlcat ( encoder_string , cname , encoder_string_len ) ; av_dict_set ( & ost -> st -> metadata , \"encoder\" , encoder_string , AV_DICT_DONT_STRDUP_VAL | AV_DICT_DONT_OVERWRITE ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@init_encoder_time_base": "static void init_encoder_time_base ( OutputStream * ost , AVRational default_time_base ) { InputStream * ist = ost -> ist ; AVCodecContext * enc_ctx = ost -> enc_ctx ; if ( ost -> enc_timebase . num > 0 ) { enc_ctx -> time_base = ost -> enc_timebase ; return ; } if ( ost -> enc_timebase . num < 0 ) { if ( ist ) { enc_ctx -> time_base = ist -> st -> time_base ; return ; } av_log ( ost , AV_LOG_WARNING , \"Input stream data not available, using default time base\\n\" ) ; } enc_ctx -> time_base = default_time_base ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@init_output_stream_encode": "static int init_output_stream_encode ( OutputStream * ost , AVFrame * frame ) { InputStream * ist = ost -> ist ; AVCodecContext * enc_ctx = ost -> enc_ctx ; AVCodecContext * dec_ctx = NULL ; OutputFile * of = output_files [ ost -> file_index ] ; int ret ; set_encoder_id ( output_files [ ost -> file_index ] , ost ) ; if ( ist ) { dec_ctx = ist -> dec_ctx ; } if ( enc_ctx -> codec_type == AVMEDIA_TYPE_VIDEO ) { if ( ! ost -> frame_rate . num ) ost -> frame_rate = av_buffersink_get_frame_rate ( ost -> filter -> filter ) ; if ( ! ost -> frame_rate . num && ! ost -> max_frame_rate . num ) { ost -> frame_rate = ( AVRational ) { 25 , 1 } ; av_log ( ost , AV_LOG_WARNING , \"No information \" \"about the input framerate is available. Falling \" \"back to a default value of 25fps. Use the -r option \" \"if you want a different framerate.\\n\" ) ; } if ( ost -> max_frame_rate . num && ( av_q2d ( ost -> frame_rate ) > av_q2d ( ost -> max_frame_rate ) || ! ost -> frame_rate . den ) ) ost -> frame_rate = ost -> max_frame_rate ; if ( enc_ctx -> codec -> supported_framerates && ! ost -> force_fps ) { int idx = av_find_nearest_q_idx ( ost -> frame_rate , enc_ctx -> codec -> supported_framerates ) ; ost -> frame_rate = enc_ctx -> codec -> supported_framerates [ idx ] ; } // reduce frame rate for mpeg4 to be within the spec limits if ( enc_ctx -> codec_id == AV_CODEC_ID_MPEG4 ) { av_reduce ( & ost -> frame_rate . num , & ost -> frame_rate . den , ost -> frame_rate . num , ost -> frame_rate . den , 65535 ) ; } } switch ( enc_ctx -> codec_type ) { case AVMEDIA_TYPE_AUDIO : enc_ctx -> sample_fmt = av_buffersink_get_format ( ost -> filter -> filter ) ; enc_ctx -> sample_rate = av_buffersink_get_sample_rate ( ost -> filter -> filter ) ; ret = av_buffersink_get_ch_layout ( ost -> filter -> filter , & enc_ctx -> ch_layout ) ; if ( ret < 0 ) return ret ; if ( ost -> bits_per_raw_sample ) enc_ctx -> bits_per_raw_sample = ost -> bits_per_raw_sample ; else if ( dec_ctx && ost -> filter -> graph -> is_meta ) enc_ctx -> bits_per_raw_sample = FFMIN ( dec_ctx -> bits_per_raw_sample , av_get_bytes_per_sample ( enc_ctx -> sample_fmt ) << 3 ) ; init_encoder_time_base ( ost , av_make_q ( 1 , enc_ctx -> sample_rate ) ) ; break ; case AVMEDIA_TYPE_VIDEO : init_encoder_time_base ( ost , av_inv_q ( ost -> frame_rate ) ) ; if ( ! ( enc_ctx -> time_base . num && enc_ctx -> time_base . den ) ) enc_ctx -> time_base = av_buffersink_get_time_base ( ost -> filter -> filter ) ; if ( av_q2d ( enc_ctx -> time_base ) < 0.001 && ost -> vsync_method != VSYNC_PASSTHROUGH && ( ost -> vsync_method == VSYNC_CFR || ost -> vsync_method == VSYNC_VSCFR || ( ost -> vsync_method == VSYNC_AUTO && ! ( of -> format -> flags & AVFMT_VARIABLE_FPS ) ) ) ) { av_log ( ost , AV_LOG_WARNING , \"Frame rate very high for a muxer not efficiently supporting it.\\n\" \"Please consider specifying a lower framerate, a different muxer or \" \"setting vsync/fps_mode to vfr\\n\" ) ; } enc_ctx -> width = av_buffersink_get_w ( ost -> filter -> filter ) ; enc_ctx -> height = av_buffersink_get_h ( ost -> filter -> filter ) ; enc_ctx -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = ost -> frame_aspect_ratio . num ? // overridden by the -aspect cli option av_mul_q ( ost -> frame_aspect_ratio , ( AVRational ) { enc_ctx -> height , enc_ctx -> width } ) : av_buffersink_get_sample_aspect_ratio ( ost -> filter -> filter ) ; enc_ctx -> pix_fmt = av_buffersink_get_format ( ost -> filter -> filter ) ; if ( ost -> bits_per_raw_sample ) enc_ctx -> bits_per_raw_sample = ost -> bits_per_raw_sample ; else if ( dec_ctx && ost -> filter -> graph -> is_meta ) enc_ctx -> bits_per_raw_sample = FFMIN ( dec_ctx -> bits_per_raw_sample , av_pix_fmt_desc_get ( enc_ctx -> pix_fmt ) -> comp [ 0 ] . depth ) ; if ( frame ) { enc_ctx -> color_range = frame -> color_range ; enc_ctx -> color_primaries = frame -> color_primaries ; enc_ctx -> color_trc = frame -> color_trc ; enc_ctx -> colorspace = frame -> colorspace ; enc_ctx -> chroma_sample_location = frame -> chroma_location ; } enc_ctx -> framerate = ost -> frame_rate ; ost -> st -> avg_frame_rate = ost -> frame_rate ; // Field order: autodetection if ( frame ) { if ( enc_ctx -> flags & ( AV_CODEC_FLAG_INTERLACED_DCT | AV_CODEC_FLAG_INTERLACED_ME ) && ost -> top_field_first >= 0 ) frame -> top_field_first = ! ! ost -> top_field_first ; if ( frame -> interlaced_frame ) { if ( enc_ctx -> codec -> id == AV_CODEC_ID_MJPEG ) enc_ctx -> field_order = frame -> top_field_first ? AV_FIELD_TT : AV_FIELD_BB ; else enc_ctx -> field_order = frame -> top_field_first ? AV_FIELD_TB : AV_FIELD_BT ; } else enc_ctx -> field_order = AV_FIELD_PROGRESSIVE ; } // Field order: override if ( ost -> top_field_first == 0 ) { enc_ctx -> field_order = AV_FIELD_BB ; } else if ( ost -> top_field_first == 1 ) { enc_ctx -> field_order = AV_FIELD_TT ; } break ; case AVMEDIA_TYPE_SUBTITLE : enc_ctx -> time_base = AV_TIME_BASE_Q ; if ( ! enc_ctx -> width ) { enc_ctx -> width = ost -> ist -> par -> width ; enc_ctx -> height = ost -> ist -> par -> height ; } if ( dec_ctx && dec_ctx -> subtitle_header ) { /* ASS code assumes this buffer is null terminated so add extra byte. */ ost -> enc_ctx -> subtitle_header = av_mallocz ( dec_ctx -> subtitle_header_size + 1 ) ; if ( ! ost -> enc_ctx -> subtitle_header ) return AVERROR ( ENOMEM ) ; memcpy ( ost -> enc_ctx -> subtitle_header , dec_ctx -> subtitle_header , dec_ctx -> subtitle_header_size ) ; ost -> enc_ctx -> subtitle_header_size = dec_ctx -> subtitle_header_size ; } if ( ist && ist -> dec -> type == AVMEDIA_TYPE_SUBTITLE && enc_ctx -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { int input_props = 0 , output_props = 0 ; AVCodecDescriptor const * input_descriptor = avcodec_descriptor_get ( ist -> dec -> id ) ; AVCodecDescriptor const * output_descriptor = avcodec_descriptor_get ( ost -> enc_ctx -> codec_id ) ; if ( input_descriptor ) input_props = input_descriptor -> props & ( AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB ) ; if ( output_descriptor ) output_props = output_descriptor -> props & ( AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB ) ; if ( input_props && output_props && input_props != output_props ) { av_log ( ost , AV_LOG_ERROR , \"Subtitle encoding currently only possible from text to text \" \"or bitmap to bitmap\" ) ; return AVERROR_INVALIDDATA ; } } break ; case AVMEDIA_TYPE_DATA : break ; default : abort ( ) ; break ; } if ( ost -> bitexact ) enc_ctx -> flags |= AV_CODEC_FLAG_BITEXACT ; if ( ost -> sq_idx_encode >= 0 ) sq_set_tb ( of -> sq_encode , ost -> sq_idx_encode , enc_ctx -> time_base ) ; ost -> mux_timebase = enc_ctx -> time_base ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@init_output_stream": "static int init_output_stream ( OutputStream * ost , AVFrame * frame , char * error , int error_len ) { int ret = 0 ; if ( ost -> enc_ctx ) { const AVCodec * codec = ost -> enc_ctx -> codec ; InputStream * ist = ost -> ist ; ret = init_output_stream_encode ( ost , frame ) ; if ( ret < 0 ) return ret ; if ( ! av_dict_get ( ost -> encoder_opts , \"threads\" , NULL , 0 ) ) av_dict_set ( & ost -> encoder_opts , \"threads\" , \"auto\" , 0 ) ; if ( codec -> capabilities & AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE ) { ret = av_dict_set ( & ost -> encoder_opts , \"flags\" , \"+copy_opaque\" , AV_DICT_MULTIKEY ) ; if ( ret < 0 ) return ret ; } ret = hw_device_setup_for_encode ( ost ) ; if ( ret < 0 ) { snprintf ( error , error_len , \"Device setup failed for \" \"encoder on output stream #%d:%d : %s\" , ost -> file_index , ost -> index , av_err2str ( ret ) ) ; return ret ; } if ( ( ret = avcodec_open2 ( ost -> enc_ctx , codec , & ost -> encoder_opts ) ) < 0 ) { if ( ret == AVERROR_EXPERIMENTAL ) abort_codec_experimental ( codec , 1 ) ; snprintf ( error , error_len , \"Error while opening encoder for output stream #%d:%d - \" \"maybe incorrect parameters such as bit_rate, rate, width or height\" , ost -> file_index , ost -> index ) ; return ret ; } if ( codec -> type == AVMEDIA_TYPE_AUDIO && ! ( codec -> capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE ) ) av_buffersink_set_frame_size ( ost -> filter -> filter , ost -> enc_ctx -> frame_size ) ; assert_avoptions ( ost -> encoder_opts ) ; if ( ost -> enc_ctx -> bit_rate && ost -> enc_ctx -> bit_rate < 1000 && ost -> enc_ctx -> codec_id != AV_CODEC_ID_CODEC2 /* don't complain about 700 bit/s modes */ ) av_log ( ost , AV_LOG_WARNING , \"The bitrate parameter is set too low.\" \" It takes bits/s as argument, not kbits/s\\n\" ) ; ret = avcodec_parameters_from_context ( ost -> st -> codecpar , ost -> enc_ctx ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Error initializing the output stream codec context.\\n\" ) ; exit_program ( 1 ) ; } if ( ost -> enc_ctx -> nb_coded_side_data ) { int i ; for ( i = 0 ; i < ost -> enc_ctx -> nb_coded_side_data ; i ++ ) { const AVPacketSideData * sd_src = & ost -> enc_ctx -> coded_side_data [ i ] ; uint8_t * dst_data ; dst_data = av_stream_new_side_data ( ost -> st , sd_src -> type , sd_src -> size ) ; if ( ! dst_data ) return AVERROR ( ENOMEM ) ; memcpy ( dst_data , sd_src -> data , sd_src -> size ) ; } } /*\n         * Add global input side data. For now this is naive, and copies it\n         * from the input stream's global side data. All side data should\n         * really be funneled over AVFrame and libavfilter, then added back to\n         * packet side data, and then potentially using the first packet for\n         * global side data.\n         */ if ( ist ) { int i ; for ( i = 0 ; i < ist -> st -> nb_side_data ; i ++ ) { AVPacketSideData * sd = & ist -> st -> side_data [ i ] ; if ( sd -> type != AV_PKT_DATA_CPB_PROPERTIES ) { uint8_t * dst = av_stream_new_side_data ( ost -> st , sd -> type , sd -> size ) ; if ( ! dst ) return AVERROR ( ENOMEM ) ; memcpy ( dst , sd -> data , sd -> size ) ; if ( ist -> autorotate && sd -> type == AV_PKT_DATA_DISPLAYMATRIX ) av_display_rotation_set ( ( int32_t * ) dst , 0 ) ; } } } // copy timebase while removing common factors if ( ost -> st -> time_base . num <= 0 || ost -> st -> time_base . den <= 0 ) ost -> st -> time_base = av_add_q ( ost -> enc_ctx -> time_base , ( AVRational ) { 0 , 1 } ) ; // copy estimated duration as a hint to the muxer if ( ost -> st -> duration <= 0 && ist && ist -> st -> duration > 0 ) ost -> st -> duration = av_rescale_q ( ist -> st -> duration , ist -> st -> time_base , ost -> st -> time_base ) ; } else if ( ost -> ist ) { ret = init_output_stream_streamcopy ( ost ) ; if ( ret < 0 ) return ret ; } ret = of_stream_init ( output_files [ ost -> file_index ] , ost ) ; if ( ret < 0 ) return ret ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@transcode_init": "static int transcode_init ( void ) { int ret = 0 ; char error [ 1024 ] = { 0 } ; /* init framerate emulation */ for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * ifile = input_files [ i ] ; if ( ifile -> readrate || ifile -> rate_emu ) for ( int j = 0 ; j < ifile -> nb_streams ; j ++ ) ifile -> streams [ j ] -> start = av_gettime_relative ( ) ; } /* init input streams */ for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) if ( ( ret = init_input_stream ( ist , error , sizeof ( error ) ) ) < 0 ) goto dump_format ; /*\n     * initialize stream copy and subtitle/data streams.\n     * Encoded AVFrame based streams will get initialized as follows:\n     * - when the first AVFrame is received in do_video_out\n     * - just before the first AVFrame is received in either transcode_step\n     *   or reap_filters due to us requiring the filter chain buffer sink\n     *   to be configured with the correct audio frame size, which is only\n     *   known after the encoder is initialized.\n     */ for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> enc_ctx && ( ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO || ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) ) continue ; ret = init_output_stream_wrapper ( ost , NULL , 0 ) ; if ( ret < 0 ) goto dump_format ; } /* discard unused programs */ for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * ifile = input_files [ i ] ; for ( int j = 0 ; j < ifile -> ctx -> nb_programs ; j ++ ) { AVProgram * p = ifile -> ctx -> programs [ j ] ; int discard = AVDISCARD_ALL ; for ( int k = 0 ; k < p -> nb_stream_indexes ; k ++ ) if ( ! ifile -> streams [ p -> stream_index [ k ] ] -> discard ) { discard = AVDISCARD_DEFAULT ; break ; } p -> discard = discard ; } } dump_format : /* dump the stream mapping */ av_log ( NULL , AV_LOG_INFO , \"Stream mapping:\\n\" ) ; for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) { for ( int j = 0 ; j < ist -> nb_filters ; j ++ ) { if ( ! filtergraph_is_simple ( ist -> filters [ j ] -> graph ) ) { av_log ( NULL , AV_LOG_INFO , \"  Stream #%d:%d (%s) -> %s\" , ist -> file_index , ist -> st -> index , ist -> dec ? ist -> dec -> name : \"?\" , ist -> filters [ j ] -> name ) ; if ( nb_filtergraphs > 1 ) av_log ( NULL , AV_LOG_INFO , \" (graph %d)\" , ist -> filters [ j ] -> graph -> index ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; } } } for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> attachment_filename ) { /* an attached file */ av_log ( NULL , AV_LOG_INFO , \"  File %s -> Stream #%d:%d\\n\" , ost -> attachment_filename , ost -> file_index , ost -> index ) ; continue ; } if ( ost -> filter && ! filtergraph_is_simple ( ost -> filter -> graph ) ) { /* output from a complex graph */ av_log ( NULL , AV_LOG_INFO , \"  %s\" , ost -> filter -> name ) ; if ( nb_filtergraphs > 1 ) av_log ( NULL , AV_LOG_INFO , \" (graph %d)\" , ost -> filter -> graph -> index ) ; av_log ( NULL , AV_LOG_INFO , \" -> Stream #%d:%d (%s)\\n\" , ost -> file_index , ost -> index , ost -> enc_ctx -> codec -> name ) ; continue ; } av_log ( NULL , AV_LOG_INFO , \"  Stream #%d:%d -> #%d:%d\" , ost -> ist -> file_index , ost -> ist -> st -> index , ost -> file_index , ost -> index ) ; if ( ost -> enc_ctx ) { const AVCodec * in_codec = ost -> ist -> dec ; const AVCodec * out_codec = ost -> enc_ctx -> codec ; const char * decoder_name = \"?\" ; const char * in_codec_name = \"?\" ; const char * encoder_name = \"?\" ; const char * out_codec_name = \"?\" ; const AVCodecDescriptor * desc ; if ( in_codec ) { decoder_name = in_codec -> name ; desc = avcodec_descriptor_get ( in_codec -> id ) ; if ( desc ) in_codec_name = desc -> name ; if ( ! strcmp ( decoder_name , in_codec_name ) ) decoder_name = \"native\" ; } if ( out_codec ) { encoder_name = out_codec -> name ; desc = avcodec_descriptor_get ( out_codec -> id ) ; if ( desc ) out_codec_name = desc -> name ; if ( ! strcmp ( encoder_name , out_codec_name ) ) encoder_name = \"native\" ; } av_log ( NULL , AV_LOG_INFO , \" (%s (%s) -> %s (%s))\" , in_codec_name , decoder_name , out_codec_name , encoder_name ) ; } else av_log ( NULL , AV_LOG_INFO , \" (copy)\" ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; } if ( ret ) { av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" , error ) ; return ret ; } atomic_store ( & transcode_init_done , 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@need_output": "static int need_output ( void ) { for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> finished ) continue ; return 1 ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@choose_output": "static OutputStream * choose_output ( void ) { int64_t opts_min = INT64_MAX ; OutputStream * ost_min = NULL ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { int64_t opts ; if ( ost -> filter && ost -> last_filter_pts != AV_NOPTS_VALUE ) { opts = ost -> last_filter_pts ; } else { opts = ost -> last_mux_dts == AV_NOPTS_VALUE ? INT64_MIN : ost -> last_mux_dts ; if ( ost -> last_mux_dts == AV_NOPTS_VALUE ) av_log ( ost , AV_LOG_DEBUG , \"cur_dts is invalid [init:%d i_done:%d finish:%d] (this is harmless if it occurs once at the start per stream)\\n\" , ost -> initialized , ost -> inputs_done , ost -> finished ) ; } if ( ! ost -> initialized && ! ost -> inputs_done ) return ost -> unavailable ? NULL : ost ; if ( ! ost -> finished && opts < opts_min ) { opts_min = opts ; ost_min = ost -> unavailable ? NULL : ost ; } } return ost_min ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@set_tty_echo": "static void set_tty_echo ( int on ) { # if HAVE_TERMIOS_H struct termios tty ; if ( tcgetattr ( 0 , & tty ) == 0 ) { if ( on ) tty . c_lflag |= ECHO ; else tty . c_lflag &= ~ ECHO ; tcsetattr ( 0 , TCSANOW , & tty ) ; } # endif }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@check_keyboard_interaction": "static int check_keyboard_interaction ( int64_t cur_time ) { int i , ret , key ; if ( received_nb_signals ) return AVERROR_EXIT ; /* read_key() returns 0 on EOF */ if ( cur_time - keyboard_last_time >= 100000 ) { key = read_key ( ) ; keyboard_last_time = cur_time ; } else key = - 1 ; if ( key == 'q' ) { av_log ( NULL , AV_LOG_INFO , \"\\n\\n[q] command received. Exiting.\\n\\n\" ) ; return AVERROR_EXIT ; } if ( key == '+' ) av_log_set_level ( av_log_get_level ( ) + 10 ) ; if ( key == '-' ) av_log_set_level ( av_log_get_level ( ) - 10 ) ; if ( key == 's' ) qp_hist ^= 1 ; if ( key == 'c' || key == 'C' ) { char buf [ 4096 ] , target [ 64 ] , command [ 256 ] , arg [ 256 ] = { 0 } ; double time ; int k , n = 0 ; av_log ( NULL , AV_LOG_STDERR , \"\\nEnter command: <target>|all <time>|-1 <command>[ <argument>]\\n\" ) ; i = 0 ; set_tty_echo ( 1 ) ; while ( ( k = read_key ( ) ) != '\\n' && k != '\\r' && i < sizeof ( buf ) - 1 ) if ( k > 0 ) buf [ i ++ ] = k ; buf [ i ] = 0 ; set_tty_echo ( 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; if ( k > 0 && ( n = sscanf ( buf , \"%63[^ ] %lf %255[^ ] %255[^\\n]\" , target , & time , command , arg ) ) >= 3 ) { av_log ( NULL , AV_LOG_DEBUG , \"Processing command target:%s time:%f command:%s arg:%s\" , target , time , command , arg ) ; for ( i = 0 ; i < nb_filtergraphs ; i ++ ) { FilterGraph * fg = filtergraphs [ i ] ; if ( fg -> graph ) { if ( time < 0 ) { ret = avfilter_graph_send_command ( fg -> graph , target , command , arg , buf , sizeof ( buf ) , key == 'c' ? AVFILTER_CMD_FLAG_ONE : 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"Command reply for stream %d: ret:%d res:\\n%s\" , i , ret , buf ) ; } else if ( key == 'c' ) { av_log ( NULL , AV_LOG_STDERR , \"Queuing commands only on filters supporting the specific command is unsupported\\n\" ) ; ret = AVERROR_PATCHWELCOME ; } else { ret = avfilter_graph_queue_command ( fg -> graph , target , command , arg , 0 , time ) ; if ( ret < 0 ) av_log ( NULL , AV_LOG_STDERR , \"Queuing command failed with error %s\\n\" , av_err2str ( ret ) ) ; } } } } else { av_log ( NULL , AV_LOG_ERROR , \"Parse error, at least 3 arguments were expected, \" \"only %d given in string '%s'\\n\" , n , buf ) ; } } if ( key == 'd' || key == 'D' ) { int debug = 0 ; if ( key == 'D' ) { InputStream * ist = ist_iter ( NULL ) ; if ( ist ) debug = ist -> dec_ctx -> debug << 1 ; if ( ! debug ) debug = 1 ; while ( debug & FF_DEBUG_DCT_COEFF ) //unsupported, would just crash debug += debug ; } else { char buf [ 32 ] ; int k = 0 ; i = 0 ; set_tty_echo ( 1 ) ; while ( ( k = read_key ( ) ) != '\\n' && k != '\\r' && i < sizeof ( buf ) - 1 ) if ( k > 0 ) buf [ i ++ ] = k ; buf [ i ] = 0 ; set_tty_echo ( 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; if ( k <= 0 || sscanf ( buf , \"%d\" , & debug ) != 1 ) av_log ( NULL , AV_LOG_STDERR , \"error parsing debug value\\n\" ) ; } for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) ist -> dec_ctx -> debug = debug ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> enc_ctx ) ost -> enc_ctx -> debug = debug ; } if ( debug ) av_log_set_level ( AV_LOG_DEBUG ) ; av_log ( NULL , AV_LOG_STDERR , \"debug=%d\\n\" , debug ) ; } if ( key == '?' ) { av_log ( NULL , AV_LOG_STDERR , \"key    function\\n\" \"?      show this help\\n\" \"+      increase verbosity\\n\" \"-      decrease verbosity\\n\" \"c      Send command to first matching filter supporting it\\n\" \"C      Send/Queue command to all matching filters\\n\" \"D      cycle through available debug modes\\n\" \"h      dump packets/hex press to cycle through the 3 states\\n\" \"q      quit\\n\" \"s      Show QP histogram\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@got_eagain": "static int got_eagain ( void ) { for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) if ( ost -> unavailable ) return 1 ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@reset_eagain": "static void reset_eagain ( void ) { int i ; for ( i = 0 ; i < nb_input_files ; i ++ ) input_files [ i ] -> eagain = 0 ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) ost -> unavailable = 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@decode_flush": "static void decode_flush ( InputFile * ifile ) { for ( int i = 0 ; i < ifile -> nb_streams ; i ++ ) { InputStream * ist = ifile -> streams [ i ] ; int ret ; if ( ! ist -> processing_needed ) continue ; do { ret = process_input_packet ( ist , NULL , 1 ) ; } while ( ret > 0 ) ; if ( ist -> decoding_needed ) { /* report last frame duration to the demuxer thread */ if ( ist -> par -> codec_type == AVMEDIA_TYPE_AUDIO ) { LastFrameDuration dur ; dur . stream_idx = i ; dur . duration = av_rescale_q ( ist -> nb_samples , ( AVRational ) { 1 , ist -> dec_ctx -> sample_rate } , ist -> st -> time_base ) ; av_thread_message_queue_send ( ifile -> audio_duration_queue , & dur , 0 ) ; } avcodec_flush_buffers ( ist -> dec_ctx ) ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@ts_discontinuity_detect": "static void ts_discontinuity_detect ( InputFile * ifile , InputStream * ist , AVPacket * pkt ) { const int fmt_is_discont = ifile -> ctx -> iformat -> flags & AVFMT_TS_DISCONT ; int disable_discontinuity_correction = copy_ts ; int64_t pkt_dts = av_rescale_q_rnd ( pkt -> dts , ist -> st -> time_base , AV_TIME_BASE_Q , AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX ) ; if ( copy_ts && ist -> next_dts != AV_NOPTS_VALUE && fmt_is_discont && ist -> st -> pts_wrap_bits < 60 ) { int64_t wrap_dts = av_rescale_q_rnd ( pkt -> dts + ( 1LL << ist -> st -> pts_wrap_bits ) , ist -> st -> time_base , AV_TIME_BASE_Q , AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX ) ; if ( FFABS ( wrap_dts - ist -> next_dts ) < FFABS ( pkt_dts - ist -> next_dts ) / 10 ) disable_discontinuity_correction = 0 ; } if ( ist -> next_dts != AV_NOPTS_VALUE && ! disable_discontinuity_correction ) { int64_t delta = pkt_dts - ist -> next_dts ; if ( fmt_is_discont ) { if ( FFABS ( delta ) > 1LL * dts_delta_threshold * AV_TIME_BASE || pkt_dts + AV_TIME_BASE / 10 < FFMAX ( ist -> pts , ist -> dts ) ) { ifile -> ts_offset_discont -= delta ; av_log ( NULL , AV_LOG_DEBUG , \"timestamp discontinuity for stream #%d:%d \" \"(id=%d, type=%s): %\" PRId64 \", new offset= %\" PRId64 \"\\n\" , ist -> file_index , ist -> st -> index , ist -> st -> id , av_get_media_type_string ( ist -> par -> codec_type ) , delta , ifile -> ts_offset_discont ) ; pkt -> dts -= av_rescale_q ( delta , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts -= av_rescale_q ( delta , AV_TIME_BASE_Q , ist -> st -> time_base ) ; } } else { if ( FFABS ( delta ) > 1LL * dts_error_threshold * AV_TIME_BASE ) { av_log ( NULL , AV_LOG_WARNING , \"DTS %\" PRId64 \", next:%\" PRId64 \" st:%d invalid dropping\\n\" , pkt -> dts , ist -> next_dts , pkt -> stream_index ) ; pkt -> dts = AV_NOPTS_VALUE ; } if ( pkt -> pts != AV_NOPTS_VALUE ) { int64_t pkt_pts = av_rescale_q ( pkt -> pts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; delta = pkt_pts - ist -> next_dts ; if ( FFABS ( delta ) > 1LL * dts_error_threshold * AV_TIME_BASE ) { av_log ( NULL , AV_LOG_WARNING , \"PTS %\" PRId64 \", next:%\" PRId64 \" invalid dropping st:%d\\n\" , pkt -> pts , ist -> next_dts , pkt -> stream_index ) ; pkt -> pts = AV_NOPTS_VALUE ; } } } } else if ( ist -> next_dts == AV_NOPTS_VALUE && ! copy_ts && fmt_is_discont && ifile -> last_ts != AV_NOPTS_VALUE ) { int64_t delta = pkt_dts - ifile -> last_ts ; if ( FFABS ( delta ) > 1LL * dts_delta_threshold * AV_TIME_BASE ) { ifile -> ts_offset_discont -= delta ; av_log ( NULL , AV_LOG_DEBUG , \"Inter stream timestamp discontinuity %\" PRId64 \", new offset= %\" PRId64 \"\\n\" , delta , ifile -> ts_offset_discont ) ; pkt -> dts -= av_rescale_q ( delta , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts -= av_rescale_q ( delta , AV_TIME_BASE_Q , ist -> st -> time_base ) ; } } ifile -> last_ts = av_rescale_q ( pkt -> dts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@ts_discontinuity_process": "static void ts_discontinuity_process ( InputFile * ifile , InputStream * ist , AVPacket * pkt ) { int64_t offset = av_rescale_q ( ifile -> ts_offset_discont , AV_TIME_BASE_Q , ist -> st -> time_base ) ; // apply previously-detected timestamp-discontinuity offset // (to all streams, not just audio/video) if ( pkt -> dts != AV_NOPTS_VALUE ) pkt -> dts += offset ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts += offset ; // detect timestamp discontinuities for audio/video if ( ( ist -> par -> codec_type == AVMEDIA_TYPE_VIDEO || ist -> par -> codec_type == AVMEDIA_TYPE_AUDIO ) && pkt -> dts != AV_NOPTS_VALUE ) ts_discontinuity_detect ( ifile , ist , pkt ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@process_input": "static int process_input ( int file_index ) { InputFile * ifile = input_files [ file_index ] ; AVFormatContext * is ; InputStream * ist ; AVPacket * pkt ; int ret , i ; is = ifile -> ctx ; ret = ifile_get_packet ( ifile , & pkt ) ; if ( ret == AVERROR ( EAGAIN ) ) { ifile -> eagain = 1 ; return ret ; } if ( ret == 1 ) { /* the input file is looped: flush the decoders */ decode_flush ( ifile ) ; return AVERROR ( EAGAIN ) ; } if ( ret < 0 ) { if ( ret != AVERROR_EOF ) { print_error ( is -> url , ret ) ; if ( exit_on_error ) exit_program ( 1 ) ; } for ( i = 0 ; i < ifile -> nb_streams ; i ++ ) { ist = ifile -> streams [ i ] ; if ( ist -> processing_needed ) { ret = process_input_packet ( ist , NULL , 0 ) ; if ( ret > 0 ) return 0 ; } /* mark all outputs that don't go through lavfi as finished */ for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> ist == ist && ( ! ost -> enc_ctx || ost -> enc_ctx -> codec_type == AVMEDIA_TYPE_SUBTITLE ) ) { OutputFile * of = output_files [ ost -> file_index ] ; of_output_packet ( of , ost -> pkt , ost , 1 ) ; } } } ifile -> eof_reached = 1 ; return AVERROR ( EAGAIN ) ; } reset_eagain ( ) ; ist = ifile -> streams [ pkt -> stream_index ] ; ist -> data_size += pkt -> size ; ist -> nb_packets ++ ; if ( ist -> discard ) goto discard_packet ; /* add the stream-global side data to the first packet */ if ( ist -> nb_packets == 1 ) { for ( i = 0 ; i < ist -> st -> nb_side_data ; i ++ ) { AVPacketSideData * src_sd = & ist -> st -> side_data [ i ] ; uint8_t * dst_data ; if ( src_sd -> type == AV_PKT_DATA_DISPLAYMATRIX ) continue ; if ( av_packet_get_side_data ( pkt , src_sd -> type , NULL ) ) continue ; dst_data = av_packet_new_side_data ( pkt , src_sd -> type , src_sd -> size ) ; if ( ! dst_data ) report_and_exit ( AVERROR ( ENOMEM ) ) ; memcpy ( dst_data , src_sd -> data , src_sd -> size ) ; } } // detect and try to correct for timestamp discontinuities ts_discontinuity_process ( ifile , ist , pkt ) ; if ( debug_ts ) { av_log ( NULL , AV_LOG_INFO , \"demuxer+ffmpeg -> ist_index:%d:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s off:%s off_time:%s\\n\" , ifile -> index , pkt -> stream_index , av_get_media_type_string ( ist -> par -> codec_type ) , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & ist -> st -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & ist -> st -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & ist -> st -> time_base ) , av_ts2str ( input_files [ ist -> file_index ] -> ts_offset ) , av_ts2timestr ( input_files [ ist -> file_index ] -> ts_offset , & AV_TIME_BASE_Q ) ) ; } sub2video_heartbeat ( ist , pkt -> pts ) ; process_input_packet ( ist , pkt , 0 ) ; discard_packet : av_packet_free ( & pkt ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@transcode_from_filter": "static int transcode_from_filter ( FilterGraph * graph , InputStream * * best_ist ) { int i , ret ; int nb_requests , nb_requests_max = 0 ; InputFilter * ifilter ; InputStream * ist ; * best_ist = NULL ; ret = avfilter_graph_request_oldest ( graph -> graph ) ; if ( ret >= 0 ) return reap_filters ( 0 ) ; if ( ret == AVERROR_EOF ) { ret = reap_filters ( 1 ) ; for ( i = 0 ; i < graph -> nb_outputs ; i ++ ) close_output_stream ( graph -> outputs [ i ] -> ost ) ; return ret ; } if ( ret != AVERROR ( EAGAIN ) ) return ret ; for ( i = 0 ; i < graph -> nb_inputs ; i ++ ) { ifilter = graph -> inputs [ i ] ; ist = ifilter -> ist ; if ( input_files [ ist -> file_index ] -> eagain || input_files [ ist -> file_index ] -> eof_reached ) continue ; nb_requests = av_buffersrc_get_nb_failed_requests ( ifilter -> filter ) ; if ( nb_requests > nb_requests_max ) { nb_requests_max = nb_requests ; * best_ist = ist ; } } if ( ! * best_ist ) for ( i = 0 ; i < graph -> nb_outputs ; i ++ ) graph -> outputs [ i ] -> ost -> unavailable = 1 ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@transcode_step": "static int transcode_step ( void ) { OutputStream * ost ; InputStream * ist = NULL ; int ret ; ost = choose_output ( ) ; if ( ! ost ) { if ( got_eagain ( ) ) { reset_eagain ( ) ; av_usleep ( 10000 ) ; return 0 ; } av_log ( NULL , AV_LOG_VERBOSE , \"No more inputs to read from, finishing.\\n\" ) ; return AVERROR_EOF ; } if ( ost -> filter && ! ost -> filter -> graph -> graph ) { if ( ifilter_has_all_input_formats ( ost -> filter -> graph ) ) { ret = configure_filtergraph ( ost -> filter -> graph ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error reinitializing filters!\\n\" ) ; return ret ; } } } if ( ost -> filter && ost -> filter -> graph -> graph ) { /*\n         * Similar case to the early audio initialization in reap_filters.\n         * Audio is special in ffmpeg.c currently as we depend on lavfi's\n         * audio frame buffering/creation to get the output audio frame size\n         * in samples correct. The audio frame size for the filter chain is\n         * configured during the output stream initialization.\n         *\n         * Apparently avfilter_graph_request_oldest (called in\n         * transcode_from_filter just down the line) peeks. Peeking already\n         * puts one frame \"ready to be given out\", which means that any\n         * update in filter buffer sink configuration afterwards will not\n         * help us. And yes, even if it would be utilized,\n         * av_buffersink_get_samples is affected, as it internally utilizes\n         * the same early exit for peeked frames.\n         *\n         * In other words, if avfilter_graph_request_oldest would not make\n         * further filter chain configuration or usage of\n         * av_buffersink_get_samples useless (by just causing the return\n         * of the peeked AVFrame as-is), we could get rid of this additional\n         * early encoder initialization.\n         */ if ( av_buffersink_get_type ( ost -> filter -> filter ) == AVMEDIA_TYPE_AUDIO ) init_output_stream_wrapper ( ost , NULL , 1 ) ; if ( ( ret = transcode_from_filter ( ost -> filter -> graph , & ist ) ) < 0 ) return ret ; if ( ! ist ) return 0 ; } else if ( ost -> filter ) { int i ; for ( i = 0 ; i < ost -> filter -> graph -> nb_inputs ; i ++ ) { InputFilter * ifilter = ost -> filter -> graph -> inputs [ i ] ; if ( ! ifilter -> ist -> got_output && ! input_files [ ifilter -> ist -> file_index ] -> eof_reached ) { ist = ifilter -> ist ; break ; } } if ( ! ist ) { ost -> inputs_done = 1 ; return 0 ; } } else { ist = ost -> ist ; av_assert0 ( ist ) ; } ret = process_input ( ist -> file_index ) ; if ( ret == AVERROR ( EAGAIN ) ) { if ( input_files [ ist -> file_index ] -> eagain ) ost -> unavailable = 1 ; return 0 ; } if ( ret < 0 ) return ret == AVERROR_EOF ? 0 : ret ; return reap_filters ( 0 ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@transcode": "static int transcode ( void ) { int ret , i ; InputStream * ist ; int64_t timer_start ; int64_t total_packets_written = 0 ; ret = transcode_init ( ) ; if ( ret < 0 ) goto fail ; if ( stdin_interaction ) { av_log ( NULL , AV_LOG_INFO , \"Press [q] to stop, [?] for help\\n\" ) ; } timer_start = av_gettime_relative ( ) ; while ( ! received_sigterm && ! cancelRequested ( globalSessionId ) ) { int64_t cur_time = av_gettime_relative ( ) ; /* if 'q' pressed, exits */ if ( stdin_interaction ) if ( check_keyboard_interaction ( cur_time ) < 0 ) break ; /* check if there's any stream where output is still needed */ if ( ! need_output ( ) ) { av_log ( NULL , AV_LOG_VERBOSE , \"No more output streams to write to, finishing.\\n\" ) ; break ; } ret = transcode_step ( ) ; if ( ret < 0 && ret != AVERROR_EOF ) { av_log ( NULL , AV_LOG_ERROR , \"Error while filtering: %s\\n\" , av_err2str ( ret ) ) ; break ; } /* dump report by using the output first video and audio streams */ print_report ( 0 , timer_start , cur_time ) ; } /* at the end of stream, we must flush the decoder buffers */ for ( ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) { if ( ! input_files [ ist -> file_index ] -> eof_reached ) { process_input_packet ( ist , NULL , 0 ) ; } } flush_encoders ( ) ; term_exit ( ) ; /* write the trailer if needed */ for ( i = 0 ; i < nb_output_files ; i ++ ) { ret = of_write_trailer ( output_files [ i ] ) ; if ( ret < 0 && exit_on_error ) exit_program ( 1 ) ; } /* dump report by using the first video and audio streams */ print_report ( 1 , timer_start , av_gettime_relative ( ) ) ; /* close each encoder */ for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { uint64_t packets_written ; packets_written = atomic_load ( & ost -> packets_written ) ; total_packets_written += packets_written ; if ( ! packets_written && ( abort_on_flags & ABORT_ON_FLAG_EMPTY_OUTPUT_STREAM ) ) { av_log ( ost , AV_LOG_FATAL , \"Empty output\\n\" ) ; exit_program ( 1 ) ; } } if ( ! total_packets_written && ( abort_on_flags & ABORT_ON_FLAG_EMPTY_OUTPUT ) ) { av_log ( NULL , AV_LOG_FATAL , \"Empty output\\n\" ) ; exit_program ( 1 ) ; } hw_device_free_all ( ) ; /* finished ! */ ret = 0 ; fail : return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@get_benchmark_time_stamps": "static BenchmarkTimeStamps get_benchmark_time_stamps ( void ) { BenchmarkTimeStamps time_stamps = { av_gettime_relative ( ) } ; # if HAVE_GETRUSAGE struct rusage rusage ; getrusage ( RUSAGE_SELF , & rusage ) ; time_stamps . user_usec = ( rusage . ru_utime . tv_sec * 1000000LL ) + rusage . ru_utime . tv_usec ; time_stamps . sys_usec = ( rusage . ru_stime . tv_sec * 1000000LL ) + rusage . ru_stime . tv_usec ; # elif HAVE_GETPROCESSTIMES HANDLE proc ; FILETIME c , e , k , u ; proc = GetCurrentProcess ( ) ; GetProcessTimes ( proc , & c , & e , & k , & u ) ; time_stamps . user_usec = ( ( int64_t ) u . dwHighDateTime << 32 | u . dwLowDateTime ) / 10 ; time_stamps . sys_usec = ( ( int64_t ) k . dwHighDateTime << 32 | k . dwLowDateTime ) / 10 ; # else time_stamps . user_usec = time_stamps . sys_usec = 0 ; # endif return time_stamps ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@getmaxrss": "static int64_t getmaxrss ( void ) { # if HAVE_GETRUSAGE && HAVE_STRUCT_RUSAGE_RU_MAXRSS struct rusage rusage ; getrusage ( RUSAGE_SELF , & rusage ) ; return ( int64_t ) rusage . ru_maxrss * 1024 ; # elif HAVE_GETPROCESSMEMORYINFO HANDLE proc ; PROCESS_MEMORY_COUNTERS memcounters ; proc = GetCurrentProcess ( ) ; memcounters . cb = sizeof ( memcounters ) ; GetProcessMemoryInfo ( proc , & memcounters , sizeof ( memcounters ) ) ; return memcounters . PeakPagefileUsage ; # else return 0 ; # endif }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@ffmpeg_var_cleanup": "void ffmpeg_var_cleanup ( ) { received_sigterm = 0 ; received_nb_signals = 0 ; transcode_init_done = ATOMIC_VAR_INIT ( 0 ) ; ffmpeg_exited = 0 ; main_ffmpeg_return_code = 0 ; copy_ts_first_pts = AV_NOPTS_VALUE ; longjmp_value = 0 ; want_sdp = 1 ; enc_stats_files = NULL ; nb_enc_stats_files = 0 ; vstats_file = NULL ; nb_frames_dup = 0 ; dup_warning = 1000 ; nb_frames_drop = 0 ; decode_error_stat [ 0 ] = 0 ; decode_error_stat [ 1 ] = 0 ; nb_output_dumped = 0 ; progress_avio = NULL ; input_files = NULL ; nb_input_files = 0 ; output_files = NULL ; nb_output_files = 0 ; filtergraphs = NULL ; nb_filtergraphs = 0 ; last_time = - 1 ; keyboard_last_time = 0 ; first_report = 1 ; for ( int i = 0 ; i < FF_ARRAY_ELEMS ( qp_histogram ) ; i ++ ) { qp_histogram [ i ] = 0 ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@set_report_callback": "void set_report_callback ( void ( * callback ) ( int , float , float , int64_t , double , double , double ) ) { report_callback = callback ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@cancel_operation": "void cancel_operation ( long id ) { if ( id == 0 ) { sigterm_handler ( SIGINT ) ; } else { cancelSession ( id ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg.c@ffmpeg_execute": "int ffmpeg_execute ( int argc , char * * argv ) { char _program_name [ ] = \"ffmpeg\" ; program_name = ( char * ) & _program_name ; program_birth_year = 2000 ; # define OFFSET ( x ) offsetof ( OptionsContext , x ) OptionDef options [ ] = { /* main options */ { \"L\" , OPT_EXIT , { . func_arg = show_license } , \"show license\" } , { \"h\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"?\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"help\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"-help\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"version\" , OPT_EXIT , { . func_arg = show_version } , \"show version\" } , { \"buildconf\" , OPT_EXIT , { . func_arg = show_buildconf } , \"show build configuration\" } , { \"formats\" , OPT_EXIT , { . func_arg = show_formats } , \"show available formats\" } , { \"muxers\" , OPT_EXIT , { . func_arg = show_muxers } , \"show available muxers\" } , { \"demuxers\" , OPT_EXIT , { . func_arg = show_demuxers } , \"show available demuxers\" } , { \"devices\" , OPT_EXIT , { . func_arg = show_devices } , \"show available devices\" } , { \"codecs\" , OPT_EXIT , { . func_arg = show_codecs } , \"show available codecs\" } , { \"decoders\" , OPT_EXIT , { . func_arg = show_decoders } , \"show available decoders\" } , { \"encoders\" , OPT_EXIT , { . func_arg = show_encoders } , \"show available encoders\" } , { \"bsfs\" , OPT_EXIT , { . func_arg = show_bsfs } , \"show available bit stream filters\" } , { \"protocols\" , OPT_EXIT , { . func_arg = show_protocols } , \"show available protocols\" } , { \"filters\" , OPT_EXIT , { . func_arg = show_filters } , \"show available filters\" } , { \"pix_fmts\" , OPT_EXIT , { . func_arg = show_pix_fmts } , \"show available pixel formats\" } , { \"layouts\" , OPT_EXIT , { . func_arg = show_layouts } , \"show standard channel layouts\" } , { \"sample_fmts\" , OPT_EXIT , { . func_arg = show_sample_fmts } , \"show available audio sample formats\" } , { \"dispositions\" , OPT_EXIT , { . func_arg = show_dispositions } , \"show available stream dispositions\" } , { \"colors\" , OPT_EXIT , { . func_arg = show_colors } , \"show available color names\" } , { \"loglevel\" , HAS_ARG , { . func_arg = opt_loglevel } , \"set logging level\" , \"loglevel\" } , { \"v\" , HAS_ARG , { . func_arg = opt_loglevel } , \"set logging level\" , \"loglevel\" } , { \"report\" , 0 , { . func_arg = opt_report } , \"generate a report\" } , { \"max_alloc\" , HAS_ARG , { . func_arg = opt_max_alloc } , \"set maximum size of a single allocated block\" , \"bytes\" } , { \"cpuflags\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_cpuflags } , \"force specific cpu flags\" , \"flags\" } , { \"cpucount\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_cpucount } , \"force specific cpu count\" , \"count\" } , { \"hide_banner\" , OPT_BOOL | OPT_EXPERT , { & hide_banner } , \"do not show program banner\" , \"hide_banner\" } , # if CONFIG_AVDEVICE { \"sources\" , OPT_EXIT | HAS_ARG , { . func_arg = show_sources } , \"list sources of the input device\" , \"device\" } , { \"sinks\" , OPT_EXIT | HAS_ARG , { . func_arg = show_sinks } , \"list sinks of the output device\" , \"device\" } , # endif { \"f\" , HAS_ARG | OPT_STRING | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( format ) } , \"force format\" , \"fmt\" } , { \"y\" , OPT_BOOL , { & file_overwrite } , \"overwrite output files\" } , { \"n\" , OPT_BOOL , { & no_file_overwrite } , \"never overwrite output files\" } , { \"ignore_unknown\" , OPT_BOOL , { & ignore_unknown_streams } , \"Ignore unknown stream types\" } , { \"copy_unknown\" , OPT_BOOL | OPT_EXPERT , { & copy_unknown_streams } , \"Copy unknown stream types\" } , { \"recast_media\" , OPT_BOOL | OPT_EXPERT , { & recast_media } , \"allow recasting stream type in order to force a decoder of different media type\" } , { \"c\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( codec_names ) } , \"codec name\" , \"codec\" } , { \"codec\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( codec_names ) } , \"codec name\" , \"codec\" } , { \"pre\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( presets ) } , \"preset name\" , \"preset\" } , { \"map\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_map } , \"set input stream mapping\" , \"[-]input_file_id[:stream_specifier][,sync_file_id[:stream_specifier]]\" } , # if FFMPEG_OPT_MAP_CHANNEL { \"map_channel\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_map_channel } , \"map an audio channel from one stream to another (deprecated)\" , \"file.stream.channel[:syncfile.syncstream]\" } , # endif { \"map_metadata\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( metadata_map ) } , \"set metadata information of outfile from infile\" , \"outfile[,metadata]:infile[,metadata]\" } , { \"map_chapters\" , HAS_ARG | OPT_INT | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( chapters_input_file ) } , \"set chapters mapping\" , \"input_file_index\" } , { \"t\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( recording_time ) } , \"record or transcode \\\"duration\\\" seconds of audio/video\" , \"duration\" } , { \"to\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( stop_time ) } , \"record or transcode stop time\" , \"time_stop\" } , { \"fs\" , HAS_ARG | OPT_INT64 | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( limit_filesize ) } , \"set the limit file size in bytes\" , \"limit_size\" } , { \"ss\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( start_time ) } , \"set the start time offset\" , \"time_off\" } , { \"sseof\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_INPUT , { . off = OFFSET ( start_time_eof ) } , \"set the start time offset relative to EOF\" , \"time_off\" } , { \"seek_timestamp\" , HAS_ARG | OPT_INT | OPT_OFFSET | OPT_INPUT , { . off = OFFSET ( seek_timestamp ) } , \"enable/disable seeking by timestamp with -ss\" } , { \"accurate_seek\" , OPT_BOOL | OPT_OFFSET | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( accurate_seek ) } , \"enable/disable accurate seeking with -ss\" } , { \"isync\" , HAS_ARG | OPT_INT | OPT_OFFSET | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( input_sync_ref ) } , \"Indicate the input index for sync reference\" , \"sync ref\" } , { \"itsoffset\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( input_ts_offset ) } , \"set the input ts offset\" , \"time_off\" } , { \"itsscale\" , HAS_ARG | OPT_DOUBLE | OPT_SPEC | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( ts_scale ) } , \"set the input ts scale\" , \"scale\" } , { \"timestamp\" , HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_recording_timestamp } , \"set the recording timestamp ('now' to set the current time)\" , \"time\" } , { \"metadata\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( metadata ) } , \"add metadata\" , \"string=string\" } , { \"program\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( program ) } , \"add program with specified streams\" , \"title=string:st=number...\" } , { \"dframes\" , HAS_ARG | OPT_PERFILE | OPT_EXPERT | OPT_OUTPUT , { . func_arg = opt_data_frames } , \"set the number of data frames to output\" , \"number\" } , { \"benchmark\" , OPT_BOOL | OPT_EXPERT , { & do_benchmark } , \"add timings for benchmarking\" } , { \"benchmark_all\" , OPT_BOOL | OPT_EXPERT , { & do_benchmark_all } , \"add timings for each task\" } , { \"progress\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_progress } , \"write program-readable progress information\" , \"url\" } , { \"stdin\" , OPT_BOOL | OPT_EXPERT , { & stdin_interaction } , \"enable or disable interaction on standard input\" } , { \"timelimit\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_timelimit } , \"set max runtime in seconds in CPU user time\" , \"limit\" } , { \"dump\" , OPT_BOOL | OPT_EXPERT , { & do_pkt_dump } , \"dump each input packet\" } , { \"hex\" , OPT_BOOL | OPT_EXPERT , { & do_hex_dump } , \"when dumping packets, also dump the payload\" } , { \"re\" , OPT_BOOL | OPT_EXPERT | OPT_OFFSET | OPT_INPUT , { . off = OFFSET ( rate_emu ) } , \"read input at native frame rate; equivalent to -readrate 1\" , \"\" } , { \"readrate\" , HAS_ARG | OPT_FLOAT | OPT_OFFSET | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( readrate ) } , \"read input at specified rate\" , \"speed\" } , { \"target\" , HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_target } , \"specify target file type (\\\"vcd\\\", \\\"svcd\\\", \\\"dvd\\\", \\\"dv\\\" or \\\"dv50\\\" \" \"with optional prefixes \\\"pal-\\\", \\\"ntsc-\\\" or \\\"film-\\\")\" , \"type\" } , { \"vsync\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_vsync } , \"set video sync method globally; deprecated, use -fps_mode\" , \"\" } , { \"frame_drop_threshold\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT , { & frame_drop_threshold } , \"frame drop threshold\" , \"\" } , { \"adrift_threshold\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT , { & audio_drift_threshold } , \"audio drift threshold\" , \"threshold\" } , { \"copyts\" , OPT_BOOL | OPT_EXPERT , { & copy_ts } , \"copy timestamps\" } , { \"start_at_zero\" , OPT_BOOL | OPT_EXPERT , { & start_at_zero } , \"shift input timestamps to start at 0 when using copyts\" } , { \"copytb\" , HAS_ARG | OPT_INT | OPT_EXPERT , { & copy_tb } , \"copy input stream time base when stream copying\" , \"mode\" } , { \"shortest\" , OPT_BOOL | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( shortest ) } , \"finish encoding within shortest input\" } , { \"shortest_buf_duration\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( shortest_buf_duration ) } , \"maximum buffering duration (in seconds) for the -shortest option\" } , { \"bitexact\" , OPT_BOOL | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT | OPT_INPUT , { . off = OFFSET ( bitexact ) } , \"bitexact mode\" } , { \"apad\" , OPT_STRING | HAS_ARG | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( apad ) } , \"audio pad\" , \"\" } , { \"dts_delta_threshold\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT , { & dts_delta_threshold } , \"timestamp discontinuity delta threshold\" , \"threshold\" } , { \"dts_error_threshold\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT , { & dts_error_threshold } , \"timestamp error delta threshold\" , \"threshold\" } , { \"xerror\" , OPT_BOOL | OPT_EXPERT , { & exit_on_error } , \"exit on error\" , \"error\" } , { \"abort_on\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_abort_on } , \"abort on the specified condition flags\" , \"flags\" } , { \"copyinkf\" , OPT_BOOL | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( copy_initial_nonkeyframes ) } , \"copy initial non-keyframes\" } , { \"copypriorss\" , OPT_INT | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( copy_prior_start ) } , \"copy or discard frames before start time\" } , { \"frames\" , OPT_INT64 | HAS_ARG | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( max_frames ) } , \"set the number of frames to output\" , \"number\" } , { \"tag\" , OPT_STRING | HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_INPUT , { . off = OFFSET ( codec_tags ) } , \"force codec tag/fourcc\" , \"fourcc/tag\" } , { \"q\" , HAS_ARG | OPT_EXPERT | OPT_DOUBLE | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( qscale ) } , \"use fixed quality scale (VBR)\" , \"q\" } , { \"qscale\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_qscale } , \"use fixed quality scale (VBR)\" , \"q\" } , { \"profile\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_profile } , \"set profile\" , \"profile\" } , { \"filter\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( filters ) } , \"set stream filtergraph\" , \"filter_graph\" } , { \"filter_threads\" , HAS_ARG , { . func_arg = opt_filter_threads } , \"number of non-complex filter threads\" } , { \"filter_script\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( filter_scripts ) } , \"read stream filtergraph description from a file\" , \"filename\" } , { \"reinit_filter\" , HAS_ARG | OPT_INT | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( reinit_filters ) } , \"reinit filtergraph on input parameter changes\" , \"\" } , { \"filter_complex\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_filter_complex } , \"create a complex filtergraph\" , \"graph_description\" } , { \"filter_complex_threads\" , HAS_ARG | OPT_INT , { & filter_complex_nbthreads } , \"number of threads for -filter_complex\" } , { \"lavfi\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_filter_complex } , \"create a complex filtergraph\" , \"graph_description\" } , { \"filter_complex_script\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_filter_complex_script } , \"read complex filtergraph description from a file\" , \"filename\" } , { \"auto_conversion_filters\" , OPT_BOOL | OPT_EXPERT , { & auto_conversion_filters } , \"enable automatic conversion filters globally\" } , { \"stats\" , OPT_BOOL , { & print_stats } , \"print progress report during encoding\" , } , { \"stats_period\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_stats_period } , \"set the period at which ffmpeg updates stats and -progress output\" , \"time\" } , { \"attach\" , HAS_ARG | OPT_PERFILE | OPT_EXPERT | OPT_OUTPUT , { . func_arg = opt_attach } , \"add an attachment to the output file\" , \"filename\" } , { \"dump_attachment\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( dump_attachment ) } , \"extract an attachment into a file\" , \"filename\" } , { \"stream_loop\" , OPT_INT | HAS_ARG | OPT_EXPERT | OPT_INPUT | OPT_OFFSET , { . off = OFFSET ( loop ) } , \"set number of times input stream shall be looped\" , \"loop count\" } , { \"debug_ts\" , OPT_BOOL | OPT_EXPERT , { & debug_ts } , \"print timestamp debugging info\" } , { \"max_error_rate\" , HAS_ARG | OPT_FLOAT , { & max_error_rate } , \"ratio of decoding errors (0.0: no errors, 1.0: 100% errors) above which ffmpeg returns an error instead of success.\" , \"maximum error rate\" } , { \"discard\" , OPT_STRING | HAS_ARG | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( discard ) } , \"discard\" , \"\" } , { \"disposition\" , OPT_STRING | HAS_ARG | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( disposition ) } , \"disposition\" , \"\" } , { \"thread_queue_size\" , HAS_ARG | OPT_INT | OPT_OFFSET | OPT_EXPERT | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( thread_queue_size ) } , \"set the maximum number of queued packets from the demuxer\" } , { \"find_stream_info\" , OPT_BOOL | OPT_INPUT | OPT_EXPERT | OPT_OFFSET , { . off = OFFSET ( find_stream_info ) } , \"read and decode the streams to fill missing information with heuristics\" } , { \"bits_per_raw_sample\" , OPT_INT | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( bits_per_raw_sample ) } , \"set the number of bits per raw sample\" , \"number\" } , { \"stats_enc_pre\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( enc_stats_pre ) } , \"write encoding stats before encoding\" } , { \"stats_enc_post\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( enc_stats_post ) } , \"write encoding stats after encoding\" } , { \"stats_mux_pre\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( mux_stats ) } , \"write packets stats before muxing\" } , { \"stats_enc_pre_fmt\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( enc_stats_pre_fmt ) } , \"format of the stats written with -stats_enc_pre\" } , { \"stats_enc_post_fmt\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( enc_stats_post_fmt ) } , \"format of the stats written with -stats_enc_post\" } , { \"stats_mux_pre_fmt\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( mux_stats_fmt ) } , \"format of the stats written with -stats_mux_pre\" } , /* video options */ { \"vframes\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_video_frames } , \"set the number of video frames to output\" , \"number\" } , { \"r\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( frame_rates ) } , \"set frame rate (Hz value, fraction or abbreviation)\" , \"rate\" } , { \"fpsmax\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( max_frame_rates ) } , \"set max frame rate (Hz value, fraction or abbreviation)\" , \"rate\" } , { \"s\" , OPT_VIDEO | HAS_ARG | OPT_SUBTITLE | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( frame_sizes ) } , \"set frame size (WxH or abbreviation)\" , \"size\" } , { \"aspect\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( frame_aspect_ratios ) } , \"set aspect ratio (4:3, 16:9 or 1.3333, 1.7777)\" , \"aspect\" } , { \"pix_fmt\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( frame_pix_fmts ) } , \"set pixel format\" , \"format\" } , { \"display_rotation\" , OPT_VIDEO | HAS_ARG | OPT_DOUBLE | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( display_rotations ) } , \"set pure counter-clockwise rotation in degrees for stream(s)\" , \"angle\" } , { \"display_hflip\" , OPT_VIDEO | OPT_BOOL | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( display_hflips ) } , \"set display horizontal flip for stream(s) \" \"(overrides any display rotation if it is not set)\" } , { \"display_vflip\" , OPT_VIDEO | OPT_BOOL | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( display_vflips ) } , \"set display vertical flip for stream(s) \" \"(overrides any display rotation if it is not set)\" } , { \"vn\" , OPT_VIDEO | OPT_BOOL | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( video_disable ) } , \"disable video\" } , { \"rc_override\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( rc_overrides ) } , \"rate control override for specific intervals\" , \"override\" } , { \"vcodec\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_video_codec } , \"force video codec ('copy' to copy stream)\" , \"codec\" } , { \"timecode\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_timecode } , \"set initial TimeCode value.\" , \"hh:mm:ss[:;.]ff\" } , { \"pass\" , OPT_VIDEO | HAS_ARG | OPT_SPEC | OPT_INT | OPT_OUTPUT , { . off = OFFSET ( pass ) } , \"select the pass number (1 to 3)\" , \"n\" } , { \"passlogfile\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( passlogfiles ) } , \"select two pass log file name prefix\" , \"prefix\" } , # if FFMPEG_OPT_PSNR { \"psnr\" , OPT_VIDEO | OPT_BOOL | OPT_EXPERT , { & do_psnr } , \"calculate PSNR of compressed frames (deprecated, use -flags +psnr)\" } , # endif { \"vstats\" , OPT_VIDEO | OPT_EXPERT , { . func_arg = opt_vstats } , \"dump video coding statistics to file\" } , { \"vstats_file\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT , { . func_arg = opt_vstats_file } , \"dump video coding statistics to file\" , \"file\" } , { \"vstats_version\" , OPT_VIDEO | OPT_INT | HAS_ARG | OPT_EXPERT , { & vstats_version } , \"Version of the vstats format to use.\" } , { \"vf\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_video_filters } , \"set video filters\" , \"filter_graph\" } , { \"intra_matrix\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( intra_matrices ) } , \"specify intra matrix coeffs\" , \"matrix\" } , { \"inter_matrix\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( inter_matrices ) } , \"specify inter matrix coeffs\" , \"matrix\" } , { \"chroma_intra_matrix\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( chroma_intra_matrices ) } , \"specify intra matrix coeffs\" , \"matrix\" } , { \"top\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_INT | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( top_field_first ) } , \"top=1/bottom=0/auto=-1 field first\" , \"\" } , { \"vtag\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_old2new } , \"force video tag/fourcc\" , \"fourcc/tag\" } , { \"qphist\" , OPT_VIDEO | OPT_BOOL | OPT_EXPERT , { & qp_hist } , \"show QP histogram\" } , { \"fps_mode\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( fps_mode ) } , \"set framerate mode for matching video streams; overrides vsync\" } , { \"force_fps\" , OPT_VIDEO | OPT_BOOL | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( force_fps ) } , \"force the selected framerate, disable the best supported framerate selection\" } , { \"streamid\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_streamid } , \"set the value of an outfile streamid\" , \"streamIndex:value\" } , { \"force_key_frames\" , OPT_VIDEO | OPT_STRING | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( forced_key_frames ) } , \"force key frames at specified timestamps\" , \"timestamps\" } , { \"b\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_bitrate } , \"video bitrate (please use -b:v)\" , \"bitrate\" } , { \"hwaccel\" , OPT_VIDEO | OPT_STRING | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( hwaccels ) } , \"use HW accelerated decoding\" , \"hwaccel name\" } , { \"hwaccel_device\" , OPT_VIDEO | OPT_STRING | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( hwaccel_devices ) } , \"select a device for HW acceleration\" , \"devicename\" } , { \"hwaccel_output_format\" , OPT_VIDEO | OPT_STRING | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( hwaccel_output_formats ) } , \"select output format used with HW accelerated decoding\" , \"format\" } , { \"hwaccels\" , OPT_EXIT , { . func_arg = show_hwaccels } , \"show available HW acceleration methods\" } , { \"autorotate\" , HAS_ARG | OPT_BOOL | OPT_SPEC | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( autorotate ) } , \"automatically insert correct rotate filters\" } , { \"autoscale\" , HAS_ARG | OPT_BOOL | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT , { . off = OFFSET ( autoscale ) } , \"automatically insert a scale filter at the end of the filter graph\" } , { \"fix_sub_duration_heartbeat\" , OPT_VIDEO | OPT_BOOL | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( fix_sub_duration_heartbeat ) } , \"set this video output stream to be a heartbeat stream for \" \"fix_sub_duration, according to which subtitles should be split at \" \"random access points\" } , /* audio options */ { \"aframes\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_audio_frames } , \"set the number of audio frames to output\" , \"number\" } , { \"aq\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_audio_qscale } , \"set audio quality (codec-specific)\" , \"quality\" , } , { \"ar\" , OPT_AUDIO | HAS_ARG | OPT_INT | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_sample_rate ) } , \"set audio sampling rate (in Hz)\" , \"rate\" } , { \"ac\" , OPT_AUDIO | HAS_ARG | OPT_INT | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_channels ) } , \"set number of audio channels\" , \"channels\" } , { \"an\" , OPT_AUDIO | OPT_BOOL | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_disable ) } , \"disable audio\" } , { \"acodec\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_audio_codec } , \"force audio codec ('copy' to copy stream)\" , \"codec\" } , { \"ab\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_bitrate } , \"audio bitrate (please use -b:a)\" , \"bitrate\" } , { \"atag\" , OPT_AUDIO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_old2new } , \"force audio tag/fourcc\" , \"fourcc/tag\" } , { \"sample_fmt\" , OPT_AUDIO | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_STRING | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( sample_fmts ) } , \"set sample format\" , \"format\" } , { \"channel_layout\" , OPT_AUDIO | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_STRING | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_ch_layouts ) } , \"set channel layout\" , \"layout\" } , { \"ch_layout\" , OPT_AUDIO | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_STRING | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_ch_layouts ) } , \"set channel layout\" , \"layout\" } , { \"af\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_audio_filters } , \"set audio filters\" , \"filter_graph\" } , { \"guess_layout_max\" , OPT_AUDIO | HAS_ARG | OPT_INT | OPT_SPEC | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( guess_layout_max ) } , \"set the maximum number of channels to try to guess the channel layout\" } , /* subtitle options */ { \"sn\" , OPT_SUBTITLE | OPT_BOOL | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( subtitle_disable ) } , \"disable subtitle\" } , { \"scodec\" , OPT_SUBTITLE | HAS_ARG | OPT_PERFILE | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_subtitle_codec } , \"force subtitle codec ('copy' to copy stream)\" , \"codec\" } , { \"stag\" , OPT_SUBTITLE | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_old2new } , \"force subtitle tag/fourcc\" , \"fourcc/tag\" } , { \"fix_sub_duration\" , OPT_BOOL | OPT_EXPERT | OPT_SUBTITLE | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( fix_sub_duration ) } , \"fix subtitles duration\" } , { \"canvas_size\" , OPT_SUBTITLE | HAS_ARG | OPT_STRING | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( canvas_sizes ) } , \"set canvas size (WxH or abbreviation)\" , \"size\" } , /* muxer options */ { \"muxdelay\" , OPT_FLOAT | HAS_ARG | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( mux_max_delay ) } , \"set the maximum demux-decode delay\" , \"seconds\" } , { \"muxpreload\" , OPT_FLOAT | HAS_ARG | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( mux_preload ) } , \"set the initial demux-decode delay\" , \"seconds\" } , { \"sdp_file\" , HAS_ARG | OPT_EXPERT | OPT_OUTPUT , { . func_arg = opt_sdp_file } , \"specify a file in which to print sdp information\" , \"file\" } , { \"time_base\" , HAS_ARG | OPT_STRING | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( time_bases ) } , \"set the desired time base hint for output stream (1:24, 1:48000 or 0.04166, 2.0833e-5)\" , \"ratio\" } , { \"enc_time_base\" , HAS_ARG | OPT_STRING | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( enc_time_bases ) } , \"set the desired time base for the encoder (1:24, 1:48000 or 0.04166, 2.0833e-5). \" \"two special values are defined - \" \"0 = use frame rate (video) or sample rate (audio),\" \"-1 = match source time base\" , \"ratio\" } , { \"bsf\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT , { . off = OFFSET ( bitstream_filters ) } , \"A comma-separated list of bitstream filters\" , \"bitstream_filters\" } , { \"absf\" , HAS_ARG | OPT_AUDIO | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_old2new } , \"deprecated\" , \"audio bitstream_filters\" } , { \"vbsf\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_old2new } , \"deprecated\" , \"video bitstream_filters\" } , { \"apre\" , HAS_ARG | OPT_AUDIO | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_preset } , \"set the audio options to the indicated preset\" , \"preset\" } , { \"vpre\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_preset } , \"set the video options to the indicated preset\" , \"preset\" } , { \"spre\" , HAS_ARG | OPT_SUBTITLE | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_preset } , \"set the subtitle options to the indicated preset\" , \"preset\" } , { \"fpre\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_preset } , \"set options from indicated preset file\" , \"filename\" } , { \"max_muxing_queue_size\" , HAS_ARG | OPT_INT | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT , { . off = OFFSET ( max_muxing_queue_size ) } , \"maximum number of packets that can be buffered while waiting for all streams to initialize\" , \"packets\" } , { \"muxing_queue_data_threshold\" , HAS_ARG | OPT_INT | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT , { . off = OFFSET ( muxing_queue_data_threshold ) } , \"set the threshold after which max_muxing_queue_size is taken into account\" , \"bytes\" } , /* data codec support */ { \"dcodec\" , HAS_ARG | OPT_DATA | OPT_PERFILE | OPT_EXPERT | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_data_codec } , \"force data codec ('copy' to copy stream)\" , \"codec\" } , { \"dn\" , OPT_BOOL | OPT_VIDEO | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( data_disable ) } , \"disable data\" } , # if CONFIG_VAAPI { \"vaapi_device\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_vaapi_device } , \"set VAAPI hardware device (DRM path or X11 display name)\" , \"device\" } , # endif # if CONFIG_QSV { \"qsv_device\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_qsv_device } , \"set QSV hardware device (DirectX adapter index, DRM path or X11 display name)\" , \"device\" } , # endif { \"init_hw_device\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_init_hw_device } , \"initialise hardware device\" , \"args\" } , { \"filter_hw_device\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_filter_hw_device } , \"set hardware device used when filtering\" , \"device\" } , { NULL , } , } ; ffmpeg_options = options ; int ret ; BenchmarkTimeStamps ti ; int savedCode = setjmp ( ex_buf__ ) ; if ( savedCode == 0 ) { ffmpeg_var_cleanup ( ) ; init_dynload ( ) ; register_exit ( ffmpeg_cleanup ) ; av_log_set_flags ( AV_LOG_SKIP_REPEATED ) ; parse_loglevel ( argc , argv , options ) ; # if CONFIG_AVDEVICE avdevice_register_all ( ) ; # endif avformat_network_init ( ) ; show_banner ( argc , argv , options ) ; /* parse options and open all input/output files */ ret = ffmpeg_parse_options ( argc , argv ) ; if ( ret < 0 ) exit_program ( 1 ) ; if ( nb_output_files <= 0 && nb_input_files == 0 ) { show_usage ( ) ; av_log ( NULL , AV_LOG_WARNING , \"Use -h to get full help or, even better, run 'man %s'\\n\" , program_name ) ; exit_program ( 1 ) ; } /* file converter / grab */ if ( nb_output_files <= 0 ) { av_log ( NULL , AV_LOG_FATAL , \"At least one output file must be specified\\n\" ) ; exit_program ( 1 ) ; } current_time = ti = get_benchmark_time_stamps ( ) ; if ( transcode ( ) < 0 ) exit_program ( 1 ) ; if ( do_benchmark ) { int64_t utime , stime , rtime ; current_time = get_benchmark_time_stamps ( ) ; utime = current_time . user_usec - ti . user_usec ; stime = current_time . sys_usec - ti . sys_usec ; rtime = current_time . real_usec - ti . real_usec ; av_log ( NULL , AV_LOG_INFO , \"bench: utime=%0.3fs stime=%0.3fs rtime=%0.3fs\\n\" , utime / 1000000.0 , stime / 1000000.0 , rtime / 1000000.0 ) ; } av_log ( NULL , AV_LOG_DEBUG , \"%\" PRIu64 \" frames successfully decoded, %\" PRIu64 \" decoding errors\\n\" , decode_error_stat [ 0 ] , decode_error_stat [ 1 ] ) ; if ( ( decode_error_stat [ 0 ] + decode_error_stat [ 1 ] ) * max_error_rate < decode_error_stat [ 1 ] ) exit_program ( 69 ) ; exit_program ( ( received_nb_signals || cancelRequested ( globalSessionId ) ) ? 255 : main_ffmpeg_return_code ) ; } else { main_ffmpeg_return_code = ( received_nb_signals || cancelRequested ( globalSessionId ) ) ? 255 : longjmp_value ; } return main_ffmpeg_return_code ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_hw.c@hw_device_get_by_type": "static HWDevice * hw_device_get_by_type ( enum AVHWDeviceType type ) { HWDevice * found = NULL ; int i ; for ( i = 0 ; i < nb_hw_devices ; i ++ ) { if ( hw_devices [ i ] -> type == type ) { if ( found ) return NULL ; found = hw_devices [ i ] ; } } return found ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_hw.c@hw_device_get_by_name": "HWDevice * hw_device_get_by_name ( const char * name ) { int i ; for ( i = 0 ; i < nb_hw_devices ; i ++ ) { if ( ! strcmp ( hw_devices [ i ] -> name , name ) ) return hw_devices [ i ] ; } return NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_hw.c@hw_device_add": "static HWDevice * hw_device_add ( void ) { int err ; err = av_reallocp_array ( & hw_devices , nb_hw_devices + 1 , sizeof ( * hw_devices ) ) ; if ( err ) { nb_hw_devices = 0 ; return NULL ; } hw_devices [ nb_hw_devices ] = av_mallocz ( sizeof ( HWDevice ) ) ; if ( ! hw_devices [ nb_hw_devices ] ) return NULL ; return hw_devices [ nb_hw_devices ++ ] ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_hw.c@hw_device_default_name": "static char * hw_device_default_name ( enum AVHWDeviceType type ) { // Make an automatic name of the form \"type%d\".  We arbitrarily // limit at 1000 anonymous devices of the same type - there is // probably something else very wrong if you get to this limit. const char * type_name = av_hwdevice_get_type_name ( type ) ; char * name ; size_t index_pos ; int index , index_limit = 1000 ; index_pos = strlen ( type_name ) ; name = av_malloc ( index_pos + 4 ) ; if ( ! name ) return NULL ; for ( index = 0 ; index < index_limit ; index ++ ) { snprintf ( name , index_pos + 4 , \"%s%d\" , type_name , index ) ; if ( ! hw_device_get_by_name ( name ) ) break ; } if ( index >= index_limit ) { av_freep ( & name ) ; return NULL ; } return name ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_hw.c@hw_device_init_from_string": "int hw_device_init_from_string ( const char * arg , HWDevice * * dev_out ) { // \"type=name\" // \"type=name,key=value,key2=value2\" // \"type=name:device,key=value,key2=value2\" // \"type:device,key=value,key2=value2\" // -> av_hwdevice_ctx_create() // \"type=name@name\" // \"type@name\" // -> av_hwdevice_ctx_create_derived() AVDictionary * options = NULL ; const char * type_name = NULL , * name = NULL , * device = NULL ; enum AVHWDeviceType type ; HWDevice * dev , * src ; AVBufferRef * device_ref = NULL ; int err ; const char * errmsg , * p , * q ; size_t k ; k = strcspn ( arg , \":=@\" ) ; p = arg + k ; type_name = av_strndup ( arg , k ) ; if ( ! type_name ) { err = AVERROR ( ENOMEM ) ; goto fail ; } type = av_hwdevice_find_type_by_name ( type_name ) ; if ( type == AV_HWDEVICE_TYPE_NONE ) { errmsg = \"unknown device type\" ; goto invalid ; } if ( * p == '=' ) { k = strcspn ( p + 1 , \":@,\" ) ; name = av_strndup ( p + 1 , k ) ; if ( ! name ) { err = AVERROR ( ENOMEM ) ; goto fail ; } if ( hw_device_get_by_name ( name ) ) { errmsg = \"named device already exists\" ; goto invalid ; } p += 1 + k ; } else { name = hw_device_default_name ( type ) ; if ( ! name ) { err = AVERROR ( ENOMEM ) ; goto fail ; } } if ( ! * p ) { // New device with no parameters. err = av_hwdevice_ctx_create ( & device_ref , type , NULL , NULL , 0 ) ; if ( err < 0 ) goto fail ; } else if ( * p == ':' ) { // New device with some parameters. ++ p ; q = strchr ( p , ',' ) ; if ( q ) { if ( q - p > 0 ) { device = av_strndup ( p , q - p ) ; if ( ! device ) { err = AVERROR ( ENOMEM ) ; goto fail ; } } err = av_dict_parse_string ( & options , q + 1 , \"=\" , \",\" , 0 ) ; if ( err < 0 ) { errmsg = \"failed to parse options\" ; goto invalid ; } } err = av_hwdevice_ctx_create ( & device_ref , type , q ? device : p [ 0 ] ? p : NULL , options , 0 ) ; if ( err < 0 ) goto fail ; } else if ( * p == '@' ) { // Derive from existing device. src = hw_device_get_by_name ( p + 1 ) ; if ( ! src ) { errmsg = \"invalid source device name\" ; goto invalid ; } err = av_hwdevice_ctx_create_derived ( & device_ref , type , src -> device_ref , 0 ) ; if ( err < 0 ) goto fail ; } else if ( * p == ',' ) { err = av_dict_parse_string ( & options , p + 1 , \"=\" , \",\" , 0 ) ; if ( err < 0 ) { errmsg = \"failed to parse options\" ; goto invalid ; } err = av_hwdevice_ctx_create ( & device_ref , type , NULL , options , 0 ) ; if ( err < 0 ) goto fail ; } else { errmsg = \"parse error\" ; goto invalid ; } dev = hw_device_add ( ) ; if ( ! dev ) { err = AVERROR ( ENOMEM ) ; goto fail ; } dev -> name = name ; dev -> type = type ; dev -> device_ref = device_ref ; if ( dev_out ) * dev_out = dev ; name = NULL ; err = 0 ; done : av_freep ( & type_name ) ; av_freep ( & name ) ; av_freep ( & device ) ; av_dict_free ( & options ) ; return err ; invalid : av_log ( NULL , AV_LOG_ERROR , \"Invalid device specification \\\"%s\\\": %s\\n\" , arg , errmsg ) ; err = AVERROR ( EINVAL ) ; goto done ; fail : av_log ( NULL , AV_LOG_ERROR , \"Device creation failed: %d.\\n\" , err ) ; av_buffer_unref ( & device_ref ) ; goto done ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_hw.c@hw_device_init_from_type": "static int hw_device_init_from_type ( enum AVHWDeviceType type , const char * device , HWDevice * * dev_out ) { AVBufferRef * device_ref = NULL ; HWDevice * dev ; char * name ; int err ; name = hw_device_default_name ( type ) ; if ( ! name ) { err = AVERROR ( ENOMEM ) ; goto fail ; } err = av_hwdevice_ctx_create ( & device_ref , type , device , NULL , 0 ) ; if ( err < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Device creation failed: %d.\\n\" , err ) ; goto fail ; } dev = hw_device_add ( ) ; if ( ! dev ) { err = AVERROR ( ENOMEM ) ; goto fail ; } dev -> name = name ; dev -> type = type ; dev -> device_ref = device_ref ; if ( dev_out ) * dev_out = dev ; return 0 ; fail : av_freep ( & name ) ; av_buffer_unref ( & device_ref ) ; return err ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_hw.c@hw_device_free_all": "void hw_device_free_all ( void ) { int i ; for ( i = 0 ; i < nb_hw_devices ; i ++ ) { av_freep ( & hw_devices [ i ] -> name ) ; av_buffer_unref ( & hw_devices [ i ] -> device_ref ) ; av_freep ( & hw_devices [ i ] ) ; } av_freep ( & hw_devices ) ; nb_hw_devices = 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_hw.c@hw_device_match_by_codec": "static HWDevice * hw_device_match_by_codec ( const AVCodec * codec ) { const AVCodecHWConfig * config ; HWDevice * dev ; int i ; for ( i = 0 ; ; i ++ ) { config = avcodec_get_hw_config ( codec , i ) ; if ( ! config ) return NULL ; if ( ! ( config -> methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX ) ) continue ; dev = hw_device_get_by_type ( config -> device_type ) ; if ( dev ) return dev ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_hw.c@hw_device_setup_for_decode": "int hw_device_setup_for_decode ( InputStream * ist ) { const AVCodecHWConfig * config ; enum AVHWDeviceType type ; HWDevice * dev = NULL ; int err , auto_device = 0 ; if ( ist -> hwaccel_device ) { dev = hw_device_get_by_name ( ist -> hwaccel_device ) ; if ( ! dev ) { if ( ist -> hwaccel_id == HWACCEL_AUTO ) { auto_device = 1 ; } else if ( ist -> hwaccel_id == HWACCEL_GENERIC ) { type = ist -> hwaccel_device_type ; err = hw_device_init_from_type ( type , ist -> hwaccel_device , & dev ) ; } else { // This will be dealt with by API-specific initialisation // (using hwaccel_device), so nothing further needed here. return 0 ; } } else { if ( ist -> hwaccel_id == HWACCEL_AUTO ) { ist -> hwaccel_device_type = dev -> type ; } else if ( ist -> hwaccel_device_type != dev -> type ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid hwaccel device \" \"specified for decoder: device %s of type %s is not \" \"usable with hwaccel %s.\\n\" , dev -> name , av_hwdevice_get_type_name ( dev -> type ) , av_hwdevice_get_type_name ( ist -> hwaccel_device_type ) ) ; return AVERROR ( EINVAL ) ; } } } else { if ( ist -> hwaccel_id == HWACCEL_AUTO ) { auto_device = 1 ; } else if ( ist -> hwaccel_id == HWACCEL_GENERIC ) { type = ist -> hwaccel_device_type ; dev = hw_device_get_by_type ( type ) ; // When \"-qsv_device device\" is used, an internal QSV device named // as \"__qsv_device\" is created. Another QSV device is created too // if \"-init_hw_device qsv=name:device\" is used. There are 2 QSV devices // if both \"-qsv_device device\" and \"-init_hw_device qsv=name:device\" // are used, hw_device_get_by_type(AV_HWDEVICE_TYPE_QSV) returns NULL. // To keep back-compatibility with the removed ad-hoc libmfx setup code, // call hw_device_get_by_name(\"__qsv_device\") to select the internal QSV // device. if ( ! dev && type == AV_HWDEVICE_TYPE_QSV ) dev = hw_device_get_by_name ( \"__qsv_device\" ) ; if ( ! dev ) err = hw_device_init_from_type ( type , NULL , & dev ) ; } else { dev = hw_device_match_by_codec ( ist -> dec ) ; if ( ! dev ) { // No device for this codec, but not using generic hwaccel // and therefore may well not need one - ignore. return 0 ; } } } if ( auto_device ) { int i ; if ( ! avcodec_get_hw_config ( ist -> dec , 0 ) ) { // Decoder does not support any hardware devices. return 0 ; } for ( i = 0 ; ! dev ; i ++ ) { config = avcodec_get_hw_config ( ist -> dec , i ) ; if ( ! config ) break ; type = config -> device_type ; dev = hw_device_get_by_type ( type ) ; if ( dev ) { av_log ( NULL , AV_LOG_INFO , \"Using auto \" \"hwaccel type %s with existing device %s.\\n\" , av_hwdevice_get_type_name ( type ) , dev -> name ) ; } } for ( i = 0 ; ! dev ; i ++ ) { config = avcodec_get_hw_config ( ist -> dec , i ) ; if ( ! config ) break ; type = config -> device_type ; // Try to make a new device of this type. err = hw_device_init_from_type ( type , ist -> hwaccel_device , & dev ) ; if ( err < 0 ) { // Can't make a device of this type. continue ; } if ( ist -> hwaccel_device ) { av_log ( NULL , AV_LOG_INFO , \"Using auto \" \"hwaccel type %s with new device created \" \"from %s.\\n\" , av_hwdevice_get_type_name ( type ) , ist -> hwaccel_device ) ; } else { av_log ( NULL , AV_LOG_INFO , \"Using auto \" \"hwaccel type %s with new default device.\\n\" , av_hwdevice_get_type_name ( type ) ) ; } } if ( dev ) { ist -> hwaccel_device_type = type ; } else { av_log ( NULL , AV_LOG_INFO , \"Auto hwaccel \" \"disabled: no device found.\\n\" ) ; ist -> hwaccel_id = HWACCEL_NONE ; return 0 ; } } if ( ! dev ) { av_log ( NULL , AV_LOG_ERROR , \"No device available \" \"for decoder: device type %s needed for codec %s.\\n\" , av_hwdevice_get_type_name ( type ) , ist -> dec -> name ) ; return err ; } ist -> dec_ctx -> hw_device_ctx = av_buffer_ref ( dev -> device_ref ) ; if ( ! ist -> dec_ctx -> hw_device_ctx ) return AVERROR ( ENOMEM ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_hw.c@hw_device_setup_for_encode": "int hw_device_setup_for_encode ( OutputStream * ost ) { const AVCodecHWConfig * config ; HWDevice * dev = NULL ; AVBufferRef * frames_ref = NULL ; int i ; if ( ost -> filter ) { frames_ref = av_buffersink_get_hw_frames_ctx ( ost -> filter -> filter ) ; if ( frames_ref && ( ( AVHWFramesContext * ) frames_ref -> data ) -> format == ost -> enc_ctx -> pix_fmt ) { // Matching format, will try to use hw_frames_ctx. } else { frames_ref = NULL ; } } for ( i = 0 ; ; i ++ ) { config = avcodec_get_hw_config ( ost -> enc_ctx -> codec , i ) ; if ( ! config ) break ; if ( frames_ref && config -> methods & AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX && ( config -> pix_fmt == AV_PIX_FMT_NONE || config -> pix_fmt == ost -> enc_ctx -> pix_fmt ) ) { av_log ( ost -> enc_ctx , AV_LOG_VERBOSE , \"Using input \" \"frames context (format %s) with %s encoder.\\n\" , av_get_pix_fmt_name ( ost -> enc_ctx -> pix_fmt ) , ost -> enc_ctx -> codec -> name ) ; ost -> enc_ctx -> hw_frames_ctx = av_buffer_ref ( frames_ref ) ; if ( ! ost -> enc_ctx -> hw_frames_ctx ) return AVERROR ( ENOMEM ) ; return 0 ; } if ( ! dev && config -> methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX ) dev = hw_device_get_by_type ( config -> device_type ) ; } if ( dev ) { av_log ( ost -> enc_ctx , AV_LOG_VERBOSE , \"Using device %s \" \"(type %s) with %s encoder.\\n\" , dev -> name , av_hwdevice_get_type_name ( dev -> type ) , ost -> enc_ctx -> codec -> name ) ; ost -> enc_ctx -> hw_device_ctx = av_buffer_ref ( dev -> device_ref ) ; if ( ! ost -> enc_ctx -> hw_device_ctx ) return AVERROR ( ENOMEM ) ; } else { // No device required, or no device available. } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_hw.c@hwaccel_retrieve_data": "static int hwaccel_retrieve_data ( AVCodecContext * avctx , AVFrame * input ) { InputStream * ist = avctx -> opaque ; AVFrame * output = NULL ; enum AVPixelFormat output_format = ist -> hwaccel_output_format ; int err ; if ( input -> format == output_format ) { // Nothing to do. return 0 ; } output = av_frame_alloc ( ) ; if ( ! output ) return AVERROR ( ENOMEM ) ; output -> format = output_format ; err = av_hwframe_transfer_data ( output , input , 0 ) ; if ( err < 0 ) { av_log ( avctx , AV_LOG_ERROR , \"Failed to transfer data to \" \"output frame: %d.\\n\" , err ) ; goto fail ; } err = av_frame_copy_props ( output , input ) ; if ( err < 0 ) { av_frame_unref ( output ) ; goto fail ; } av_frame_unref ( input ) ; av_frame_move_ref ( input , output ) ; av_frame_free ( & output ) ; return 0 ; fail : av_frame_free ( & output ) ; return err ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_hw.c@hwaccel_decode_init": "int hwaccel_decode_init ( AVCodecContext * avctx ) { InputStream * ist = avctx -> opaque ; ist -> hwaccel_retrieve_data = & hwaccel_retrieve_data ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_hw.c@hw_device_setup_for_filter": "int hw_device_setup_for_filter ( FilterGraph * fg ) { HWDevice * dev ; int i ; // Pick the last hardware device if the user doesn't pick the device for // filters explicitly with the filter_hw_device option. if ( filter_hw_device ) dev = filter_hw_device ; else if ( nb_hw_devices > 0 ) { dev = hw_devices [ nb_hw_devices - 1 ] ; if ( nb_hw_devices > 1 ) av_log ( NULL , AV_LOG_WARNING , \"There are %d hardware devices. device \" \"%s of type %s is picked for filters by default. Set hardware \" \"device explicitly with the filter_hw_device option if device \" \"%s is not usable for filters.\\n\" , nb_hw_devices , dev -> name , av_hwdevice_get_type_name ( dev -> type ) , dev -> name ) ; } else dev = NULL ; if ( dev ) { for ( i = 0 ; i < fg -> graph -> nb_filters ; i ++ ) { fg -> graph -> filters [ i ] -> hw_device_ctx = av_buffer_ref ( dev -> device_ref ) ; if ( ! fg -> graph -> filters [ i ] -> hw_device_ctx ) return AVERROR ( ENOMEM ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@fopen_utf8": "static inline FILE * fopen_utf8 ( const char * path , const char * mode ) { return fopen ( path , mode ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@check_opt_bitexact": "static int check_opt_bitexact ( void * ctx , const AVDictionary * opts , const char * opt_name , int flag ) { const AVDictionaryEntry * e = av_dict_get ( opts , opt_name , NULL , 0 ) ; if ( e ) { const AVOption * o = av_opt_find ( ctx , opt_name , NULL , 0 , 0 ) ; int val = 0 ; if ( ! o ) return 0 ; av_opt_eval_flags ( ctx , o , e -> value , & val ) ; return ! ! ( val & flag ) ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@choose_encoder": "static int choose_encoder ( const OptionsContext * o , AVFormatContext * s , OutputStream * ost , const AVCodec * * enc ) { enum AVMediaType type = ost -> st -> codecpar -> codec_type ; char * codec_name = NULL ; * enc = NULL ; if ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO || type == AVMEDIA_TYPE_SUBTITLE ) { MATCH_PER_STREAM_OPT ( codec_names , str , codec_name , s , ost -> st ) ; if ( ! codec_name ) { ost -> st -> codecpar -> codec_id = av_guess_codec ( s -> oformat , NULL , s -> url , NULL , ost -> st -> codecpar -> codec_type ) ; * enc = avcodec_find_encoder ( ost -> st -> codecpar -> codec_id ) ; if ( ! * enc ) { av_log ( ost , AV_LOG_FATAL , \"Automatic encoder selection failed \" \"Default encoder for format %s (codec %s) is \" \"probably disabled. Please choose an encoder manually.\\n\" , s -> oformat -> name , avcodec_get_name ( ost -> st -> codecpar -> codec_id ) ) ; return AVERROR_ENCODER_NOT_FOUND ; } } else if ( strcmp ( codec_name , \"copy\" ) ) { * enc = find_codec_or_die ( ost , codec_name , ost -> st -> codecpar -> codec_type , 1 ) ; ost -> st -> codecpar -> codec_id = ( * enc ) -> id ; } } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@get_line": "static char * get_line ( AVIOContext * s , AVBPrint * bprint ) { char c ; while ( ( c = avio_r8 ( s ) ) && c != '\\n' ) av_bprint_chars ( bprint , c , 1 ) ; if ( ! av_bprint_is_complete ( bprint ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return bprint -> str ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@get_preset_file_2": "static int get_preset_file_2 ( const char * preset_name , const char * codec_name , AVIOContext * * s ) { int i , ret = - 1 ; char filename [ 1000 ] ; char * env_avconv_datadir = getenv_utf8 ( \"AVCONV_DATADIR\" ) ; char * env_home = getenv_utf8 ( \"HOME\" ) ; const char * base [ 3 ] = { env_avconv_datadir , env_home , AVCONV_DATADIR , } ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( base ) && ret < 0 ; i ++ ) { if ( ! base [ i ] ) continue ; if ( codec_name ) { snprintf ( filename , sizeof ( filename ) , \"%s%s/%s-%s.avpreset\" , base [ i ] , i != 1 ? \"\" : \"/.avconv\" , codec_name , preset_name ) ; ret = avio_open2 ( s , filename , AVIO_FLAG_READ , & int_cb , NULL ) ; } if ( ret < 0 ) { snprintf ( filename , sizeof ( filename ) , \"%s%s/%s.avpreset\" , base [ i ] , i != 1 ? \"\" : \"/.avconv\" , preset_name ) ; ret = avio_open2 ( s , filename , AVIO_FLAG_READ , & int_cb , NULL ) ; } } freeenv_utf8 ( env_home ) ; freeenv_utf8 ( env_avconv_datadir ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@enc_stats_get_file": "static int enc_stats_get_file ( AVIOContext * * io , const char * path ) { EncStatsFile * esf ; int ret ; for ( int i = 0 ; i < nb_enc_stats_files ; i ++ ) if ( ! strcmp ( path , enc_stats_files [ i ] . path ) ) { * io = enc_stats_files [ i ] . io ; return 0 ; } GROW_ARRAY ( enc_stats_files , nb_enc_stats_files ) ; esf = & enc_stats_files [ nb_enc_stats_files - 1 ] ; ret = avio_open2 ( & esf -> io , path , AVIO_FLAG_WRITE , & int_cb , NULL ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error opening stats file '%s': %s\\n\" , path , av_err2str ( ret ) ) ; return ret ; } esf -> path = av_strdup ( path ) ; if ( ! esf -> path ) return AVERROR ( ENOMEM ) ; * io = esf -> io ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@of_enc_stats_close": "void of_enc_stats_close ( void ) { for ( int i = 0 ; i < nb_enc_stats_files ; i ++ ) { av_freep ( & enc_stats_files [ i ] . path ) ; avio_closep ( & enc_stats_files [ i ] . io ) ; } av_freep ( & enc_stats_files ) ; nb_enc_stats_files = 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@unescape": "static int unescape ( char * * pdst , size_t * dst_len , const char * * pstr , char delim ) { const char * str = * pstr ; char * dst ; size_t len , idx ; * pdst = NULL ; len = strlen ( str ) ; if ( ! len ) return 0 ; dst = av_malloc ( len + 1 ) ; if ( ! dst ) return AVERROR ( ENOMEM ) ; for ( idx = 0 ; * str ; idx ++ , str ++ ) { if ( str [ 0 ] == '\\\\' && str [ 1 ] ) str ++ ; else if ( * str == delim ) break ; dst [ idx ] = * str ; } if ( ! idx ) { av_freep ( & dst ) ; return 0 ; } dst [ idx ] = 0 ; * pdst = dst ; * dst_len = idx ; * pstr = str ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@enc_stats_init": "static int enc_stats_init ( OutputStream * ost , EncStats * es , int pre , const char * path , const char * fmt_spec ) { static const struct { enum EncStatsType type ; const char * str ; int pre_only : 1 ; int post_only : 1 ; int need_input_data : 1 ; } fmt_specs [ ] = { { ENC_STATS_FILE_IDX , \"fidx\" } , { ENC_STATS_STREAM_IDX , \"sidx\" } , { ENC_STATS_FRAME_NUM , \"n\" } , { ENC_STATS_FRAME_NUM_IN , \"ni\" , 0 , 0 , 1 } , { ENC_STATS_TIMEBASE , \"tb\" } , { ENC_STATS_TIMEBASE_IN , \"tbi\" , 0 , 0 , 1 } , { ENC_STATS_PTS , \"pts\" } , { ENC_STATS_PTS_TIME , \"t\" } , { ENC_STATS_PTS_IN , \"ptsi\" , 0 , 0 , 1 } , { ENC_STATS_PTS_TIME_IN , \"ti\" , 0 , 0 , 1 } , { ENC_STATS_DTS , \"dts\" , 0 , 1 } , { ENC_STATS_DTS_TIME , \"dt\" , 0 , 1 } , { ENC_STATS_SAMPLE_NUM , \"sn\" , 1 } , { ENC_STATS_NB_SAMPLES , \"samp\" , 1 } , { ENC_STATS_PKT_SIZE , \"size\" , 0 , 1 } , { ENC_STATS_BITRATE , \"br\" , 0 , 1 } , { ENC_STATS_AVG_BITRATE , \"abr\" , 0 , 1 } , } ; const char * next = fmt_spec ; int ret ; while ( * next ) { EncStatsComponent * c ; char * val ; size_t val_len ; // get the sequence up until next opening brace ret = unescape ( & val , & val_len , & next , '{' ) ; if ( ret < 0 ) return ret ; if ( val ) { GROW_ARRAY ( es -> components , es -> nb_components ) ; c = & es -> components [ es -> nb_components - 1 ] ; c -> type = ENC_STATS_LITERAL ; c -> str = val ; c -> str_len = val_len ; } if ( ! * next ) break ; next ++ ; // get the part inside braces ret = unescape ( & val , & val_len , & next , '}' ) ; if ( ret < 0 ) return ret ; if ( ! val ) { av_log ( NULL , AV_LOG_ERROR , \"Empty formatting directive in: %s\\n\" , fmt_spec ) ; return AVERROR ( EINVAL ) ; } if ( ! * next ) { av_log ( NULL , AV_LOG_ERROR , \"Missing closing brace in: %s\\n\" , fmt_spec ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } next ++ ; GROW_ARRAY ( es -> components , es -> nb_components ) ; c = & es -> components [ es -> nb_components - 1 ] ; for ( size_t i = 0 ; i < FF_ARRAY_ELEMS ( fmt_specs ) ; i ++ ) { if ( ! strcmp ( val , fmt_specs [ i ] . str ) ) { if ( ( pre && fmt_specs [ i ] . post_only ) || ( ! pre && fmt_specs [ i ] . pre_only ) ) { av_log ( NULL , AV_LOG_ERROR , \"Format directive '%s' may only be used %s-encoding\\n\" , val , pre ? \"post\" : \"pre\" ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } c -> type = fmt_specs [ i ] . type ; if ( fmt_specs [ i ] . need_input_data ) { if ( ost -> ist ) ost -> ist -> want_frame_data = 1 ; else { av_log ( ost , AV_LOG_WARNING , \"Format directive '%s' is unavailable, because \" \"this output stream has no associated input stream\\n\" , val ) ; } } break ; } } if ( ! c -> type ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid format directive: %s\\n\" , val ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } fail : av_freep ( & val ) ; if ( ret < 0 ) return ret ; } ret = enc_stats_get_file ( & es -> io , path ) ; if ( ret < 0 ) return ret ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@output_stream_item_name": "static const char * output_stream_item_name ( void * obj ) { const MuxStream * ms = obj ; return ms -> log_name ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@mux_stream_alloc": "static MuxStream * mux_stream_alloc ( Muxer * mux , enum AVMediaType type ) { const char * type_str = av_get_media_type_string ( type ) ; MuxStream * ms = allocate_array_elem ( & mux -> of . streams , sizeof ( * ms ) , & mux -> of . nb_streams ) ; ms -> ost . file_index = mux -> of . index ; ms -> ost . index = mux -> of . nb_streams - 1 ; ms -> ost . clazz = & output_stream_class ; snprintf ( ms -> log_name , sizeof ( ms -> log_name ) , \"%cost#%d:%d\" , type_str ? * type_str : '?' , mux -> of . index , ms -> ost . index ) ; return ms ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@new_output_stream": "static OutputStream * new_output_stream ( Muxer * mux , const OptionsContext * o , enum AVMediaType type , InputStream * ist ) { AVFormatContext * oc = mux -> fc ; MuxStream * ms ; OutputStream * ost ; const AVCodec * enc ; AVStream * st = avformat_new_stream ( oc , NULL ) ; int ret = 0 ; const char * bsfs = NULL , * time_base = NULL ; char * next , * codec_tag = NULL ; double qscale = - 1 ; int i ; if ( ! st ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( oc -> nb_streams - 1 < o -> nb_streamid_map ) st -> id = o -> streamid_map [ oc -> nb_streams - 1 ] ; ms = mux_stream_alloc ( mux , type ) ; ost = & ms -> ost ; ms -> muxing_queue = av_fifo_alloc2 ( 8 , sizeof ( AVPacket * ) , 0 ) ; if ( ! ms -> muxing_queue ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ms -> last_mux_dts = AV_NOPTS_VALUE ; ost -> st = st ; ost -> ist = ist ; ost -> kf . ref_pts = AV_NOPTS_VALUE ; st -> codecpar -> codec_type = type ; ret = choose_encoder ( o , oc , ost , & enc ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Error selecting an encoder\\n\" ) ; exit_program ( 1 ) ; } if ( enc ) { ost -> enc_ctx = avcodec_alloc_context3 ( enc ) ; if ( ! ost -> enc_ctx ) report_and_exit ( AVERROR ( ENOMEM ) ) ; av_strlcat ( ms -> log_name , \"/\" , sizeof ( ms -> log_name ) ) ; av_strlcat ( ms -> log_name , enc -> name , sizeof ( ms -> log_name ) ) ; } else { av_strlcat ( ms -> log_name , \"/copy\" , sizeof ( ms -> log_name ) ) ; } ost -> filtered_frame = av_frame_alloc ( ) ; if ( ! ost -> filtered_frame ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ost -> pkt = av_packet_alloc ( ) ; if ( ! ost -> pkt ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( ost -> enc_ctx ) { AVCodecContext * enc = ost -> enc_ctx ; AVIOContext * s = NULL ; char * buf = NULL , * arg = NULL , * preset = NULL ; const char * enc_stats_pre = NULL , * enc_stats_post = NULL , * mux_stats = NULL ; ost -> encoder_opts = filter_codec_opts ( o -> g -> codec_opts , enc -> codec_id , oc , st , enc -> codec ) ; MATCH_PER_STREAM_OPT ( presets , str , preset , oc , st ) ; ost -> autoscale = 1 ; MATCH_PER_STREAM_OPT ( autoscale , i , ost -> autoscale , oc , st ) ; if ( preset && ( ! ( ret = get_preset_file_2 ( preset , enc -> codec -> name , & s ) ) ) ) { AVBPrint bprint ; av_bprint_init ( & bprint , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; do { av_bprint_clear ( & bprint ) ; buf = get_line ( s , & bprint ) ; if ( ! buf [ 0 ] || buf [ 0 ] == '#' ) continue ; if ( ! ( arg = strchr ( buf , '=' ) ) ) { av_log ( ost , AV_LOG_FATAL , \"Invalid line found in the preset file.\\n\" ) ; exit_program ( 1 ) ; } * arg ++ = 0 ; av_dict_set ( & ost -> encoder_opts , buf , arg , AV_DICT_DONT_OVERWRITE ) ; } while ( ! s -> eof_reached ) ; av_bprint_finalize ( & bprint , NULL ) ; avio_closep ( & s ) ; } if ( ret ) { av_log ( ost , AV_LOG_FATAL , \"Preset %s specified, but could not be opened.\\n\" , preset ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( enc_stats_pre , str , enc_stats_pre , oc , st ) ; if ( enc_stats_pre && ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO ) ) { const char * format = \"{fidx} {sidx} {n} {t}\" ; MATCH_PER_STREAM_OPT ( enc_stats_pre_fmt , str , format , oc , st ) ; ret = enc_stats_init ( ost , & ost -> enc_stats_pre , 1 , enc_stats_pre , format ) ; if ( ret < 0 ) exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( enc_stats_post , str , enc_stats_post , oc , st ) ; if ( enc_stats_post && ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO ) ) { const char * format = \"{fidx} {sidx} {n} {t}\" ; MATCH_PER_STREAM_OPT ( enc_stats_post_fmt , str , format , oc , st ) ; ret = enc_stats_init ( ost , & ost -> enc_stats_post , 0 , enc_stats_post , format ) ; if ( ret < 0 ) exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( mux_stats , str , mux_stats , oc , st ) ; if ( mux_stats && ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO ) ) { const char * format = \"{fidx} {sidx} {n} {t}\" ; MATCH_PER_STREAM_OPT ( mux_stats_fmt , str , format , oc , st ) ; ret = enc_stats_init ( ost , & ms -> stats , 0 , mux_stats , format ) ; if ( ret < 0 ) exit_program ( 1 ) ; } } else { ost -> encoder_opts = filter_codec_opts ( o -> g -> codec_opts , AV_CODEC_ID_NONE , oc , st , NULL ) ; } if ( o -> bitexact ) { ost -> bitexact = 1 ; } else if ( ost -> enc_ctx ) { ost -> bitexact = check_opt_bitexact ( ost -> enc_ctx , ost -> encoder_opts , \"flags\" , AV_CODEC_FLAG_BITEXACT ) ; } MATCH_PER_STREAM_OPT ( time_bases , str , time_base , oc , st ) ; if ( time_base ) { AVRational q ; if ( av_parse_ratio ( & q , time_base , INT_MAX , 0 , NULL ) < 0 || q . num <= 0 || q . den <= 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid time base: %s\\n\" , time_base ) ; exit_program ( 1 ) ; } st -> time_base = q ; } MATCH_PER_STREAM_OPT ( enc_time_bases , str , time_base , oc , st ) ; if ( time_base ) { AVRational q ; if ( av_parse_ratio ( & q , time_base , INT_MAX , 0 , NULL ) < 0 || q . den <= 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid time base: %s\\n\" , time_base ) ; exit_program ( 1 ) ; } ost -> enc_timebase = q ; } ms -> max_frames = INT64_MAX ; MATCH_PER_STREAM_OPT ( max_frames , i64 , ms -> max_frames , oc , st ) ; for ( i = 0 ; i < o -> nb_max_frames ; i ++ ) { char * p = o -> max_frames [ i ] . specifier ; if ( ! * p && type != AVMEDIA_TYPE_VIDEO ) { av_log ( ost , AV_LOG_WARNING , \"Applying unspecific -frames to non video streams, maybe you meant -vframes ?\\n\" ) ; break ; } } ost -> copy_prior_start = - 1 ; MATCH_PER_STREAM_OPT ( copy_prior_start , i , ost -> copy_prior_start , oc , st ) ; MATCH_PER_STREAM_OPT ( bitstream_filters , str , bsfs , oc , st ) ; if ( bsfs && * bsfs ) { ret = av_bsf_list_parse_str ( bsfs , & ms -> bsf_ctx ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error parsing bitstream filter sequence '%s': %s\\n\" , bsfs , av_err2str ( ret ) ) ; exit_program ( 1 ) ; } } MATCH_PER_STREAM_OPT ( codec_tags , str , codec_tag , oc , st ) ; if ( codec_tag ) { uint32_t tag = strtol ( codec_tag , & next , 0 ) ; if ( * next ) tag = AV_RL32 ( codec_tag ) ; ost -> st -> codecpar -> codec_tag = tag ; if ( ost -> enc_ctx ) ost -> enc_ctx -> codec_tag = tag ; } MATCH_PER_STREAM_OPT ( qscale , dbl , qscale , oc , st ) ; if ( ost -> enc_ctx && qscale >= 0 ) { ost -> enc_ctx -> flags |= AV_CODEC_FLAG_QSCALE ; ost -> enc_ctx -> global_quality = FF_QP2LAMBDA * qscale ; } ms -> max_muxing_queue_size = 128 ; MATCH_PER_STREAM_OPT ( max_muxing_queue_size , i , ms -> max_muxing_queue_size , oc , st ) ; ms -> muxing_queue_data_threshold = 50 * 1024 * 1024 ; MATCH_PER_STREAM_OPT ( muxing_queue_data_threshold , i , ms -> muxing_queue_data_threshold , oc , st ) ; MATCH_PER_STREAM_OPT ( bits_per_raw_sample , i , ost -> bits_per_raw_sample , oc , st ) ; MATCH_PER_STREAM_OPT ( fix_sub_duration_heartbeat , i , ost -> fix_sub_duration_heartbeat , oc , st ) ; if ( oc -> oformat -> flags & AVFMT_GLOBALHEADER && ost -> enc_ctx ) ost -> enc_ctx -> flags |= AV_CODEC_FLAG_GLOBAL_HEADER ; av_dict_copy ( & ost -> sws_dict , o -> g -> sws_dict , 0 ) ; av_dict_copy ( & ost -> swr_opts , o -> g -> swr_opts , 0 ) ; if ( ost -> enc_ctx && av_get_exact_bits_per_sample ( ost -> enc_ctx -> codec_id ) == 24 ) av_dict_set ( & ost -> swr_opts , \"output_sample_bits\" , \"24\" , 0 ) ; if ( ost -> ist ) { ost -> ist -> discard = 0 ; ost -> ist -> st -> discard = ost -> ist -> user_set_discard ; } ost -> last_mux_dts = AV_NOPTS_VALUE ; ost -> last_filter_pts = AV_NOPTS_VALUE ; MATCH_PER_STREAM_OPT ( copy_initial_nonkeyframes , i , ost -> copy_initial_nonkeyframes , oc , st ) ; return ost ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@get_ost_filters": "static char * get_ost_filters ( const OptionsContext * o , AVFormatContext * oc , OutputStream * ost ) { AVStream * st = ost -> st ; if ( ost -> filters_script && ost -> filters ) { av_log ( ost , AV_LOG_ERROR , \"Both -filter and -filter_script set\\n\" ) ; exit_program ( 1 ) ; } if ( ost -> filters_script ) return file_read ( ost -> filters_script ) ; else if ( ost -> filters ) return av_strdup ( ost -> filters ) ; return av_strdup ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ? \"null\" : \"anull\" ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@check_streamcopy_filters": "static void check_streamcopy_filters ( const OptionsContext * o , AVFormatContext * oc , OutputStream * ost , enum AVMediaType type ) { if ( ost -> filters_script || ost -> filters ) { av_log ( ost , AV_LOG_ERROR , \"%s '%s' was defined, but codec copy was selected.\\n\" \"Filtering and streamcopy cannot be used together.\\n\" , ost -> filters ? \"Filtergraph\" : \"Filtergraph script\" , ost -> filters ? ost -> filters : ost -> filters_script ) ; exit_program ( 1 ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@parse_matrix_coeffs": "static void parse_matrix_coeffs ( void * logctx , uint16_t * dest , const char * str ) { int i ; const char * p = str ; for ( i = 0 ; ; i ++ ) { dest [ i ] = atoi ( p ) ; if ( i == 63 ) break ; p = strchr ( p , ',' ) ; if ( ! p ) { av_log ( logctx , AV_LOG_FATAL , \"Syntax error in matrix \\\"%s\\\" at coeff %d\\n\" , str , i ) ; exit_program ( 1 ) ; } p ++ ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@new_video_stream": "static OutputStream * new_video_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { AVFormatContext * oc = mux -> fc ; AVStream * st ; OutputStream * ost ; char * frame_rate = NULL , * max_frame_rate = NULL , * frame_aspect_ratio = NULL ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_VIDEO , ist ) ; st = ost -> st ; MATCH_PER_STREAM_OPT ( frame_rates , str , frame_rate , oc , st ) ; if ( frame_rate && av_parse_video_rate ( & ost -> frame_rate , frame_rate ) < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid framerate value: %s\\n\" , frame_rate ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( max_frame_rates , str , max_frame_rate , oc , st ) ; if ( max_frame_rate && av_parse_video_rate ( & ost -> max_frame_rate , max_frame_rate ) < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid maximum framerate value: %s\\n\" , max_frame_rate ) ; exit_program ( 1 ) ; } if ( frame_rate && max_frame_rate ) { av_log ( ost , AV_LOG_ERROR , \"Only one of -fpsmax and -r can be set for a stream.\\n\" ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( frame_aspect_ratios , str , frame_aspect_ratio , oc , st ) ; if ( frame_aspect_ratio ) { AVRational q ; if ( av_parse_ratio ( & q , frame_aspect_ratio , 255 , 0 , NULL ) < 0 || q . num <= 0 || q . den <= 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid aspect ratio: %s\\n\" , frame_aspect_ratio ) ; exit_program ( 1 ) ; } ost -> frame_aspect_ratio = q ; } MATCH_PER_STREAM_OPT ( filter_scripts , str , ost -> filters_script , oc , st ) ; MATCH_PER_STREAM_OPT ( filters , str , ost -> filters , oc , st ) ; if ( ost -> enc_ctx ) { AVCodecContext * video_enc = ost -> enc_ctx ; const char * p = NULL , * fps_mode = NULL ; char * frame_size = NULL ; char * frame_pix_fmt = NULL ; char * intra_matrix = NULL , * inter_matrix = NULL ; char * chroma_intra_matrix = NULL ; int do_pass = 0 ; int i ; MATCH_PER_STREAM_OPT ( frame_sizes , str , frame_size , oc , st ) ; if ( frame_size && av_parse_video_size ( & video_enc -> width , & video_enc -> height , frame_size ) < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid frame size: %s.\\n\" , frame_size ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( frame_pix_fmts , str , frame_pix_fmt , oc , st ) ; if ( frame_pix_fmt && * frame_pix_fmt == '+' ) { ost -> keep_pix_fmt = 1 ; if ( ! * ++ frame_pix_fmt ) frame_pix_fmt = NULL ; } if ( frame_pix_fmt && ( video_enc -> pix_fmt = av_get_pix_fmt ( frame_pix_fmt ) ) == AV_PIX_FMT_NONE ) { av_log ( ost , AV_LOG_FATAL , \"Unknown pixel format requested: %s.\\n\" , frame_pix_fmt ) ; exit_program ( 1 ) ; } st -> sample_aspect_ratio = video_enc -> sample_aspect_ratio ; MATCH_PER_STREAM_OPT ( intra_matrices , str , intra_matrix , oc , st ) ; if ( intra_matrix ) { if ( ! ( video_enc -> intra_matrix = av_mallocz ( sizeof ( * video_enc -> intra_matrix ) * 64 ) ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; parse_matrix_coeffs ( ost , video_enc -> intra_matrix , intra_matrix ) ; } MATCH_PER_STREAM_OPT ( chroma_intra_matrices , str , chroma_intra_matrix , oc , st ) ; if ( chroma_intra_matrix ) { uint16_t * p = av_mallocz ( sizeof ( * video_enc -> chroma_intra_matrix ) * 64 ) ; if ( ! p ) report_and_exit ( AVERROR ( ENOMEM ) ) ; video_enc -> chroma_intra_matrix = p ; parse_matrix_coeffs ( ost , p , chroma_intra_matrix ) ; } MATCH_PER_STREAM_OPT ( inter_matrices , str , inter_matrix , oc , st ) ; if ( inter_matrix ) { if ( ! ( video_enc -> inter_matrix = av_mallocz ( sizeof ( * video_enc -> inter_matrix ) * 64 ) ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; parse_matrix_coeffs ( ost , video_enc -> inter_matrix , inter_matrix ) ; } MATCH_PER_STREAM_OPT ( rc_overrides , str , p , oc , st ) ; for ( i = 0 ; p ; i ++ ) { int start , end , q ; int e = sscanf ( p , \"%d,%d,%d\" , & start , & end , & q ) ; if ( e != 3 ) { av_log ( ost , AV_LOG_FATAL , \"error parsing rc_override\\n\" ) ; exit_program ( 1 ) ; } video_enc -> rc_override = av_realloc_array ( video_enc -> rc_override , i + 1 , sizeof ( RcOverride ) ) ; if ( ! video_enc -> rc_override ) { av_log ( ost , AV_LOG_FATAL , \"Could not (re)allocate memory for rc_override.\\n\" ) ; exit_program ( 1 ) ; } video_enc -> rc_override [ i ] . start_frame = start ; video_enc -> rc_override [ i ] . end_frame = end ; if ( q > 0 ) { video_enc -> rc_override [ i ] . qscale = q ; video_enc -> rc_override [ i ] . quality_factor = 1.0 ; } else { video_enc -> rc_override [ i ] . qscale = 0 ; video_enc -> rc_override [ i ] . quality_factor = - q / 100.0 ; } p = strchr ( p , '/' ) ; if ( p ) p ++ ; } video_enc -> rc_override_count = i ; # if FFMPEG_OPT_PSNR if ( do_psnr ) { av_log ( ost , AV_LOG_WARNING , \"The -psnr option is deprecated, use -flags +psnr\\n\" ) ; video_enc -> flags |= AV_CODEC_FLAG_PSNR ; } # endif /* two pass mode */ MATCH_PER_STREAM_OPT ( pass , i , do_pass , oc , st ) ; if ( do_pass ) { if ( do_pass & 1 ) { video_enc -> flags |= AV_CODEC_FLAG_PASS1 ; av_dict_set ( & ost -> encoder_opts , \"flags\" , \"+pass1\" , AV_DICT_APPEND ) ; } if ( do_pass & 2 ) { video_enc -> flags |= AV_CODEC_FLAG_PASS2 ; av_dict_set ( & ost -> encoder_opts , \"flags\" , \"+pass2\" , AV_DICT_APPEND ) ; } } MATCH_PER_STREAM_OPT ( passlogfiles , str , ost -> logfile_prefix , oc , st ) ; if ( ost -> logfile_prefix && ! ( ost -> logfile_prefix = av_strdup ( ost -> logfile_prefix ) ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( do_pass ) { int ost_idx = - 1 ; char logfilename [ 1024 ] ; FILE * f ; /* compute this stream's global index */ for ( int i = 0 ; i <= ost -> file_index ; i ++ ) ost_idx += output_files [ i ] -> nb_streams ; snprintf ( logfilename , sizeof ( logfilename ) , \"%s-%d.log\" , ost -> logfile_prefix ? ost -> logfile_prefix : DEFAULT_PASS_LOGFILENAME_PREFIX , ost_idx ) ; if ( ! strcmp ( ost -> enc_ctx -> codec -> name , \"libx264\" ) ) { av_dict_set ( & ost -> encoder_opts , \"stats\" , logfilename , AV_DICT_DONT_OVERWRITE ) ; } else { if ( video_enc -> flags & AV_CODEC_FLAG_PASS2 ) { char * logbuffer = file_read ( logfilename ) ; if ( ! logbuffer ) { av_log ( ost , AV_LOG_FATAL , \"Error reading log file '%s' for pass-2 encoding\\n\" , logfilename ) ; exit_program ( 1 ) ; } video_enc -> stats_in = logbuffer ; } if ( video_enc -> flags & AV_CODEC_FLAG_PASS1 ) { f = fopen_utf8 ( logfilename , \"wb\" ) ; if ( ! f ) { av_log ( ost , AV_LOG_FATAL , \"Cannot write log file '%s' for pass-1 encoding: %s\\n\" , logfilename , strerror ( errno ) ) ; exit_program ( 1 ) ; } ost -> logfile = f ; } } } MATCH_PER_STREAM_OPT ( force_fps , i , ost -> force_fps , oc , st ) ; ost -> top_field_first = - 1 ; MATCH_PER_STREAM_OPT ( top_field_first , i , ost -> top_field_first , oc , st ) ; ost -> vsync_method = video_sync_method ; MATCH_PER_STREAM_OPT ( fps_mode , str , fps_mode , oc , st ) ; if ( fps_mode ) parse_and_set_vsync ( fps_mode , & ost -> vsync_method , ost -> file_index , ost -> index , 0 ) ; if ( ( ost -> frame_rate . num || ost -> max_frame_rate . num ) && ! ( ost -> vsync_method == VSYNC_AUTO || ost -> vsync_method == VSYNC_CFR || ost -> vsync_method == VSYNC_VSCFR ) ) { av_log ( ost , AV_LOG_FATAL , \"One of -r/-fpsmax was specified \" \"together a non-CFR -vsync/-fps_mode. This is contradictory.\\n\" ) ; exit_program ( 1 ) ; } if ( ost -> vsync_method == VSYNC_AUTO ) { if ( ost -> frame_rate . num || ost -> max_frame_rate . num ) { ost -> vsync_method = VSYNC_CFR ; } else if ( ! strcmp ( oc -> oformat -> name , \"avi\" ) ) { ost -> vsync_method = VSYNC_VFR ; } else { ost -> vsync_method = ( oc -> oformat -> flags & AVFMT_VARIABLE_FPS ) ? ( ( oc -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ? VSYNC_PASSTHROUGH : VSYNC_VFR ) : VSYNC_CFR ; } if ( ost -> ist && ost -> vsync_method == VSYNC_CFR ) { const InputFile * ifile = input_files [ ost -> ist -> file_index ] ; if ( ifile -> nb_streams == 1 && ifile -> input_ts_offset == 0 ) ost -> vsync_method = VSYNC_VSCFR ; } if ( ost -> vsync_method == VSYNC_CFR && copy_ts ) { ost -> vsync_method = VSYNC_VSCFR ; } } ost -> is_cfr = ( ost -> vsync_method == VSYNC_CFR || ost -> vsync_method == VSYNC_VSCFR ) ; ost -> avfilter = get_ost_filters ( o , oc , ost ) ; if ( ! ost -> avfilter ) exit_program ( 1 ) ; ost -> last_frame = av_frame_alloc ( ) ; if ( ! ost -> last_frame ) report_and_exit ( AVERROR ( ENOMEM ) ) ; } else check_streamcopy_filters ( o , oc , ost , AVMEDIA_TYPE_VIDEO ) ; return ost ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@new_audio_stream": "static OutputStream * new_audio_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { AVFormatContext * oc = mux -> fc ; AVStream * st ; OutputStream * ost ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_AUDIO , ist ) ; st = ost -> st ; MATCH_PER_STREAM_OPT ( filter_scripts , str , ost -> filters_script , oc , st ) ; MATCH_PER_STREAM_OPT ( filters , str , ost -> filters , oc , st ) ; if ( ost -> enc_ctx ) { AVCodecContext * audio_enc = ost -> enc_ctx ; int channels = 0 ; char * layout = NULL ; char * sample_fmt = NULL ; MATCH_PER_STREAM_OPT ( audio_channels , i , channels , oc , st ) ; if ( channels ) { audio_enc -> ch_layout . order = AV_CHANNEL_ORDER_UNSPEC ; audio_enc -> ch_layout . nb_channels = channels ; } MATCH_PER_STREAM_OPT ( audio_ch_layouts , str , layout , oc , st ) ; if ( layout ) { if ( av_channel_layout_from_string ( & audio_enc -> ch_layout , layout ) < 0 ) { # if FF_API_OLD_CHANNEL_LAYOUT uint64_t mask ; AV_NOWARN_DEPRECATED ( { mask = av_get_channel_layout ( layout ) ; } ) if ( ! mask ) { # endif av_log ( ost , AV_LOG_FATAL , \"Unknown channel layout: %s\\n\" , layout ) ; exit_program ( 1 ) ; # if FF_API_OLD_CHANNEL_LAYOUT } av_log ( ost , AV_LOG_WARNING , \"Channel layout '%s' uses a deprecated syntax.\\n\" , layout ) ; av_channel_layout_from_mask ( & audio_enc -> ch_layout , mask ) ; # endif } } MATCH_PER_STREAM_OPT ( sample_fmts , str , sample_fmt , oc , st ) ; if ( sample_fmt && ( audio_enc -> sample_fmt = av_get_sample_fmt ( sample_fmt ) ) == AV_SAMPLE_FMT_NONE ) { av_log ( ost , AV_LOG_FATAL , \"Invalid sample format '%s'\\n\" , sample_fmt ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( audio_sample_rate , i , audio_enc -> sample_rate , oc , st ) ; MATCH_PER_STREAM_OPT ( apad , str , ost -> apad , oc , st ) ; ost -> apad = av_strdup ( ost -> apad ) ; ost -> avfilter = get_ost_filters ( o , oc , ost ) ; if ( ! ost -> avfilter ) exit_program ( 1 ) ; # if FFMPEG_OPT_MAP_CHANNEL /* check for channel mapping for this audio stream */ for ( int n = 0 ; n < o -> nb_audio_channel_maps ; n ++ ) { AudioChannelMap * map = & o -> audio_channel_maps [ n ] ; if ( ( map -> ofile_idx == - 1 || ost -> file_index == map -> ofile_idx ) && ( map -> ostream_idx == - 1 || ost -> st -> index == map -> ostream_idx ) ) { InputStream * ist ; if ( map -> channel_idx == - 1 ) { ist = NULL ; } else if ( ! ost -> ist ) { av_log ( ost , AV_LOG_FATAL , \"Cannot determine input stream for channel mapping %d.%d\\n\" , ost -> file_index , ost -> st -> index ) ; continue ; } else { ist = ost -> ist ; } if ( ! ist || ( ist -> file_index == map -> file_idx && ist -> st -> index == map -> stream_idx ) ) { if ( av_reallocp_array ( & ost -> audio_channels_map , ost -> audio_channels_mapped + 1 , sizeof ( * ost -> audio_channels_map ) ) < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ost -> audio_channels_map [ ost -> audio_channels_mapped ++ ] = map -> channel_idx ; } } } # endif } else check_streamcopy_filters ( o , oc , ost , AVMEDIA_TYPE_AUDIO ) ; return ost ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@new_data_stream": "static OutputStream * new_data_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { OutputStream * ost ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_DATA , ist ) ; if ( ost -> enc_ctx ) { av_log ( ost , AV_LOG_FATAL , \"Data stream encoding not supported yet (only streamcopy)\\n\" ) ; exit_program ( 1 ) ; } return ost ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@new_unknown_stream": "static OutputStream * new_unknown_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { OutputStream * ost ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_UNKNOWN , ist ) ; if ( ost -> enc_ctx ) { av_log ( ost , AV_LOG_FATAL , \"Unknown stream encoding not supported yet (only streamcopy)\\n\" ) ; exit_program ( 1 ) ; } return ost ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@new_attachment_stream": "static OutputStream * new_attachment_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { OutputStream * ost = new_output_stream ( mux , o , AVMEDIA_TYPE_ATTACHMENT , ist ) ; ost -> finished = 1 ; return ost ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@new_subtitle_stream": "static OutputStream * new_subtitle_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { AVStream * st ; OutputStream * ost ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_SUBTITLE , ist ) ; st = ost -> st ; if ( ost -> enc_ctx ) { AVCodecContext * subtitle_enc = ost -> enc_ctx ; char * frame_size = NULL ; MATCH_PER_STREAM_OPT ( frame_sizes , str , frame_size , mux -> fc , st ) ; if ( frame_size && av_parse_video_size ( & subtitle_enc -> width , & subtitle_enc -> height , frame_size ) < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid frame size: %s.\\n\" , frame_size ) ; exit_program ( 1 ) ; } } return ost ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@init_output_filter": "static void init_output_filter ( OutputFilter * ofilter , const OptionsContext * o , Muxer * mux ) { OutputStream * ost ; switch ( ofilter -> type ) { case AVMEDIA_TYPE_VIDEO : ost = new_video_stream ( mux , o , NULL ) ; break ; case AVMEDIA_TYPE_AUDIO : ost = new_audio_stream ( mux , o , NULL ) ; break ; default : av_log ( mux , AV_LOG_FATAL , \"Only video and audio filters are supported \" \"currently.\\n\" ) ; exit_program ( 1 ) ; } ost -> filter = ofilter ; ofilter -> ost = ost ; ofilter -> format = - 1 ; if ( ! ost -> enc_ctx ) { av_log ( ost , AV_LOG_ERROR , \"Streamcopy requested for output stream fed \" \"from a complex filtergraph. Filtering and streamcopy \" \"cannot be used together.\\n\" ) ; exit_program ( 1 ) ; } if ( ost -> avfilter && ( ost -> filters || ost -> filters_script ) ) { const char * opt = ost -> filters ? \"-vf/-af/-filter\" : \"-filter_script\" ; av_log ( ost , AV_LOG_ERROR , \"%s '%s' was specified through the %s option \" \"for output stream %d:%d, which is fed from a complex filtergraph.\\n\" \"%s and -filter_complex cannot be used together for the same stream.\\n\" , ost -> filters ? \"Filtergraph\" : \"Filtergraph script\" , ost -> filters ? ost -> filters : ost -> filters_script , opt , ost -> file_index , ost -> index , opt ) ; exit_program ( 1 ) ; } avfilter_inout_free ( & ofilter -> out_tmp ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@map_auto_video": "static void map_auto_video ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; InputStream * best_ist = NULL ; int best_score = 0 ; int qcr ; /* video: highest resolution */ if ( av_guess_codec ( oc -> oformat , NULL , oc -> url , NULL , AVMEDIA_TYPE_VIDEO ) == AV_CODEC_ID_NONE ) return ; qcr = avformat_query_codec ( oc -> oformat , oc -> oformat -> video_codec , 0 ) ; for ( int j = 0 ; j < nb_input_files ; j ++ ) { InputFile * ifile = input_files [ j ] ; InputStream * file_best_ist = NULL ; int file_best_score = 0 ; for ( int i = 0 ; i < ifile -> nb_streams ; i ++ ) { InputStream * ist = ifile -> streams [ i ] ; int score ; if ( ist -> user_set_discard == AVDISCARD_ALL || ist -> st -> codecpar -> codec_type != AVMEDIA_TYPE_VIDEO ) continue ; score = ist -> st -> codecpar -> width * ist -> st -> codecpar -> height + 100000000 * ! ! ( ist -> st -> event_flags & AVSTREAM_EVENT_FLAG_NEW_PACKETS ) + 5000000 * ! ! ( ist -> st -> disposition & AV_DISPOSITION_DEFAULT ) ; if ( ( qcr != MKTAG ( 'A' , 'P' , 'I' , 'C' ) ) && ( ist -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) ) score = 1 ; if ( score > file_best_score ) { if ( ( qcr == MKTAG ( 'A' , 'P' , 'I' , 'C' ) ) && ! ( ist -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) ) continue ; file_best_score = score ; file_best_ist = ist ; } } if ( file_best_ist ) { if ( ( qcr == MKTAG ( 'A' , 'P' , 'I' , 'C' ) ) || ! ( file_best_ist -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) ) file_best_score -= 5000000 * ! ! ( file_best_ist -> st -> disposition & AV_DISPOSITION_DEFAULT ) ; if ( file_best_score > best_score ) { best_score = file_best_score ; best_ist = file_best_ist ; } } } if ( best_ist ) new_video_stream ( mux , o , best_ist ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@map_auto_audio": "static void map_auto_audio ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; InputStream * best_ist = NULL ; int best_score = 0 ; /* audio: most channels */ if ( av_guess_codec ( oc -> oformat , NULL , oc -> url , NULL , AVMEDIA_TYPE_AUDIO ) == AV_CODEC_ID_NONE ) return ; for ( int j = 0 ; j < nb_input_files ; j ++ ) { InputFile * ifile = input_files [ j ] ; InputStream * file_best_ist = NULL ; int file_best_score = 0 ; for ( int i = 0 ; i < ifile -> nb_streams ; i ++ ) { InputStream * ist = ifile -> streams [ i ] ; int score ; if ( ist -> user_set_discard == AVDISCARD_ALL || ist -> st -> codecpar -> codec_type != AVMEDIA_TYPE_AUDIO ) continue ; score = ist -> st -> codecpar -> ch_layout . nb_channels + 100000000 * ! ! ( ist -> st -> event_flags & AVSTREAM_EVENT_FLAG_NEW_PACKETS ) + 5000000 * ! ! ( ist -> st -> disposition & AV_DISPOSITION_DEFAULT ) ; if ( score > file_best_score ) { file_best_score = score ; file_best_ist = ist ; } } if ( file_best_ist ) { file_best_score -= 5000000 * ! ! ( file_best_ist -> st -> disposition & AV_DISPOSITION_DEFAULT ) ; if ( file_best_score > best_score ) { best_score = file_best_score ; best_ist = file_best_ist ; } } } if ( best_ist ) new_audio_stream ( mux , o , best_ist ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@map_auto_subtitle": "static void map_auto_subtitle ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; char * subtitle_codec_name = NULL ; /* subtitles: pick first */ MATCH_PER_TYPE_OPT ( codec_names , str , subtitle_codec_name , oc , \"s\" ) ; if ( ! avcodec_find_encoder ( oc -> oformat -> subtitle_codec ) && ! subtitle_codec_name ) return ; for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) if ( ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { AVCodecDescriptor const * input_descriptor = avcodec_descriptor_get ( ist -> st -> codecpar -> codec_id ) ; AVCodecDescriptor const * output_descriptor = NULL ; AVCodec const * output_codec = avcodec_find_encoder ( oc -> oformat -> subtitle_codec ) ; int input_props = 0 , output_props = 0 ; if ( ist -> user_set_discard == AVDISCARD_ALL ) continue ; if ( output_codec ) output_descriptor = avcodec_descriptor_get ( output_codec -> id ) ; if ( input_descriptor ) input_props = input_descriptor -> props & ( AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB ) ; if ( output_descriptor ) output_props = output_descriptor -> props & ( AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB ) ; if ( subtitle_codec_name || input_props & output_props || // Map dvb teletext which has neither property to any output subtitle encoder ( input_descriptor && output_descriptor && ( ! input_descriptor -> props || ! output_descriptor -> props ) ) ) { new_subtitle_stream ( mux , o , ist ) ; break ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@map_auto_data": "static void map_auto_data ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; /* Data only if codec id match */ enum AVCodecID codec_id = av_guess_codec ( oc -> oformat , NULL , oc -> url , NULL , AVMEDIA_TYPE_DATA ) ; if ( codec_id == AV_CODEC_ID_NONE ) return ; for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) { if ( ist -> user_set_discard == AVDISCARD_ALL ) continue ; if ( ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA && ist -> st -> codecpar -> codec_id == codec_id ) new_data_stream ( mux , o , ist ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@map_manual": "static void map_manual ( Muxer * mux , const OptionsContext * o , const StreamMap * map ) { InputStream * ist ; if ( map -> disabled ) return ; if ( map -> linklabel ) { FilterGraph * fg ; OutputFilter * ofilter = NULL ; int j , k ; for ( j = 0 ; j < nb_filtergraphs ; j ++ ) { fg = filtergraphs [ j ] ; for ( k = 0 ; k < fg -> nb_outputs ; k ++ ) { AVFilterInOut * out = fg -> outputs [ k ] -> out_tmp ; if ( out && ! strcmp ( out -> name , map -> linklabel ) ) { ofilter = fg -> outputs [ k ] ; goto loop_end ; } } } loop_end : if ( ! ofilter ) { av_log ( mux , AV_LOG_FATAL , \"Output with label '%s' does not exist \" \"in any defined filter graph, or was already used elsewhere.\\n\" , map -> linklabel ) ; exit_program ( 1 ) ; } init_output_filter ( ofilter , o , mux ) ; } else { ist = input_files [ map -> file_index ] -> streams [ map -> stream_index ] ; if ( ist -> user_set_discard == AVDISCARD_ALL ) { av_log ( mux , AV_LOG_FATAL , \"Stream #%d:%d is disabled and cannot be mapped.\\n\" , map -> file_index , map -> stream_index ) ; exit_program ( 1 ) ; } if ( o -> subtitle_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_SUBTITLE ) return ; if ( o -> audio_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) return ; if ( o -> video_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) return ; if ( o -> data_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) return ; switch ( ist -> st -> codecpar -> codec_type ) { case AVMEDIA_TYPE_VIDEO : new_video_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_AUDIO : new_audio_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_SUBTITLE : new_subtitle_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_DATA : new_data_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_ATTACHMENT : new_attachment_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_UNKNOWN : if ( copy_unknown_streams ) { new_unknown_stream ( mux , o , ist ) ; break ; } default : av_log ( mux , ignore_unknown_streams ? AV_LOG_WARNING : AV_LOG_FATAL , \"Cannot map stream #%d:%d - unsupported type.\\n\" , map -> file_index , map -> stream_index ) ; if ( ! ignore_unknown_streams ) { av_log ( mux , AV_LOG_FATAL , \"If you want unsupported types ignored instead \" \"of failing, please use the -ignore_unknown option\\n\" \"If you want them copied, please use -copy_unknown\\n\" ) ; exit_program ( 1 ) ; } } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@of_add_attachments": "static void of_add_attachments ( Muxer * mux , const OptionsContext * o ) { OutputStream * ost ; int err ; for ( int i = 0 ; i < o -> nb_attachments ; i ++ ) { AVIOContext * pb ; uint8_t * attachment ; const char * p ; int64_t len ; if ( ( err = avio_open2 ( & pb , o -> attachments [ i ] , AVIO_FLAG_READ , & int_cb , NULL ) ) < 0 ) { av_log ( mux , AV_LOG_FATAL , \"Could not open attachment file %s.\\n\" , o -> attachments [ i ] ) ; exit_program ( 1 ) ; } if ( ( len = avio_size ( pb ) ) <= 0 ) { av_log ( mux , AV_LOG_FATAL , \"Could not get size of the attachment %s.\\n\" , o -> attachments [ i ] ) ; exit_program ( 1 ) ; } if ( len > INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE || ! ( attachment = av_malloc ( len + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { av_log ( mux , AV_LOG_FATAL , \"Attachment %s too large.\\n\" , o -> attachments [ i ] ) ; exit_program ( 1 ) ; } avio_read ( pb , attachment , len ) ; memset ( attachment + len , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; ost = new_attachment_stream ( mux , o , NULL ) ; ost -> attachment_filename = o -> attachments [ i ] ; ost -> st -> codecpar -> extradata = attachment ; ost -> st -> codecpar -> extradata_size = len ; p = strrchr ( o -> attachments [ i ] , '/' ) ; av_dict_set ( & ost -> st -> metadata , \"filename\" , ( p && * p ) ? p + 1 : o -> attachments [ i ] , AV_DICT_DONT_OVERWRITE ) ; avio_closep ( & pb ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@create_streams": "static void create_streams ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; int auto_disable_v = o -> video_disable ; int auto_disable_a = o -> audio_disable ; int auto_disable_s = o -> subtitle_disable ; int auto_disable_d = o -> data_disable ; /* create streams for all unlabeled output pads */ for ( int i = 0 ; i < nb_filtergraphs ; i ++ ) { FilterGraph * fg = filtergraphs [ i ] ; for ( int j = 0 ; j < fg -> nb_outputs ; j ++ ) { OutputFilter * ofilter = fg -> outputs [ j ] ; if ( ! ofilter -> out_tmp || ofilter -> out_tmp -> name ) continue ; switch ( ofilter -> type ) { case AVMEDIA_TYPE_VIDEO : auto_disable_v = 1 ; break ; case AVMEDIA_TYPE_AUDIO : auto_disable_a = 1 ; break ; case AVMEDIA_TYPE_SUBTITLE : auto_disable_s = 1 ; break ; } init_output_filter ( ofilter , o , mux ) ; } } if ( ! o -> nb_stream_maps ) { /* pick the \"best\" stream of each type */ if ( ! auto_disable_v ) map_auto_video ( mux , o ) ; if ( ! auto_disable_a ) map_auto_audio ( mux , o ) ; if ( ! auto_disable_s ) map_auto_subtitle ( mux , o ) ; if ( ! auto_disable_d ) map_auto_data ( mux , o ) ; } else { for ( int i = 0 ; i < o -> nb_stream_maps ; i ++ ) map_manual ( mux , o , & o -> stream_maps [ i ] ) ; } of_add_attachments ( mux , o ) ; if ( ! oc -> nb_streams && ! ( oc -> oformat -> flags & AVFMT_NOSTREAMS ) ) { av_dump_format ( oc , nb_output_files - 1 , oc -> url , 1 ) ; av_log ( mux , AV_LOG_ERROR , \"Output file does not contain any stream\\n\" ) ; exit_program ( 1 ) ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@setup_sync_queues": "static int setup_sync_queues ( Muxer * mux , AVFormatContext * oc , int64_t buf_size_us ) { OutputFile * of = & mux -> of ; int nb_av_enc = 0 , nb_interleaved = 0 ; int limit_frames = 0 , limit_frames_av_enc = 0 ; # define IS_AV_ENC ( ost , type ) ( ost -> enc_ctx && ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO ) ) # define IS_INTERLEAVED ( type ) ( type != AVMEDIA_TYPE_ATTACHMENT ) for ( int i = 0 ; i < oc -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; MuxStream * ms = ms_from_ost ( ost ) ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; ost -> sq_idx_encode = - 1 ; ost -> sq_idx_mux = - 1 ; nb_interleaved += IS_INTERLEAVED ( type ) ; nb_av_enc += IS_AV_ENC ( ost , type ) ; limit_frames |= ms -> max_frames < INT64_MAX ; limit_frames_av_enc |= ( ms -> max_frames < INT64_MAX ) && IS_AV_ENC ( ost , type ) ; } if ( ! ( ( nb_interleaved > 1 && of -> shortest ) || ( nb_interleaved > 0 && limit_frames ) ) ) return 0 ; /* if we have more than one encoded audio/video streams, or at least\n     * one encoded audio/video stream is frame-limited, then we\n     * synchronize them before encoding */ if ( ( of -> shortest && nb_av_enc > 1 ) || limit_frames_av_enc ) { of -> sq_encode = sq_alloc ( SYNC_QUEUE_FRAMES , buf_size_us ) ; if ( ! of -> sq_encode ) return AVERROR ( ENOMEM ) ; for ( int i = 0 ; i < oc -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; MuxStream * ms = ms_from_ost ( ost ) ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; if ( ! IS_AV_ENC ( ost , type ) ) continue ; ost -> sq_idx_encode = sq_add_stream ( of -> sq_encode , of -> shortest || ms -> max_frames < INT64_MAX ) ; if ( ost -> sq_idx_encode < 0 ) return ost -> sq_idx_encode ; ost -> sq_frame = av_frame_alloc ( ) ; if ( ! ost -> sq_frame ) return AVERROR ( ENOMEM ) ; if ( ms -> max_frames != INT64_MAX ) sq_limit_frames ( of -> sq_encode , ost -> sq_idx_encode , ms -> max_frames ) ; } } /* if there are any additional interleaved streams, then ALL the streams\n     * are also synchronized before sending them to the muxer */ if ( nb_interleaved > nb_av_enc ) { mux -> sq_mux = sq_alloc ( SYNC_QUEUE_PACKETS , buf_size_us ) ; if ( ! mux -> sq_mux ) return AVERROR ( ENOMEM ) ; mux -> sq_pkt = av_packet_alloc ( ) ; if ( ! mux -> sq_pkt ) return AVERROR ( ENOMEM ) ; for ( int i = 0 ; i < oc -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; MuxStream * ms = ms_from_ost ( ost ) ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; if ( ! IS_INTERLEAVED ( type ) ) continue ; ost -> sq_idx_mux = sq_add_stream ( mux -> sq_mux , of -> shortest || ms -> max_frames < INT64_MAX ) ; if ( ost -> sq_idx_mux < 0 ) return ost -> sq_idx_mux ; if ( ms -> max_frames != INT64_MAX ) sq_limit_frames ( mux -> sq_mux , ost -> sq_idx_mux , ms -> max_frames ) ; } } # undef IS_AV_ENC # undef IS_INTERLEAVED return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@of_add_programs": "static void of_add_programs ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; /* process manually set programs */ for ( int i = 0 ; i < o -> nb_program ; i ++ ) { const char * p = o -> program [ i ] . u . str ; int progid = i + 1 ; AVProgram * program ; while ( * p ) { const char * p2 = av_get_token ( & p , \":\" ) ; const char * to_dealloc = p2 ; char * key ; if ( ! p2 ) break ; if ( * p ) p ++ ; key = av_get_token ( & p2 , \"=\" ) ; if ( ! key || ! * p2 ) { av_freep ( & to_dealloc ) ; av_freep ( & key ) ; break ; } p2 ++ ; if ( ! strcmp ( key , \"program_num\" ) ) progid = strtol ( p2 , NULL , 0 ) ; av_freep ( & to_dealloc ) ; av_freep ( & key ) ; } program = av_new_program ( oc , progid ) ; if ( ! program ) report_and_exit ( AVERROR ( ENOMEM ) ) ; p = o -> program [ i ] . u . str ; while ( * p ) { const char * p2 = av_get_token ( & p , \":\" ) ; const char * to_dealloc = p2 ; char * key ; if ( ! p2 ) break ; if ( * p ) p ++ ; key = av_get_token ( & p2 , \"=\" ) ; if ( ! key ) { av_log ( mux , AV_LOG_FATAL , \"No '=' character in program string %s.\\n\" , p2 ) ; exit_program ( 1 ) ; } if ( ! * p2 ) exit_program ( 1 ) ; p2 ++ ; if ( ! strcmp ( key , \"title\" ) ) { av_dict_set ( & program -> metadata , \"title\" , p2 , 0 ) ; } else if ( ! strcmp ( key , \"program_num\" ) ) { } else if ( ! strcmp ( key , \"st\" ) ) { int st_num = strtol ( p2 , NULL , 0 ) ; av_program_add_stream_index ( oc , progid , st_num ) ; } else { av_log ( mux , AV_LOG_FATAL , \"Unknown program key %s.\\n\" , key ) ; exit_program ( 1 ) ; } av_freep ( & to_dealloc ) ; av_freep ( & key ) ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@parse_meta_type": "static void parse_meta_type ( void * logctx , const char * arg , char * type , int * index , const char * * stream_spec ) { if ( * arg ) { * type = * arg ; switch ( * arg ) { case 'g' : break ; case 's' : if ( * ( ++ arg ) && * arg != ':' ) { av_log ( logctx , AV_LOG_FATAL , \"Invalid metadata specifier %s.\\n\" , arg ) ; exit_program ( 1 ) ; } * stream_spec = * arg == ':' ? arg + 1 : \"\" ; break ; case 'c' : case 'p' : if ( * ( ++ arg ) == ':' ) * index = strtol ( ++ arg , NULL , 0 ) ; break ; default : av_log ( logctx , AV_LOG_FATAL , \"Invalid metadata type %c.\\n\" , * arg ) ; exit_program ( 1 ) ; } } else * type = 'g' ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@of_add_metadata": "static void of_add_metadata ( OutputFile * of , AVFormatContext * oc , const OptionsContext * o ) { for ( int i = 0 ; i < o -> nb_metadata ; i ++ ) { AVDictionary * * m ; char type , * val ; const char * stream_spec ; int index = 0 , ret = 0 ; val = strchr ( o -> metadata [ i ] . u . str , '=' ) ; if ( ! val ) { av_log ( of , AV_LOG_FATAL , \"No '=' character in metadata string %s.\\n\" , o -> metadata [ i ] . u . str ) ; exit_program ( 1 ) ; } * val ++ = 0 ; parse_meta_type ( of , o -> metadata [ i ] . specifier , & type , & index , & stream_spec ) ; if ( type == 's' ) { for ( int j = 0 ; j < oc -> nb_streams ; j ++ ) { OutputStream * ost = of -> streams [ j ] ; if ( ( ret = check_stream_specifier ( oc , oc -> streams [ j ] , stream_spec ) ) > 0 ) { # if FFMPEG_ROTATION_METADATA if ( ! strcmp ( o -> metadata [ i ] . u . str , \"rotate\" ) ) { char * tail ; double theta = av_strtod ( val , & tail ) ; if ( ! * tail ) { ost -> rotate_overridden = 1 ; ost -> rotate_override_value = theta ; } av_log ( ost , AV_LOG_WARNING , \"Conversion of a 'rotate' metadata key to a \" \"proper display matrix rotation is deprecated. \" \"See -display_rotation for setting rotation \" \"instead.\" ) ; } else { # endif av_dict_set ( & oc -> streams [ j ] -> metadata , o -> metadata [ i ] . u . str , * val ? val : NULL , 0 ) ; # if FFMPEG_ROTATION_METADATA } # endif } else if ( ret < 0 ) exit_program ( 1 ) ; } } else { switch ( type ) { case 'g' : m = & oc -> metadata ; break ; case 'c' : if ( index < 0 || index >= oc -> nb_chapters ) { av_log ( of , AV_LOG_FATAL , \"Invalid chapter index %d in metadata specifier.\\n\" , index ) ; exit_program ( 1 ) ; } m = & oc -> chapters [ index ] -> metadata ; break ; case 'p' : if ( index < 0 || index >= oc -> nb_programs ) { av_log ( of , AV_LOG_FATAL , \"Invalid program index %d in metadata specifier.\\n\" , index ) ; exit_program ( 1 ) ; } m = & oc -> programs [ index ] -> metadata ; break ; default : av_log ( of , AV_LOG_FATAL , \"Invalid metadata specifier %s.\\n\" , o -> metadata [ i ] . specifier ) ; exit_program ( 1 ) ; } av_dict_set ( m , o -> metadata [ i ] . u . str , * val ? val : NULL , 0 ) ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@set_channel_layout": "static void set_channel_layout ( OutputFilter * f , OutputStream * ost ) { const AVCodec * c = ost -> enc_ctx -> codec ; int i , err ; if ( ost -> enc_ctx -> ch_layout . order != AV_CHANNEL_ORDER_UNSPEC ) { /* Pass the layout through for all orders but UNSPEC */ err = av_channel_layout_copy ( & f -> ch_layout , & ost -> enc_ctx -> ch_layout ) ; if ( err < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return ; } /* Requested layout is of order UNSPEC */ if ( ! c -> ch_layouts ) { /* Use the default native layout for the requested amount of channels when the\n           encoder doesn't have a list of supported layouts */ av_channel_layout_default ( & f -> ch_layout , ost -> enc_ctx -> ch_layout . nb_channels ) ; return ; } /* Encoder has a list of supported layouts. Pick the first layout in it with the\n       same amount of channels as the requested layout */ for ( i = 0 ; c -> ch_layouts [ i ] . nb_channels ; i ++ ) { if ( c -> ch_layouts [ i ] . nb_channels == ost -> enc_ctx -> ch_layout . nb_channels ) break ; } if ( c -> ch_layouts [ i ] . nb_channels ) { /* Use it if one is found */ err = av_channel_layout_copy ( & f -> ch_layout , & c -> ch_layouts [ i ] ) ; if ( err < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return ; } /* If no layout for the amount of channels requested was found, use the default\n       native layout for it. */ av_channel_layout_default ( & f -> ch_layout , ost -> enc_ctx -> ch_layout . nb_channels ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@copy_chapters": "static int copy_chapters ( InputFile * ifile , OutputFile * ofile , AVFormatContext * os , int copy_metadata ) { AVFormatContext * is = ifile -> ctx ; AVChapter * * tmp ; int i ; tmp = av_realloc_f ( os -> chapters , is -> nb_chapters + os -> nb_chapters , sizeof ( * os -> chapters ) ) ; if ( ! tmp ) return AVERROR ( ENOMEM ) ; os -> chapters = tmp ; for ( i = 0 ; i < is -> nb_chapters ; i ++ ) { AVChapter * in_ch = is -> chapters [ i ] , * out_ch ; int64_t start_time = ( ofile -> start_time == AV_NOPTS_VALUE ) ? 0 : ofile -> start_time ; int64_t ts_off = av_rescale_q ( start_time - ifile -> ts_offset , AV_TIME_BASE_Q , in_ch -> time_base ) ; int64_t rt = ( ofile -> recording_time == INT64_MAX ) ? INT64_MAX : av_rescale_q ( ofile -> recording_time , AV_TIME_BASE_Q , in_ch -> time_base ) ; if ( in_ch -> end < ts_off ) continue ; if ( rt != INT64_MAX && in_ch -> start > rt + ts_off ) break ; out_ch = av_mallocz ( sizeof ( AVChapter ) ) ; if ( ! out_ch ) return AVERROR ( ENOMEM ) ; out_ch -> id = in_ch -> id ; out_ch -> time_base = in_ch -> time_base ; out_ch -> start = FFMAX ( 0 , in_ch -> start - ts_off ) ; out_ch -> end = FFMIN ( rt , in_ch -> end - ts_off ) ; if ( copy_metadata ) av_dict_copy ( & out_ch -> metadata , in_ch -> metadata , 0 ) ; os -> chapters [ os -> nb_chapters ++ ] = out_ch ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@copy_metadata": "static int copy_metadata ( Muxer * mux , AVFormatContext * ic , const char * outspec , const char * inspec , int * metadata_global_manual , int * metadata_streams_manual , int * metadata_chapters_manual , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; AVDictionary * * meta_in = NULL ; AVDictionary * * meta_out = NULL ; int i , ret = 0 ; char type_in , type_out ; const char * istream_spec = NULL , * ostream_spec = NULL ; int idx_in = 0 , idx_out = 0 ; parse_meta_type ( mux , inspec , & type_in , & idx_in , & istream_spec ) ; parse_meta_type ( mux , outspec , & type_out , & idx_out , & ostream_spec ) ; if ( type_in == 'g' || type_out == 'g' ) * metadata_global_manual = 1 ; if ( type_in == 's' || type_out == 's' ) * metadata_streams_manual = 1 ; if ( type_in == 'c' || type_out == 'c' ) * metadata_chapters_manual = 1 ; /* ic is NULL when just disabling automatic mappings */ if ( ! ic ) return 0 ; # define METADATA_CHECK_INDEX ( index , nb_elems , desc ) if ( ( index ) < 0 || ( index ) >= ( nb_elems ) ) { av_log ( mux , AV_LOG_FATAL , \"Invalid %s index %d while processing metadata maps.\\n\" , ( desc ) , ( index ) ) ; exit_program ( 1 ) ; } # define SET_DICT ( type , meta , context , index ) switch ( type ) { case 'g' : meta = & context -> metadata ; break ; case 'c' : METADATA_CHECK_INDEX ( index , context -> nb_chapters , \"chapter\" ) meta = & context -> chapters [ index ] -> metadata ; break ; case 'p' : METADATA_CHECK_INDEX ( index , context -> nb_programs , \"program\" ) meta = & context -> programs [ index ] -> metadata ; break ; case 's' : break ; /* handled separately below */ default : av_assert0 ( 0 ) ; } SET_DICT ( type_in , meta_in , ic , idx_in ) ; SET_DICT ( type_out , meta_out , oc , idx_out ) ; /* for input streams choose first matching stream */ if ( type_in == 's' ) { for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { if ( ( ret = check_stream_specifier ( ic , ic -> streams [ i ] , istream_spec ) ) > 0 ) { meta_in = & ic -> streams [ i ] -> metadata ; break ; } else if ( ret < 0 ) exit_program ( 1 ) ; } if ( ! meta_in ) { av_log ( mux , AV_LOG_FATAL , \"Stream specifier %s does not match  any streams.\\n\" , istream_spec ) ; exit_program ( 1 ) ; } } if ( type_out == 's' ) { for ( i = 0 ; i < oc -> nb_streams ; i ++ ) { if ( ( ret = check_stream_specifier ( oc , oc -> streams [ i ] , ostream_spec ) ) > 0 ) { meta_out = & oc -> streams [ i ] -> metadata ; av_dict_copy ( meta_out , * meta_in , AV_DICT_DONT_OVERWRITE ) ; } else if ( ret < 0 ) exit_program ( 1 ) ; } } else av_dict_copy ( meta_out , * meta_in , AV_DICT_DONT_OVERWRITE ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@copy_meta": "static void copy_meta ( Muxer * mux , const OptionsContext * o ) { OutputFile * of = & mux -> of ; AVFormatContext * oc = mux -> fc ; int chapters_input_file = o -> chapters_input_file ; int metadata_global_manual = 0 ; int metadata_streams_manual = 0 ; int metadata_chapters_manual = 0 ; /* copy metadata */ for ( int i = 0 ; i < o -> nb_metadata_map ; i ++ ) { char * p ; int in_file_index = strtol ( o -> metadata_map [ i ] . u . str , & p , 0 ) ; if ( in_file_index >= nb_input_files ) { av_log ( mux , AV_LOG_FATAL , \"Invalid input file index %d while \" \"processing metadata maps\\n\" , in_file_index ) ; exit_program ( 1 ) ; } copy_metadata ( mux , in_file_index >= 0 ? input_files [ in_file_index ] -> ctx : NULL , o -> metadata_map [ i ] . specifier , * p ? p + 1 : p , & metadata_global_manual , & metadata_streams_manual , & metadata_chapters_manual , o ) ; } /* copy chapters */ if ( chapters_input_file >= nb_input_files ) { if ( chapters_input_file == INT_MAX ) { /* copy chapters from the first input file that has them*/ chapters_input_file = - 1 ; for ( int i = 0 ; i < nb_input_files ; i ++ ) if ( input_files [ i ] -> ctx -> nb_chapters ) { chapters_input_file = i ; break ; } } else { av_log ( mux , AV_LOG_FATAL , \"Invalid input file index %d in chapter mapping.\\n\" , chapters_input_file ) ; exit_program ( 1 ) ; } } if ( chapters_input_file >= 0 ) copy_chapters ( input_files [ chapters_input_file ] , of , oc , ! metadata_chapters_manual ) ; /* copy global metadata by default */ if ( ! metadata_global_manual && nb_input_files ) { av_dict_copy ( & oc -> metadata , input_files [ 0 ] -> ctx -> metadata , AV_DICT_DONT_OVERWRITE ) ; if ( of -> recording_time != INT64_MAX ) av_dict_set ( & oc -> metadata , \"duration\" , NULL , 0 ) ; av_dict_set ( & oc -> metadata , \"creation_time\" , NULL , 0 ) ; av_dict_set ( & oc -> metadata , \"company_name\" , NULL , 0 ) ; av_dict_set ( & oc -> metadata , \"product_name\" , NULL , 0 ) ; av_dict_set ( & oc -> metadata , \"product_version\" , NULL , 0 ) ; } if ( ! metadata_streams_manual ) for ( int i = 0 ; i < of -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; if ( ! ost -> ist ) /* this is true e.g. for attached files */ continue ; av_dict_copy ( & ost -> st -> metadata , ost -> ist -> st -> metadata , AV_DICT_DONT_OVERWRITE ) ; if ( ost -> enc_ctx ) { av_dict_set ( & ost -> st -> metadata , \"encoder\" , NULL , 0 ) ; } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@set_dispositions": "static int set_dispositions ( Muxer * mux , const OptionsContext * o ) { OutputFile * of = & mux -> of ; AVFormatContext * ctx = mux -> fc ; int nb_streams [ AVMEDIA_TYPE_NB ] = { 0 } ; int have_default [ AVMEDIA_TYPE_NB ] = { 0 } ; int have_manual = 0 ; int ret = 0 ; const char * * dispositions ; dispositions = av_calloc ( ctx -> nb_streams , sizeof ( * dispositions ) ) ; if ( ! dispositions ) return AVERROR ( ENOMEM ) ; // first, copy the input dispositions for ( int i = 0 ; i < ctx -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; nb_streams [ ost -> st -> codecpar -> codec_type ] ++ ; MATCH_PER_STREAM_OPT ( disposition , str , dispositions [ i ] , ctx , ost -> st ) ; have_manual |= ! ! dispositions [ i ] ; if ( ost -> ist ) { ost -> st -> disposition = ost -> ist -> st -> disposition ; if ( ost -> st -> disposition & AV_DISPOSITION_DEFAULT ) have_default [ ost -> st -> codecpar -> codec_type ] = 1 ; } } if ( have_manual ) { // process manually set dispositions - they override the above copy for ( int i = 0 ; i < ctx -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; const char * disp = dispositions [ i ] ; if ( ! disp ) continue ; ret = av_opt_set ( ost -> st , \"disposition\" , disp , 0 ) ; if ( ret < 0 ) goto finish ; } } else { // For each media type with more than one stream, find a suitable stream to // mark as default, unless one is already marked default. // \"Suitable\" means the first of that type, skipping attached pictures. for ( int i = 0 ; i < ctx -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; if ( nb_streams [ type ] < 2 || have_default [ type ] || ost -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) continue ; ost -> st -> disposition |= AV_DISPOSITION_DEFAULT ; have_default [ type ] = 1 ; } } finish : av_freep ( & dispositions ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@compare_int64": "static int compare_int64 ( const void * a , const void * b ) { return FFDIFFSIGN ( * ( const int64_t * ) a , * ( const int64_t * ) b ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@parse_forced_key_frames": "static void parse_forced_key_frames ( KeyframeForceCtx * kf , const Muxer * mux , const char * spec ) { const char * p ; int n = 1 , i , size , index = 0 ; int64_t t , * pts ; for ( p = spec ; * p ; p ++ ) if ( * p == ',' ) n ++ ; size = n ; pts = av_malloc_array ( size , sizeof ( * pts ) ) ; if ( ! pts ) report_and_exit ( AVERROR ( ENOMEM ) ) ; p = spec ; for ( i = 0 ; i < n ; i ++ ) { char * next = strchr ( p , ',' ) ; if ( next ) * next ++ = 0 ; if ( ! memcmp ( p , \"chapters\" , 8 ) ) { AVChapter * const * ch = mux -> fc -> chapters ; unsigned int nb_ch = mux -> fc -> nb_chapters ; int j ; if ( nb_ch > INT_MAX - size || ! ( pts = av_realloc_f ( pts , size += nb_ch - 1 , sizeof ( * pts ) ) ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; t = p [ 8 ] ? parse_time_or_die ( \"force_key_frames\" , p + 8 , 1 ) : 0 ; for ( j = 0 ; j < nb_ch ; j ++ ) { const AVChapter * c = ch [ j ] ; av_assert1 ( index < size ) ; pts [ index ++ ] = av_rescale_q ( c -> start , c -> time_base , AV_TIME_BASE_Q ) + t ; } } else { av_assert1 ( index < size ) ; pts [ index ++ ] = parse_time_or_die ( \"force_key_frames\" , p , 1 ) ; } p = next ; } av_assert0 ( index == size ) ; qsort ( pts , size , sizeof ( * pts ) , compare_int64 ) ; kf -> nb_pts = size ; kf -> pts = pts ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@process_forced_keyframes": "static int process_forced_keyframes ( Muxer * mux , const OptionsContext * o ) { for ( int i = 0 ; i < mux -> of . nb_streams ; i ++ ) { OutputStream * ost = mux -> of . streams [ i ] ; const char * forced_keyframes = NULL ; MATCH_PER_STREAM_OPT ( forced_key_frames , str , forced_keyframes , mux -> fc , ost -> st ) ; if ( ! ( ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && ost -> enc_ctx && forced_keyframes ) ) continue ; if ( ! strncmp ( forced_keyframes , \"expr:\" , 5 ) ) { int ret = av_expr_parse ( & ost -> kf . pexpr , forced_keyframes + 5 , forced_keyframes_const_names , NULL , NULL , NULL , NULL , 0 , NULL ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Invalid force_key_frames expression '%s'\\n\" , forced_keyframes + 5 ) ; return ret ; } ost -> kf . expr_const_values [ FKF_N ] = 0 ; ost -> kf . expr_const_values [ FKF_N_FORCED ] = 0 ; ost -> kf . expr_const_values [ FKF_PREV_FORCED_N ] = NAN ; ost -> kf . expr_const_values [ FKF_PREV_FORCED_T ] = NAN ; // Don't parse the 'forced_keyframes' in case of 'keep-source-keyframes', // parse it only for static kf timings } else if ( ! strcmp ( forced_keyframes , \"source\" ) ) { ost -> kf . type = KF_FORCE_SOURCE ; } else if ( ! strcmp ( forced_keyframes , \"source_no_drop\" ) ) { ost -> kf . type = KF_FORCE_SOURCE_NO_DROP ; } else { parse_forced_key_frames ( & ost -> kf , mux , forced_keyframes ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@validate_enc_avopt": "static void validate_enc_avopt ( Muxer * mux , const AVDictionary * codec_avopt ) { const AVClass * class = avcodec_get_class ( ) ; const AVClass * fclass = avformat_get_class ( ) ; const OutputFile * of = & mux -> of ; AVDictionary * unused_opts ; const AVDictionaryEntry * e ; unused_opts = strip_specifiers ( codec_avopt ) ; for ( int i = 0 ; i < of -> nb_streams ; i ++ ) { e = NULL ; while ( ( e = av_dict_iterate ( of -> streams [ i ] -> encoder_opts , e ) ) ) av_dict_set ( & unused_opts , e -> key , NULL , 0 ) ; } e = NULL ; while ( ( e = av_dict_iterate ( unused_opts , e ) ) ) { const AVOption * option = av_opt_find ( & class , e -> key , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ; const AVOption * foption = av_opt_find ( & fclass , e -> key , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ; if ( ! option || foption ) continue ; if ( ! ( option -> flags & AV_OPT_FLAG_ENCODING_PARAM ) ) { av_log ( mux , AV_LOG_ERROR , \"Codec AVOption %s (%s) is not an \" \"encoding option.\\n\" , e -> key , option -> help ? option -> help : \"\" ) ; exit_program ( 1 ) ; } // gop_timecode is injected by generic code but not always used if ( ! strcmp ( e -> key , \"gop_timecode\" ) ) continue ; av_log ( mux , AV_LOG_WARNING , \"Codec AVOption %s (%s) has not been used \" \"for any stream. The most likely reason is either wrong type \" \"(e.g. a video option with no video streams) or that it is a \" \"private option of some encoder which was not actually used for \" \"any stream.\\n\" , e -> key , option -> help ? option -> help : \"\" ) ; } av_dict_free ( & unused_opts ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@output_file_item_name": "static const char * output_file_item_name ( void * obj ) { const Muxer * mux = obj ; return mux -> log_name ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@mux_alloc": "static Muxer * mux_alloc ( void ) { Muxer * mux = allocate_array_elem ( & output_files , sizeof ( * mux ) , & nb_output_files ) ; mux -> of . clazz = & output_file_class ; mux -> of . index = nb_output_files - 1 ; snprintf ( mux -> log_name , sizeof ( mux -> log_name ) , \"out#%d\" , mux -> of . index ) ; return mux ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux_init.c@of_open": "int of_open ( const OptionsContext * o , const char * filename ) { Muxer * mux ; AVFormatContext * oc ; int err ; OutputFile * of ; int64_t recording_time = o -> recording_time ; int64_t stop_time = o -> stop_time ; mux = mux_alloc ( ) ; of = & mux -> of ; if ( stop_time != INT64_MAX && recording_time != INT64_MAX ) { stop_time = INT64_MAX ; av_log ( mux , AV_LOG_WARNING , \"-t and -to cannot be used together; using -t.\\n\" ) ; } if ( stop_time != INT64_MAX && recording_time == INT64_MAX ) { int64_t start_time = o -> start_time == AV_NOPTS_VALUE ? 0 : o -> start_time ; if ( stop_time <= start_time ) { av_log ( mux , AV_LOG_ERROR , \"-to value smaller than -ss; aborting.\\n\" ) ; exit_program ( 1 ) ; } else { recording_time = stop_time - start_time ; } } of -> recording_time = recording_time ; of -> start_time = o -> start_time ; of -> shortest = o -> shortest ; mux -> thread_queue_size = o -> thread_queue_size > 0 ? o -> thread_queue_size : 8 ; mux -> limit_filesize = o -> limit_filesize ; av_dict_copy ( & mux -> opts , o -> g -> format_opts , 0 ) ; if ( ! strcmp ( filename , \"-\" ) ) filename = \"pipe:\" ; err = avformat_alloc_output_context2 ( & oc , NULL , o -> format , filename ) ; if ( ! oc ) { print_error ( filename , err ) ; exit_program ( 1 ) ; } mux -> fc = oc ; av_strlcat ( mux -> log_name , \"/\" , sizeof ( mux -> log_name ) ) ; av_strlcat ( mux -> log_name , oc -> oformat -> name , sizeof ( mux -> log_name ) ) ; if ( strcmp ( oc -> oformat -> name , \"rtp\" ) ) want_sdp = 0 ; of -> format = oc -> oformat ; if ( recording_time != INT64_MAX ) oc -> duration = recording_time ; oc -> interrupt_callback = int_cb ; if ( o -> bitexact ) { oc -> flags |= AVFMT_FLAG_BITEXACT ; of -> bitexact = 1 ; } else { of -> bitexact = check_opt_bitexact ( oc , mux -> opts , \"fflags\" , AVFMT_FLAG_BITEXACT ) ; } /* create all output streams for this file */ create_streams ( mux , o ) ; /* check if all codec options have been used */ validate_enc_avopt ( mux , o -> g -> codec_opts ) ; /* set the decoding_needed flags and create simple filtergraphs */ for ( int i = 0 ; i < of -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; if ( ost -> enc_ctx && ost -> ist ) { InputStream * ist = ost -> ist ; ist -> decoding_needed |= DECODING_FOR_OST ; ist -> processing_needed = 1 ; if ( ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO || ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { err = init_simple_filtergraph ( ist , ost ) ; if ( err < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error initializing a simple filtergraph\\n\" ) ; exit_program ( 1 ) ; } } } else if ( ost -> ist ) { ost -> ist -> processing_needed = 1 ; } /* set the filter output constraints */ if ( ost -> filter ) { const AVCodec * c = ost -> enc_ctx -> codec ; OutputFilter * f = ost -> filter ; switch ( ost -> enc_ctx -> codec_type ) { case AVMEDIA_TYPE_VIDEO : f -> frame_rate = ost -> frame_rate ; f -> width = ost -> enc_ctx -> width ; f -> height = ost -> enc_ctx -> height ; if ( ost -> enc_ctx -> pix_fmt != AV_PIX_FMT_NONE ) { f -> format = ost -> enc_ctx -> pix_fmt ; } else { f -> formats = c -> pix_fmts ; } break ; case AVMEDIA_TYPE_AUDIO : if ( ost -> enc_ctx -> sample_fmt != AV_SAMPLE_FMT_NONE ) { f -> format = ost -> enc_ctx -> sample_fmt ; } else { f -> formats = c -> sample_fmts ; } if ( ost -> enc_ctx -> sample_rate ) { f -> sample_rate = ost -> enc_ctx -> sample_rate ; } else { f -> sample_rates = c -> supported_samplerates ; } if ( ost -> enc_ctx -> ch_layout . nb_channels ) { set_channel_layout ( f , ost ) ; } else if ( c -> ch_layouts ) { f -> ch_layouts = c -> ch_layouts ; } break ; } } } /* check filename in case of an image number is expected */ if ( oc -> oformat -> flags & AVFMT_NEEDNUMBER ) { if ( ! av_filename_number_test ( oc -> url ) ) { print_error ( oc -> url , AVERROR ( EINVAL ) ) ; exit_program ( 1 ) ; } } if ( ! ( oc -> oformat -> flags & AVFMT_NOFILE ) ) { /* test if it already exists to avoid losing precious files */ assert_file_overwrite ( filename ) ; /* open the file */ if ( ( err = avio_open2 ( & oc -> pb , filename , AVIO_FLAG_WRITE , & oc -> interrupt_callback , & mux -> opts ) ) < 0 ) { print_error ( filename , err ) ; exit_program ( 1 ) ; } } else if ( strcmp ( oc -> oformat -> name , \"image2\" ) == 0 && ! av_filename_number_test ( filename ) ) assert_file_overwrite ( filename ) ; if ( o -> mux_preload ) { av_dict_set_int ( & mux -> opts , \"preload\" , o -> mux_preload * AV_TIME_BASE , 0 ) ; } oc -> max_delay = ( int ) ( o -> mux_max_delay * AV_TIME_BASE ) ; /* copy metadata and chapters from input files */ copy_meta ( mux , o ) ; of_add_programs ( mux , o ) ; of_add_metadata ( of , oc , o ) ; err = set_dispositions ( mux , o ) ; if ( err < 0 ) { av_log ( mux , AV_LOG_FATAL , \"Error setting output stream dispositions\\n\" ) ; exit_program ( 1 ) ; } // parse forced keyframe specifications; // must be done after chapters are created err = process_forced_keyframes ( mux , o ) ; if ( err < 0 ) { av_log ( mux , AV_LOG_FATAL , \"Error processing forced keyframes\\n\" ) ; exit_program ( 1 ) ; } err = setup_sync_queues ( mux , oc , o -> shortest_buf_duration * AV_TIME_BASE ) ; if ( err < 0 ) { av_log ( mux , AV_LOG_FATAL , \"Error setting up output sync queues\\n\" ) ; exit_program ( 1 ) ; } of -> url = filename ; /* write the header for files with no streams */ if ( of -> format -> flags & AVFMT_NOSTREAMS && oc -> nb_streams == 0 ) { int ret = mux_check_init ( mux ) ; if ( ret < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@get_compliance_normal_pix_fmts": "static const enum AVPixelFormat * get_compliance_normal_pix_fmts ( const AVCodec * codec , const enum AVPixelFormat default_formats [ ] ) { static const enum AVPixelFormat mjpeg_formats [ ] = { AV_PIX_FMT_YUVJ420P , AV_PIX_FMT_YUVJ422P , AV_PIX_FMT_YUVJ444P , AV_PIX_FMT_NONE } ; if ( ! strcmp ( codec -> name , \"mjpeg\" ) ) { return mjpeg_formats ; } else { return default_formats ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@choose_pixel_fmt": "enum AVPixelFormat choose_pixel_fmt ( const AVCodec * codec , enum AVPixelFormat target , int strict_std_compliance ) { if ( codec && codec -> pix_fmts ) { const enum AVPixelFormat * p = codec -> pix_fmts ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( target ) ; //FIXME: This should check for AV_PIX_FMT_FLAG_ALPHA after PAL8 pixel format without alpha is implemented int has_alpha = desc ? desc -> nb_components % 2 == 0 : 0 ; enum AVPixelFormat best = AV_PIX_FMT_NONE ; if ( strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL ) { p = get_compliance_normal_pix_fmts ( codec , p ) ; } for ( ; * p != AV_PIX_FMT_NONE ; p ++ ) { best = av_find_best_pix_fmt_of_2 ( best , * p , target , has_alpha , NULL ) ; if ( * p == target ) break ; } if ( * p == AV_PIX_FMT_NONE ) { if ( target != AV_PIX_FMT_NONE ) av_log ( NULL , AV_LOG_WARNING , \"Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\\n\" , av_get_pix_fmt_name ( target ) , codec -> name , av_get_pix_fmt_name ( best ) ) ; return best ; } } return target ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@choose_pix_fmts": "static const char * choose_pix_fmts ( OutputFilter * ofilter , AVBPrint * bprint ) { OutputStream * ost = ofilter -> ost ; AVCodecContext * enc = ost -> enc_ctx ; const AVDictionaryEntry * strict_dict = av_dict_get ( ost -> encoder_opts , \"strict\" , NULL , 0 ) ; if ( strict_dict ) // used by choose_pixel_fmt() and below av_opt_set ( ost -> enc_ctx , \"strict\" , strict_dict -> value , 0 ) ; if ( ost -> keep_pix_fmt ) { avfilter_graph_set_auto_convert ( ofilter -> graph -> graph , AVFILTER_AUTO_CONVERT_NONE ) ; if ( ost -> enc_ctx -> pix_fmt == AV_PIX_FMT_NONE ) return NULL ; return av_get_pix_fmt_name ( ost -> enc_ctx -> pix_fmt ) ; } if ( ost -> enc_ctx -> pix_fmt != AV_PIX_FMT_NONE ) { return av_get_pix_fmt_name ( choose_pixel_fmt ( enc -> codec , enc -> pix_fmt , ost -> enc_ctx -> strict_std_compliance ) ) ; } else if ( enc -> codec -> pix_fmts ) { const enum AVPixelFormat * p ; p = enc -> codec -> pix_fmts ; if ( ost -> enc_ctx -> strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL ) { p = get_compliance_normal_pix_fmts ( enc -> codec , p ) ; } for ( ; * p != AV_PIX_FMT_NONE ; p ++ ) { const char * name = av_get_pix_fmt_name ( * p ) ; av_bprintf ( bprint , \"%s%c\" , name , p [ 1 ] == AV_PIX_FMT_NONE ? '\\0' : '|' ) ; } if ( ! av_bprint_is_complete ( bprint ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return bprint -> str ; } else return NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@choose_sample_fmts": "static void choose_ ## name ( OutputFilter * ofilter , AVBPrint * bprint ) \\\n{ if ( ofilter -> var == none && ! ofilter -> supported_list ) return ; av_bprintf ( bprint , # name \"=\" ) ; if ( ofilter -> var != none ) { av_bprintf ( bprint , printf_format , get_name ( ofilter -> var ) ) ; } else { const type * p ; for ( p = ofilter -> supported_list ; * p != none ; p ++ ) { av_bprintf ( bprint , printf_format \"|\" , get_name ( * p ) ) ; } if ( bprint -> len > 0 ) bprint -> str [ -- bprint -> len ] = '\\0' ; } av_bprint_chars ( bprint , ':' , 1 ) ; \\\n} //DEF_CHOOSE_FORMAT(pix_fmts, enum AVPixelFormat, format, formats, AV_PIX_FMT_NONE, //                  GET_PIX_FMT_NAME) DEF_CHOOSE_FORMAT ( sample_fmts , enum AVSampleFormat , format , formats , AV_SAMPLE_FMT_NONE , \"%s\" , av_get_sample_fmt_name )",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@choose_sample_rates": "static void choose_ ## name ( OutputFilter * ofilter , AVBPrint * bprint ) \\\n{ if ( ofilter -> var == none && ! ofilter -> supported_list ) return ; av_bprintf ( bprint , # name \"=\" ) ; if ( ofilter -> var != none ) { av_bprintf ( bprint , printf_format , get_name ( ofilter -> var ) ) ; } else { const type * p ; for ( p = ofilter -> supported_list ; * p != none ; p ++ ) { av_bprintf ( bprint , printf_format \"|\" , get_name ( * p ) ) ; } if ( bprint -> len > 0 ) bprint -> str [ -- bprint -> len ] = '\\0' ; } av_bprint_chars ( bprint , ':' , 1 ) ; \\\n} //DEF_CHOOSE_FORMAT(pix_fmts, enum AVPixelFormat, format, formats, AV_PIX_FMT_NONE, //                  GET_PIX_FMT_NAME) DEF_CHOOSE_FORMAT ( sample_fmts , enum AVSampleFormat , format , formats , AV_SAMPLE_FMT_NONE , \"%s\" , av_get_sample_fmt_name ) DEF_CHOOSE_FORMAT ( sample_rates , int , sample_rate , sample_rates , 0 , \"%d\" , )",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@choose_channel_layouts": "static void choose_channel_layouts ( OutputFilter * ofilter , AVBPrint * bprint ) { if ( av_channel_layout_check ( & ofilter -> ch_layout ) ) { av_bprintf ( bprint , \"channel_layouts=\" ) ; av_channel_layout_describe_bprint ( & ofilter -> ch_layout , bprint ) ; } else if ( ofilter -> ch_layouts ) { const AVChannelLayout * p ; av_bprintf ( bprint , \"channel_layouts=\" ) ; for ( p = ofilter -> ch_layouts ; p -> nb_channels ; p ++ ) { av_channel_layout_describe_bprint ( p , bprint ) ; av_bprintf ( bprint , \"|\" ) ; } if ( bprint -> len > 0 ) bprint -> str [ -- bprint -> len ] = '\\0' ; } else return ; av_bprint_chars ( bprint , ':' , 1 ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@init_simple_filtergraph": "int init_simple_filtergraph ( InputStream * ist , OutputStream * ost ) { FilterGraph * fg = av_mallocz ( sizeof ( * fg ) ) ; OutputFilter * ofilter ; InputFilter * ifilter ; if ( ! fg ) report_and_exit ( AVERROR ( ENOMEM ) ) ; fg -> index = nb_filtergraphs ; ofilter = ALLOC_ARRAY_ELEM ( fg -> outputs , fg -> nb_outputs ) ; ofilter -> ost = ost ; ofilter -> graph = fg ; ofilter -> format = - 1 ; ost -> filter = ofilter ; ifilter = ALLOC_ARRAY_ELEM ( fg -> inputs , fg -> nb_inputs ) ; ifilter -> ist = ist ; ifilter -> graph = fg ; ifilter -> format = - 1 ; ifilter -> frame_queue = av_fifo_alloc2 ( 8 , sizeof ( AVFrame * ) , AV_FIFO_FLAG_AUTO_GROW ) ; if ( ! ifilter -> frame_queue ) report_and_exit ( AVERROR ( ENOMEM ) ) ; GROW_ARRAY ( ist -> filters , ist -> nb_filters ) ; ist -> filters [ ist -> nb_filters - 1 ] = ifilter ; GROW_ARRAY ( filtergraphs , nb_filtergraphs ) ; filtergraphs [ nb_filtergraphs - 1 ] = fg ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@describe_filter_link": "static char * describe_filter_link ( FilterGraph * fg , AVFilterInOut * inout , int in ) { AVFilterContext * ctx = inout -> filter_ctx ; AVFilterPad * pads = in ? ctx -> input_pads : ctx -> output_pads ; int nb_pads = in ? ctx -> nb_inputs : ctx -> nb_outputs ; char * res ; if ( nb_pads > 1 ) res = av_strdup ( ctx -> filter -> name ) ; else res = av_asprintf ( \"%s:%s\" , ctx -> filter -> name , avfilter_pad_get_name ( pads , inout -> pad_idx ) ) ; if ( ! res ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return res ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@init_input_filter": "static void init_input_filter ( FilterGraph * fg , AVFilterInOut * in ) { InputStream * ist = NULL ; enum AVMediaType type = avfilter_pad_get_type ( in -> filter_ctx -> input_pads , in -> pad_idx ) ; InputFilter * ifilter ; int i ; // TODO: support other filter types if ( type != AVMEDIA_TYPE_VIDEO && type != AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_FATAL , \"Only video and audio filters supported \" \"currently.\\n\" ) ; exit_program ( 1 ) ; } if ( in -> name ) { AVFormatContext * s ; AVStream * st = NULL ; char * p ; int file_idx = strtol ( in -> name , & p , 0 ) ; if ( file_idx < 0 || file_idx >= nb_input_files ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid file index %d in filtergraph description %s.\\n\" , file_idx , fg -> graph_desc ) ; exit_program ( 1 ) ; } s = input_files [ file_idx ] -> ctx ; for ( i = 0 ; i < s -> nb_streams ; i ++ ) { enum AVMediaType stream_type = s -> streams [ i ] -> codecpar -> codec_type ; if ( stream_type != type && ! ( stream_type == AVMEDIA_TYPE_SUBTITLE && type == AVMEDIA_TYPE_VIDEO /* sub2video hack */ ) ) continue ; if ( check_stream_specifier ( s , s -> streams [ i ] , * p == ':' ? p + 1 : p ) == 1 ) { st = s -> streams [ i ] ; break ; } } if ( ! st ) { av_log ( NULL , AV_LOG_FATAL , \"Stream specifier '%s' in filtergraph description %s \" \"matches no streams.\\n\" , p , fg -> graph_desc ) ; exit_program ( 1 ) ; } ist = input_files [ file_idx ] -> streams [ st -> index ] ; if ( ist -> user_set_discard == AVDISCARD_ALL ) { av_log ( NULL , AV_LOG_FATAL , \"Stream specifier '%s' in filtergraph description %s \" \"matches a disabled input stream.\\n\" , p , fg -> graph_desc ) ; exit_program ( 1 ) ; } } else { /* find the first unused stream of corresponding type */ for ( ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) { if ( ist -> user_set_discard == AVDISCARD_ALL ) continue ; if ( ist -> dec_ctx -> codec_type == type && ist -> discard ) break ; } if ( ! ist ) { av_log ( NULL , AV_LOG_FATAL , \"Cannot find a matching stream for \" \"unlabeled input pad %d on filter %s\\n\" , in -> pad_idx , in -> filter_ctx -> name ) ; exit_program ( 1 ) ; } } av_assert0 ( ist ) ; ist -> discard = 0 ; ist -> decoding_needed |= DECODING_FOR_FILTER ; ist -> processing_needed = 1 ; ist -> st -> discard = AVDISCARD_NONE ; ifilter = ALLOC_ARRAY_ELEM ( fg -> inputs , fg -> nb_inputs ) ; ifilter -> ist = ist ; ifilter -> graph = fg ; ifilter -> format = - 1 ; ifilter -> type = ist -> st -> codecpar -> codec_type ; ifilter -> name = describe_filter_link ( fg , in , 1 ) ; ifilter -> frame_queue = av_fifo_alloc2 ( 8 , sizeof ( AVFrame * ) , AV_FIFO_FLAG_AUTO_GROW ) ; if ( ! ifilter -> frame_queue ) report_and_exit ( AVERROR ( ENOMEM ) ) ; GROW_ARRAY ( ist -> filters , ist -> nb_filters ) ; ist -> filters [ ist -> nb_filters - 1 ] = ifilter ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@read_binary": "static int read_binary ( const char * path , uint8_t * * data , int * len ) { AVIOContext * io = NULL ; int64_t fsize ; int ret ; * data = NULL ; * len = 0 ; ret = avio_open2 ( & io , path , AVIO_FLAG_READ , & int_cb , NULL ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot open file '%s': %s\\n\" , path , av_err2str ( ret ) ) ; return ret ; } fsize = avio_size ( io ) ; if ( fsize < 0 || fsize > INT_MAX ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot obtain size of file %s\\n\" , path ) ; ret = AVERROR ( EIO ) ; goto fail ; } * data = av_malloc ( fsize ) ; if ( ! * data ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } ret = avio_read ( io , * data , fsize ) ; if ( ret != fsize ) { av_log ( NULL , AV_LOG_ERROR , \"Error reading file %s\\n\" , path ) ; ret = ret < 0 ? ret : AVERROR ( EIO ) ; goto fail ; } * len = fsize ; return 0 ; fail : avio_close ( io ) ; av_freep ( data ) ; * len = 0 ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@filter_opt_apply": "static int filter_opt_apply ( AVFilterContext * f , const char * key , const char * val ) { const AVOption * o = NULL ; int ret ; ret = av_opt_set ( f , key , val , AV_OPT_SEARCH_CHILDREN ) ; if ( ret >= 0 ) return 0 ; if ( ret == AVERROR_OPTION_NOT_FOUND && key [ 0 ] == '/' ) o = av_opt_find ( f , key + 1 , NULL , 0 , AV_OPT_SEARCH_CHILDREN ) ; if ( ! o ) goto err_apply ; // key is a valid option name prefixed with '/' // interpret value as a path from which to load the actual option value key ++ ; if ( o -> type == AV_OPT_TYPE_BINARY ) { uint8_t * data ; int len ; ret = read_binary ( val , & data , & len ) ; if ( ret < 0 ) goto err_load ; ret = av_opt_set_bin ( f , key , data , len , AV_OPT_SEARCH_CHILDREN ) ; av_freep ( & data ) ; } else { char * data = file_read ( val ) ; if ( ! data ) { ret = AVERROR ( EIO ) ; goto err_load ; } ret = av_opt_set ( f , key , data , AV_OPT_SEARCH_CHILDREN ) ; av_freep ( & data ) ; } if ( ret < 0 ) goto err_apply ; return 0 ; err_apply : av_log ( NULL , AV_LOG_ERROR , \"Error applying option '%s' to filter '%s': %s\\n\" , key , f -> filter -> name , av_err2str ( ret ) ) ; return ret ; err_load : av_log ( NULL , AV_LOG_ERROR , \"Error loading value for option '%s' from file '%s'\\n\" , key , val ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@graph_opts_apply": "static int graph_opts_apply ( AVFilterGraphSegment * seg ) { for ( size_t i = 0 ; i < seg -> nb_chains ; i ++ ) { AVFilterChain * ch = seg -> chains [ i ] ; for ( size_t j = 0 ; j < ch -> nb_filters ; j ++ ) { AVFilterParams * p = ch -> filters [ j ] ; const AVDictionaryEntry * e = NULL ; av_assert0 ( p -> filter ) ; while ( ( e = av_dict_iterate ( p -> opts , e ) ) ) { int ret = filter_opt_apply ( p -> filter , e -> key , e -> value ) ; if ( ret < 0 ) return ret ; } av_dict_free ( & p -> opts ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@graph_parse": "static int graph_parse ( AVFilterGraph * graph , const char * desc , AVFilterInOut * * inputs , AVFilterInOut * * outputs ) { AVFilterGraphSegment * seg ; int ret ; ret = avfilter_graph_segment_parse ( graph , desc , 0 , & seg ) ; if ( ret < 0 ) return ret ; ret = avfilter_graph_segment_create_filters ( seg , 0 ) ; if ( ret < 0 ) goto fail ; ret = graph_opts_apply ( seg ) ; if ( ret < 0 ) goto fail ; ret = avfilter_graph_segment_apply ( seg , 0 , inputs , outputs ) ; fail : avfilter_graph_segment_free ( & seg ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@init_complex_filtergraph": "int init_complex_filtergraph ( FilterGraph * fg ) { AVFilterInOut * inputs , * outputs , * cur ; AVFilterGraph * graph ; int ret = 0 ; /* this graph is only used for determining the kinds of inputs\n     * and outputs we have, and is discarded on exit from this function */ graph = avfilter_graph_alloc ( ) ; if ( ! graph ) return AVERROR ( ENOMEM ) ; graph -> nb_threads = 1 ; ret = graph_parse ( graph , fg -> graph_desc , & inputs , & outputs ) ; if ( ret < 0 ) goto fail ; for ( cur = inputs ; cur ; cur = cur -> next ) init_input_filter ( fg , cur ) ; for ( cur = outputs ; cur ; ) { OutputFilter * const ofilter = ALLOC_ARRAY_ELEM ( fg -> outputs , fg -> nb_outputs ) ; ofilter -> graph = fg ; ofilter -> out_tmp = cur ; ofilter -> type = avfilter_pad_get_type ( cur -> filter_ctx -> output_pads , cur -> pad_idx ) ; ofilter -> name = describe_filter_link ( fg , cur , 0 ) ; cur = cur -> next ; ofilter -> out_tmp -> next = NULL ; } fail : avfilter_inout_free ( & inputs ) ; avfilter_graph_free ( & graph ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@insert_trim": "static int insert_trim ( int64_t start_time , int64_t duration , AVFilterContext * * last_filter , int * pad_idx , const char * filter_name ) { AVFilterGraph * graph = ( * last_filter ) -> graph ; AVFilterContext * ctx ; const AVFilter * trim ; enum AVMediaType type = avfilter_pad_get_type ( ( * last_filter ) -> output_pads , * pad_idx ) ; const char * name = ( type == AVMEDIA_TYPE_VIDEO ) ? \"trim\" : \"atrim\" ; int ret = 0 ; if ( duration == INT64_MAX && start_time == AV_NOPTS_VALUE ) return 0 ; trim = avfilter_get_by_name ( name ) ; if ( ! trim ) { av_log ( NULL , AV_LOG_ERROR , \"%s filter not present, cannot limit \" \"recording time.\\n\" , name ) ; return AVERROR_FILTER_NOT_FOUND ; } ctx = avfilter_graph_alloc_filter ( graph , trim , filter_name ) ; if ( ! ctx ) return AVERROR ( ENOMEM ) ; if ( duration != INT64_MAX ) { ret = av_opt_set_int ( ctx , \"durationi\" , duration , AV_OPT_SEARCH_CHILDREN ) ; } if ( ret >= 0 && start_time != AV_NOPTS_VALUE ) { ret = av_opt_set_int ( ctx , \"starti\" , start_time , AV_OPT_SEARCH_CHILDREN ) ; } if ( ret < 0 ) { av_log ( ctx , AV_LOG_ERROR , \"Error configuring the %s filter\" , name ) ; return ret ; } ret = avfilter_init_str ( ctx , NULL ) ; if ( ret < 0 ) return ret ; ret = avfilter_link ( * last_filter , * pad_idx , ctx , 0 ) ; if ( ret < 0 ) return ret ; * last_filter = ctx ; * pad_idx = 0 ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@insert_filter": "static int insert_filter ( AVFilterContext * * last_filter , int * pad_idx , const char * filter_name , const char * args ) { AVFilterGraph * graph = ( * last_filter ) -> graph ; AVFilterContext * ctx ; int ret ; ret = avfilter_graph_create_filter ( & ctx , avfilter_get_by_name ( filter_name ) , filter_name , args , NULL , graph ) ; if ( ret < 0 ) return ret ; ret = avfilter_link ( * last_filter , * pad_idx , ctx , 0 ) ; if ( ret < 0 ) return ret ; * last_filter = ctx ; * pad_idx = 0 ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@configure_output_video_filter": "static int configure_output_video_filter ( FilterGraph * fg , OutputFilter * ofilter , AVFilterInOut * out ) { OutputStream * ost = ofilter -> ost ; OutputFile * of = output_files [ ost -> file_index ] ; AVFilterContext * last_filter = out -> filter_ctx ; AVBPrint bprint ; int pad_idx = out -> pad_idx ; int ret ; const char * pix_fmts ; char name [ 255 ] ; snprintf ( name , sizeof ( name ) , \"out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = avfilter_graph_create_filter ( & ofilter -> filter , avfilter_get_by_name ( \"buffersink\" ) , name , NULL , NULL , fg -> graph ) ; if ( ret < 0 ) return ret ; if ( ( ofilter -> width || ofilter -> height ) && ofilter -> ost -> autoscale ) { char args [ 255 ] ; AVFilterContext * filter ; const AVDictionaryEntry * e = NULL ; snprintf ( args , sizeof ( args ) , \"%d:%d\" , ofilter -> width , ofilter -> height ) ; while ( ( e = av_dict_iterate ( ost -> sws_dict , e ) ) ) { av_strlcatf ( args , sizeof ( args ) , \":%s=%s\" , e -> key , e -> value ) ; } snprintf ( name , sizeof ( name ) , \"scaler_out_%d_%d\" , ost -> file_index , ost -> index ) ; if ( ( ret = avfilter_graph_create_filter ( & filter , avfilter_get_by_name ( \"scale\" ) , name , args , NULL , fg -> graph ) ) < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , pad_idx , filter , 0 ) ) < 0 ) return ret ; last_filter = filter ; pad_idx = 0 ; } av_bprint_init ( & bprint , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; if ( ( pix_fmts = choose_pix_fmts ( ofilter , & bprint ) ) ) { AVFilterContext * filter ; ret = avfilter_graph_create_filter ( & filter , avfilter_get_by_name ( \"format\" ) , \"format\" , pix_fmts , NULL , fg -> graph ) ; av_bprint_finalize ( & bprint , NULL ) ; if ( ret < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , pad_idx , filter , 0 ) ) < 0 ) return ret ; last_filter = filter ; pad_idx = 0 ; } if ( ost -> frame_rate . num && 0 ) { AVFilterContext * fps ; char args [ 255 ] ; snprintf ( args , sizeof ( args ) , \"fps=%d/%d\" , ost -> frame_rate . num , ost -> frame_rate . den ) ; snprintf ( name , sizeof ( name ) , \"fps_out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = avfilter_graph_create_filter ( & fps , avfilter_get_by_name ( \"fps\" ) , name , args , NULL , fg -> graph ) ; if ( ret < 0 ) return ret ; ret = avfilter_link ( last_filter , pad_idx , fps , 0 ) ; if ( ret < 0 ) return ret ; last_filter = fps ; pad_idx = 0 ; } snprintf ( name , sizeof ( name ) , \"trim_out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = insert_trim ( of -> start_time , of -> recording_time , & last_filter , & pad_idx , name ) ; if ( ret < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , pad_idx , ofilter -> filter , 0 ) ) < 0 ) return ret ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@configure_output_audio_filter": "static int configure_output_audio_filter ( FilterGraph * fg , OutputFilter * ofilter , AVFilterInOut * out ) { OutputStream * ost = ofilter -> ost ; OutputFile * of = output_files [ ost -> file_index ] ; AVCodecContext * codec = ost -> enc_ctx ; AVFilterContext * last_filter = out -> filter_ctx ; int pad_idx = out -> pad_idx ; AVBPrint args ; char name [ 255 ] ; int ret ; snprintf ( name , sizeof ( name ) , \"out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = avfilter_graph_create_filter ( & ofilter -> filter , avfilter_get_by_name ( \"abuffersink\" ) , name , NULL , NULL , fg -> graph ) ; if ( ret < 0 ) return ret ; if ( ( ret = av_opt_set_int ( ofilter -> filter , \"all_channel_counts\" , 1 , AV_OPT_SEARCH_CHILDREN ) ) < 0 ) return ret ; # define AUTO_INSERT_FILTER ( opt_name , filter_name , arg ) do { AVFilterContext * filt_ctx ; av_log ( NULL , AV_LOG_INFO , opt_name \" is forwarded to lavfi \" \"similarly to -af \" filter_name \"=%s.\\n\" , arg ) ; ret = avfilter_graph_create_filter ( & filt_ctx , avfilter_get_by_name ( filter_name ) , filter_name , arg , NULL , fg -> graph ) ; if ( ret < 0 ) goto fail ; ret = avfilter_link ( last_filter , pad_idx , filt_ctx , 0 ) ; if ( ret < 0 ) goto fail ; last_filter = filt_ctx ; pad_idx = 0 ; \\\n} while ( 0 ) av_bprint_init ( & args , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; # if FFMPEG_OPT_MAP_CHANNEL if ( ost -> audio_channels_mapped ) { AVChannelLayout mapped_layout = { 0 } ; int i ; av_channel_layout_default ( & mapped_layout , ost -> audio_channels_mapped ) ; av_channel_layout_describe_bprint ( & mapped_layout , & args ) ; for ( i = 0 ; i < ost -> audio_channels_mapped ; i ++ ) if ( ost -> audio_channels_map [ i ] != - 1 ) av_bprintf ( & args , \"|c%d=c%d\" , i , ost -> audio_channels_map [ i ] ) ; AUTO_INSERT_FILTER ( \"-map_channel\" , \"pan\" , args . str ) ; av_bprint_clear ( & args ) ; } # endif if ( codec -> ch_layout . order == AV_CHANNEL_ORDER_UNSPEC ) av_channel_layout_default ( & codec -> ch_layout , codec -> ch_layout . nb_channels ) ; choose_sample_fmts ( ofilter , & args ) ; choose_sample_rates ( ofilter , & args ) ; choose_channel_layouts ( ofilter , & args ) ; if ( ! av_bprint_is_complete ( & args ) ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } if ( args . len ) { AVFilterContext * format ; snprintf ( name , sizeof ( name ) , \"format_out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = avfilter_graph_create_filter ( & format , avfilter_get_by_name ( \"aformat\" ) , name , args . str , NULL , fg -> graph ) ; if ( ret < 0 ) goto fail ; ret = avfilter_link ( last_filter , pad_idx , format , 0 ) ; if ( ret < 0 ) goto fail ; last_filter = format ; pad_idx = 0 ; } if ( ost -> apad && of -> shortest ) { int i ; for ( i = 0 ; i < of -> nb_streams ; i ++ ) if ( of -> streams [ i ] -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) break ; if ( i < of -> nb_streams ) { AUTO_INSERT_FILTER ( \"-apad\" , \"apad\" , ost -> apad ) ; } } snprintf ( name , sizeof ( name ) , \"trim for output stream %d:%d\" , ost -> file_index , ost -> index ) ; ret = insert_trim ( of -> start_time , of -> recording_time , & last_filter , & pad_idx , name ) ; if ( ret < 0 ) goto fail ; if ( ( ret = avfilter_link ( last_filter , pad_idx , ofilter -> filter , 0 ) ) < 0 ) goto fail ; fail : av_bprint_finalize ( & args , NULL ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@configure_output_filter": "int configure_output_filter ( FilterGraph * fg , OutputFilter * ofilter , AVFilterInOut * out ) { if ( ! ofilter -> ost ) { av_log ( NULL , AV_LOG_FATAL , \"Filter %s has an unconnected output\\n\" , ofilter -> name ) ; exit_program ( 1 ) ; } switch ( avfilter_pad_get_type ( out -> filter_ctx -> output_pads , out -> pad_idx ) ) { case AVMEDIA_TYPE_VIDEO : return configure_output_video_filter ( fg , ofilter , out ) ; case AVMEDIA_TYPE_AUDIO : return configure_output_audio_filter ( fg , ofilter , out ) ; default : av_assert0 ( 0 ) ; return 0 ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@check_filter_outputs": "void check_filter_outputs ( void ) { int i ; for ( i = 0 ; i < nb_filtergraphs ; i ++ ) { int n ; for ( n = 0 ; n < filtergraphs [ i ] -> nb_outputs ; n ++ ) { OutputFilter * output = filtergraphs [ i ] -> outputs [ n ] ; if ( ! output -> ost ) { av_log ( NULL , AV_LOG_FATAL , \"Filter %s has an unconnected output\\n\" , output -> name ) ; exit_program ( 1 ) ; } } } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@sub2video_prepare": "static int sub2video_prepare ( InputStream * ist , InputFilter * ifilter ) { AVFormatContext * avf = input_files [ ist -> file_index ] -> ctx ; int i , w , h ; /* Compute the size of the canvas for the subtitles stream.\n       If the subtitles codecpar has set a size, use it. Otherwise use the\n       maximum dimensions of the video streams in the same file. */ w = ifilter -> width ; h = ifilter -> height ; if ( ! ( w && h ) ) { for ( i = 0 ; i < avf -> nb_streams ; i ++ ) { if ( avf -> streams [ i ] -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { w = FFMAX ( w , avf -> streams [ i ] -> codecpar -> width ) ; h = FFMAX ( h , avf -> streams [ i ] -> codecpar -> height ) ; } } if ( ! ( w && h ) ) { w = FFMAX ( w , 720 ) ; h = FFMAX ( h , 576 ) ; } av_log ( avf , AV_LOG_INFO , \"sub2video: using %dx%d canvas\\n\" , w , h ) ; } ist -> sub2video . w = ifilter -> width = w ; ist -> sub2video . h = ifilter -> height = h ; ifilter -> width = ist -> dec_ctx -> width ? ist -> dec_ctx -> width : ist -> sub2video . w ; ifilter -> height = ist -> dec_ctx -> height ? ist -> dec_ctx -> height : ist -> sub2video . h ; /* rectangles are AV_PIX_FMT_PAL8, but we have no guarantee that the\n       palettes for all rectangles are identical or compatible */ ifilter -> format = AV_PIX_FMT_RGB32 ; ist -> sub2video . frame = av_frame_alloc ( ) ; if ( ! ist -> sub2video . frame ) return AVERROR ( ENOMEM ) ; ist -> sub2video . last_pts = INT64_MIN ; ist -> sub2video . end_pts = INT64_MIN ; /* sub2video structure has been (re-)initialized.\n       Mark it as such so that the system will be\n       initialized with the first received heartbeat. */ ist -> sub2video . initialize = 1 ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@configure_input_video_filter": "static int configure_input_video_filter ( FilterGraph * fg , InputFilter * ifilter , AVFilterInOut * in ) { AVFilterContext * last_filter ; const AVFilter * buffer_filt = avfilter_get_by_name ( \"buffer\" ) ; const AVPixFmtDescriptor * desc ; InputStream * ist = ifilter -> ist ; InputFile * f = input_files [ ist -> file_index ] ; AVRational tb = ist -> framerate . num ? av_inv_q ( ist -> framerate ) : ist -> st -> time_base ; AVRational fr = ist -> framerate ; AVRational sar ; AVBPrint args ; char name [ 255 ] ; int ret , pad_idx = 0 ; int64_t tsoffset = 0 ; AVBufferSrcParameters * par = av_buffersrc_parameters_alloc ( ) ; if ( ! par ) return AVERROR ( ENOMEM ) ; memset ( par , 0 , sizeof ( * par ) ) ; par -> format = AV_PIX_FMT_NONE ; if ( ist -> dec_ctx -> codec_type == AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot connect video filter to audio input\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } if ( ! fr . num ) fr = ist -> framerate_guessed ; if ( ist -> dec_ctx -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { ret = sub2video_prepare ( ist , ifilter ) ; if ( ret < 0 ) goto fail ; } sar = ifilter -> sample_aspect_ratio ; if ( ! sar . den ) sar = ( AVRational ) { 0 , 1 } ; av_bprint_init ( & args , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; av_bprintf ( & args , \"video_size=%dx%d:pix_fmt=%d:time_base=%d/%d:\" \"pixel_aspect=%d/%d\" , ifilter -> width , ifilter -> height , ifilter -> format , tb . num , tb . den , sar . num , sar . den ) ; if ( fr . num && fr . den ) av_bprintf ( & args , \":frame_rate=%d/%d\" , fr . num , fr . den ) ; snprintf ( name , sizeof ( name ) , \"graph %d input from stream %d:%d\" , fg -> index , ist -> file_index , ist -> st -> index ) ; if ( ( ret = avfilter_graph_create_filter ( & ifilter -> filter , buffer_filt , name , args . str , NULL , fg -> graph ) ) < 0 ) goto fail ; par -> hw_frames_ctx = ifilter -> hw_frames_ctx ; ret = av_buffersrc_parameters_set ( ifilter -> filter , par ) ; if ( ret < 0 ) goto fail ; av_freep ( & par ) ; last_filter = ifilter -> filter ; desc = av_pix_fmt_desc_get ( ifilter -> format ) ; av_assert0 ( desc ) ; // TODO: insert hwaccel enabled filters like transpose_vaapi into the graph if ( ist -> autorotate && ! ( desc -> flags & AV_PIX_FMT_FLAG_HWACCEL ) ) { int32_t * displaymatrix = ifilter -> displaymatrix ; double theta ; if ( ! displaymatrix ) displaymatrix = ( int32_t * ) av_stream_get_side_data ( ist -> st , AV_PKT_DATA_DISPLAYMATRIX , NULL ) ; theta = get_rotation ( displaymatrix ) ; if ( fabs ( theta - 90 ) < 1.0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"transpose\" , displaymatrix [ 3 ] > 0 ? \"cclock_flip\" : \"clock\" ) ; } else if ( fabs ( theta - 180 ) < 1.0 ) { if ( displaymatrix [ 0 ] < 0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"hflip\" , NULL ) ; if ( ret < 0 ) return ret ; } if ( displaymatrix [ 4 ] < 0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"vflip\" , NULL ) ; } } else if ( fabs ( theta - 270 ) < 1.0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"transpose\" , displaymatrix [ 3 ] < 0 ? \"clock_flip\" : \"cclock\" ) ; } else if ( fabs ( theta ) > 1.0 ) { char rotate_buf [ 64 ] ; snprintf ( rotate_buf , sizeof ( rotate_buf ) , \"%f*PI/180\" , theta ) ; ret = insert_filter ( & last_filter , & pad_idx , \"rotate\" , rotate_buf ) ; } else if ( fabs ( theta ) < 1.0 ) { if ( displaymatrix && displaymatrix [ 4 ] < 0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"vflip\" , NULL ) ; } } if ( ret < 0 ) return ret ; } snprintf ( name , sizeof ( name ) , \"trim_in_%d_%d\" , ist -> file_index , ist -> st -> index ) ; if ( copy_ts ) { tsoffset = f -> start_time == AV_NOPTS_VALUE ? 0 : f -> start_time ; if ( ! start_at_zero && f -> ctx -> start_time != AV_NOPTS_VALUE ) tsoffset += f -> ctx -> start_time ; } ret = insert_trim ( ( ( f -> start_time == AV_NOPTS_VALUE ) || ! f -> accurate_seek ) ? AV_NOPTS_VALUE : tsoffset , f -> recording_time , & last_filter , & pad_idx , name ) ; if ( ret < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , 0 , in -> filter_ctx , in -> pad_idx ) ) < 0 ) return ret ; return 0 ; fail : av_freep ( & par ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@configure_input_audio_filter": "static int configure_input_audio_filter ( FilterGraph * fg , InputFilter * ifilter , AVFilterInOut * in ) { AVFilterContext * last_filter ; const AVFilter * abuffer_filt = avfilter_get_by_name ( \"abuffer\" ) ; InputStream * ist = ifilter -> ist ; InputFile * f = input_files [ ist -> file_index ] ; AVBPrint args ; char name [ 255 ] ; int ret , pad_idx = 0 ; int64_t tsoffset = 0 ; if ( ist -> dec_ctx -> codec_type != AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot connect audio filter to non audio input\\n\" ) ; return AVERROR ( EINVAL ) ; } av_bprint_init ( & args , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; av_bprintf ( & args , \"time_base=%d/%d:sample_rate=%d:sample_fmt=%s\" , 1 , ifilter -> sample_rate , ifilter -> sample_rate , av_get_sample_fmt_name ( ifilter -> format ) ) ; if ( av_channel_layout_check ( & ifilter -> ch_layout ) && ifilter -> ch_layout . order != AV_CHANNEL_ORDER_UNSPEC ) { av_bprintf ( & args , \":channel_layout=\" ) ; av_channel_layout_describe_bprint ( & ifilter -> ch_layout , & args ) ; } else av_bprintf ( & args , \":channels=%d\" , ifilter -> ch_layout . nb_channels ) ; snprintf ( name , sizeof ( name ) , \"graph_%d_in_%d_%d\" , fg -> index , ist -> file_index , ist -> st -> index ) ; if ( ( ret = avfilter_graph_create_filter ( & ifilter -> filter , abuffer_filt , name , args . str , NULL , fg -> graph ) ) < 0 ) return ret ; last_filter = ifilter -> filter ; # define AUTO_INSERT_FILTER_INPUT ( opt_name , filter_name , arg ) do { AVFilterContext * filt_ctx ; av_log ( NULL , AV_LOG_INFO , opt_name \" is forwarded to lavfi \" \"similarly to -af \" filter_name \"=%s.\\n\" , arg ) ; snprintf ( name , sizeof ( name ) , \"graph_%d_%s_in_%d_%d\" , fg -> index , filter_name , ist -> file_index , ist -> st -> index ) ; ret = avfilter_graph_create_filter ( & filt_ctx , avfilter_get_by_name ( filter_name ) , name , arg , NULL , fg -> graph ) ; if ( ret < 0 ) return ret ; ret = avfilter_link ( last_filter , 0 , filt_ctx , 0 ) ; if ( ret < 0 ) return ret ; last_filter = filt_ctx ; \\\n} while ( 0 ) snprintf ( name , sizeof ( name ) , \"trim for input stream %d:%d\" , ist -> file_index , ist -> st -> index ) ; if ( copy_ts ) { tsoffset = f -> start_time == AV_NOPTS_VALUE ? 0 : f -> start_time ; if ( ! start_at_zero && f -> ctx -> start_time != AV_NOPTS_VALUE ) tsoffset += f -> ctx -> start_time ; } ret = insert_trim ( ( ( f -> start_time == AV_NOPTS_VALUE ) || ! f -> accurate_seek ) ? AV_NOPTS_VALUE : tsoffset , f -> recording_time , & last_filter , & pad_idx , name ) ; if ( ret < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , 0 , in -> filter_ctx , in -> pad_idx ) ) < 0 ) return ret ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@configure_input_filter": "static int configure_input_filter ( FilterGraph * fg , InputFilter * ifilter , AVFilterInOut * in ) { if ( ! ifilter -> ist -> dec ) { av_log ( NULL , AV_LOG_ERROR , \"No decoder for stream #%d:%d, filtering impossible\\n\" , ifilter -> ist -> file_index , ifilter -> ist -> st -> index ) ; return AVERROR_DECODER_NOT_FOUND ; } switch ( avfilter_pad_get_type ( in -> filter_ctx -> input_pads , in -> pad_idx ) ) { case AVMEDIA_TYPE_VIDEO : return configure_input_video_filter ( fg , ifilter , in ) ; case AVMEDIA_TYPE_AUDIO : return configure_input_audio_filter ( fg , ifilter , in ) ; default : av_assert0 ( 0 ) ; return 0 ; } }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@cleanup_filtergraph": "static void cleanup_filtergraph ( FilterGraph * fg ) { int i ; for ( i = 0 ; i < fg -> nb_outputs ; i ++ ) fg -> outputs [ i ] -> filter = ( AVFilterContext * ) NULL ; for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) fg -> inputs [ i ] -> filter = ( AVFilterContext * ) NULL ; avfilter_graph_free ( & fg -> graph ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@filter_is_buffersrc": "static int filter_is_buffersrc ( const AVFilterContext * f ) { return f -> nb_inputs == 0 && ( ! strcmp ( f -> filter -> name , \"buffer\" ) || ! strcmp ( f -> filter -> name , \"abuffer\" ) ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@graph_is_meta": "static int graph_is_meta ( AVFilterGraph * graph ) { for ( unsigned i = 0 ; i < graph -> nb_filters ; i ++ ) { const AVFilterContext * f = graph -> filters [ i ] ; /* in addition to filters flagged as meta, also\n         * disregard sinks and buffersources (but not other sources,\n         * since they introduce data we are not aware of)\n         */ if ( ! ( ( f -> filter -> flags & AVFILTER_FLAG_METADATA_ONLY ) || f -> nb_outputs == 0 || filter_is_buffersrc ( f ) ) ) return 0 ; } return 1 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@configure_filtergraph": "int configure_filtergraph ( FilterGraph * fg ) { AVFilterInOut * inputs , * outputs , * cur ; int ret , i , simple = filtergraph_is_simple ( fg ) ; const char * graph_desc = simple ? fg -> outputs [ 0 ] -> ost -> avfilter : fg -> graph_desc ; cleanup_filtergraph ( fg ) ; if ( ! ( fg -> graph = avfilter_graph_alloc ( ) ) ) return AVERROR ( ENOMEM ) ; if ( simple ) { OutputStream * ost = fg -> outputs [ 0 ] -> ost ; if ( filter_nbthreads ) { ret = av_opt_set ( fg -> graph , \"threads\" , filter_nbthreads , 0 ) ; if ( ret < 0 ) goto fail ; } else { const AVDictionaryEntry * e = NULL ; e = av_dict_get ( ost -> encoder_opts , \"threads\" , NULL , 0 ) ; if ( e ) av_opt_set ( fg -> graph , \"threads\" , e -> value , 0 ) ; } if ( av_dict_count ( ost -> sws_dict ) ) { ret = av_dict_get_string ( ost -> sws_dict , & fg -> graph -> scale_sws_opts , '=' , ':' ) ; if ( ret < 0 ) goto fail ; } if ( av_dict_count ( ost -> swr_opts ) ) { char * args ; ret = av_dict_get_string ( ost -> swr_opts , & args , '=' , ':' ) ; if ( ret < 0 ) goto fail ; av_opt_set ( fg -> graph , \"aresample_swr_opts\" , args , 0 ) ; av_free ( args ) ; } } else { fg -> graph -> nb_threads = filter_complex_nbthreads ; } if ( ( ret = graph_parse ( fg -> graph , graph_desc , & inputs , & outputs ) ) < 0 ) goto fail ; ret = hw_device_setup_for_filter ( fg ) ; if ( ret < 0 ) goto fail ; if ( simple && ( ! inputs || inputs -> next || ! outputs || outputs -> next ) ) { const char * num_inputs ; const char * num_outputs ; if ( ! outputs ) { num_outputs = \"0\" ; } else if ( outputs -> next ) { num_outputs = \">1\" ; } else { num_outputs = \"1\" ; } if ( ! inputs ) { num_inputs = \"0\" ; } else if ( inputs -> next ) { num_inputs = \">1\" ; } else { num_inputs = \"1\" ; } av_log ( NULL , AV_LOG_ERROR , \"Simple filtergraph '%s' was expected \" \"to have exactly 1 input and 1 output.\" \" However, it had %s input(s) and %s output(s).\" \" Please adjust, or use a complex filtergraph (-filter_complex) instead.\\n\" , graph_desc , num_inputs , num_outputs ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } for ( cur = inputs , i = 0 ; cur ; cur = cur -> next , i ++ ) if ( ( ret = configure_input_filter ( fg , fg -> inputs [ i ] , cur ) ) < 0 ) { avfilter_inout_free ( & inputs ) ; avfilter_inout_free ( & outputs ) ; goto fail ; } avfilter_inout_free ( & inputs ) ; for ( cur = outputs , i = 0 ; cur ; cur = cur -> next , i ++ ) configure_output_filter ( fg , fg -> outputs [ i ] , cur ) ; avfilter_inout_free ( & outputs ) ; if ( ! auto_conversion_filters ) avfilter_graph_set_auto_convert ( fg -> graph , AVFILTER_AUTO_CONVERT_NONE ) ; if ( ( ret = avfilter_graph_config ( fg -> graph , NULL ) ) < 0 ) goto fail ; fg -> is_meta = graph_is_meta ( fg -> graph ) ; /* limit the lists of allowed formats to the ones selected, to\n     * make sure they stay the same if the filtergraph is reconfigured later */ for ( i = 0 ; i < fg -> nb_outputs ; i ++ ) { OutputFilter * ofilter = fg -> outputs [ i ] ; AVFilterContext * sink = ofilter -> filter ; ofilter -> format = av_buffersink_get_format ( sink ) ; ofilter -> width = av_buffersink_get_w ( sink ) ; ofilter -> height = av_buffersink_get_h ( sink ) ; ofilter -> sample_rate = av_buffersink_get_sample_rate ( sink ) ; av_channel_layout_uninit ( & ofilter -> ch_layout ) ; ret = av_buffersink_get_ch_layout ( sink , & ofilter -> ch_layout ) ; if ( ret < 0 ) goto fail ; } fg -> reconfiguration = 1 ; for ( i = 0 ; i < fg -> nb_outputs ; i ++ ) { OutputStream * ost = fg -> outputs [ i ] -> ost ; if ( ost -> enc_ctx -> codec_type == AVMEDIA_TYPE_AUDIO && ! ( ost -> enc_ctx -> codec -> capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE ) ) av_buffersink_set_frame_size ( ost -> filter -> filter , ost -> enc_ctx -> frame_size ) ; } for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) { AVFrame * tmp ; while ( av_fifo_read ( fg -> inputs [ i ] -> frame_queue , & tmp , 1 ) >= 0 ) { ret = av_buffersrc_add_frame ( fg -> inputs [ i ] -> filter , tmp ) ; av_frame_free ( & tmp ) ; if ( ret < 0 ) goto fail ; } } /* send the EOFs for the finished inputs */ for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) { if ( fg -> inputs [ i ] -> eof ) { ret = av_buffersrc_add_frame ( fg -> inputs [ i ] -> filter , NULL ) ; if ( ret < 0 ) goto fail ; } } /* process queued up subtitle packets */ for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) { InputStream * ist = fg -> inputs [ i ] -> ist ; if ( ist -> sub2video . sub_queue && ist -> sub2video . frame ) { AVSubtitle tmp ; while ( av_fifo_read ( ist -> sub2video . sub_queue , & tmp , 1 ) >= 0 ) { sub2video_update ( ist , INT64_MIN , & tmp ) ; avsubtitle_free ( & tmp ) ; } } } return 0 ; fail : cleanup_filtergraph ( fg ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@ifilter_parameters_from_frame": "int ifilter_parameters_from_frame ( InputFilter * ifilter , const AVFrame * frame ) { AVFrameSideData * sd ; int ret ; av_buffer_unref ( & ifilter -> hw_frames_ctx ) ; ifilter -> format = frame -> format ; ifilter -> width = frame -> width ; ifilter -> height = frame -> height ; ifilter -> sample_aspect_ratio = frame -> sample_aspect_ratio ; ifilter -> sample_rate = frame -> sample_rate ; ret = av_channel_layout_copy ( & ifilter -> ch_layout , & frame -> ch_layout ) ; if ( ret < 0 ) return ret ; av_freep ( & ifilter -> displaymatrix ) ; sd = av_frame_get_side_data ( frame , AV_FRAME_DATA_DISPLAYMATRIX ) ; if ( sd ) ifilter -> displaymatrix = av_memdup ( sd -> data , sizeof ( int32_t ) * 9 ) ; if ( frame -> hw_frames_ctx ) { ifilter -> hw_frames_ctx = av_buffer_ref ( frame -> hw_frames_ctx ) ; if ( ! ifilter -> hw_frames_ctx ) return AVERROR ( ENOMEM ) ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_filter.c@filtergraph_is_simple": "int filtergraph_is_simple ( FilterGraph * fg ) { return ! fg -> graph_desc ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@ms_from_ost": "MuxStream * ms_from_ost ( OutputStream * ost ) { return ( MuxStream * ) ost ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@mux_from_of": "static Muxer * mux_from_of ( OutputFile * of ) { return ( Muxer * ) of ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@filesize": "static int64_t filesize ( AVIOContext * pb ) { int64_t ret = - 1 ; if ( pb ) { ret = avio_size ( pb ) ; if ( ret <= 0 ) // FIXME improve avio_size() so it works with non seekable output too ret = avio_tell ( pb ) ; } return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@write_packet": "static int write_packet ( Muxer * mux , OutputStream * ost , AVPacket * pkt ) { MuxStream * ms = ms_from_ost ( ost ) ; AVFormatContext * s = mux -> fc ; AVStream * st = ost -> st ; int64_t fs ; uint64_t frame_num ; int ret ; fs = filesize ( s -> pb ) ; atomic_store ( & mux -> last_filesize , fs ) ; if ( fs >= mux -> limit_filesize ) { ret = AVERROR_EOF ; goto fail ; } if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && ost -> vsync_method == VSYNC_DROP ) pkt -> pts = pkt -> dts = AV_NOPTS_VALUE ; if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { if ( ost -> frame_rate . num && ost -> is_cfr ) { if ( pkt -> duration > 0 ) av_log ( ost , AV_LOG_WARNING , \"Overriding packet duration by frame rate, this should not happen\\n\" ) ; pkt -> duration = av_rescale_q ( 1 , av_inv_q ( ost -> frame_rate ) , pkt -> time_base ) ; } } av_packet_rescale_ts ( pkt , pkt -> time_base , ost -> st -> time_base ) ; pkt -> time_base = ost -> st -> time_base ; if ( ! ( s -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ) { if ( pkt -> dts != AV_NOPTS_VALUE && pkt -> pts != AV_NOPTS_VALUE && pkt -> dts > pkt -> pts ) { av_log ( s , AV_LOG_WARNING , \"Invalid DTS: %\" PRId64 \" PTS: %\" PRId64 \" in output stream %d:%d, replacing by guess\\n\" , pkt -> dts , pkt -> pts , ost -> file_index , ost -> st -> index ) ; pkt -> pts = pkt -> dts = pkt -> pts + pkt -> dts + ms -> last_mux_dts + 1 - FFMIN3 ( pkt -> pts , pkt -> dts , ms -> last_mux_dts + 1 ) - FFMAX3 ( pkt -> pts , pkt -> dts , ms -> last_mux_dts + 1 ) ; } if ( ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO || st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO || st -> codecpar -> codec_type == AVMEDIA_TYPE_SUBTITLE ) && pkt -> dts != AV_NOPTS_VALUE && ms -> last_mux_dts != AV_NOPTS_VALUE ) { int64_t max = ms -> last_mux_dts + ! ( s -> oformat -> flags & AVFMT_TS_NONSTRICT ) ; if ( pkt -> dts < max ) { int loglevel = max - pkt -> dts > 2 || st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ? AV_LOG_WARNING : AV_LOG_DEBUG ; if ( exit_on_error ) loglevel = AV_LOG_ERROR ; av_log ( s , loglevel , \"Non-monotonous DTS in output stream \" \"%d:%d; previous: %\" PRId64 \", current: %\" PRId64 \"; \" , ost -> file_index , ost -> st -> index , ms -> last_mux_dts , pkt -> dts ) ; if ( exit_on_error ) { ret = AVERROR ( EINVAL ) ; goto fail ; } av_log ( s , loglevel , \"changing to %\" PRId64 \". This may result \" \"in incorrect timestamps in the output file.\\n\" , max ) ; if ( pkt -> pts >= pkt -> dts ) pkt -> pts = FFMAX ( pkt -> pts , max ) ; pkt -> dts = max ; } } } ms -> last_mux_dts = pkt -> dts ; ost -> data_size_mux += pkt -> size ; frame_num = atomic_fetch_add ( & ost -> packets_written , 1 ) ; pkt -> stream_index = ost -> index ; if ( debug_ts ) { av_log ( ost , AV_LOG_INFO , \"muxer <- type:%s \" \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s size:%d\\n\" , av_get_media_type_string ( st -> codecpar -> codec_type ) , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & ost -> st -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & ost -> st -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & ost -> st -> time_base ) , pkt -> size ) ; } if ( ms -> stats . io ) enc_stats_write ( ost , & ms -> stats , NULL , pkt , frame_num ) ; ret = av_interleaved_write_frame ( s , pkt ) ; if ( ret < 0 ) { print_error ( \"av_interleaved_write_frame()\" , ret ) ; goto fail ; } return 0 ; fail : av_packet_unref ( pkt ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@sync_queue_process": "static int sync_queue_process ( Muxer * mux , OutputStream * ost , AVPacket * pkt , int * stream_eof ) { OutputFile * of = & mux -> of ; if ( ost -> sq_idx_mux >= 0 ) { int ret = sq_send ( mux -> sq_mux , ost -> sq_idx_mux , SQPKT ( pkt ) ) ; if ( ret < 0 ) { if ( ret == AVERROR_EOF ) * stream_eof = 1 ; return ret ; } while ( 1 ) { ret = sq_receive ( mux -> sq_mux , - 1 , SQPKT ( mux -> sq_pkt ) ) ; if ( ret < 0 ) return ( ret == AVERROR_EOF || ret == AVERROR ( EAGAIN ) ) ? 0 : ret ; ret = write_packet ( mux , of -> streams [ ret ] , mux -> sq_pkt ) ; if ( ret < 0 ) return ret ; } } else if ( pkt ) return write_packet ( mux , ost , pkt ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@thread_set_name": "static void thread_set_name ( OutputFile * of ) { char name [ 16 ] ; snprintf ( name , sizeof ( name ) , \"mux%d:%s\" , of -> index , of -> format -> name ) ; ff_thread_setname ( name ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@muxer_thread": "static void * muxer_thread ( void * arg ) { Muxer * mux = arg ; OutputFile * of = & mux -> of ; AVPacket * pkt = NULL ; int ret = 0 ; pkt = av_packet_alloc ( ) ; if ( ! pkt ) { ret = AVERROR ( ENOMEM ) ; goto finish ; } thread_set_name ( of ) ; while ( 1 ) { OutputStream * ost ; int stream_idx , stream_eof = 0 ; ret = tq_receive ( mux -> tq , & stream_idx , pkt ) ; if ( stream_idx < 0 ) { av_log ( mux , AV_LOG_VERBOSE , \"All streams finished\\n\" ) ; ret = 0 ; break ; } ost = of -> streams [ stream_idx ] ; ret = sync_queue_process ( mux , ost , ret < 0 ? NULL : pkt , & stream_eof ) ; av_packet_unref ( pkt ) ; if ( ret == AVERROR_EOF && stream_eof ) tq_receive_finish ( mux -> tq , stream_idx ) ; else if ( ret < 0 ) { av_log ( mux , AV_LOG_ERROR , \"Error muxing a packet\\n\" ) ; break ; } } finish : av_packet_free ( & pkt ) ; for ( unsigned int i = 0 ; i < mux -> fc -> nb_streams ; i ++ ) tq_receive_finish ( mux -> tq , i ) ; av_log ( mux , AV_LOG_VERBOSE , \"Terminating muxer thread\\n\" ) ; return ( void * ) ( intptr_t ) ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@thread_submit_packet": "static int thread_submit_packet ( Muxer * mux , OutputStream * ost , AVPacket * pkt ) { int ret = 0 ; if ( ! pkt || ost -> finished & MUXER_FINISHED ) goto finish ; ret = tq_send ( mux -> tq , ost -> index , pkt ) ; if ( ret < 0 ) goto finish ; return 0 ; finish : if ( pkt ) av_packet_unref ( pkt ) ; ost -> finished |= MUXER_FINISHED ; tq_send_finish ( mux -> tq , ost -> index ) ; return ret == AVERROR_EOF ? 0 : ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@queue_packet": "static int queue_packet ( Muxer * mux , OutputStream * ost , AVPacket * pkt ) { MuxStream * ms = ms_from_ost ( ost ) ; AVPacket * tmp_pkt = NULL ; int ret ; if ( ! av_fifo_can_write ( ms -> muxing_queue ) ) { size_t cur_size = av_fifo_can_read ( ms -> muxing_queue ) ; size_t pkt_size = pkt ? pkt -> size : 0 ; unsigned int are_we_over_size = ( ms -> muxing_queue_data_size + pkt_size ) > ms -> muxing_queue_data_threshold ; size_t limit = are_we_over_size ? ms -> max_muxing_queue_size : SIZE_MAX ; size_t new_size = FFMIN ( 2 * cur_size , limit ) ; if ( new_size <= cur_size ) { av_log ( ost , AV_LOG_ERROR , \"Too many packets buffered for output stream %d:%d.\\n\" , ost -> file_index , ost -> st -> index ) ; return AVERROR ( ENOSPC ) ; } ret = av_fifo_grow2 ( ms -> muxing_queue , new_size - cur_size ) ; if ( ret < 0 ) return ret ; } if ( pkt ) { ret = av_packet_make_refcounted ( pkt ) ; if ( ret < 0 ) return ret ; tmp_pkt = av_packet_alloc ( ) ; if ( ! tmp_pkt ) return AVERROR ( ENOMEM ) ; av_packet_move_ref ( tmp_pkt , pkt ) ; ms -> muxing_queue_data_size += tmp_pkt -> size ; } av_fifo_write ( ms -> muxing_queue , & tmp_pkt , 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@submit_packet": "static int submit_packet ( Muxer * mux , AVPacket * pkt , OutputStream * ost ) { int ret ; if ( mux -> tq ) { return thread_submit_packet ( mux , ost , pkt ) ; } else { /* the muxer is not initialized yet, buffer the packet */ ret = queue_packet ( mux , ost , pkt ) ; if ( ret < 0 ) { if ( pkt ) av_packet_unref ( pkt ) ; return ret ; } } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@of_output_packet": "void of_output_packet ( OutputFile * of , AVPacket * pkt , OutputStream * ost , int eof ) { Muxer * mux = mux_from_of ( of ) ; MuxStream * ms = ms_from_ost ( ost ) ; const char * err_msg ; int ret = 0 ; if ( ! eof && pkt -> dts != AV_NOPTS_VALUE ) ost -> last_mux_dts = av_rescale_q ( pkt -> dts , pkt -> time_base , AV_TIME_BASE_Q ) ; /* apply the output bitstream filters */ if ( ms -> bsf_ctx ) { int bsf_eof = 0 ; ret = av_bsf_send_packet ( ms -> bsf_ctx , eof ? NULL : pkt ) ; if ( ret < 0 ) { err_msg = \"submitting a packet for bitstream filtering\" ; goto fail ; } while ( ! bsf_eof ) { ret = av_bsf_receive_packet ( ms -> bsf_ctx , pkt ) ; if ( ret == AVERROR ( EAGAIN ) ) return ; else if ( ret == AVERROR_EOF ) bsf_eof = 1 ; else if ( ret < 0 ) { err_msg = \"applying bitstream filters to a packet\" ; goto fail ; } ret = submit_packet ( mux , bsf_eof ? NULL : pkt , ost ) ; if ( ret < 0 ) goto mux_fail ; } } else { ret = submit_packet ( mux , eof ? NULL : pkt , ost ) ; if ( ret < 0 ) goto mux_fail ; } return ; mux_fail : err_msg = \"submitting a packet to the muxer\" ; fail : av_log ( ost , AV_LOG_ERROR , \"Error %s\\n\" , err_msg ) ; if ( exit_on_error ) exit_program ( 1 ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@thread_stop": "static int thread_stop ( Muxer * mux ) { void * ret ; if ( ! mux || ! mux -> tq ) return 0 ; for ( unsigned int i = 0 ; i < mux -> fc -> nb_streams ; i ++ ) tq_send_finish ( mux -> tq , i ) ; pthread_join ( mux -> thread , & ret ) ; tq_free ( & mux -> tq ) ; return ( int ) ( intptr_t ) ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@pkt_move": "static void pkt_move ( void * dst , void * src ) { av_packet_move_ref ( dst , src ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@thread_start": "static int thread_start ( Muxer * mux ) { AVFormatContext * fc = mux -> fc ; ObjPool * op ; int ret ; op = objpool_alloc_packets ( ) ; if ( ! op ) return AVERROR ( ENOMEM ) ; mux -> tq = tq_alloc ( fc -> nb_streams , mux -> thread_queue_size , op , pkt_move ) ; if ( ! mux -> tq ) { objpool_free ( & op ) ; return AVERROR ( ENOMEM ) ; } ret = pthread_create ( & mux -> thread , NULL , muxer_thread , ( void * ) mux ) ; if ( ret ) { tq_free ( & mux -> tq ) ; return AVERROR ( ret ) ; } /* flush the muxing queues */ for ( int i = 0 ; i < fc -> nb_streams ; i ++ ) { OutputStream * ost = mux -> of . streams [ i ] ; MuxStream * ms = ms_from_ost ( ost ) ; AVPacket * pkt ; /* try to improve muxing time_base (only possible if nothing has been written yet) */ if ( ! av_fifo_can_read ( ms -> muxing_queue ) ) ost -> mux_timebase = ost -> st -> time_base ; while ( av_fifo_read ( ms -> muxing_queue , & pkt , 1 ) >= 0 ) { ret = thread_submit_packet ( mux , ost , pkt ) ; if ( pkt ) { ms -> muxing_queue_data_size -= pkt -> size ; av_packet_free ( & pkt ) ; } if ( ret < 0 ) return ret ; } } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@print_sdp": "static int print_sdp ( void ) { char sdp [ 16384 ] ; int i ; int j , ret ; AVIOContext * sdp_pb ; AVFormatContext * * avc ; for ( i = 0 ; i < nb_output_files ; i ++ ) { if ( ! mux_from_of ( output_files [ i ] ) -> header_written ) return 0 ; } avc = av_malloc_array ( nb_output_files , sizeof ( * avc ) ) ; if ( ! avc ) return AVERROR ( ENOMEM ) ; for ( i = 0 , j = 0 ; i < nb_output_files ; i ++ ) { if ( ! strcmp ( output_files [ i ] -> format -> name , \"rtp\" ) ) { avc [ j ] = mux_from_of ( output_files [ i ] ) -> fc ; j ++ ; } } if ( ! j ) { av_log ( NULL , AV_LOG_ERROR , \"No output streams in the SDP.\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } ret = av_sdp_create ( avc , j , sdp , sizeof ( sdp ) ) ; if ( ret < 0 ) goto fail ; if ( ! sdp_filename ) { av_log ( NULL , AV_LOG_ERROR , \"SDP:\\n%s\\n\" , sdp ) ; fflush ( stdout ) ; } else { ret = avio_open2 ( & sdp_pb , sdp_filename , AVIO_FLAG_WRITE , & int_cb , NULL ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Failed to open sdp file '%s'\\n\" , sdp_filename ) ; goto fail ; } avio_print ( sdp_pb , sdp ) ; avio_closep ( & sdp_pb ) ; av_freep ( & sdp_filename ) ; } // SDP successfully written, allow muxer threads to start ret = 1 ; fail : av_freep ( & avc ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@mux_check_init": "int mux_check_init ( Muxer * mux ) { OutputFile * of = & mux -> of ; AVFormatContext * fc = mux -> fc ; int ret , i ; for ( i = 0 ; i < fc -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; if ( ! ost -> initialized ) return 0 ; } ret = avformat_write_header ( fc , & mux -> opts ) ; if ( ret < 0 ) { av_log ( mux , AV_LOG_ERROR , \"Could not write header (incorrect codec \" \"parameters ?): %s\\n\" , av_err2str ( ret ) ) ; return ret ; } //assert_avoptions(of->opts); mux -> header_written = 1 ; av_dump_format ( fc , of -> index , fc -> url , 1 ) ; nb_output_dumped ++ ; if ( sdp_filename || want_sdp ) { ret = print_sdp ( ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error writing the SDP.\\n\" ) ; return ret ; } else if ( ret == 1 ) { /* SDP is written only after all the muxers are ready, so now we\n             * start ALL the threads */ for ( i = 0 ; i < nb_output_files ; i ++ ) { ret = thread_start ( mux_from_of ( output_files [ i ] ) ) ; if ( ret < 0 ) return ret ; } } } else { ret = thread_start ( mux_from_of ( of ) ) ; if ( ret < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@bsf_init": "static int bsf_init ( MuxStream * ms ) { OutputStream * ost = & ms -> ost ; AVBSFContext * ctx = ms -> bsf_ctx ; int ret ; if ( ! ctx ) return 0 ; ret = avcodec_parameters_copy ( ctx -> par_in , ost -> st -> codecpar ) ; if ( ret < 0 ) return ret ; ctx -> time_base_in = ost -> st -> time_base ; ret = av_bsf_init ( ctx ) ; if ( ret < 0 ) { av_log ( ms , AV_LOG_ERROR , \"Error initializing bitstream filter: %s\\n\" , ctx -> filter -> name ) ; return ret ; } ret = avcodec_parameters_copy ( ost -> st -> codecpar , ctx -> par_out ) ; if ( ret < 0 ) return ret ; ost -> st -> time_base = ctx -> time_base_out ; return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@of_stream_init": "int of_stream_init ( OutputFile * of , OutputStream * ost ) { Muxer * mux = mux_from_of ( of ) ; MuxStream * ms = ms_from_ost ( ost ) ; int ret ; if ( ost -> sq_idx_mux >= 0 ) sq_set_tb ( mux -> sq_mux , ost -> sq_idx_mux , ost -> mux_timebase ) ; /* initialize bitstream filters for the output stream\n     * needs to be done here, because the codec id for streamcopy is not\n     * known until now */ ret = bsf_init ( ms ) ; if ( ret < 0 ) return ret ; ost -> initialized = 1 ; return mux_check_init ( mux ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@of_write_trailer": "int of_write_trailer ( OutputFile * of ) { Muxer * mux = mux_from_of ( of ) ; AVFormatContext * fc = mux -> fc ; int ret ; if ( ! mux -> tq ) { av_log ( mux , AV_LOG_ERROR , \"Nothing was written into output file, because \" \"at least one of its streams received no packets.\\n\" ) ; return AVERROR ( EINVAL ) ; } ret = thread_stop ( mux ) ; if ( ret < 0 ) main_ffmpeg_return_code = ret ; ret = av_write_trailer ( fc ) ; if ( ret < 0 ) { av_log ( mux , AV_LOG_ERROR , \"Error writing trailer: %s\\n\" , av_err2str ( ret ) ) ; return ret ; } mux -> last_filesize = filesize ( fc -> pb ) ; if ( ! ( of -> format -> flags & AVFMT_NOFILE ) ) { ret = avio_closep ( & fc -> pb ) ; if ( ret < 0 ) { av_log ( mux , AV_LOG_ERROR , \"Error closing file: %s\\n\" , av_err2str ( ret ) ) ; return ret ; } } return 0 ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@ost_free": "static void ost_free ( OutputStream * * post ) { OutputStream * ost = * post ; MuxStream * ms ; if ( ! ost ) return ; ms = ms_from_ost ( ost ) ; if ( ost -> logfile ) { if ( fclose ( ost -> logfile ) ) av_log ( ms , AV_LOG_ERROR , \"Error closing logfile, loss of information possible: %s\\n\" , av_err2str ( AVERROR ( errno ) ) ) ; ost -> logfile = NULL ; } if ( ms -> muxing_queue ) { AVPacket * pkt ; while ( av_fifo_read ( ms -> muxing_queue , & pkt , 1 ) >= 0 ) av_packet_free ( & pkt ) ; av_fifo_freep2 ( & ms -> muxing_queue ) ; } av_bsf_free ( & ms -> bsf_ctx ) ; av_frame_free ( & ost -> filtered_frame ) ; av_frame_free ( & ost -> sq_frame ) ; av_frame_free ( & ost -> last_frame ) ; av_packet_free ( & ost -> pkt ) ; av_dict_free ( & ost -> encoder_opts ) ; av_freep ( & ost -> kf . pts ) ; av_expr_free ( ost -> kf . pexpr ) ; av_freep ( & ost -> avfilter ) ; av_freep ( & ost -> logfile_prefix ) ; av_freep ( & ost -> apad ) ; # if FFMPEG_OPT_MAP_CHANNEL av_freep ( & ost -> audio_channels_map ) ; ost -> audio_channels_mapped = 0 ; # endif av_dict_free ( & ost -> sws_dict ) ; av_dict_free ( & ost -> swr_opts ) ; if ( ost -> enc_ctx ) av_freep ( & ost -> enc_ctx -> stats_in ) ; avcodec_free_context ( & ost -> enc_ctx ) ; for ( int i = 0 ; i < ost -> enc_stats_pre . nb_components ; i ++ ) av_freep ( & ost -> enc_stats_pre . components [ i ] . str ) ; av_freep ( & ost -> enc_stats_pre . components ) ; for ( int i = 0 ; i < ost -> enc_stats_post . nb_components ; i ++ ) av_freep ( & ost -> enc_stats_post . components [ i ] . str ) ; av_freep ( & ost -> enc_stats_post . components ) ; for ( int i = 0 ; i < ms -> stats . nb_components ; i ++ ) av_freep ( & ms -> stats . components [ i ] . str ) ; av_freep ( & ms -> stats . components ) ; av_freep ( post ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@fc_close": "static void fc_close ( AVFormatContext * * pfc ) { AVFormatContext * fc = * pfc ; if ( ! fc ) return ; if ( ! ( fc -> oformat -> flags & AVFMT_NOFILE ) ) avio_closep ( & fc -> pb ) ; avformat_free_context ( fc ) ; * pfc = NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@of_close": "void of_close ( OutputFile * * pof ) { OutputFile * of = * pof ; Muxer * mux ; if ( ! of ) return ; mux = mux_from_of ( of ) ; thread_stop ( mux ) ; sq_free ( & of -> sq_encode ) ; sq_free ( & mux -> sq_mux ) ; for ( int i = 0 ; i < of -> nb_streams ; i ++ ) ost_free ( & of -> streams [ i ] ) ; av_freep ( & of -> streams ) ; av_dict_free ( & mux -> opts ) ; av_packet_free ( & mux -> sq_pkt ) ; fc_close ( & mux -> fc ) ; av_freep ( pof ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_ffmpeg_mux.c@of_filesize": "int64_t of_filesize ( OutputFile * of ) { Muxer * mux = mux_from_of ( of ) ; return atomic_load ( & mux -> last_filesize ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_thread_queue.c@tq_free": "void tq_free ( ThreadQueue * * ptq ) { ThreadQueue * tq = * ptq ; if ( ! tq ) return ; if ( tq -> fifo ) { FifoElem elem ; while ( av_fifo_read ( tq -> fifo , & elem , 1 ) >= 0 ) objpool_release ( tq -> obj_pool , & elem . obj ) ; } av_fifo_freep2 ( & tq -> fifo ) ; objpool_free ( & tq -> obj_pool ) ; av_freep ( & tq -> finished ) ; pthread_cond_destroy ( & tq -> cond ) ; pthread_mutex_destroy ( & tq -> lock ) ; av_freep ( ptq ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_thread_queue.c@tq_alloc": "ThreadQueue * tq_alloc ( unsigned int nb_streams , size_t queue_size , ObjPool * obj_pool , void ( * obj_move ) ( void * dst , void * src ) ) { ThreadQueue * tq ; int ret ; tq = av_mallocz ( sizeof ( * tq ) ) ; if ( ! tq ) return NULL ; ret = pthread_cond_init ( & tq -> cond , NULL ) ; if ( ret ) { av_freep ( & tq ) ; return NULL ; } ret = pthread_mutex_init ( & tq -> lock , NULL ) ; if ( ret ) { pthread_cond_destroy ( & tq -> cond ) ; av_freep ( & tq ) ; return NULL ; } tq -> finished = av_calloc ( nb_streams , sizeof ( * tq -> finished ) ) ; if ( ! tq -> finished ) goto fail ; tq -> nb_streams = nb_streams ; tq -> fifo = av_fifo_alloc2 ( queue_size , sizeof ( FifoElem ) , 0 ) ; if ( ! tq -> fifo ) goto fail ; tq -> obj_pool = obj_pool ; tq -> obj_move = obj_move ; return tq ; fail : tq_free ( & tq ) ; return NULL ; }",
    "resources/ffmpeg-kit/linux/src/fftools_thread_queue.c@tq_send": "int tq_send ( ThreadQueue * tq , unsigned int stream_idx , void * data ) { int * finished ; int ret ; av_assert0 ( stream_idx < tq -> nb_streams ) ; finished = & tq -> finished [ stream_idx ] ; pthread_mutex_lock ( & tq -> lock ) ; if ( * finished & FINISHED_SEND ) { ret = AVERROR ( EINVAL ) ; goto finish ; } while ( ! ( * finished & FINISHED_RECV ) && ! av_fifo_can_write ( tq -> fifo ) ) pthread_cond_wait ( & tq -> cond , & tq -> lock ) ; if ( * finished & FINISHED_RECV ) { ret = AVERROR_EOF ; * finished |= FINISHED_SEND ; } else { FifoElem elem = { . stream_idx = stream_idx } ; ret = objpool_get ( tq -> obj_pool , & elem . obj ) ; if ( ret < 0 ) goto finish ; tq -> obj_move ( elem . obj , data ) ; ret = av_fifo_write ( tq -> fifo , & elem , 1 ) ; av_assert0 ( ret >= 0 ) ; pthread_cond_broadcast ( & tq -> cond ) ; } finish : pthread_mutex_unlock ( & tq -> lock ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_thread_queue.c@receive_locked": "static int receive_locked ( ThreadQueue * tq , int * stream_idx , void * data ) { FifoElem elem ; unsigned int nb_finished = 0 ; if ( av_fifo_read ( tq -> fifo , & elem , 1 ) >= 0 ) { tq -> obj_move ( data , elem . obj ) ; objpool_release ( tq -> obj_pool , & elem . obj ) ; * stream_idx = elem . stream_idx ; return 0 ; } for ( unsigned int i = 0 ; i < tq -> nb_streams ; i ++ ) { if ( ! ( tq -> finished [ i ] & FINISHED_SEND ) ) continue ; /* return EOF to the consumer at most once for each stream */ if ( ! ( tq -> finished [ i ] & FINISHED_RECV ) ) { tq -> finished [ i ] |= FINISHED_RECV ; * stream_idx = i ; return AVERROR_EOF ; } nb_finished ++ ; } return nb_finished == tq -> nb_streams ? AVERROR_EOF : AVERROR ( EAGAIN ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_thread_queue.c@tq_receive": "int tq_receive ( ThreadQueue * tq , int * stream_idx , void * data ) { int ret ; * stream_idx = - 1 ; pthread_mutex_lock ( & tq -> lock ) ; while ( 1 ) { ret = receive_locked ( tq , stream_idx , data ) ; if ( ret == AVERROR ( EAGAIN ) ) { pthread_cond_wait ( & tq -> cond , & tq -> lock ) ; continue ; } break ; } if ( ret == 0 ) pthread_cond_broadcast ( & tq -> cond ) ; pthread_mutex_unlock ( & tq -> lock ) ; return ret ; }",
    "resources/ffmpeg-kit/linux/src/fftools_thread_queue.c@tq_send_finish": "void tq_send_finish ( ThreadQueue * tq , unsigned int stream_idx ) { av_assert0 ( stream_idx < tq -> nb_streams ) ; pthread_mutex_lock ( & tq -> lock ) ; /* mark the stream as send-finished;\n     * next time the consumer thread tries to read this stream it will get\n     * an EOF and recv-finished flag will be set */ tq -> finished [ stream_idx ] |= FINISHED_SEND ; pthread_cond_broadcast ( & tq -> cond ) ; pthread_mutex_unlock ( & tq -> lock ) ; }",
    "resources/ffmpeg-kit/linux/src/fftools_thread_queue.c@tq_receive_finish": "void tq_receive_finish ( ThreadQueue * tq , unsigned int stream_idx ) { av_assert0 ( stream_idx < tq -> nb_streams ) ; pthread_mutex_lock ( & tq -> lock ) ; /* mark the stream as recv-finished;\n     * next time the producer thread tries to send for this stream, it will\n     * get an EOF and send-finished flag will be set */ tq -> finished [ stream_idx ] |= FINISHED_RECV ; pthread_cond_broadcast ( & tq -> cond ) ; pthread_mutex_unlock ( & tq -> lock ) ; }",
    "resources/ffmpeg-kit/linux/src/FFprobeKit.cpp@defaultGetMediaInformationCommandArguments": "static std :: list < std :: string > defaultGetMediaInformationCommandArguments ( const std :: string & path ) { return std :: list < std :: string > { \"-v\" , \"error\" , \"-hide_banner\" , \"-print_format\" , \"json\" , \"-show_format\" , \"-show_streams\" , \"-show_chapters\" , \"-i\" , path } ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@fopen_utf8": "static inline FILE * fopen_utf8 ( const char * path , const char * mode ) { return fopen ( path , mode ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@uninit_opts": "void uninit_opts ( void ) { av_dict_free ( & swr_opts ) ; av_dict_free ( & sws_dict ) ; av_dict_free ( & format_opts ) ; av_dict_free ( & codec_opts ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@init_dynload": "void init_dynload ( void ) { # if HAVE_SETDLLDIRECTORY && defined ( _WIN32 ) /* Calling SetDllDirectory with the empty string (but not NULL) removes the\n     * current working directory from the DLL search path as a security pre-caution. */ SetDllDirectory ( \"\" ) ; # endif }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@register_exit": "void register_exit ( void ( * cb ) ( int ret ) ) { program_exit = cb ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@report_and_exit": "void report_and_exit ( int ret ) { av_log ( NULL , AV_LOG_FATAL , \"%s\\n\" , av_err2str ( ret ) ) ; exit_program ( AVUNERROR ( ret ) ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@exit_program": "void exit_program ( int ret ) { if ( program_exit ) program_exit ( ret ) ; // FFmpegKit // exit disabled and replaced with longjmp, exit value stored in longjmp_value // exit(ret); longjmp_value = ret ; longjmp ( ex_buf__ , ret ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@parse_number_or_die": "double parse_number_or_die ( const char * context , const char * numstr , int type , double min , double max ) { char * tail ; const char * error ; double d = av_strtod ( numstr , & tail ) ; if ( * tail ) error = \"Expected number for %s but found: %s\\n\" ; else if ( d < min || d > max ) error = \"The value for %s was %s which is not within %f - %f\\n\" ; else if ( type == OPT_INT64 && ( int64_t ) d != d ) error = \"Expected int64 for %s but found %s\\n\" ; else if ( type == OPT_INT && ( int ) d != d ) error = \"Expected int for %s but found %s\\n\" ; else return d ; av_log ( NULL , AV_LOG_FATAL , error , context , numstr , min , max ) ; exit_program ( 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@parse_time_or_die": "int64_t parse_time_or_die ( const char * context , const char * timestr , int is_duration ) { int64_t us ; if ( av_parse_time ( & us , timestr , is_duration ) < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid %s specification for %s: %s\\n\" , is_duration ? \"duration\" : \"date\" , context , timestr ) ; exit_program ( 1 ) ; } return us ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@show_help_options": "void show_help_options ( const OptionDef * options , const char * msg , int req_flags , int rej_flags , int alt_flags ) { const OptionDef * po ; int first ; first = 1 ; for ( po = options ; po -> name ; po ++ ) { char buf [ 128 ] ; if ( ( ( po -> flags & req_flags ) != req_flags ) || ( alt_flags && ! ( po -> flags & alt_flags ) ) || ( po -> flags & rej_flags ) ) continue ; if ( first ) { av_log ( NULL , AV_LOG_STDERR , \"%s\\n\" , msg ) ; first = 0 ; } av_strlcpy ( buf , po -> name , sizeof ( buf ) ) ; if ( po -> argname ) { av_strlcat ( buf , \" \" , sizeof ( buf ) ) ; av_strlcat ( buf , po -> argname , sizeof ( buf ) ) ; } av_log ( NULL , AV_LOG_STDERR , \"-%-17s  %s\\n\" , buf , po -> help ) ; } av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@show_help_children": "void show_help_children ( const AVClass * class , int flags ) { void * iter = NULL ; const AVClass * child ; if ( class -> option ) { av_opt_show2 ( & class , NULL , flags , 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; } while ( ( child = av_opt_child_class_iterate ( class , & iter ) ) ) show_help_children ( child , flags ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@find_option": "static const OptionDef * find_option ( const OptionDef * po , const char * name ) { while ( po -> name ) { const char * end ; if ( av_strstart ( name , po -> name , & end ) && ( ! * end || * end == ':' ) ) break ; po ++ ; } return po ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@prepare_app_arguments": "static inline void prepare_app_arguments ( int * argc_ptr , char * * * argv_ptr ) { /* nothing to do */ }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@write_option": "static int write_option ( void * optctx , const OptionDef * po , const char * opt , const char * arg ) { /* new-style options contain an offset into optctx, old-style address of\n     * a global var*/ void * dst = po -> flags & ( OPT_OFFSET | OPT_SPEC ) ? ( uint8_t * ) optctx + po -> u . off : po -> u . dst_ptr ; int * dstcount ; if ( po -> flags & OPT_SPEC ) { SpecifierOpt * * so = dst ; char * p = strchr ( opt , ':' ) ; char * str ; dstcount = ( int * ) ( so + 1 ) ; * so = grow_array ( * so , sizeof ( * * so ) , dstcount , * dstcount + 1 ) ; str = av_strdup ( p ? p + 1 : \"\" ) ; if ( ! str ) return AVERROR ( ENOMEM ) ; ( * so ) [ * dstcount - 1 ] . specifier = str ; dst = & ( * so ) [ * dstcount - 1 ] . u ; } if ( po -> flags & OPT_STRING ) { char * str ; str = av_strdup ( arg ) ; av_freep ( dst ) ; if ( ! str ) return AVERROR ( ENOMEM ) ; * ( char * * ) dst = str ; } else if ( po -> flags & OPT_BOOL || po -> flags & OPT_INT ) { * ( int * ) dst = parse_number_or_die ( opt , arg , OPT_INT64 , INT_MIN , INT_MAX ) ; } else if ( po -> flags & OPT_INT64 ) { * ( int64_t * ) dst = parse_number_or_die ( opt , arg , OPT_INT64 , INT64_MIN , ( double ) INT64_MAX ) ; } else if ( po -> flags & OPT_TIME ) { * ( int64_t * ) dst = parse_time_or_die ( opt , arg , 1 ) ; } else if ( po -> flags & OPT_FLOAT ) { * ( float * ) dst = parse_number_or_die ( opt , arg , OPT_FLOAT , - INFINITY , INFINITY ) ; } else if ( po -> flags & OPT_DOUBLE ) { * ( double * ) dst = parse_number_or_die ( opt , arg , OPT_DOUBLE , - INFINITY , INFINITY ) ; } else if ( po -> u . func_arg ) { int ret = po -> u . func_arg ( optctx , opt , arg ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Failed to set value '%s' for option '%s': %s\\n\" , arg , opt , av_err2str ( ret ) ) ; return ret ; } } if ( po -> flags & OPT_EXIT ) exit_program ( 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@parse_option": "int parse_option ( void * optctx , const char * opt , const char * arg , const OptionDef * options ) { static const OptionDef opt_avoptions = { . name = \"AVOption passthrough\" , . flags = HAS_ARG , . u . func_arg = opt_default , } ; const OptionDef * po ; int ret ; po = find_option ( options , opt ) ; if ( ! po -> name && opt [ 0 ] == 'n' && opt [ 1 ] == 'o' ) { /* handle 'no' bool option */ po = find_option ( options , opt + 2 ) ; if ( ( po -> name && ( po -> flags & OPT_BOOL ) ) ) arg = \"0\" ; } else if ( po -> flags & OPT_BOOL ) arg = \"1\" ; if ( ! po -> name ) po = & opt_avoptions ; if ( ! po -> name ) { av_log ( NULL , AV_LOG_ERROR , \"Unrecognized option '%s'\\n\" , opt ) ; return AVERROR ( EINVAL ) ; } if ( po -> flags & HAS_ARG && ! arg ) { av_log ( NULL , AV_LOG_ERROR , \"Missing argument for option '%s'\\n\" , opt ) ; return AVERROR ( EINVAL ) ; } ret = write_option ( optctx , po , opt , arg ) ; if ( ret < 0 ) return ret ; return ! ! ( po -> flags & HAS_ARG ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@parse_options": "void parse_options ( void * optctx , int argc , char * * argv , const OptionDef * options , void ( * parse_arg_function ) ( void * , const char * ) ) { const char * opt ; int optindex , handleoptions = 1 , ret ; /* perform system-dependent conversions for arguments list */ prepare_app_arguments ( & argc , & argv ) ; /* parse options */ optindex = 1 ; while ( optindex < argc ) { opt = argv [ optindex ++ ] ; if ( handleoptions && opt [ 0 ] == '-' && opt [ 1 ] != '\\0' ) { if ( opt [ 1 ] == '-' && opt [ 2 ] == '\\0' ) { handleoptions = 0 ; continue ; } opt ++ ; if ( optindex >= argc ) { if ( ( ret = parse_option ( optctx , opt , NULL , options ) ) < 0 ) exit_program ( 1 ) ; } else { if ( ( ret = parse_option ( optctx , opt , argv [ optindex ] , options ) ) < 0 ) exit_program ( 1 ) ; } optindex += ret ; } else { if ( parse_arg_function ) parse_arg_function ( optctx , opt ) ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@parse_optgroup": "int parse_optgroup ( void * optctx , OptionGroup * g ) { int i , ret ; av_log ( NULL , AV_LOG_DEBUG , \"Parsing a group of options: %s %s.\\n\" , g -> group_def -> name , g -> arg ) ; for ( i = 0 ; i < g -> nb_opts ; i ++ ) { Option * o = & g -> opts [ i ] ; if ( g -> group_def -> flags && ! ( g -> group_def -> flags & o -> opt -> flags ) ) { av_log ( NULL , AV_LOG_ERROR , \"Option %s (%s) cannot be applied to \" \"%s %s -- you are trying to apply an input option to an \" \"output file or vice versa. Move this option before the \" \"file it belongs to.\\n\" , o -> key , o -> opt -> help , g -> group_def -> name , g -> arg ) ; return AVERROR ( EINVAL ) ; } av_log ( NULL , AV_LOG_DEBUG , \"Applying option %s (%s) with argument %s.\\n\" , o -> key , o -> opt -> help , o -> val ) ; ret = write_option ( optctx , o -> opt , o -> key , o -> val ) ; if ( ret < 0 ) return ret ; } av_log ( NULL , AV_LOG_DEBUG , \"Successfully parsed a group of options.\\n\" ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@locate_option": "int locate_option ( int argc , char * * argv , const OptionDef * options , const char * optname ) { const OptionDef * po ; int i ; for ( i = 1 ; i < argc ; i ++ ) { const char * cur_opt = argv [ i ] ; if ( * cur_opt ++ != '-' ) continue ; po = find_option ( options , cur_opt ) ; if ( ! po -> name && cur_opt [ 0 ] == 'n' && cur_opt [ 1 ] == 'o' ) po = find_option ( options , cur_opt + 2 ) ; if ( ( ! po -> name && ! strcmp ( cur_opt , optname ) ) || ( po -> name && ! strcmp ( optname , po -> name ) ) ) return i ; if ( ! po -> name || po -> flags & HAS_ARG ) i ++ ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@dump_argument": "static void dump_argument ( FILE * report_file , const char * a ) { const unsigned char * p ; for ( p = a ; * p ; p ++ ) if ( ! ( ( * p >= '+' && * p <= ':' ) || ( * p >= '@' && * p <= 'Z' ) || * p == '_' || ( * p >= 'a' && * p <= 'z' ) ) ) break ; if ( ! * p ) { fputs ( a , report_file ) ; return ; } fputc ( '\"' , report_file ) ; for ( p = a ; * p ; p ++ ) { if ( * p == '\\\\' || * p == '\"' || * p == '$' || * p == '`' ) fprintf ( report_file , \"\\\\%c\" , * p ) ; else if ( * p < ' ' || * p > '~' ) fprintf ( report_file , \"\\\\x%02x\" , * p ) ; else fputc ( * p , report_file ) ; } fputc ( '\"' , report_file ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@check_options": "static void check_options ( const OptionDef * po ) { while ( po -> name ) { if ( po -> flags & OPT_PERFILE ) av_assert0 ( po -> flags & ( OPT_INPUT | OPT_OUTPUT ) ) ; po ++ ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@parse_loglevel": "void parse_loglevel ( int argc , char * * argv , const OptionDef * options ) { int idx = locate_option ( argc , argv , options , \"loglevel\" ) ; char * env ; check_options ( options ) ; if ( ! idx ) idx = locate_option ( argc , argv , options , \"v\" ) ; if ( idx && ( idx + 1 < argc ) && argv [ idx + 1 ] ) opt_loglevel ( NULL , \"loglevel\" , argv [ idx + 1 ] ) ; idx = locate_option ( argc , argv , options , \"report\" ) ; env = getenv_utf8 ( \"FFREPORT\" ) ; if ( env || idx ) { FILE * report_file = NULL ; init_report ( env , & report_file ) ; if ( report_file ) { int i ; fprintf ( report_file , \"Command line:\\n\" ) ; for ( i = 0 ; i < argc ; i ++ ) { dump_argument ( report_file , argv [ i ] ) ; fputc ( i < argc - 1 ? ' ' : '\\n' , report_file ) ; } fflush ( report_file ) ; } } freeenv_utf8 ( env ) ; idx = locate_option ( argc , argv , options , \"hide_banner\" ) ; if ( idx ) hide_banner = 1 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@opt_find": "static const AVOption * opt_find ( void * obj , const char * name , const char * unit , int opt_flags , int search_flags ) { const AVOption * o = av_opt_find ( obj , name , unit , opt_flags , search_flags ) ; if ( o && ! o -> flags ) return NULL ; return o ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@opt_default": "int opt_default ( void * optctx , const char * opt , const char * arg ) { const AVOption * o ; int consumed = 0 ; char opt_stripped [ 128 ] ; const char * p ; const AVClass * cc = avcodec_get_class ( ) , * fc = avformat_get_class ( ) ; # if CONFIG_SWSCALE const AVClass * sc = sws_get_class ( ) ; # endif # if CONFIG_SWRESAMPLE const AVClass * swr_class = swr_get_class ( ) ; # endif if ( ! strcmp ( opt , \"debug\" ) || ! strcmp ( opt , \"fdebug\" ) ) av_log_set_level ( AV_LOG_DEBUG ) ; if ( ! ( p = strchr ( opt , ':' ) ) ) p = opt + strlen ( opt ) ; av_strlcpy ( opt_stripped , opt , FFMIN ( sizeof ( opt_stripped ) , p - opt + 1 ) ) ; if ( ( o = opt_find ( & cc , opt_stripped , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ) || ( ( opt [ 0 ] == 'v' || opt [ 0 ] == 'a' || opt [ 0 ] == 's' ) && ( o = opt_find ( & cc , opt + 1 , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ) ) ) { av_dict_set ( & codec_opts , opt , arg , FLAGS ) ; consumed = 1 ; } if ( ( o = opt_find ( & fc , opt , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ) ) { av_dict_set ( & format_opts , opt , arg , FLAGS ) ; if ( consumed ) av_log ( NULL , AV_LOG_VERBOSE , \"Routing option %s to both codec and muxer layer\\n\" , opt ) ; consumed = 1 ; } # if CONFIG_SWSCALE if ( ! consumed && ( o = opt_find ( & sc , opt , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ) ) { if ( ! strcmp ( opt , \"srcw\" ) || ! strcmp ( opt , \"srch\" ) || ! strcmp ( opt , \"dstw\" ) || ! strcmp ( opt , \"dsth\" ) || ! strcmp ( opt , \"src_format\" ) || ! strcmp ( opt , \"dst_format\" ) ) { av_log ( NULL , AV_LOG_ERROR , \"Directly using swscale dimensions/format options is not supported, please use the -s or -pix_fmt options\\n\" ) ; return AVERROR ( EINVAL ) ; } av_dict_set ( & sws_dict , opt , arg , FLAGS ) ; consumed = 1 ; } # else if ( ! consumed && ! strcmp ( opt , \"sws_flags\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"Ignoring %s %s, due to disabled swscale\\n\" , opt , arg ) ; consumed = 1 ; } # endif # if CONFIG_SWRESAMPLE if ( ! consumed && ( o = opt_find ( & swr_class , opt , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ) ) { av_dict_set ( & swr_opts , opt , arg , FLAGS ) ; consumed = 1 ; } # endif if ( consumed ) return 0 ; return AVERROR_OPTION_NOT_FOUND ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@match_group_separator": "static int match_group_separator ( const OptionGroupDef * groups , int nb_groups , const char * opt ) { int i ; for ( i = 0 ; i < nb_groups ; i ++ ) { const OptionGroupDef * p = & groups [ i ] ; if ( p -> sep && ! strcmp ( p -> sep , opt ) ) return i ; } return - 1 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@finish_group": "static void finish_group ( OptionParseContext * octx , int group_idx , const char * arg ) { OptionGroupList * l = & octx -> groups [ group_idx ] ; OptionGroup * g ; GROW_ARRAY ( l -> groups , l -> nb_groups ) ; g = & l -> groups [ l -> nb_groups - 1 ] ; * g = octx -> cur_group ; g -> arg = arg ; g -> group_def = l -> group_def ; g -> sws_dict = sws_dict ; g -> swr_opts = swr_opts ; g -> codec_opts = codec_opts ; g -> format_opts = format_opts ; codec_opts = NULL ; format_opts = NULL ; sws_dict = NULL ; swr_opts = NULL ; memset ( & octx -> cur_group , 0 , sizeof ( octx -> cur_group ) ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@add_opt": "static void add_opt ( OptionParseContext * octx , const OptionDef * opt , const char * key , const char * val ) { int global = ! ( opt -> flags & ( OPT_PERFILE | OPT_SPEC | OPT_OFFSET ) ) ; OptionGroup * g = global ? & octx -> global_opts : & octx -> cur_group ; GROW_ARRAY ( g -> opts , g -> nb_opts ) ; g -> opts [ g -> nb_opts - 1 ] . opt = opt ; g -> opts [ g -> nb_opts - 1 ] . key = key ; g -> opts [ g -> nb_opts - 1 ] . val = val ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@init_parse_context": "static void init_parse_context ( OptionParseContext * octx , const OptionGroupDef * groups , int nb_groups ) { static const OptionGroupDef global_group = { \"global\" } ; int i ; memset ( octx , 0 , sizeof ( * octx ) ) ; octx -> nb_groups = nb_groups ; octx -> groups = av_calloc ( octx -> nb_groups , sizeof ( * octx -> groups ) ) ; if ( ! octx -> groups ) report_and_exit ( AVERROR ( ENOMEM ) ) ; for ( i = 0 ; i < octx -> nb_groups ; i ++ ) octx -> groups [ i ] . group_def = & groups [ i ] ; octx -> global_opts . group_def = & global_group ; octx -> global_opts . arg = \"\" ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@uninit_parse_context": "void uninit_parse_context ( OptionParseContext * octx ) { int i , j ; for ( i = 0 ; i < octx -> nb_groups ; i ++ ) { OptionGroupList * l = & octx -> groups [ i ] ; for ( j = 0 ; j < l -> nb_groups ; j ++ ) { av_freep ( & l -> groups [ j ] . opts ) ; av_dict_free ( & l -> groups [ j ] . codec_opts ) ; av_dict_free ( & l -> groups [ j ] . format_opts ) ; av_dict_free ( & l -> groups [ j ] . sws_dict ) ; av_dict_free ( & l -> groups [ j ] . swr_opts ) ; } av_freep ( & l -> groups ) ; } av_freep ( & octx -> groups ) ; av_freep ( & octx -> cur_group . opts ) ; av_freep ( & octx -> global_opts . opts ) ; uninit_opts ( ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@split_commandline": "int split_commandline ( OptionParseContext * octx , int argc , char * argv [ ] , const OptionDef * options , const OptionGroupDef * groups , int nb_groups ) { int optindex = 1 ; int dashdash = - 2 ; /* perform system-dependent conversions for arguments list */ prepare_app_arguments ( & argc , & argv ) ; init_parse_context ( octx , groups , nb_groups ) ; av_log ( NULL , AV_LOG_DEBUG , \"Splitting the commandline.\\n\" ) ; while ( optindex < argc ) { const char * opt = argv [ optindex ++ ] , * arg ; const OptionDef * po ; int ret ; av_log ( NULL , AV_LOG_DEBUG , \"Reading option '%s' ...\" , opt ) ; if ( opt [ 0 ] == '-' && opt [ 1 ] == '-' && ! opt [ 2 ] ) { dashdash = optindex ; continue ; } /* unnamed group separators, e.g. output filename */ if ( opt [ 0 ] != '-' || ! opt [ 1 ] || dashdash + 1 == optindex ) { finish_group ( octx , 0 , opt ) ; av_log ( NULL , AV_LOG_DEBUG , \" matched as %s.\\n\" , groups [ 0 ] . name ) ; continue ; } opt ++ ; # define GET_ARG ( arg ) do { if ( optindex < argc ) { arg = argv [ optindex ++ ] ; } else { av_log ( NULL , AV_LOG_ERROR , \"Missing argument for option '%s'.\\n\" , opt ) ; return AVERROR ( EINVAL ) ; } \\\n} while ( 0 ) /* named group separators, e.g. -i */ if ( ( ret = match_group_separator ( groups , nb_groups , opt ) ) >= 0 ) { GET_ARG ( arg ) ; finish_group ( octx , ret , arg ) ; av_log ( NULL , AV_LOG_DEBUG , \" matched as %s with argument '%s'.\\n\" , groups [ ret ] . name , arg ) ; continue ; } /* normal options */ po = find_option ( options , opt ) ; if ( po -> name ) { if ( po -> flags & OPT_EXIT ) { /* optional argument, e.g. -h */ if ( optindex < argc ) { arg = argv [ optindex ++ ] ; } else { arg = NULL ; } } else if ( po -> flags & HAS_ARG ) { GET_ARG ( arg ) ; } else { arg = \"1\" ; } add_opt ( octx , po , opt , arg ) ; av_log ( NULL , AV_LOG_DEBUG , \" matched as option '%s' (%s) with \" \"argument '%s'.\\n\" , po -> name , po -> help , arg ) ; continue ; } /* AVOptions */ if ( ( optindex < argc ) && argv [ optindex ] ) { ret = opt_default ( NULL , opt , argv [ optindex ] ) ; if ( ret >= 0 ) { av_log ( NULL , AV_LOG_DEBUG , \" matched as AVOption '%s' with \" \"argument '%s'.\\n\" , opt , argv [ optindex ] ) ; optindex ++ ; continue ; } else if ( ret != AVERROR_OPTION_NOT_FOUND ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing option '%s' \" \"with argument '%s'.\\n\" , opt , argv [ optindex ] ) ; return ret ; } } /* boolean -nofoo options */ if ( opt [ 0 ] == 'n' && opt [ 1 ] == 'o' && ( po = find_option ( options , opt + 2 ) ) && po -> name && po -> flags & OPT_BOOL ) { add_opt ( octx , po , opt , \"0\" ) ; av_log ( NULL , AV_LOG_DEBUG , \" matched as option '%s' (%s) with \" \"argument 0.\\n\" , po -> name , po -> help ) ; continue ; } av_log ( NULL , AV_LOG_ERROR , \"Unrecognized option '%s'.\\n\" , opt ) ; return AVERROR_OPTION_NOT_FOUND ; } if ( octx -> cur_group . nb_opts || codec_opts || format_opts ) av_log ( NULL , AV_LOG_WARNING , \"Trailing option(s) found in the \" \"command: may be ignored.\\n\" ) ; av_log ( NULL , AV_LOG_DEBUG , \"Finished splitting the commandline.\\n\" ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@print_error": "void print_error ( const char * filename , int err ) { av_log ( NULL , AV_LOG_ERROR , \"%s: %s\\n\" , filename , av_err2str ( err ) ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@read_yesno": "int read_yesno ( void ) { int c = getchar ( ) ; int yesno = ( av_toupper ( c ) == 'Y' ) ; while ( c != '\\n' && c != EOF ) c = getchar ( ) ; return yesno ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@get_preset_file": "FILE * get_preset_file ( char * filename , size_t filename_size , const char * preset_name , int is_path , const char * codec_name ) { FILE * f = NULL ; int i ; # if HAVE_GETMODULEHANDLE && defined ( _WIN32 ) char * datadir = NULL ; # endif char * env_home = getenv_utf8 ( \"HOME\" ) ; char * env_ffmpeg_datadir = getenv_utf8 ( \"FFMPEG_DATADIR\" ) ; const char * base [ 3 ] = { env_ffmpeg_datadir , env_home , /* index=1(HOME) is special: search in a .ffmpeg subfolder */ FFMPEG_DATADIR , } ; if ( is_path ) { av_strlcpy ( filename , preset_name , filename_size ) ; f = fopen_utf8 ( filename , \"r\" ) ; } else { # if HAVE_GETMODULEHANDLE && defined ( _WIN32 ) wchar_t * datadir_w = get_module_filename ( NULL ) ; base [ 2 ] = NULL ; if ( wchartoutf8 ( datadir_w , & datadir ) ) datadir = NULL ; av_free ( datadir_w ) ; if ( datadir ) { char * ls ; for ( ls = datadir ; * ls ; ls ++ ) if ( * ls == '\\\\' ) * ls = '/' ; if ( ls = strrchr ( datadir , '/' ) ) { ptrdiff_t datadir_len = ls - datadir ; size_t desired_size = datadir_len + strlen ( \"/ffpresets\" ) + 1 ; char * new_datadir = av_realloc_array ( datadir , desired_size , sizeof * datadir ) ; if ( new_datadir ) { datadir = new_datadir ; datadir [ datadir_len ] = 0 ; strncat ( datadir , \"/ffpresets\" , desired_size - 1 - datadir_len ) ; base [ 2 ] = datadir ; } } } # endif for ( i = 0 ; i < 3 && ! f ; i ++ ) { if ( ! base [ i ] ) continue ; snprintf ( filename , filename_size , \"%s%s/%s.ffpreset\" , base [ i ] , i != 1 ? \"\" : \"/.ffmpeg\" , preset_name ) ; f = fopen_utf8 ( filename , \"r\" ) ; if ( ! f && codec_name ) { snprintf ( filename , filename_size , \"%s%s/%s-%s.ffpreset\" , base [ i ] , i != 1 ? \"\" : \"/.ffmpeg\" , codec_name , preset_name ) ; f = fopen_utf8 ( filename , \"r\" ) ; } } } # if HAVE_GETMODULEHANDLE && defined ( _WIN32 ) av_free ( datadir ) ; # endif freeenv_utf8 ( env_ffmpeg_datadir ) ; freeenv_utf8 ( env_home ) ; return f ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@check_stream_specifier": "int check_stream_specifier ( AVFormatContext * s , AVStream * st , const char * spec ) { int ret = avformat_match_stream_specifier ( s , st , spec ) ; if ( ret < 0 ) av_log ( s , AV_LOG_ERROR , \"Invalid stream specifier: %s.\\n\" , spec ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@filter_codec_opts": "AVDictionary * filter_codec_opts ( AVDictionary * opts , enum AVCodecID codec_id , AVFormatContext * s , AVStream * st , const AVCodec * codec ) { AVDictionary * ret = NULL ; const AVDictionaryEntry * t = NULL ; int flags = s -> oformat ? AV_OPT_FLAG_ENCODING_PARAM : AV_OPT_FLAG_DECODING_PARAM ; char prefix = 0 ; const AVClass * cc = avcodec_get_class ( ) ; if ( ! codec ) codec = s -> oformat ? avcodec_find_encoder ( codec_id ) : avcodec_find_decoder ( codec_id ) ; switch ( st -> codecpar -> codec_type ) { case AVMEDIA_TYPE_VIDEO : prefix = 'v' ; flags |= AV_OPT_FLAG_VIDEO_PARAM ; break ; case AVMEDIA_TYPE_AUDIO : prefix = 'a' ; flags |= AV_OPT_FLAG_AUDIO_PARAM ; break ; case AVMEDIA_TYPE_SUBTITLE : prefix = 's' ; flags |= AV_OPT_FLAG_SUBTITLE_PARAM ; break ; } while ( ( t = av_dict_iterate ( opts , t ) ) ) { const AVClass * priv_class ; char * p = strchr ( t -> key , ':' ) ; /* check stream specification in opt name */ if ( p ) switch ( check_stream_specifier ( s , st , p + 1 ) ) { case 1 : * p = 0 ; break ; case 0 : continue ; default : exit_program ( 1 ) ; } if ( av_opt_find ( & cc , t -> key , NULL , flags , AV_OPT_SEARCH_FAKE_OBJ ) || ! codec || ( ( priv_class = codec -> priv_class ) && av_opt_find ( & priv_class , t -> key , NULL , flags , AV_OPT_SEARCH_FAKE_OBJ ) ) ) av_dict_set ( & ret , t -> key , t -> value , 0 ) ; else if ( t -> key [ 0 ] == prefix && av_opt_find ( & cc , t -> key + 1 , NULL , flags , AV_OPT_SEARCH_FAKE_OBJ ) ) av_dict_set ( & ret , t -> key + 1 , t -> value , 0 ) ; if ( p ) * p = ':' ; } return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@setup_find_stream_info_opts": "AVDictionary * * setup_find_stream_info_opts ( AVFormatContext * s , AVDictionary * codec_opts ) { int i ; AVDictionary * * opts ; if ( ! s -> nb_streams ) return NULL ; opts = av_calloc ( s -> nb_streams , sizeof ( * opts ) ) ; if ( ! opts ) report_and_exit ( AVERROR ( ENOMEM ) ) ; for ( i = 0 ; i < s -> nb_streams ; i ++ ) opts [ i ] = filter_codec_opts ( codec_opts , s -> streams [ i ] -> codecpar -> codec_id , s , s -> streams [ i ] , NULL ) ; return opts ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@grow_array": "void * grow_array ( void * array , int elem_size , int * size , int new_size ) { if ( new_size >= INT_MAX / elem_size ) { av_log ( NULL , AV_LOG_ERROR , \"Array too big.\\n\" ) ; exit_program ( 1 ) ; } if ( * size < new_size ) { uint8_t * tmp = av_realloc_array ( array , new_size , elem_size ) ; if ( ! tmp ) report_and_exit ( AVERROR ( ENOMEM ) ) ; memset ( tmp + * size * elem_size , 0 , ( new_size - * size ) * elem_size ) ; * size = new_size ; return tmp ; } return array ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@allocate_array_elem": "void * allocate_array_elem ( void * ptr , size_t elem_size , int * nb_elems ) { void * new_elem ; if ( ! ( new_elem = av_mallocz ( elem_size ) ) || av_dynarray_add_nofree ( ptr , nb_elems , new_elem ) < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return new_elem ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_cmdutils.c@get_rotation": "double get_rotation ( int32_t * displaymatrix ) { double theta = 0 ; if ( displaymatrix ) theta = - round ( av_display_rotation_get ( ( int32_t * ) displaymatrix ) ) ; theta -= 360 * floor ( theta / 360 + 0.9 / 360 ) ; if ( fabs ( theta - 90 * round ( theta / 90 ) ) > 2 ) av_log ( NULL , AV_LOG_WARNING , \"Odd rotation angle.\\n\" \"If you want to help, upload a sample \" \"of this file to https://streams.videolan.org/upload/ \" \"and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)\" ) ; return theta ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@frame_move": "static void frame_move ( const SyncQueue * sq , SyncQueueFrame dst , SyncQueueFrame src ) { if ( sq -> type == SYNC_QUEUE_PACKETS ) av_packet_move_ref ( dst . p , src . p ) ; else av_frame_move_ref ( dst . f , src . f ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@frame_ts": "static int64_t frame_ts ( const SyncQueue * sq , SyncQueueFrame frame ) { return ( sq -> type == SYNC_QUEUE_PACKETS ) ? frame . p -> pts + frame . p -> duration : frame . f -> pts + frame . f -> duration ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@frame_null": "static int frame_null ( const SyncQueue * sq , SyncQueueFrame frame ) { return ( sq -> type == SYNC_QUEUE_PACKETS ) ? ( frame . p == NULL ) : ( frame . f == NULL ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@finish_stream": "static void finish_stream ( SyncQueue * sq , unsigned int stream_idx ) { SyncQueueStream * st = & sq -> streams [ stream_idx ] ; st -> finished = 1 ; if ( st -> limiting && st -> head_ts != AV_NOPTS_VALUE ) { /* check if this stream is the new finished head */ if ( sq -> head_finished_stream < 0 || av_compare_ts ( st -> head_ts , st -> tb , sq -> streams [ sq -> head_finished_stream ] . head_ts , sq -> streams [ sq -> head_finished_stream ] . tb ) < 0 ) { sq -> head_finished_stream = stream_idx ; } /* mark as finished all streams that should no longer receive new frames,\n         * due to them being ahead of some finished stream */ st = & sq -> streams [ sq -> head_finished_stream ] ; for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueStream * st1 = & sq -> streams [ i ] ; if ( st != st1 && st1 -> head_ts != AV_NOPTS_VALUE && av_compare_ts ( st -> head_ts , st -> tb , st1 -> head_ts , st1 -> tb ) <= 0 ) st1 -> finished = 1 ; } } /* mark the whole queue as finished if all streams are finished */ for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { if ( ! sq -> streams [ i ] . finished ) return ; } sq -> finished = 1 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@queue_head_update": "static void queue_head_update ( SyncQueue * sq ) { if ( sq -> head_stream < 0 ) { /* wait for one timestamp in each stream before determining\n         * the queue head */ for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueStream * st = & sq -> streams [ i ] ; if ( st -> limiting && st -> head_ts == AV_NOPTS_VALUE ) return ; } // placeholder value, correct one will be found below sq -> head_stream = 0 ; } for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueStream * st_head = & sq -> streams [ sq -> head_stream ] ; SyncQueueStream * st_other = & sq -> streams [ i ] ; if ( st_other -> limiting && st_other -> head_ts != AV_NOPTS_VALUE && av_compare_ts ( st_other -> head_ts , st_other -> tb , st_head -> head_ts , st_head -> tb ) < 0 ) sq -> head_stream = i ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@stream_update_ts": "static void stream_update_ts ( SyncQueue * sq , unsigned int stream_idx , int64_t ts ) { SyncQueueStream * st = & sq -> streams [ stream_idx ] ; if ( ts == AV_NOPTS_VALUE || ( st -> head_ts != AV_NOPTS_VALUE && st -> head_ts >= ts ) ) return ; st -> head_ts = ts ; /* if this stream is now ahead of some finished stream, then\n     * this stream is also finished */ if ( sq -> head_finished_stream >= 0 && av_compare_ts ( sq -> streams [ sq -> head_finished_stream ] . head_ts , sq -> streams [ sq -> head_finished_stream ] . tb , ts , st -> tb ) <= 0 ) finish_stream ( sq , stream_idx ) ; /* update the overall head timestamp if it could have changed */ if ( st -> limiting && ( sq -> head_stream < 0 || sq -> head_stream == stream_idx ) ) queue_head_update ( sq ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@overflow_heartbeat": "static int overflow_heartbeat ( SyncQueue * sq , int stream_idx ) { SyncQueueStream * st ; SyncQueueFrame frame ; int64_t tail_ts = AV_NOPTS_VALUE ; /* if no stream specified, pick the one that is most ahead */ if ( stream_idx < 0 ) { int64_t ts = AV_NOPTS_VALUE ; for ( int i = 0 ; i < sq -> nb_streams ; i ++ ) { st = & sq -> streams [ i ] ; if ( st -> head_ts != AV_NOPTS_VALUE && ( ts == AV_NOPTS_VALUE || av_compare_ts ( ts , sq -> streams [ stream_idx ] . tb , st -> head_ts , st -> tb ) < 0 ) ) { ts = st -> head_ts ; stream_idx = i ; } } /* no stream has a timestamp yet -> nothing to do */ if ( stream_idx < 0 ) return 0 ; } st = & sq -> streams [ stream_idx ] ; /* get the chosen stream's tail timestamp */ for ( size_t i = 0 ; tail_ts == AV_NOPTS_VALUE && av_fifo_peek ( st -> fifo , & frame , 1 , i ) >= 0 ; i ++ ) tail_ts = frame_ts ( sq , frame ) ; /* overflow triggers when the tail is over specified duration behind the head */ if ( tail_ts == AV_NOPTS_VALUE || tail_ts >= st -> head_ts || av_rescale_q ( st -> head_ts - tail_ts , st -> tb , AV_TIME_BASE_Q ) < sq -> buf_size_us ) return 0 ; /* signal a fake timestamp for all streams that prevent tail_ts from being output */ tail_ts ++ ; for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueStream * st1 = & sq -> streams [ i ] ; int64_t ts ; if ( st == st1 || st1 -> finished || ( st1 -> head_ts != AV_NOPTS_VALUE && av_compare_ts ( tail_ts , st -> tb , st1 -> head_ts , st1 -> tb ) <= 0 ) ) continue ; ts = av_rescale_q ( tail_ts , st -> tb , st1 -> tb ) ; if ( st1 -> head_ts != AV_NOPTS_VALUE ) ts = FFMAX ( st1 -> head_ts + 1 , ts ) ; stream_update_ts ( sq , i , ts ) ; } return 1 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@sq_send": "int sq_send ( SyncQueue * sq , unsigned int stream_idx , SyncQueueFrame frame ) { SyncQueueStream * st ; SyncQueueFrame dst ; int64_t ts ; int ret ; av_assert0 ( stream_idx < sq -> nb_streams ) ; st = & sq -> streams [ stream_idx ] ; av_assert0 ( st -> tb . num > 0 && st -> tb . den > 0 ) ; if ( frame_null ( sq , frame ) ) { finish_stream ( sq , stream_idx ) ; return 0 ; } if ( st -> finished ) return AVERROR_EOF ; ret = objpool_get ( sq -> pool , ( void * * ) & dst ) ; if ( ret < 0 ) return ret ; frame_move ( sq , dst , frame ) ; ts = frame_ts ( sq , dst ) ; ret = av_fifo_write ( st -> fifo , & dst , 1 ) ; if ( ret < 0 ) { frame_move ( sq , frame , dst ) ; objpool_release ( sq -> pool , ( void * * ) & dst ) ; return ret ; } stream_update_ts ( sq , stream_idx , ts ) ; st -> frames_sent ++ ; if ( st -> frames_sent >= st -> frames_max ) finish_stream ( sq , stream_idx ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@receive_for_stream": "static int receive_for_stream ( SyncQueue * sq , unsigned int stream_idx , SyncQueueFrame frame ) { SyncQueueStream * st_head = sq -> head_stream >= 0 ? & sq -> streams [ sq -> head_stream ] : NULL ; SyncQueueStream * st ; av_assert0 ( stream_idx < sq -> nb_streams ) ; st = & sq -> streams [ stream_idx ] ; if ( av_fifo_can_read ( st -> fifo ) ) { SyncQueueFrame peek ; int64_t ts ; int cmp = 1 ; av_fifo_peek ( st -> fifo , & peek , 1 , 0 ) ; ts = frame_ts ( sq , peek ) ; /* check if this stream's tail timestamp does not overtake\n         * the overall queue head */ if ( ts != AV_NOPTS_VALUE && st_head ) cmp = av_compare_ts ( ts , st -> tb , st_head -> head_ts , st_head -> tb ) ; /* We can release frames that do not end after the queue head.\n         * Frames with no timestamps are just passed through with no conditions.\n         */ if ( cmp <= 0 || ts == AV_NOPTS_VALUE ) { frame_move ( sq , frame , peek ) ; objpool_release ( sq -> pool , ( void * * ) & peek ) ; av_fifo_drain2 ( st -> fifo , 1 ) ; return 0 ; } } return ( sq -> finished || ( st -> finished && ! av_fifo_can_read ( st -> fifo ) ) ) ? AVERROR_EOF : AVERROR ( EAGAIN ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@receive_internal": "static int receive_internal ( SyncQueue * sq , int stream_idx , SyncQueueFrame frame ) { int nb_eof = 0 ; int ret ; /* read a frame for a specific stream */ if ( stream_idx >= 0 ) { ret = receive_for_stream ( sq , stream_idx , frame ) ; return ( ret < 0 ) ? ret : stream_idx ; } /* read a frame for any stream with available output */ for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { ret = receive_for_stream ( sq , i , frame ) ; if ( ret == AVERROR_EOF || ret == AVERROR ( EAGAIN ) ) { nb_eof += ( ret == AVERROR_EOF ) ; continue ; } return ( ret < 0 ) ? ret : i ; } return ( nb_eof == sq -> nb_streams ) ? AVERROR_EOF : AVERROR ( EAGAIN ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@sq_receive": "int sq_receive ( SyncQueue * sq , int stream_idx , SyncQueueFrame frame ) { int ret = receive_internal ( sq , stream_idx , frame ) ; /* try again if the queue overflowed and triggered a fake heartbeat\n     * for lagging streams */ if ( ret == AVERROR ( EAGAIN ) && overflow_heartbeat ( sq , stream_idx ) ) ret = receive_internal ( sq , stream_idx , frame ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@sq_add_stream": "int sq_add_stream ( SyncQueue * sq , int limiting ) { SyncQueueStream * tmp , * st ; tmp = av_realloc_array ( sq -> streams , sq -> nb_streams + 1 , sizeof ( * sq -> streams ) ) ; if ( ! tmp ) return AVERROR ( ENOMEM ) ; sq -> streams = tmp ; st = & sq -> streams [ sq -> nb_streams ] ; memset ( st , 0 , sizeof ( * st ) ) ; st -> fifo = av_fifo_alloc2 ( 1 , sizeof ( SyncQueueFrame ) , AV_FIFO_FLAG_AUTO_GROW ) ; if ( ! st -> fifo ) return AVERROR ( ENOMEM ) ; /* we set a valid default, so that a pathological stream that never\n     * receives even a real timebase (and no frames) won't stall all other\n     * streams forever; cf. overflow_heartbeat() */ st -> tb = ( AVRational ) { 1 , 1 } ; st -> head_ts = AV_NOPTS_VALUE ; st -> frames_max = UINT64_MAX ; st -> limiting = limiting ; return sq -> nb_streams ++ ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@sq_set_tb": "void sq_set_tb ( SyncQueue * sq , unsigned int stream_idx , AVRational tb ) { SyncQueueStream * st ; av_assert0 ( stream_idx < sq -> nb_streams ) ; st = & sq -> streams [ stream_idx ] ; av_assert0 ( ! av_fifo_can_read ( st -> fifo ) ) ; if ( st -> head_ts != AV_NOPTS_VALUE ) st -> head_ts = av_rescale_q ( st -> head_ts , st -> tb , tb ) ; st -> tb = tb ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@sq_limit_frames": "void sq_limit_frames ( SyncQueue * sq , unsigned int stream_idx , uint64_t frames ) { SyncQueueStream * st ; av_assert0 ( stream_idx < sq -> nb_streams ) ; st = & sq -> streams [ stream_idx ] ; st -> frames_max = frames ; if ( st -> frames_sent >= st -> frames_max ) finish_stream ( sq , stream_idx ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@sq_alloc": "SyncQueue * sq_alloc ( enum SyncQueueType type , int64_t buf_size_us ) { SyncQueue * sq = av_mallocz ( sizeof ( * sq ) ) ; if ( ! sq ) return NULL ; sq -> type = type ; sq -> buf_size_us = buf_size_us ; sq -> head_stream = - 1 ; sq -> head_finished_stream = - 1 ; sq -> pool = ( type == SYNC_QUEUE_PACKETS ) ? objpool_alloc_packets ( ) : objpool_alloc_frames ( ) ; if ( ! sq -> pool ) { av_freep ( & sq ) ; return NULL ; } return sq ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_sync_queue.c@sq_free": "void sq_free ( SyncQueue * * psq ) { SyncQueue * sq = * psq ; if ( ! sq ) return ; for ( unsigned int i = 0 ; i < sq -> nb_streams ; i ++ ) { SyncQueueFrame frame ; while ( av_fifo_read ( sq -> streams [ i ] . fifo , & frame , 1 ) >= 0 ) objpool_release ( sq -> pool , ( void * * ) & frame ) ; av_fifo_freep2 ( & sq -> streams [ i ] . fifo ) ; } av_freep ( & sq -> streams ) ; objpool_free ( & sq -> pool ) ; av_freep ( psq ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@demuxer_from_ifile": "static Demuxer * demuxer_from_ifile ( InputFile * f ) { return ( Demuxer * ) f ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@report_new_stream": "static void report_new_stream ( Demuxer * d , const AVPacket * pkt ) { AVStream * st = d -> f . ctx -> streams [ pkt -> stream_index ] ; if ( pkt -> stream_index < d -> nb_streams_warn ) return ; av_log ( NULL , AV_LOG_WARNING , \"New %s stream %d:%d at pos:%\" PRId64 \" and DTS:%ss\\n\" , av_get_media_type_string ( st -> codecpar -> codec_type ) , d -> f . index , pkt -> stream_index , pkt -> pos , av_ts2timestr ( pkt -> dts , & st -> time_base ) ) ; d -> nb_streams_warn = pkt -> stream_index + 1 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@ifile_duration_update": "static void ifile_duration_update ( Demuxer * d , InputStream * ist , int64_t last_duration ) { /* the total duration of the stream, max_pts - min_pts is\n     * the duration of the stream without the last frame */ if ( ist -> max_pts > ist -> min_pts && ist -> max_pts - ( uint64_t ) ist -> min_pts < INT64_MAX - last_duration ) last_duration += ist -> max_pts - ist -> min_pts ; if ( ! d -> duration || av_compare_ts ( d -> duration , d -> time_base , last_duration , ist -> st -> time_base ) < 0 ) { d -> duration = last_duration ; d -> time_base = ist -> st -> time_base ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@seek_to_start": "static int seek_to_start ( Demuxer * d ) { InputFile * ifile = & d -> f ; AVFormatContext * is = ifile -> ctx ; InputStream * ist ; int ret ; ret = avformat_seek_file ( is , - 1 , INT64_MIN , is -> start_time , is -> start_time , 0 ) ; if ( ret < 0 ) return ret ; if ( ifile -> audio_duration_queue_size ) { /* duration is the length of the last frame in a stream\n         * when audio stream is present we don't care about\n         * last video frame length because it's not defined exactly */ int got_durations = 0 ; while ( got_durations < ifile -> audio_duration_queue_size ) { LastFrameDuration dur ; ret = av_thread_message_queue_recv ( ifile -> audio_duration_queue , & dur , 0 ) ; if ( ret < 0 ) return ret ; got_durations ++ ; ist = ifile -> streams [ dur . stream_idx ] ; ifile_duration_update ( d , ist , dur . duration ) ; } } else { for ( int i = 0 ; i < ifile -> nb_streams ; i ++ ) { int64_t duration = 0 ; ist = ifile -> streams [ i ] ; if ( ist -> framerate . num ) { duration = av_rescale_q ( 1 , av_inv_q ( ist -> framerate ) , ist -> st -> time_base ) ; } else if ( ist -> st -> avg_frame_rate . num ) { duration = av_rescale_q ( 1 , av_inv_q ( ist -> st -> avg_frame_rate ) , ist -> st -> time_base ) ; } else { duration = 1 ; } ifile_duration_update ( d , ist , duration ) ; } } if ( d -> loop > 0 ) d -> loop -- ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@ts_fixup": "static void ts_fixup ( Demuxer * d , AVPacket * pkt , int * repeat_pict ) { InputFile * ifile = & d -> f ; InputStream * ist = ifile -> streams [ pkt -> stream_index ] ; const int64_t start_time = ifile -> start_time_effective ; int64_t duration ; if ( debug_ts ) { av_log ( NULL , AV_LOG_INFO , \"demuxer -> ist_index:%d:%d type:%s \" \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s\\n\" , ifile -> index , pkt -> stream_index , av_get_media_type_string ( ist -> st -> codecpar -> codec_type ) , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & ist -> st -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & ist -> st -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & ist -> st -> time_base ) ) ; } if ( ! ist -> wrap_correction_done && start_time != AV_NOPTS_VALUE && ist -> st -> pts_wrap_bits < 64 ) { int64_t stime , stime2 ; stime = av_rescale_q ( start_time , AV_TIME_BASE_Q , ist -> st -> time_base ) ; stime2 = stime + ( 1ULL << ist -> st -> pts_wrap_bits ) ; ist -> wrap_correction_done = 1 ; if ( stime2 > stime && pkt -> dts != AV_NOPTS_VALUE && pkt -> dts > stime + ( 1LL << ( ist -> st -> pts_wrap_bits - 1 ) ) ) { pkt -> dts -= 1ULL << ist -> st -> pts_wrap_bits ; ist -> wrap_correction_done = 0 ; } if ( stime2 > stime && pkt -> pts != AV_NOPTS_VALUE && pkt -> pts > stime + ( 1LL << ( ist -> st -> pts_wrap_bits - 1 ) ) ) { pkt -> pts -= 1ULL << ist -> st -> pts_wrap_bits ; ist -> wrap_correction_done = 0 ; } } if ( pkt -> dts != AV_NOPTS_VALUE ) pkt -> dts += av_rescale_q ( ifile -> ts_offset , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts += av_rescale_q ( ifile -> ts_offset , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts *= ist -> ts_scale ; if ( pkt -> dts != AV_NOPTS_VALUE ) pkt -> dts *= ist -> ts_scale ; duration = av_rescale_q ( d -> duration , d -> time_base , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) { pkt -> pts += duration ; ist -> max_pts = FFMAX ( pkt -> pts , ist -> max_pts ) ; ist -> min_pts = FFMIN ( pkt -> pts , ist -> min_pts ) ; } if ( pkt -> dts != AV_NOPTS_VALUE ) pkt -> dts += duration ; * repeat_pict = - 1 ; if ( ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && av_stream_get_parser ( ist -> st ) ) * repeat_pict = av_stream_get_parser ( ist -> st ) -> repeat_pict ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@thread_set_name": "static void thread_set_name ( InputFile * f ) { char name [ 16 ] ; snprintf ( name , sizeof ( name ) , \"dmx%d:%s\" , f -> index , f -> ctx -> iformat -> name ) ; ff_thread_setname ( name ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@input_thread": "static void * input_thread ( void * arg ) { Demuxer * d = arg ; InputFile * f = & d -> f ; AVPacket * pkt ; unsigned flags = d -> non_blocking ? AV_THREAD_MESSAGE_NONBLOCK : 0 ; int ret = 0 ; pkt = av_packet_alloc ( ) ; if ( ! pkt ) { ret = AVERROR ( ENOMEM ) ; goto finish ; } thread_set_name ( f ) ; while ( 1 ) { DemuxMsg msg = { NULL } ; ret = av_read_frame ( f -> ctx , pkt ) ; if ( ret == AVERROR ( EAGAIN ) ) { av_usleep ( 10000 ) ; continue ; } if ( ret < 0 ) { if ( d -> loop ) { /* signal looping to the consumer thread */ msg . looping = 1 ; ret = av_thread_message_queue_send ( d -> in_thread_queue , & msg , 0 ) ; if ( ret >= 0 ) ret = seek_to_start ( d ) ; if ( ret >= 0 ) continue ; /* fallthrough to the error path */ } if ( ret == AVERROR_EOF ) av_log ( NULL , AV_LOG_VERBOSE , \"EOF in input file %d\\n\" , f -> index ) ; else av_log ( NULL , AV_LOG_ERROR , \"Error demuxing input file %d: %s\\n\" , f -> index , av_err2str ( ret ) ) ; break ; } if ( do_pkt_dump ) { av_pkt_dump_log2 ( NULL , AV_LOG_INFO , pkt , do_hex_dump , f -> ctx -> streams [ pkt -> stream_index ] ) ; } /* the following test is needed in case new streams appear\n           dynamically in stream : we ignore them */ if ( pkt -> stream_index >= f -> nb_streams ) { report_new_stream ( d , pkt ) ; av_packet_unref ( pkt ) ; continue ; } if ( pkt -> flags & AV_PKT_FLAG_CORRUPT ) { av_log ( NULL , exit_on_error ? AV_LOG_FATAL : AV_LOG_WARNING , \"%s: corrupt input packet in stream %d\\n\" , f -> ctx -> url , pkt -> stream_index ) ; if ( exit_on_error ) { av_packet_unref ( pkt ) ; ret = AVERROR_INVALIDDATA ; break ; } } ts_fixup ( d , pkt , & msg . repeat_pict ) ; msg . pkt = av_packet_alloc ( ) ; if ( ! msg . pkt ) { av_packet_unref ( pkt ) ; ret = AVERROR ( ENOMEM ) ; break ; } av_packet_move_ref ( msg . pkt , pkt ) ; ret = av_thread_message_queue_send ( d -> in_thread_queue , & msg , flags ) ; if ( flags && ret == AVERROR ( EAGAIN ) ) { flags = 0 ; ret = av_thread_message_queue_send ( d -> in_thread_queue , & msg , flags ) ; av_log ( f -> ctx , AV_LOG_WARNING , \"Thread message queue blocking; consider raising the \" \"thread_queue_size option (current value: %d)\\n\" , d -> thread_queue_size ) ; } if ( ret < 0 ) { if ( ret != AVERROR_EOF ) av_log ( f -> ctx , AV_LOG_ERROR , \"Unable to send packet to main thread: %s\\n\" , av_err2str ( ret ) ) ; av_packet_free ( & msg . pkt ) ; break ; } } finish : av_assert0 ( ret < 0 ) ; av_thread_message_queue_set_err_recv ( d -> in_thread_queue , ret ) ; av_packet_free ( & pkt ) ; av_log ( NULL , AV_LOG_VERBOSE , \"Terminating demuxer thread %d\\n\" , f -> index ) ; return NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@thread_stop": "static void thread_stop ( Demuxer * d ) { InputFile * f = & d -> f ; DemuxMsg msg ; if ( ! d -> in_thread_queue ) return ; av_thread_message_queue_set_err_send ( d -> in_thread_queue , AVERROR_EOF ) ; while ( av_thread_message_queue_recv ( d -> in_thread_queue , & msg , 0 ) >= 0 ) av_packet_free ( & msg . pkt ) ; pthread_join ( d -> thread , NULL ) ; av_thread_message_queue_free ( & d -> in_thread_queue ) ; av_thread_message_queue_free ( & f -> audio_duration_queue ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@thread_start": "static int thread_start ( Demuxer * d ) { int ret ; InputFile * f = & d -> f ; if ( d -> thread_queue_size <= 0 ) d -> thread_queue_size = ( nb_input_files > 1 ? 8 : 1 ) ; if ( nb_input_files > 1 && ( f -> ctx -> pb ? ! f -> ctx -> pb -> seekable : strcmp ( f -> ctx -> iformat -> name , \"lavfi\" ) ) ) d -> non_blocking = 1 ; ret = av_thread_message_queue_alloc ( & d -> in_thread_queue , d -> thread_queue_size , sizeof ( DemuxMsg ) ) ; if ( ret < 0 ) return ret ; if ( d -> loop ) { int nb_audio_dec = 0 ; for ( int i = 0 ; i < f -> nb_streams ; i ++ ) { InputStream * ist = f -> streams [ i ] ; nb_audio_dec += ! ! ( ist -> decoding_needed && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) ; } if ( nb_audio_dec ) { ret = av_thread_message_queue_alloc ( & f -> audio_duration_queue , nb_audio_dec , sizeof ( LastFrameDuration ) ) ; if ( ret < 0 ) goto fail ; f -> audio_duration_queue_size = nb_audio_dec ; } } if ( ( ret = pthread_create ( & d -> thread , NULL , input_thread , d ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"pthread_create failed: %s. Try to increase `ulimit -v` or decrease `ulimit -s`.\\n\" , strerror ( ret ) ) ; ret = AVERROR ( ret ) ; goto fail ; } return 0 ; fail : av_thread_message_queue_free ( & d -> in_thread_queue ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@ifile_get_packet": "int ifile_get_packet ( InputFile * f , AVPacket * * pkt ) { Demuxer * d = demuxer_from_ifile ( f ) ; InputStream * ist ; DemuxMsg msg ; int ret ; if ( ! d -> in_thread_queue ) { ret = thread_start ( d ) ; if ( ret < 0 ) return ret ; } if ( f -> readrate || f -> rate_emu ) { int i ; int64_t file_start = copy_ts * ( ( f -> start_time_effective != AV_NOPTS_VALUE ? f -> start_time_effective * ! start_at_zero : 0 ) + ( f -> start_time != AV_NOPTS_VALUE ? f -> start_time : 0 ) ) ; float scale = f -> rate_emu ? 1.0 : f -> readrate ; for ( i = 0 ; i < f -> nb_streams ; i ++ ) { InputStream * ist = f -> streams [ i ] ; int64_t stream_ts_offset , pts , now ; if ( ! ist -> nb_packets || ( ist -> decoding_needed && ! ist -> got_output ) ) continue ; stream_ts_offset = FFMAX ( ist -> first_dts != AV_NOPTS_VALUE ? ist -> first_dts : 0 , file_start ) ; pts = av_rescale ( ist -> dts , 1000000 , AV_TIME_BASE ) ; now = ( av_gettime_relative ( ) - ist -> start ) * scale + stream_ts_offset ; if ( pts > now ) return AVERROR ( EAGAIN ) ; } } ret = av_thread_message_queue_recv ( d -> in_thread_queue , & msg , d -> non_blocking ? AV_THREAD_MESSAGE_NONBLOCK : 0 ) ; if ( ret < 0 ) return ret ; if ( msg . looping ) return 1 ; ist = f -> streams [ msg . pkt -> stream_index ] ; ist -> last_pkt_repeat_pict = msg . repeat_pict ; * pkt = msg . pkt ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@ist_free": "static void ist_free ( InputStream * * pist ) { InputStream * ist = * pist ; if ( ! ist ) return ; av_frame_free ( & ist -> decoded_frame ) ; av_packet_free ( & ist -> pkt ) ; av_dict_free ( & ist -> decoder_opts ) ; avsubtitle_free ( & ist -> prev_sub . subtitle ) ; av_frame_free ( & ist -> sub2video . frame ) ; av_freep ( & ist -> filters ) ; av_freep ( & ist -> hwaccel_device ) ; av_freep ( & ist -> dts_buffer ) ; avcodec_free_context ( & ist -> dec_ctx ) ; avcodec_parameters_free ( & ist -> par ) ; av_freep ( pist ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@ifile_close": "void ifile_close ( InputFile * * pf ) { InputFile * f = * pf ; Demuxer * d = demuxer_from_ifile ( f ) ; if ( ! f ) return ; thread_stop ( d ) ; for ( int i = 0 ; i < f -> nb_streams ; i ++ ) ist_free ( & f -> streams [ i ] ) ; av_freep ( & f -> streams ) ; avformat_close_input ( & f -> ctx ) ; av_freep ( pf ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@choose_decoder": "static const AVCodec * choose_decoder ( const OptionsContext * o , AVFormatContext * s , AVStream * st , enum HWAccelID hwaccel_id , enum AVHWDeviceType hwaccel_device_type ) { char * codec_name = NULL ; MATCH_PER_STREAM_OPT ( codec_names , str , codec_name , s , st ) ; if ( codec_name ) { const AVCodec * codec = find_codec_or_die ( NULL , codec_name , st -> codecpar -> codec_type , 0 ) ; st -> codecpar -> codec_id = codec -> id ; if ( recast_media && st -> codecpar -> codec_type != codec -> type ) st -> codecpar -> codec_type = codec -> type ; return codec ; } else { if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && hwaccel_id == HWACCEL_GENERIC && hwaccel_device_type != AV_HWDEVICE_TYPE_NONE ) { const AVCodec * c ; void * i = NULL ; while ( ( c = av_codec_iterate ( & i ) ) ) { const AVCodecHWConfig * config ; if ( c -> id != st -> codecpar -> codec_id || ! av_codec_is_decoder ( c ) ) continue ; for ( int j = 0 ; ( config = avcodec_get_hw_config ( c , j ) ) ; j ++ ) { if ( config -> device_type == hwaccel_device_type ) { av_log ( NULL , AV_LOG_VERBOSE , \"Selecting decoder '%s' because of requested hwaccel method %s\\n\" , c -> name , av_hwdevice_get_type_name ( hwaccel_device_type ) ) ; return c ; } } } } return avcodec_find_decoder ( st -> codecpar -> codec_id ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@guess_input_channel_layout": "static int guess_input_channel_layout ( InputStream * ist ) { AVCodecContext * dec = ist -> dec_ctx ; if ( dec -> ch_layout . order == AV_CHANNEL_ORDER_UNSPEC ) { char layout_name [ 256 ] ; if ( dec -> ch_layout . nb_channels > ist -> guess_layout_max ) return 0 ; av_channel_layout_default ( & dec -> ch_layout , dec -> ch_layout . nb_channels ) ; if ( dec -> ch_layout . order == AV_CHANNEL_ORDER_UNSPEC ) return 0 ; av_channel_layout_describe ( & dec -> ch_layout , layout_name , sizeof ( layout_name ) ) ; av_log ( NULL , AV_LOG_WARNING , \"Guessed Channel Layout for Input Stream \" \"#%d.%d : %s\\n\" , ist -> file_index , ist -> st -> index , layout_name ) ; } return 1 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@add_display_matrix_to_stream": "static void add_display_matrix_to_stream ( const OptionsContext * o , AVFormatContext * ctx , AVStream * st ) { double rotation = DBL_MAX ; int hflip = - 1 , vflip = - 1 ; int hflip_set = 0 , vflip_set = 0 , rotation_set = 0 ; int32_t * buf ; MATCH_PER_STREAM_OPT ( display_rotations , dbl , rotation , ctx , st ) ; MATCH_PER_STREAM_OPT ( display_hflips , i , hflip , ctx , st ) ; MATCH_PER_STREAM_OPT ( display_vflips , i , vflip , ctx , st ) ; rotation_set = rotation != DBL_MAX ; hflip_set = hflip != - 1 ; vflip_set = vflip != - 1 ; if ( ! rotation_set && ! hflip_set && ! vflip_set ) return ; buf = ( int32_t * ) av_stream_new_side_data ( st , AV_PKT_DATA_DISPLAYMATRIX , sizeof ( int32_t ) * 9 ) ; if ( ! buf ) { av_log ( NULL , AV_LOG_FATAL , \"Failed to generate a display matrix!\\n\" ) ; exit_program ( 1 ) ; } av_display_rotation_set ( buf , rotation_set ? - ( rotation ) : - 0.0f ) ; av_display_matrix_flip ( buf , hflip_set ? hflip : 0 , vflip_set ? vflip : 0 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@add_input_streams": "static void add_input_streams ( const OptionsContext * o , Demuxer * d ) { InputFile * f = & d -> f ; AVFormatContext * ic = f -> ctx ; int i , ret ; for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { AVStream * st = ic -> streams [ i ] ; AVCodecParameters * par = st -> codecpar ; InputStream * ist ; char * framerate = NULL , * hwaccel_device = NULL ; const char * hwaccel = NULL ; char * hwaccel_output_format = NULL ; char * codec_tag = NULL ; char * next ; char * discard_str = NULL ; const AVClass * cc = avcodec_get_class ( ) ; const AVOption * discard_opt = av_opt_find ( & cc , \"skip_frame\" , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ; ist = ALLOC_ARRAY_ELEM ( f -> streams , f -> nb_streams ) ; ist -> st = st ; ist -> file_index = f -> index ; ist -> discard = 1 ; st -> discard = AVDISCARD_ALL ; ist -> nb_samples = 0 ; ist -> first_dts = AV_NOPTS_VALUE ; ist -> min_pts = INT64_MAX ; ist -> max_pts = INT64_MIN ; ist -> ts_scale = 1.0 ; MATCH_PER_STREAM_OPT ( ts_scale , dbl , ist -> ts_scale , ic , st ) ; ist -> autorotate = 1 ; MATCH_PER_STREAM_OPT ( autorotate , i , ist -> autorotate , ic , st ) ; MATCH_PER_STREAM_OPT ( codec_tags , str , codec_tag , ic , st ) ; if ( codec_tag ) { uint32_t tag = strtol ( codec_tag , & next , 0 ) ; if ( * next ) tag = AV_RL32 ( codec_tag ) ; st -> codecpar -> codec_tag = tag ; } if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { add_display_matrix_to_stream ( o , ic , st ) ; MATCH_PER_STREAM_OPT ( hwaccels , str , hwaccel , ic , st ) ; MATCH_PER_STREAM_OPT ( hwaccel_output_formats , str , hwaccel_output_format , ic , st ) ; if ( ! hwaccel_output_format && hwaccel && ! strcmp ( hwaccel , \"cuvid\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"WARNING: defaulting hwaccel_output_format to cuda for compatibility \" \"with old commandlines. This behaviour is DEPRECATED and will be removed \" \"in the future. Please explicitly set \\\"-hwaccel_output_format cuda\\\".\\n\" ) ; ist -> hwaccel_output_format = AV_PIX_FMT_CUDA ; } else if ( ! hwaccel_output_format && hwaccel && ! strcmp ( hwaccel , \"qsv\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"WARNING: defaulting hwaccel_output_format to qsv for compatibility \" \"with old commandlines. This behaviour is DEPRECATED and will be removed \" \"in the future. Please explicitly set \\\"-hwaccel_output_format qsv\\\".\\n\" ) ; ist -> hwaccel_output_format = AV_PIX_FMT_QSV ; } else if ( ! hwaccel_output_format && hwaccel && ! strcmp ( hwaccel , \"mediacodec\" ) ) { // There is no real AVHWFrameContext implementation. Set // hwaccel_output_format to avoid av_hwframe_transfer_data error. ist -> hwaccel_output_format = AV_PIX_FMT_MEDIACODEC ; } else if ( hwaccel_output_format ) { ist -> hwaccel_output_format = av_get_pix_fmt ( hwaccel_output_format ) ; if ( ist -> hwaccel_output_format == AV_PIX_FMT_NONE ) { av_log ( NULL , AV_LOG_FATAL , \"Unrecognised hwaccel output \" \"format: %s\" , hwaccel_output_format ) ; } } else { ist -> hwaccel_output_format = AV_PIX_FMT_NONE ; } if ( hwaccel ) { // The NVDEC hwaccels use a CUDA device, so remap the name here. if ( ! strcmp ( hwaccel , \"nvdec\" ) || ! strcmp ( hwaccel , \"cuvid\" ) ) hwaccel = \"cuda\" ; if ( ! strcmp ( hwaccel , \"none\" ) ) ist -> hwaccel_id = HWACCEL_NONE ; else if ( ! strcmp ( hwaccel , \"auto\" ) ) ist -> hwaccel_id = HWACCEL_AUTO ; else { enum AVHWDeviceType type = av_hwdevice_find_type_by_name ( hwaccel ) ; if ( type != AV_HWDEVICE_TYPE_NONE ) { ist -> hwaccel_id = HWACCEL_GENERIC ; ist -> hwaccel_device_type = type ; } if ( ! ist -> hwaccel_id ) { av_log ( NULL , AV_LOG_FATAL , \"Unrecognized hwaccel: %s.\\n\" , hwaccel ) ; av_log ( NULL , AV_LOG_FATAL , \"Supported hwaccels: \" ) ; type = AV_HWDEVICE_TYPE_NONE ; while ( ( type = av_hwdevice_iterate_types ( type ) ) != AV_HWDEVICE_TYPE_NONE ) av_log ( NULL , AV_LOG_FATAL , \"%s \" , av_hwdevice_get_type_name ( type ) ) ; av_log ( NULL , AV_LOG_FATAL , \"\\n\" ) ; exit_program ( 1 ) ; } } } MATCH_PER_STREAM_OPT ( hwaccel_devices , str , hwaccel_device , ic , st ) ; if ( hwaccel_device ) { ist -> hwaccel_device = av_strdup ( hwaccel_device ) ; if ( ! ist -> hwaccel_device ) report_and_exit ( AVERROR ( ENOMEM ) ) ; } ist -> hwaccel_pix_fmt = AV_PIX_FMT_NONE ; } ist -> dec = choose_decoder ( o , ic , st , ist -> hwaccel_id , ist -> hwaccel_device_type ) ; ist -> decoder_opts = filter_codec_opts ( o -> g -> codec_opts , ist -> st -> codecpar -> codec_id , ic , st , ist -> dec ) ; ist -> reinit_filters = - 1 ; MATCH_PER_STREAM_OPT ( reinit_filters , i , ist -> reinit_filters , ic , st ) ; MATCH_PER_STREAM_OPT ( discard , str , discard_str , ic , st ) ; ist -> user_set_discard = AVDISCARD_NONE ; if ( ( o -> video_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) || ( o -> audio_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) || ( o -> subtitle_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_SUBTITLE ) || ( o -> data_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) ) ist -> user_set_discard = AVDISCARD_ALL ; if ( discard_str && av_opt_eval_int ( & cc , discard_opt , discard_str , & ist -> user_set_discard ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing discard %s.\\n\" , discard_str ) ; exit_program ( 1 ) ; } ist -> filter_in_rescale_delta_last = AV_NOPTS_VALUE ; ist -> prev_pkt_pts = AV_NOPTS_VALUE ; ist -> dec_ctx = avcodec_alloc_context3 ( ist -> dec ) ; if ( ! ist -> dec_ctx ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ret = avcodec_parameters_to_context ( ist -> dec_ctx , par ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error initializing the decoder context.\\n\" ) ; exit_program ( 1 ) ; } ist -> decoded_frame = av_frame_alloc ( ) ; if ( ! ist -> decoded_frame ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ist -> pkt = av_packet_alloc ( ) ; if ( ! ist -> pkt ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( o -> bitexact ) ist -> dec_ctx -> flags |= AV_CODEC_FLAG_BITEXACT ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : // avformat_find_stream_info() doesn't set this for us anymore. ist -> dec_ctx -> framerate = st -> avg_frame_rate ; MATCH_PER_STREAM_OPT ( frame_rates , str , framerate , ic , st ) ; if ( framerate && av_parse_video_rate ( & ist -> framerate , framerate ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing framerate %s.\\n\" , framerate ) ; exit_program ( 1 ) ; } ist -> top_field_first = - 1 ; MATCH_PER_STREAM_OPT ( top_field_first , i , ist -> top_field_first , ic , st ) ; ist -> framerate_guessed = av_guess_frame_rate ( ic , st , NULL ) ; break ; case AVMEDIA_TYPE_AUDIO : ist -> guess_layout_max = INT_MAX ; MATCH_PER_STREAM_OPT ( guess_layout_max , i , ist -> guess_layout_max , ic , st ) ; guess_input_channel_layout ( ist ) ; break ; case AVMEDIA_TYPE_DATA : case AVMEDIA_TYPE_SUBTITLE : { char * canvas_size = NULL ; MATCH_PER_STREAM_OPT ( fix_sub_duration , i , ist -> fix_sub_duration , ic , st ) ; MATCH_PER_STREAM_OPT ( canvas_sizes , str , canvas_size , ic , st ) ; if ( canvas_size && av_parse_video_size ( & ist -> dec_ctx -> width , & ist -> dec_ctx -> height , canvas_size ) < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid canvas size: %s.\\n\" , canvas_size ) ; exit_program ( 1 ) ; } break ; } case AVMEDIA_TYPE_ATTACHMENT : case AVMEDIA_TYPE_UNKNOWN : break ; default : abort ( ) ; } ist -> par = avcodec_parameters_alloc ( ) ; if ( ! ist -> par ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ret = avcodec_parameters_from_context ( ist -> par , ist -> dec_ctx ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error initializing the decoder context.\\n\" ) ; exit_program ( 1 ) ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@dump_attachment": "static void dump_attachment ( AVStream * st , const char * filename ) { int ret ; AVIOContext * out = NULL ; const AVDictionaryEntry * e ; if ( ! st -> codecpar -> extradata_size ) { av_log ( NULL , AV_LOG_WARNING , \"No extradata to dump in stream #%d:%d.\\n\" , nb_input_files - 1 , st -> index ) ; return ; } if ( ! * filename && ( e = av_dict_get ( st -> metadata , \"filename\" , NULL , 0 ) ) ) filename = e -> value ; if ( ! * filename ) { av_log ( NULL , AV_LOG_FATAL , \"No filename specified and no 'filename' tag\" \"in stream #%d:%d.\\n\" , nb_input_files - 1 , st -> index ) ; exit_program ( 1 ) ; } assert_file_overwrite ( filename ) ; if ( ( ret = avio_open2 ( & out , filename , AVIO_FLAG_WRITE , & int_cb , NULL ) ) < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Could not open file %s for writing.\\n\" , filename ) ; exit_program ( 1 ) ; } avio_write ( out , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ; avio_flush ( out ) ; avio_close ( out ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_demux.c@ifile_open": "int ifile_open ( const OptionsContext * o , const char * filename ) { Demuxer * d ; InputFile * f ; AVFormatContext * ic ; const AVInputFormat * file_iformat = NULL ; int err , i , ret ; int64_t timestamp ; AVDictionary * unused_opts = NULL ; const AVDictionaryEntry * e = NULL ; char * video_codec_name = NULL ; char * audio_codec_name = NULL ; char * subtitle_codec_name = NULL ; char * data_codec_name = NULL ; int scan_all_pmts_set = 0 ; int64_t start_time = o -> start_time ; int64_t start_time_eof = o -> start_time_eof ; int64_t stop_time = o -> stop_time ; int64_t recording_time = o -> recording_time ; if ( stop_time != INT64_MAX && recording_time != INT64_MAX ) { stop_time = INT64_MAX ; av_log ( NULL , AV_LOG_WARNING , \"-t and -to cannot be used together; using -t.\\n\" ) ; } if ( stop_time != INT64_MAX && recording_time == INT64_MAX ) { int64_t start = start_time == AV_NOPTS_VALUE ? 0 : start_time ; if ( stop_time <= start ) { av_log ( NULL , AV_LOG_ERROR , \"-to value smaller than -ss; aborting.\\n\" ) ; exit_program ( 1 ) ; } else { recording_time = stop_time - start ; } } if ( o -> format ) { if ( ! ( file_iformat = av_find_input_format ( o -> format ) ) ) { av_log ( NULL , AV_LOG_FATAL , \"Unknown input format: '%s'\\n\" , o -> format ) ; exit_program ( 1 ) ; } } if ( ! strcmp ( filename , \"-\" ) ) filename = \"fd:\" ; stdin_interaction &= strncmp ( filename , \"pipe:\" , 5 ) && strcmp ( filename , \"fd:\" ) && strcmp ( filename , \"/dev/stdin\" ) ; /* get default parameters from command line */ ic = avformat_alloc_context ( ) ; if ( ! ic ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( o -> nb_audio_sample_rate ) { av_dict_set_int ( & o -> g -> format_opts , \"sample_rate\" , o -> audio_sample_rate [ o -> nb_audio_sample_rate - 1 ] . u . i , 0 ) ; } if ( o -> nb_audio_channels ) { const AVClass * priv_class ; if ( file_iformat && ( priv_class = file_iformat -> priv_class ) && av_opt_find ( & priv_class , \"ch_layout\" , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ) { char buf [ 32 ] ; snprintf ( buf , sizeof ( buf ) , \"%dC\" , o -> audio_channels [ o -> nb_audio_channels - 1 ] . u . i ) ; av_dict_set ( & o -> g -> format_opts , \"ch_layout\" , buf , 0 ) ; } } if ( o -> nb_audio_ch_layouts ) { const AVClass * priv_class ; if ( file_iformat && ( priv_class = file_iformat -> priv_class ) && av_opt_find ( & priv_class , \"ch_layout\" , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ) { av_dict_set ( & o -> g -> format_opts , \"ch_layout\" , o -> audio_ch_layouts [ o -> nb_audio_ch_layouts - 1 ] . u . str , 0 ) ; } } if ( o -> nb_frame_rates ) { const AVClass * priv_class ; /* set the format-level framerate option;\n         * this is important for video grabbers, e.g. x11 */ if ( file_iformat && ( priv_class = file_iformat -> priv_class ) && av_opt_find ( & priv_class , \"framerate\" , NULL , 0 , AV_OPT_SEARCH_FAKE_OBJ ) ) { av_dict_set ( & o -> g -> format_opts , \"framerate\" , o -> frame_rates [ o -> nb_frame_rates - 1 ] . u . str , 0 ) ; } } if ( o -> nb_frame_sizes ) { av_dict_set ( & o -> g -> format_opts , \"video_size\" , o -> frame_sizes [ o -> nb_frame_sizes - 1 ] . u . str , 0 ) ; } if ( o -> nb_frame_pix_fmts ) av_dict_set ( & o -> g -> format_opts , \"pixel_format\" , o -> frame_pix_fmts [ o -> nb_frame_pix_fmts - 1 ] . u . str , 0 ) ; MATCH_PER_TYPE_OPT ( codec_names , str , video_codec_name , ic , \"v\" ) ; MATCH_PER_TYPE_OPT ( codec_names , str , audio_codec_name , ic , \"a\" ) ; MATCH_PER_TYPE_OPT ( codec_names , str , subtitle_codec_name , ic , \"s\" ) ; MATCH_PER_TYPE_OPT ( codec_names , str , data_codec_name , ic , \"d\" ) ; if ( video_codec_name ) ic -> video_codec = find_codec_or_die ( NULL , video_codec_name , AVMEDIA_TYPE_VIDEO , 0 ) ; if ( audio_codec_name ) ic -> audio_codec = find_codec_or_die ( NULL , audio_codec_name , AVMEDIA_TYPE_AUDIO , 0 ) ; if ( subtitle_codec_name ) ic -> subtitle_codec = find_codec_or_die ( NULL , subtitle_codec_name , AVMEDIA_TYPE_SUBTITLE , 0 ) ; if ( data_codec_name ) ic -> data_codec = find_codec_or_die ( NULL , data_codec_name , AVMEDIA_TYPE_DATA , 0 ) ; ic -> video_codec_id = video_codec_name ? ic -> video_codec -> id : AV_CODEC_ID_NONE ; ic -> audio_codec_id = audio_codec_name ? ic -> audio_codec -> id : AV_CODEC_ID_NONE ; ic -> subtitle_codec_id = subtitle_codec_name ? ic -> subtitle_codec -> id : AV_CODEC_ID_NONE ; ic -> data_codec_id = data_codec_name ? ic -> data_codec -> id : AV_CODEC_ID_NONE ; ic -> flags |= AVFMT_FLAG_NONBLOCK ; if ( o -> bitexact ) ic -> flags |= AVFMT_FLAG_BITEXACT ; ic -> interrupt_callback = int_cb ; if ( ! av_dict_get ( o -> g -> format_opts , \"scan_all_pmts\" , NULL , AV_DICT_MATCH_CASE ) ) { av_dict_set ( & o -> g -> format_opts , \"scan_all_pmts\" , \"1\" , AV_DICT_DONT_OVERWRITE ) ; scan_all_pmts_set = 1 ; } /* open the input file with generic avformat function */ err = avformat_open_input ( & ic , filename , file_iformat , & o -> g -> format_opts ) ; if ( err < 0 ) { print_error ( filename , err ) ; if ( err == AVERROR_PROTOCOL_NOT_FOUND ) av_log ( NULL , AV_LOG_ERROR , \"Did you mean file:%s?\\n\" , filename ) ; exit_program ( 1 ) ; } if ( scan_all_pmts_set ) av_dict_set ( & o -> g -> format_opts , \"scan_all_pmts\" , NULL , AV_DICT_MATCH_CASE ) ; remove_avoptions ( & o -> g -> format_opts , o -> g -> codec_opts ) ; assert_avoptions ( o -> g -> format_opts ) ; /* apply forced codec ids */ for ( i = 0 ; i < ic -> nb_streams ; i ++ ) choose_decoder ( o , ic , ic -> streams [ i ] , HWACCEL_NONE , AV_HWDEVICE_TYPE_NONE ) ; if ( o -> find_stream_info ) { AVDictionary * * opts = setup_find_stream_info_opts ( ic , o -> g -> codec_opts ) ; int orig_nb_streams = ic -> nb_streams ; /* If not enough info to get the stream parameters, we decode the\n           first frames to get it. (used in mpeg case for example) */ ret = avformat_find_stream_info ( ic , opts ) ; for ( i = 0 ; i < orig_nb_streams ; i ++ ) av_dict_free ( & opts [ i ] ) ; av_freep ( & opts ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"%s: could not find codec parameters\\n\" , filename ) ; if ( ic -> nb_streams == 0 ) { avformat_close_input ( & ic ) ; exit_program ( 1 ) ; } } } if ( start_time != AV_NOPTS_VALUE && start_time_eof != AV_NOPTS_VALUE ) { av_log ( NULL , AV_LOG_WARNING , \"Cannot use -ss and -sseof both, using -ss for %s\\n\" , filename ) ; start_time_eof = AV_NOPTS_VALUE ; } if ( start_time_eof != AV_NOPTS_VALUE ) { if ( start_time_eof >= 0 ) { av_log ( NULL , AV_LOG_ERROR , \"-sseof value must be negative; aborting\\n\" ) ; exit_program ( 1 ) ; } if ( ic -> duration > 0 ) { start_time = start_time_eof + ic -> duration ; if ( start_time < 0 ) { av_log ( NULL , AV_LOG_WARNING , \"-sseof value seeks to before start of file %s; ignored\\n\" , filename ) ; start_time = AV_NOPTS_VALUE ; } } else av_log ( NULL , AV_LOG_WARNING , \"Cannot use -sseof, duration of %s not known\\n\" , filename ) ; } timestamp = ( start_time == AV_NOPTS_VALUE ) ? 0 : start_time ; /* add the stream start time */ if ( ! o -> seek_timestamp && ic -> start_time != AV_NOPTS_VALUE ) timestamp += ic -> start_time ; /* if seeking requested, we execute it */ if ( start_time != AV_NOPTS_VALUE ) { int64_t seek_timestamp = timestamp ; if ( ! ( ic -> iformat -> flags & AVFMT_SEEK_TO_PTS ) ) { int dts_heuristic = 0 ; for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { const AVCodecParameters * par = ic -> streams [ i ] -> codecpar ; if ( par -> video_delay ) { dts_heuristic = 1 ; break ; } } if ( dts_heuristic ) { seek_timestamp -= 3 * AV_TIME_BASE / 23 ; } } ret = avformat_seek_file ( ic , - 1 , INT64_MIN , seek_timestamp , seek_timestamp , 0 ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_WARNING , \"%s: could not seek to position %0.3f\\n\" , filename , ( double ) timestamp / AV_TIME_BASE ) ; } } d = allocate_array_elem ( & input_files , sizeof ( * d ) , & nb_input_files ) ; f = & d -> f ; f -> ctx = ic ; f -> index = nb_input_files - 1 ; f -> start_time = start_time ; f -> recording_time = recording_time ; f -> input_sync_ref = o -> input_sync_ref ; f -> input_ts_offset = o -> input_ts_offset ; f -> ts_offset = o -> input_ts_offset - ( copy_ts ? ( start_at_zero && ic -> start_time != AV_NOPTS_VALUE ? ic -> start_time : 0 ) : timestamp ) ; f -> rate_emu = o -> rate_emu ; f -> accurate_seek = o -> accurate_seek ; d -> loop = o -> loop ; d -> duration = 0 ; d -> time_base = ( AVRational ) { 1 , 1 } ; f -> readrate = o -> readrate ? o -> readrate : 0.0 ; if ( f -> readrate < 0.0f ) { av_log ( NULL , AV_LOG_ERROR , \"Option -readrate for Input #%d is %0.3f; it must be non-negative.\\n\" , f -> index , f -> readrate ) ; exit_program ( 1 ) ; } if ( f -> readrate && f -> rate_emu ) { av_log ( NULL , AV_LOG_WARNING , \"Both -readrate and -re set for Input #%d. Using -readrate %0.3f.\\n\" , f -> index , f -> readrate ) ; f -> rate_emu = 0 ; } d -> thread_queue_size = o -> thread_queue_size ; /* update the current parameters so that they match the one of the input stream */ add_input_streams ( o , d ) ; /* dump the file content */ av_dump_format ( ic , f -> index , filename , 0 ) ; /* check if all codec options have been used */ unused_opts = strip_specifiers ( o -> g -> codec_opts ) ; for ( i = 0 ; i < f -> nb_streams ; i ++ ) { e = NULL ; while ( ( e = av_dict_iterate ( f -> streams [ i ] -> decoder_opts , e ) ) ) av_dict_set ( & unused_opts , e -> key , NULL , 0 ) ; } e = NULL ; while ( ( e = av_dict_iterate ( unused_opts , e ) ) ) { const AVClass * class = avcodec_get_class ( ) ; const AVOption * option = av_opt_find ( & class , e -> key , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ; const AVClass * fclass = avformat_get_class ( ) ; const AVOption * foption = av_opt_find ( & fclass , e -> key , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ; if ( ! option || foption ) continue ; if ( ! ( option -> flags & AV_OPT_FLAG_DECODING_PARAM ) ) { av_log ( NULL , AV_LOG_ERROR , \"Codec AVOption %s (%s) specified for \" \"input file #%d (%s) is not a decoding option.\\n\" , e -> key , option -> help ? option -> help : \"\" , f -> index , filename ) ; exit_program ( 1 ) ; } av_log ( NULL , AV_LOG_WARNING , \"Codec AVOption %s (%s) specified for \" \"input file #%d (%s) has not been used for any stream. The most \" \"likely reason is either wrong type (e.g. a video option with \" \"no video streams) or that it is a private option of some decoder \" \"which was not actually used for any stream.\\n\" , e -> key , option -> help ? option -> help : \"\" , f -> index , filename ) ; } av_dict_free ( & unused_opts ) ; for ( i = 0 ; i < o -> nb_dump_attachment ; i ++ ) { int j ; for ( j = 0 ; j < ic -> nb_streams ; j ++ ) { AVStream * st = ic -> streams [ j ] ; if ( check_stream_specifier ( ic , st , o -> dump_attachment [ i ] . specifier ) == 1 ) dump_attachment ( st , o -> dump_attachment [ i ] . u . str ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_objpool.c@objpool_alloc": "ObjPool * objpool_alloc ( ObjPoolCBAlloc cb_alloc , ObjPoolCBReset cb_reset , ObjPoolCBFree cb_free ) { ObjPool * op = av_mallocz ( sizeof ( * op ) ) ; if ( ! op ) return NULL ; op -> alloc = cb_alloc ; op -> reset = cb_reset ; op -> free = cb_free ; return op ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_objpool.c@objpool_free": "void objpool_free ( ObjPool * * pop ) { ObjPool * op = * pop ; if ( ! op ) return ; for ( unsigned int i = 0 ; i < op -> pool_count ; i ++ ) op -> free ( & op -> pool [ i ] ) ; av_freep ( pop ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_objpool.c@objpool_get": "int objpool_get ( ObjPool * op , void * * obj ) { if ( op -> pool_count ) { * obj = op -> pool [ -- op -> pool_count ] ; op -> pool [ op -> pool_count ] = NULL ; } else * obj = op -> alloc ( ) ; return * obj ? 0 : AVERROR ( ENOMEM ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_objpool.c@objpool_release": "void objpool_release ( ObjPool * op , void * * obj ) { if ( ! * obj ) return ; op -> reset ( * obj ) ; if ( op -> pool_count < FF_ARRAY_ELEMS ( op -> pool ) ) op -> pool [ op -> pool_count ++ ] = * obj ; else op -> free ( obj ) ; * obj = NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_objpool.c@alloc_packet": "static void * alloc_packet ( void ) { return av_packet_alloc ( ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_objpool.c@alloc_frame": "static void * alloc_frame ( void ) { return av_frame_alloc ( ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_objpool.c@reset_packet": "static void reset_packet ( void * obj ) { av_packet_unref ( obj ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_objpool.c@reset_frame": "static void reset_frame ( void * obj ) { av_frame_unref ( obj ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_objpool.c@free_packet": "static void free_packet ( void * * obj ) { AVPacket * pkt = * obj ; av_packet_free ( & pkt ) ; * obj = NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_objpool.c@free_frame": "static void free_frame ( void * * obj ) { AVFrame * frame = * obj ; av_frame_free ( & frame ) ; * obj = NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_objpool.c@objpool_alloc_packets": "ObjPool * objpool_alloc_packets ( void ) { return objpool_alloc ( alloc_packet , reset_packet , free_packet ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_objpool.c@objpool_alloc_frames": "ObjPool * objpool_alloc_frames ( void ) { return objpool_alloc ( alloc_frame , reset_frame , free_frame ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@log_callback": "static void log_callback ( void * ptr , int level , const char * fmt , va_list vl ) { AVClass * avc = ptr ? * ( AVClass * * ) ptr : NULL ; va_list vl2 ; char line [ 1024 ] ; static int print_prefix = 1 ; void * new_log_buffer ; va_copy ( vl2 , vl ) ; av_log_default_callback ( ptr , level , fmt , vl ) ; av_log_format_line ( ptr , level , fmt , vl2 , line , sizeof ( line ) , & print_prefix ) ; va_end ( vl2 ) ; # if HAVE_THREADS pthread_mutex_lock ( & log_mutex ) ; new_log_buffer = av_realloc_array ( log_buffer , log_buffer_size + 1 , sizeof ( * log_buffer ) ) ; if ( new_log_buffer ) { char * msg ; int i ; log_buffer = new_log_buffer ; memset ( & log_buffer [ log_buffer_size ] , 0 , sizeof ( log_buffer [ log_buffer_size ] ) ) ; log_buffer [ log_buffer_size ] . context_name = avc ? av_strdup ( avc -> item_name ( ptr ) ) : NULL ; if ( avc ) { if ( avc -> get_category ) log_buffer [ log_buffer_size ] . category = avc -> get_category ( ptr ) ; else log_buffer [ log_buffer_size ] . category = avc -> category ; } log_buffer [ log_buffer_size ] . log_level = level ; msg = log_buffer [ log_buffer_size ] . log_message = av_strdup ( line ) ; for ( i = strlen ( msg ) - 1 ; i >= 0 && msg [ i ] == '\\n' ; i -- ) { msg [ i ] = 0 ; } if ( avc && avc -> parent_log_context_offset ) { AVClass * * parent = * ( AVClass * * * ) ( ( ( uint8_t * ) ptr ) + avc -> parent_log_context_offset ) ; if ( parent && * parent ) { log_buffer [ log_buffer_size ] . parent_name = av_strdup ( ( * parent ) -> item_name ( parent ) ) ; log_buffer [ log_buffer_size ] . parent_category = ( * parent ) -> get_category ? ( * parent ) -> get_category ( parent ) : ( * parent ) -> category ; } } log_buffer_size ++ ; } pthread_mutex_unlock ( & log_mutex ) ; # endif }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@ffprobe_cleanup": "static void ffprobe_cleanup ( int ret ) { int i ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( sections ) ; i ++ ) av_dict_free ( & ( sections [ i ] . entries_to_show ) ) ; # if HAVE_THREADS pthread_mutex_destroy ( & log_mutex ) ; # endif }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@value_string": "static char * value_string ( char * buf , int buf_size , struct unit_value uv ) { double vald ; long long int vali ; int show_float = 0 ; if ( uv . unit == unit_second_str ) { vald = uv . val . d ; show_float = 1 ; } else { vald = vali = uv . val . i ; } if ( uv . unit == unit_second_str && use_value_sexagesimal_format ) { double secs ; int hours , mins ; secs = vald ; mins = ( int ) secs / 60 ; secs = secs - mins * 60 ; hours = mins / 60 ; mins %= 60 ; snprintf ( buf , buf_size , \"%d:%02d:%09.6f\" , hours , mins , secs ) ; } else { const char * prefix_string = \"\" ; if ( use_value_prefix && vald > 1 ) { long long int index ; if ( uv . unit == unit_byte_str && use_byte_value_binary_prefix ) { index = ( long long int ) ( log2 ( vald ) ) / 10 ; index = av_clip ( index , 0 , FF_ARRAY_ELEMS ( si_prefixes ) - 1 ) ; vald /= si_prefixes [ index ] . bin_val ; prefix_string = si_prefixes [ index ] . bin_str ; } else { index = ( long long int ) ( log10 ( vald ) ) / 3 ; index = av_clip ( index , 0 , FF_ARRAY_ELEMS ( si_prefixes ) - 1 ) ; vald /= si_prefixes [ index ] . dec_val ; prefix_string = si_prefixes [ index ] . dec_str ; } vali = vald ; } if ( show_float || ( use_value_prefix && vald != ( long long int ) vald ) ) snprintf ( buf , buf_size , \"%f\" , vald ) ; else snprintf ( buf , buf_size , \"%lld\" , vali ) ; av_strlcatf ( buf , buf_size , \"%s%s%s\" , * prefix_string || show_value_unit ? \" \" : \"\" , prefix_string , show_value_unit ? uv . unit : \"\" ) ; } return buf ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_get_name": "static const char * writer_get_name ( void * p ) { WriterContext * wctx = p ; return wctx -> writer -> name ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_child_next": "static void * writer_child_next ( void * obj , void * prev ) { WriterContext * ctx = obj ; if ( ! prev && ctx -> writer && ctx -> writer -> priv_class && ctx -> priv ) return ctx -> priv ; return NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_close": "static int writer_close ( WriterContext * * wctx ) { int i ; int ret = 0 ; if ( ! * wctx ) return - 1 ; if ( ( * wctx ) -> writer -> uninit ) ( * wctx ) -> writer -> uninit ( * wctx ) ; for ( i = 0 ; i < SECTION_MAX_NB_LEVELS ; i ++ ) av_bprint_finalize ( & ( * wctx ) -> section_pbuf [ i ] , NULL ) ; if ( ( * wctx ) -> writer -> priv_class ) av_opt_free ( ( * wctx ) -> priv ) ; av_freep ( & ( ( * wctx ) -> priv ) ) ; av_opt_free ( * wctx ) ; if ( ( * wctx ) -> avio ) { avio_flush ( ( * wctx ) -> avio ) ; ret = avio_close ( ( * wctx ) -> avio ) ; } av_freep ( wctx ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@bprint_bytes": "static void bprint_bytes ( AVBPrint * bp , const uint8_t * ubuf , size_t ubuf_size ) { int i ; av_bprintf ( bp , \"0X\" ) ; for ( i = 0 ; i < ubuf_size ; i ++ ) av_bprintf ( bp , \"%02X\" , ubuf [ i ] ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_w8_avio": "static inline void writer_w8_avio ( WriterContext * wctx , int b ) { avio_w8 ( wctx -> avio , b ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_put_str_avio": "static inline void writer_put_str_avio ( WriterContext * wctx , const char * str ) { avio_write ( wctx -> avio , str , strlen ( str ) ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_printf_avio": "static inline void writer_printf_avio ( WriterContext * wctx , const char * fmt , ... ) { va_list ap ; va_start ( ap , fmt ) ; avio_vprintf ( wctx -> avio , fmt , ap ) ; va_end ( ap ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_w8_printf": "static inline void writer_w8_printf ( WriterContext * wctx , int b ) { av_log ( NULL , AV_LOG_STDERR , \"%c\" , b ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_put_str_printf": "static inline void writer_put_str_printf ( WriterContext * wctx , const char * str ) { av_log ( NULL , AV_LOG_STDERR , \"%s\" , str ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_printf_printf": "static inline void writer_printf_printf ( WriterContext * wctx , const char * fmt , ... ) { va_list ap ; va_start ( ap , fmt ) ; av_vlog ( NULL , AV_LOG_STDERR , fmt , ap ) ; va_end ( ap ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_open": "static int writer_open ( WriterContext * * wctx , const Writer * writer , const char * args , const struct section * sections , int nb_sections , const char * output ) { int i , ret = 0 ; if ( ! ( * wctx = av_mallocz ( sizeof ( WriterContext ) ) ) ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } if ( ! ( ( * wctx ) -> priv = av_mallocz ( writer -> priv_size ) ) ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } ( * wctx ) -> class = & writer_class ; ( * wctx ) -> writer = writer ; ( * wctx ) -> level = - 1 ; ( * wctx ) -> sections = sections ; ( * wctx ) -> nb_sections = nb_sections ; av_opt_set_defaults ( * wctx ) ; if ( writer -> priv_class ) { void * priv_ctx = ( * wctx ) -> priv ; * ( ( const AVClass * * ) priv_ctx ) = writer -> priv_class ; av_opt_set_defaults ( priv_ctx ) ; } /* convert options to dictionary */ if ( args ) { AVDictionary * opts = NULL ; const AVDictionaryEntry * opt = NULL ; if ( ( ret = av_dict_parse_string ( & opts , args , \"=\" , \":\" , 0 ) ) < 0 ) { av_log ( * wctx , AV_LOG_ERROR , \"Failed to parse option string '%s' provided to writer context\\n\" , args ) ; av_dict_free ( & opts ) ; goto fail ; } while ( ( opt = av_dict_iterate ( opts , opt ) ) ) { if ( ( ret = av_opt_set ( * wctx , opt -> key , opt -> value , AV_OPT_SEARCH_CHILDREN ) ) < 0 ) { av_log ( * wctx , AV_LOG_ERROR , \"Failed to set option '%s' with value '%s' provided to writer context\\n\" , opt -> key , opt -> value ) ; av_dict_free ( & opts ) ; goto fail ; } } av_dict_free ( & opts ) ; } /* validate replace string */ { const uint8_t * p = ( * wctx ) -> string_validation_replacement ; const uint8_t * endp = p + strlen ( p ) ; while ( * p ) { const uint8_t * p0 = p ; int32_t code ; ret = av_utf8_decode ( & code , & p , endp , ( * wctx ) -> string_validation_utf8_flags ) ; if ( ret < 0 ) { AVBPrint bp ; av_bprint_init ( & bp , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; bprint_bytes ( & bp , p0 , p - p0 ) , av_log ( wctx , AV_LOG_ERROR , \"Invalid UTF8 sequence %s found in string validation replace '%s'\\n\" , bp . str , ( * wctx ) -> string_validation_replacement ) ; return ret ; } } } if ( ! output_filename ) { ( * wctx ) -> writer_w8 = writer_w8_printf ; ( * wctx ) -> writer_put_str = writer_put_str_printf ; ( * wctx ) -> writer_printf = writer_printf_printf ; } else { if ( ( ret = avio_open ( & ( * wctx ) -> avio , output , AVIO_FLAG_WRITE ) ) < 0 ) { av_log ( * wctx , AV_LOG_ERROR , \"Failed to open output '%s' with error: %s\\n\" , output , av_err2str ( ret ) ) ; goto fail ; } ( * wctx ) -> writer_w8 = writer_w8_avio ; ( * wctx ) -> writer_put_str = writer_put_str_avio ; ( * wctx ) -> writer_printf = writer_printf_avio ; } for ( i = 0 ; i < SECTION_MAX_NB_LEVELS ; i ++ ) av_bprint_init ( & ( * wctx ) -> section_pbuf [ i ] , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; if ( ( * wctx ) -> writer -> init ) ret = ( * wctx ) -> writer -> init ( * wctx ) ; if ( ret < 0 ) goto fail ; return 0 ; fail : writer_close ( wctx ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_print_section_header": "static inline void writer_print_section_header ( WriterContext * wctx , int section_id ) { int parent_section_id ; wctx -> level ++ ; av_assert0 ( wctx -> level < SECTION_MAX_NB_LEVELS ) ; parent_section_id = wctx -> level ? ( wctx -> section [ wctx -> level - 1 ] ) -> id : SECTION_ID_NONE ; wctx -> nb_item [ wctx -> level ] = 0 ; wctx -> section [ wctx -> level ] = & wctx -> sections [ section_id ] ; if ( section_id == SECTION_ID_PACKETS_AND_FRAMES ) { wctx -> nb_section_packet = wctx -> nb_section_frame = wctx -> nb_section_packet_frame = 0 ; } else if ( parent_section_id == SECTION_ID_PACKETS_AND_FRAMES ) { wctx -> nb_section_packet_frame = section_id == SECTION_ID_PACKET ? wctx -> nb_section_packet : wctx -> nb_section_frame ; } if ( wctx -> writer -> print_section_header ) wctx -> writer -> print_section_header ( wctx ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_print_section_footer": "static inline void writer_print_section_footer ( WriterContext * wctx ) { int section_id = wctx -> section [ wctx -> level ] -> id ; int parent_section_id = wctx -> level ? wctx -> section [ wctx -> level - 1 ] -> id : SECTION_ID_NONE ; if ( parent_section_id != SECTION_ID_NONE ) wctx -> nb_item [ wctx -> level - 1 ] ++ ; if ( parent_section_id == SECTION_ID_PACKETS_AND_FRAMES ) { if ( section_id == SECTION_ID_PACKET ) wctx -> nb_section_packet ++ ; else wctx -> nb_section_frame ++ ; } if ( wctx -> writer -> print_section_footer ) wctx -> writer -> print_section_footer ( wctx ) ; wctx -> level -- ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_print_integer": "static inline void writer_print_integer ( WriterContext * wctx , const char * key , long long int val ) { const struct section * section = wctx -> section [ wctx -> level ] ; if ( section -> show_all_entries || av_dict_get ( section -> entries_to_show , key , NULL , 0 ) ) { wctx -> writer -> print_integer ( wctx , key , val ) ; wctx -> nb_item [ wctx -> level ] ++ ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@validate_string": "static inline int validate_string ( WriterContext * wctx , char * * dstp , const char * src ) { const uint8_t * p , * endp ; AVBPrint dstbuf ; int invalid_chars_nb = 0 , ret = 0 ; av_bprint_init ( & dstbuf , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; endp = src + strlen ( src ) ; for ( p = ( uint8_t * ) src ; * p ; ) { uint32_t code ; int invalid = 0 ; const uint8_t * p0 = p ; if ( av_utf8_decode ( & code , & p , endp , wctx -> string_validation_utf8_flags ) < 0 ) { AVBPrint bp ; av_bprint_init ( & bp , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; bprint_bytes ( & bp , p0 , p - p0 ) ; av_log ( wctx , AV_LOG_DEBUG , \"Invalid UTF-8 sequence %s found in string '%s'\\n\" , bp . str , src ) ; invalid = 1 ; } if ( invalid ) { invalid_chars_nb ++ ; switch ( wctx -> string_validation ) { case WRITER_STRING_VALIDATION_FAIL : av_log ( wctx , AV_LOG_ERROR , \"Invalid UTF-8 sequence found in string '%s'\\n\" , src ) ; ret = AVERROR_INVALIDDATA ; goto end ; break ; case WRITER_STRING_VALIDATION_REPLACE : av_bprintf ( & dstbuf , \"%s\" , wctx -> string_validation_replacement ) ; break ; } } if ( ! invalid || wctx -> string_validation == WRITER_STRING_VALIDATION_IGNORE ) av_bprint_append_data ( & dstbuf , p0 , p - p0 ) ; } if ( invalid_chars_nb && wctx -> string_validation == WRITER_STRING_VALIDATION_REPLACE ) { av_log ( wctx , AV_LOG_WARNING , \"%d invalid UTF-8 sequence(s) found in string '%s', replaced with '%s'\\n\" , invalid_chars_nb , src , wctx -> string_validation_replacement ) ; } end : av_bprint_finalize ( & dstbuf , dstp ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_print_string": "static inline int writer_print_string ( WriterContext * wctx , const char * key , const char * val , int flags ) { const struct section * section = wctx -> section [ wctx -> level ] ; int ret = 0 ; if ( show_optional_fields == SHOW_OPTIONAL_FIELDS_NEVER || ( show_optional_fields == SHOW_OPTIONAL_FIELDS_AUTO && ( flags & PRINT_STRING_OPT ) && ! ( wctx -> writer -> flags & WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS ) ) ) return 0 ; if ( section -> show_all_entries || av_dict_get ( section -> entries_to_show , key , NULL , 0 ) ) { if ( flags & PRINT_STRING_VALIDATE ) { char * key1 = NULL , * val1 = NULL ; ret = validate_string ( wctx , & key1 , key ) ; if ( ret < 0 ) goto end ; ret = validate_string ( wctx , & val1 , val ) ; if ( ret < 0 ) goto end ; wctx -> writer -> print_string ( wctx , key1 , val1 ) ; end : if ( ret < 0 ) { av_log ( wctx , AV_LOG_ERROR , \"Invalid key=value string combination %s=%s in section %s\\n\" , key , val , section -> unique_name ) ; } av_free ( key1 ) ; av_free ( val1 ) ; } else { wctx -> writer -> print_string ( wctx , key , val ) ; } wctx -> nb_item [ wctx -> level ] ++ ; } return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_print_rational": "static inline void writer_print_rational ( WriterContext * wctx , const char * key , AVRational q , char sep ) { AVBPrint buf ; av_bprint_init ( & buf , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; av_bprintf ( & buf , \"%d%c%d\" , q . num , sep , q . den ) ; writer_print_string ( wctx , key , buf . str , 0 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_print_time": "static void writer_print_time ( WriterContext * wctx , const char * key , int64_t ts , const AVRational * time_base , int is_duration ) { char buf [ 128 ] ; if ( ( ! is_duration && ts == AV_NOPTS_VALUE ) || ( is_duration && ts == 0 ) ) { writer_print_string ( wctx , key , \"N/A\" , PRINT_STRING_OPT ) ; } else { double d = ts * av_q2d ( * time_base ) ; struct unit_value uv ; uv . val . d = d ; uv . unit = unit_second_str ; value_string ( buf , sizeof ( buf ) , uv ) ; writer_print_string ( wctx , key , buf , 0 ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_print_ts": "static void writer_print_ts ( WriterContext * wctx , const char * key , int64_t ts , int is_duration ) { if ( ( ! is_duration && ts == AV_NOPTS_VALUE ) || ( is_duration && ts == 0 ) ) { writer_print_string ( wctx , key , \"N/A\" , PRINT_STRING_OPT ) ; } else { writer_print_integer ( wctx , key , ts ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_print_data": "static void writer_print_data ( WriterContext * wctx , const char * name , const uint8_t * data , int size ) { AVBPrint bp ; int offset = 0 , l , i ; av_bprint_init ( & bp , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; av_bprintf ( & bp , \"\\n\" ) ; while ( size ) { av_bprintf ( & bp , \"%08x: \" , offset ) ; l = FFMIN ( size , 16 ) ; for ( i = 0 ; i < l ; i ++ ) { av_bprintf ( & bp , \"%02x\" , data [ i ] ) ; if ( i & 1 ) av_bprintf ( & bp , \" \" ) ; } av_bprint_chars ( & bp , ' ' , 41 - 2 * i - i / 2 ) ; for ( i = 0 ; i < l ; i ++ ) av_bprint_chars ( & bp , data [ i ] - 32U < 95 ? data [ i ] : '.' , 1 ) ; av_bprintf ( & bp , \"\\n\" ) ; offset += l ; data += l ; size -= l ; } writer_print_string ( wctx , name , bp . str , 0 ) ; av_bprint_finalize ( & bp , NULL ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_print_data_hash": "static void writer_print_data_hash ( WriterContext * wctx , const char * name , const uint8_t * data , int size ) { char * p , buf [ AV_HASH_MAX_SIZE * 2 + 64 ] = { 0 } ; if ( ! hash ) return ; av_hash_init ( hash ) ; av_hash_update ( hash , data , size ) ; snprintf ( buf , sizeof ( buf ) , \"%s:\" , av_hash_get_name ( hash ) ) ; p = buf + strlen ( buf ) ; av_hash_final_hex ( hash , p , buf + sizeof ( buf ) - p ) ; writer_print_string ( wctx , name , buf , 0 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_print_integers": "static void writer_print_integers ( WriterContext * wctx , const char * name , uint8_t * data , int size , const char * format , int columns , int bytes , int offset_add ) { AVBPrint bp ; int offset = 0 , l , i ; av_bprint_init ( & bp , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; av_bprintf ( & bp , \"\\n\" ) ; while ( size ) { av_bprintf ( & bp , \"%08x: \" , offset ) ; l = FFMIN ( size , columns ) ; for ( i = 0 ; i < l ; i ++ ) { if ( bytes == 1 ) av_bprintf ( & bp , format , * data ) ; else if ( bytes == 2 ) av_bprintf ( & bp , format , AV_RN16 ( data ) ) ; else if ( bytes == 4 ) av_bprintf ( & bp , format , AV_RN32 ( data ) ) ; data += bytes ; size -- ; } av_bprintf ( & bp , \"\\n\" ) ; offset += offset_add ; } writer_print_string ( wctx , name , bp . str , 0 ) ; av_bprint_finalize ( & bp , NULL ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_register": "static int writer_register ( const Writer * writer ) { if ( next_registered_writer_idx == MAX_REGISTERED_WRITERS_NB ) return AVERROR ( ENOMEM ) ; registered_writers [ next_registered_writer_idx ++ ] = writer ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_get_by_name": "static const Writer * writer_get_by_name ( const char * name ) { int i ; for ( i = 0 ; registered_writers [ i ] ; i ++ ) if ( ! strcmp ( registered_writers [ i ] -> name , name ) ) return registered_writers [ i ] ; return NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@default_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@upcase_string": "static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@default_print_section_header": "static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@default_print_section_footer": "static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@default_print_str": "static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@default_print_int": "static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@c_escape_str": "static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@csv_escape_str": "static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@none_escape_str": "static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@compact_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@compact_init": "static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@compact_print_section_header": "static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@compact_print_section_footer": "static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@compact_print_str": "static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@compact_print_int": "static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@csv_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@flat_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv ) ; static const Writer csv_writer = { . name = \"csv\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & csv_class , } ; /* Flat output */ typedef struct FlatContext { const AVClass * class ; const char * sep_str ; char sep ; int hierarchical ; } FlatContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( FlatContext , x ) static const AVOption flat_options [ ] = { { \"sep_char\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"s\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( flat )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@flat_init": "static av_cold int flat_init ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; if ( strlen ( flat -> sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , flat -> sep_str ) ; return AVERROR ( EINVAL ) ; } flat -> sep = flat -> sep_str [ 0 ] ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@flat_escape_key_str": "static const char * flat_escape_key_str ( AVBPrint * dst , const char * src , const char sep ) { const char * p ; for ( p = src ; * p ; p ++ ) { if ( ! ( ( * p >= '0' && * p <= '9' ) || ( * p >= 'a' && * p <= 'z' ) || ( * p >= 'A' && * p <= 'Z' ) ) ) av_bprint_chars ( dst , '_' , 1 ) ; else av_bprint_chars ( dst , * p , 1 ) ; } return dst -> str ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@flat_escape_value_str": "static const char * flat_escape_value_str ( AVBPrint * dst , const char * src ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; case '\"' : av_bprintf ( dst , \"%s\" , \"\\\\\\\"\" ) ; break ; case '`' : av_bprintf ( dst , \"%s\" , \"\\\\`\" ) ; break ; case '$' : av_bprintf ( dst , \"%s\" , \"\\\\$\" ) ; break ; default : av_bprint_chars ( dst , * p , 1 ) ; break ; } } return dst -> str ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@flat_print_section_header": "static void flat_print_section_header ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; /* build section header */ av_bprint_clear ( buf ) ; if ( ! parent_section ) return ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( flat -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , wctx -> section [ wctx -> level ] -> name , flat -> sep_str ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \"%d%s\" , n , flat -> sep_str ) ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@flat_print_int": "static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s%s=%lld\\n\" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@flat_print_str": "static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) { FlatContext * flat = wctx -> priv ; AVBPrint buf ; writer_put_str ( wctx , wctx -> section_pbuf [ wctx -> level ] . str ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"\\\"%s\\\"\\n\" , flat_escape_value_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@ini_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv ) ; static const Writer csv_writer = { . name = \"csv\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & csv_class , } ; /* Flat output */ typedef struct FlatContext { const AVClass * class ; const char * sep_str ; char sep ; int hierarchical ; } FlatContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( FlatContext , x ) static const AVOption flat_options [ ] = { { \"sep_char\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"s\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( flat ) ; static av_cold int flat_init ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; if ( strlen ( flat -> sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , flat -> sep_str ) ; return AVERROR ( EINVAL ) ; } flat -> sep = flat -> sep_str [ 0 ] ; return 0 ; } static const char * flat_escape_key_str ( AVBPrint * dst , const char * src , const char sep ) { const char * p ; for ( p = src ; * p ; p ++ ) { if ( ! ( ( * p >= '0' && * p <= '9' ) || ( * p >= 'a' && * p <= 'z' ) || ( * p >= 'A' && * p <= 'Z' ) ) ) av_bprint_chars ( dst , '_' , 1 ) ; else av_bprint_chars ( dst , * p , 1 ) ; } return dst -> str ; } static const char * flat_escape_value_str ( AVBPrint * dst , const char * src ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; case '\"' : av_bprintf ( dst , \"%s\" , \"\\\\\\\"\" ) ; break ; case '`' : av_bprintf ( dst , \"%s\" , \"\\\\`\" ) ; break ; case '$' : av_bprintf ( dst , \"%s\" , \"\\\\$\" ) ; break ; default : av_bprint_chars ( dst , * p , 1 ) ; break ; } } return dst -> str ; } static void flat_print_section_header ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; /* build section header */ av_bprint_clear ( buf ) ; if ( ! parent_section ) return ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( flat -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , wctx -> section [ wctx -> level ] -> name , flat -> sep_str ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \"%d%s\" , n , flat -> sep_str ) ; } } } static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s%s=%lld\\n\" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ; } static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) { FlatContext * flat = wctx -> priv ; AVBPrint buf ; writer_put_str ( wctx , wctx -> section_pbuf [ wctx -> level ] . str ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"\\\"%s\\\"\\n\" , flat_escape_value_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static const Writer flat_writer = { . name = \"flat\" , . priv_size = sizeof ( FlatContext ) , . init = flat_init , . print_section_header = flat_print_section_header , . print_integer = flat_print_int , . print_string = flat_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & flat_class , } ; /* INI format output */ typedef struct INIContext { const AVClass * class ; int hierarchical ; } INIContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( INIContext , x ) static const AVOption ini_options [ ] = { { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( ini )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@ini_escape_str": "static char * ini_escape_str ( AVBPrint * dst , const char * src ) { int i = 0 ; char c = 0 ; while ( ( c = src [ i ++ ] ) ) { switch ( c ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\t' : av_bprintf ( dst , \"%s\" , \"\\\\t\" ) ; break ; case '\\\\' : case '#' : case '=' : case ':' : av_bprint_chars ( dst , '\\\\' , 1 ) ; default : if ( ( unsigned char ) c < 32 ) av_bprintf ( dst , \"\\\\x00%02x\" , c & 0xff ) ; else av_bprint_chars ( dst , c , 1 ) ; break ; } } return dst -> str ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@ini_print_section_header": "static void ini_print_section_header ( WriterContext * wctx ) { INIContext * ini = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( buf ) ; if ( ! parent_section ) { writer_put_str ( wctx , \"# ffprobe output\\n\\n\" ) ; return ; } if ( wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , '\\n' ) ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( ini -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , buf -> str [ 0 ] ? \".\" : \"\" , wctx -> section [ wctx -> level ] -> name ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \".%d\" , n ) ; } } if ( ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) writer_printf ( wctx , \"[%s]\\n\" , buf -> str ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@ini_print_str": "static void ini_print_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , ini_escape_str ( & buf , key ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"%s\\n\" , ini_escape_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@ini_print_int": "static void ini_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s=%lld\\n\" , key , value ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@json_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv ) ; static const Writer csv_writer = { . name = \"csv\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & csv_class , } ; /* Flat output */ typedef struct FlatContext { const AVClass * class ; const char * sep_str ; char sep ; int hierarchical ; } FlatContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( FlatContext , x ) static const AVOption flat_options [ ] = { { \"sep_char\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"s\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( flat ) ; static av_cold int flat_init ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; if ( strlen ( flat -> sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , flat -> sep_str ) ; return AVERROR ( EINVAL ) ; } flat -> sep = flat -> sep_str [ 0 ] ; return 0 ; } static const char * flat_escape_key_str ( AVBPrint * dst , const char * src , const char sep ) { const char * p ; for ( p = src ; * p ; p ++ ) { if ( ! ( ( * p >= '0' && * p <= '9' ) || ( * p >= 'a' && * p <= 'z' ) || ( * p >= 'A' && * p <= 'Z' ) ) ) av_bprint_chars ( dst , '_' , 1 ) ; else av_bprint_chars ( dst , * p , 1 ) ; } return dst -> str ; } static const char * flat_escape_value_str ( AVBPrint * dst , const char * src ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; case '\"' : av_bprintf ( dst , \"%s\" , \"\\\\\\\"\" ) ; break ; case '`' : av_bprintf ( dst , \"%s\" , \"\\\\`\" ) ; break ; case '$' : av_bprintf ( dst , \"%s\" , \"\\\\$\" ) ; break ; default : av_bprint_chars ( dst , * p , 1 ) ; break ; } } return dst -> str ; } static void flat_print_section_header ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; /* build section header */ av_bprint_clear ( buf ) ; if ( ! parent_section ) return ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( flat -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , wctx -> section [ wctx -> level ] -> name , flat -> sep_str ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \"%d%s\" , n , flat -> sep_str ) ; } } } static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s%s=%lld\\n\" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ; } static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) { FlatContext * flat = wctx -> priv ; AVBPrint buf ; writer_put_str ( wctx , wctx -> section_pbuf [ wctx -> level ] . str ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"\\\"%s\\\"\\n\" , flat_escape_value_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static const Writer flat_writer = { . name = \"flat\" , . priv_size = sizeof ( FlatContext ) , . init = flat_init , . print_section_header = flat_print_section_header , . print_integer = flat_print_int , . print_string = flat_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & flat_class , } ; /* INI format output */ typedef struct INIContext { const AVClass * class ; int hierarchical ; } INIContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( INIContext , x ) static const AVOption ini_options [ ] = { { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( ini ) ; static char * ini_escape_str ( AVBPrint * dst , const char * src ) { int i = 0 ; char c = 0 ; while ( ( c = src [ i ++ ] ) ) { switch ( c ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\t' : av_bprintf ( dst , \"%s\" , \"\\\\t\" ) ; break ; case '\\\\' : case '#' : case '=' : case ':' : av_bprint_chars ( dst , '\\\\' , 1 ) ; default : if ( ( unsigned char ) c < 32 ) av_bprintf ( dst , \"\\\\x00%02x\" , c & 0xff ) ; else av_bprint_chars ( dst , c , 1 ) ; break ; } } return dst -> str ; } static void ini_print_section_header ( WriterContext * wctx ) { INIContext * ini = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( buf ) ; if ( ! parent_section ) { writer_put_str ( wctx , \"# ffprobe output\\n\\n\" ) ; return ; } if ( wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , '\\n' ) ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( ini -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , buf -> str [ 0 ] ? \".\" : \"\" , wctx -> section [ wctx -> level ] -> name ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \".%d\" , n ) ; } } if ( ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) writer_printf ( wctx , \"[%s]\\n\" , buf -> str ) ; } static void ini_print_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , ini_escape_str ( & buf , key ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"%s\\n\" , ini_escape_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void ini_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s=%lld\\n\" , key , value ) ; } static const Writer ini_writer = { . name = \"ini\" , . priv_size = sizeof ( INIContext ) , . print_section_header = ini_print_section_header , . print_integer = ini_print_int , . print_string = ini_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & ini_class , } ; /* JSON output */ typedef struct JSONContext { const AVClass * class ; int indent_level ; int compact ; const char * item_sep , * item_start_end ; } JSONContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( JSONContext , x ) static const AVOption json_options [ ] = { { \"compact\" , \"enable compact output\" , OFFSET ( compact ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"c\" , \"enable compact output\" , OFFSET ( compact ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } } ; DEFINE_WRITER_CLASS ( json )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@json_init": "static av_cold int json_init ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; json -> item_sep = json -> compact ? \", \" : \",\\n\" ; json -> item_start_end = json -> compact ? \" \" : \"\\n\" ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@json_escape_str": "static const char * json_escape_str ( AVBPrint * dst , const char * src , void * log_ctx ) { static const char json_escape [ ] = { '\"' , '\\\\' , '\\b' , '\\f' , '\\n' , '\\r' , '\\t' , 0 } ; static const char json_subst [ ] = { '\"' , '\\\\' , 'b' , 'f' , 'n' , 'r' , 't' , 0 } ; const char * p ; for ( p = src ; * p ; p ++ ) { char * s = strchr ( json_escape , * p ) ; if ( s ) { av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , json_subst [ s - json_escape ] , 1 ) ; } else if ( ( unsigned char ) * p < 32 ) { av_bprintf ( dst , \"\\\\u00%02x\" , * p & 0xff ) ; } else { av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@json_print_section_header": "static void json_print_section_header ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; AVBPrint buf ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_put_str ( wctx , \",\\n\" ) ; if ( section -> flags & SECTION_FLAG_IS_WRAPPER ) { writer_put_str ( wctx , \"{\\n\" ) ; json -> indent_level ++ ; } else { av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; json_escape_str ( & buf , section -> name , wctx ) ; JSON_INDENT ( ) ; json -> indent_level ++ ; if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { writer_printf ( wctx , \"\\\"%s\\\": [\\n\" , buf . str ) ; } else if ( parent_section && ! ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) ) { writer_printf ( wctx , \"\\\"%s\\\": {%s\" , buf . str , json -> item_start_end ) ; } else { writer_printf ( wctx , \"{%s\" , json -> item_start_end ) ; /* this is required so the parser can distinguish between packets and frames */ if ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) { if ( ! json -> compact ) JSON_INDENT ( ) ; writer_printf ( wctx , \"\\\"type\\\": \\\"%s\\\"\" , section -> name ) ; wctx -> nb_item [ wctx -> level ] ++ ; } } av_bprint_finalize ( & buf , NULL ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@json_print_section_footer": "static void json_print_section_footer ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; if ( wctx -> level == 0 ) { json -> indent_level -- ; writer_put_str ( wctx , \"\\n}\\n\" ) ; } else if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { writer_w8 ( wctx , '\\n' ) ; json -> indent_level -- ; JSON_INDENT ( ) ; writer_w8 ( wctx , ']' ) ; } else { writer_put_str ( wctx , json -> item_start_end ) ; json -> indent_level -- ; if ( ! json -> compact ) JSON_INDENT ( ) ; writer_w8 ( wctx , '}' ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@json_print_item_str": "static inline void json_print_item_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"\\\"%s\\\":\" , json_escape_str ( & buf , key , wctx ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \" \\\"%s\\\"\" , json_escape_str ( & buf , value , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@json_print_str": "static void json_print_str ( WriterContext * wctx , const char * key , const char * value ) { JSONContext * json = wctx -> priv ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> nb_item [ wctx -> level ] || ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) ) writer_put_str ( wctx , json -> item_sep ) ; if ( ! json -> compact ) JSON_INDENT ( ) ; json_print_item_str ( wctx , key , value ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@json_print_int": "static void json_print_int ( WriterContext * wctx , const char * key , long long int value ) { JSONContext * json = wctx -> priv ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] || ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) ) writer_put_str ( wctx , json -> item_sep ) ; if ( ! json -> compact ) JSON_INDENT ( ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"\\\"%s\\\": %lld\" , json_escape_str ( & buf , key , wctx ) , value ) ; av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@xml_get_name": "static const char * name ## _get_name ( void * ctx ) \\\n{ return # name ; \\\n} static const AVClass name ## _class = { . class_name = # name , . item_name = name ## _get_name , . option = name ## _options \\\n} /* Default output */ typedef struct DefaultContext { const AVClass * class ; int nokey ; int noprint_wrappers ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; } DefaultContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( DefaultContext , x ) static const AVOption default_options [ ] = { { \"noprint_wrappers\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nw\" , \"do not print headers and footers\" , OFFSET ( noprint_wrappers ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( default ) ; /* lame uppercasing routine, assumes the string is lower case ASCII */ static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) { int i ; for ( i = 0 ; src [ i ] && i < dst_size - 1 ; i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ; dst [ i ] = 0 ; return dst ; } static void default_print_section_header ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; char buf [ 32 ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { def -> nested_section [ wctx -> level ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , upcase_string ( buf , sizeof ( buf ) , av_x_if_null ( section -> element_name , section -> name ) ) ) ; } if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_section_footer ( WriterContext * wctx ) { DefaultContext * def = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; char buf [ 32 ] ; if ( def -> noprint_wrappers || def -> nested_section [ wctx -> level ] ) return ; if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"[/%s]\\n\" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ; } static void default_print_str ( WriterContext * wctx , const char * key , const char * value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%s\\n\" , value ) ; } static void default_print_int ( WriterContext * wctx , const char * key , long long int value ) { DefaultContext * def = wctx -> priv ; if ( ! def -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\\n\" , value ) ; } static const Writer default_writer = { . name = \"default\" , . priv_size = sizeof ( DefaultContext ) , . print_section_header = default_print_section_header , . print_section_footer = default_print_section_footer , . print_integer = default_print_int , . print_string = default_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & default_class , } ; /* Compact output */ /**\n * Apply C-language-like string escaping.\n */ static const char * c_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; default : if ( * p == sep ) av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } /**\n * Quote fields containing special characters, check RFC4180.\n */ static const char * csv_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { char meta_chars [ ] = { sep , '\"' , '\\n' , '\\r' , '\\0' } ; int needs_quoting = ! ! src [ strcspn ( src , meta_chars ) ] ; if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; for ( ; * src ; src ++ ) { if ( * src == '\"' ) av_bprint_chars ( dst , '\"' , 1 ) ; av_bprint_chars ( dst , * src , 1 ) ; } if ( needs_quoting ) av_bprint_chars ( dst , '\"' , 1 ) ; return dst -> str ; } static const char * none_escape_str ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) { return src ; } typedef struct CompactContext { const AVClass * class ; char * item_sep_str ; char item_sep ; int nokey ; int print_section ; char * escape_mode_str ; const char * ( * escape_str ) ( AVBPrint * dst , const char * src , const char sep , void * log_ctx ) ; int nested_section [ SECTION_MAX_NB_LEVELS ] ; int has_nested_elems [ SECTION_MAX_NB_LEVELS ] ; int terminate_line [ SECTION_MAX_NB_LEVELS ] ; } CompactContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption compact_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \"|\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"c\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( compact ) ; static av_cold int compact_init ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( strlen ( compact -> item_sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , compact -> item_sep_str ) ; return AVERROR ( EINVAL ) ; } compact -> item_sep = compact -> item_sep_str [ 0 ] ; if ( ! strcmp ( compact -> escape_mode_str , \"none\" ) ) compact -> escape_str = none_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"c\" ) ) compact -> escape_str = c_escape_str ; else if ( ! strcmp ( compact -> escape_mode_str , \"csv\" ) ) compact -> escape_str = csv_escape_str ; else { av_log ( wctx , AV_LOG_ERROR , \"Unknown escape mode '%s'\\n\" , compact -> escape_mode_str ) ; return AVERROR ( EINVAL ) ; } return 0 ; } static void compact_print_section_header ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; compact -> terminate_line [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level ] = 0 ; av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ; if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) { compact -> nested_section [ wctx -> level ] = 1 ; compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ; av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ; wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ; } else { if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) { compact -> terminate_line [ wctx -> level - 1 ] = 0 ; } if ( parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_printf ( wctx , \"%s%c\" , section -> name , compact -> item_sep ) ; } } static void compact_print_section_footer ( WriterContext * wctx ) { CompactContext * compact = wctx -> priv ; if ( ! compact -> nested_section [ wctx -> level ] && compact -> terminate_line [ wctx -> level ] && ! ( wctx -> section [ wctx -> level ] -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) writer_w8 ( wctx , '\\n' ) ; } static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) { CompactContext * compact = wctx -> priv ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_put_str ( wctx , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) { CompactContext * compact = wctx -> priv ; if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , compact -> item_sep ) ; if ( ! compact -> nokey ) writer_printf ( wctx , \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ; writer_printf ( wctx , \"%lld\" , value ) ; } static const Writer compact_writer = { . name = \"compact\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & compact_class , } ; /* CSV output */ # undef OFFSET # define OFFSET ( x ) offsetof ( CompactContext , x ) static const AVOption csv_options [ ] = { { \"item_sep\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"s\" , \"set item separator\" , OFFSET ( item_sep_str ) , AV_OPT_TYPE_STRING , { . str = \",\" } , 0 , 0 } , { \"nokey\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"nk\" , \"force no key printing\" , OFFSET ( nokey ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"escape\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"e\" , \"set escape mode\" , OFFSET ( escape_mode_str ) , AV_OPT_TYPE_STRING , { . str = \"csv\" } , 0 , 0 } , { \"print_section\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"p\" , \"print section name\" , OFFSET ( print_section ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( csv ) ; static const Writer csv_writer = { . name = \"csv\" , . priv_size = sizeof ( CompactContext ) , . init = compact_init , . print_section_header = compact_print_section_header , . print_section_footer = compact_print_section_footer , . print_integer = compact_print_int , . print_string = compact_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS , . priv_class = & csv_class , } ; /* Flat output */ typedef struct FlatContext { const AVClass * class ; const char * sep_str ; char sep ; int hierarchical ; } FlatContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( FlatContext , x ) static const AVOption flat_options [ ] = { { \"sep_char\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"s\" , \"set separator\" , OFFSET ( sep_str ) , AV_OPT_TYPE_STRING , { . str = \".\" } , 0 , 0 } , { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( flat ) ; static av_cold int flat_init ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; if ( strlen ( flat -> sep_str ) != 1 ) { av_log ( wctx , AV_LOG_ERROR , \"Item separator '%s' specified, but must contain a single character\\n\" , flat -> sep_str ) ; return AVERROR ( EINVAL ) ; } flat -> sep = flat -> sep_str [ 0 ] ; return 0 ; } static const char * flat_escape_key_str ( AVBPrint * dst , const char * src , const char sep ) { const char * p ; for ( p = src ; * p ; p ++ ) { if ( ! ( ( * p >= '0' && * p <= '9' ) || ( * p >= 'a' && * p <= 'z' ) || ( * p >= 'A' && * p <= 'Z' ) ) ) av_bprint_chars ( dst , '_' , 1 ) ; else av_bprint_chars ( dst , * p , 1 ) ; } return dst -> str ; } static const char * flat_escape_value_str ( AVBPrint * dst , const char * src ) { const char * p ; for ( p = src ; * p ; p ++ ) { switch ( * p ) { case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\\\' : av_bprintf ( dst , \"%s\" , \"\\\\\\\\\" ) ; break ; case '\"' : av_bprintf ( dst , \"%s\" , \"\\\\\\\"\" ) ; break ; case '`' : av_bprintf ( dst , \"%s\" , \"\\\\`\" ) ; break ; case '$' : av_bprintf ( dst , \"%s\" , \"\\\\$\" ) ; break ; default : av_bprint_chars ( dst , * p , 1 ) ; break ; } } return dst -> str ; } static void flat_print_section_header ( WriterContext * wctx ) { FlatContext * flat = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; /* build section header */ av_bprint_clear ( buf ) ; if ( ! parent_section ) return ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( flat -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , wctx -> section [ wctx -> level ] -> name , flat -> sep_str ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \"%d%s\" , n , flat -> sep_str ) ; } } } static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s%s=%lld\\n\" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ; } static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) { FlatContext * flat = wctx -> priv ; AVBPrint buf ; writer_put_str ( wctx , wctx -> section_pbuf [ wctx -> level ] . str ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"\\\"%s\\\"\\n\" , flat_escape_value_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static const Writer flat_writer = { . name = \"flat\" , . priv_size = sizeof ( FlatContext ) , . init = flat_init , . print_section_header = flat_print_section_header , . print_integer = flat_print_int , . print_string = flat_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & flat_class , } ; /* INI format output */ typedef struct INIContext { const AVClass * class ; int hierarchical ; } INIContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( INIContext , x ) static const AVOption ini_options [ ] = { { \"hierarchical\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { \"h\" , \"specify if the section specification should be hierarchical\" , OFFSET ( hierarchical ) , AV_OPT_TYPE_BOOL , { . i64 = 1 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( ini ) ; static char * ini_escape_str ( AVBPrint * dst , const char * src ) { int i = 0 ; char c = 0 ; while ( ( c = src [ i ++ ] ) ) { switch ( c ) { case '\\b' : av_bprintf ( dst , \"%s\" , \"\\\\b\" ) ; break ; case '\\f' : av_bprintf ( dst , \"%s\" , \"\\\\f\" ) ; break ; case '\\n' : av_bprintf ( dst , \"%s\" , \"\\\\n\" ) ; break ; case '\\r' : av_bprintf ( dst , \"%s\" , \"\\\\r\" ) ; break ; case '\\t' : av_bprintf ( dst , \"%s\" , \"\\\\t\" ) ; break ; case '\\\\' : case '#' : case '=' : case ':' : av_bprint_chars ( dst , '\\\\' , 1 ) ; default : if ( ( unsigned char ) c < 32 ) av_bprintf ( dst , \"\\\\x00%02x\" , c & 0xff ) ; else av_bprint_chars ( dst , c , 1 ) ; break ; } } return dst -> str ; } static void ini_print_section_header ( WriterContext * wctx ) { INIContext * ini = wctx -> priv ; AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; av_bprint_clear ( buf ) ; if ( ! parent_section ) { writer_put_str ( wctx , \"# ffprobe output\\n\\n\" ) ; return ; } if ( wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , '\\n' ) ; av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ; if ( ini -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) { av_bprintf ( buf , \"%s%s\" , buf -> str [ 0 ] ? \".\" : \"\" , wctx -> section [ wctx -> level ] -> name ) ; if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) { int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ; av_bprintf ( buf , \".%d\" , n ) ; } } if ( ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) writer_printf ( wctx , \"[%s]\\n\" , buf -> str ) ; } static void ini_print_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"%s=\" , ini_escape_str ( & buf , key ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \"%s\\n\" , ini_escape_str ( & buf , value ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void ini_print_int ( WriterContext * wctx , const char * key , long long int value ) { writer_printf ( wctx , \"%s=%lld\\n\" , key , value ) ; } static const Writer ini_writer = { . name = \"ini\" , . priv_size = sizeof ( INIContext ) , . print_section_header = ini_print_section_header , . print_integer = ini_print_int , . print_string = ini_print_str , . flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS | WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & ini_class , } ; /* JSON output */ typedef struct JSONContext { const AVClass * class ; int indent_level ; int compact ; const char * item_sep , * item_start_end ; } JSONContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( JSONContext , x ) static const AVOption json_options [ ] = { { \"compact\" , \"enable compact output\" , OFFSET ( compact ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"c\" , \"enable compact output\" , OFFSET ( compact ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } } ; DEFINE_WRITER_CLASS ( json ) ; static av_cold int json_init ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; json -> item_sep = json -> compact ? \", \" : \",\\n\" ; json -> item_start_end = json -> compact ? \" \" : \"\\n\" ; return 0 ; } static const char * json_escape_str ( AVBPrint * dst , const char * src , void * log_ctx ) { static const char json_escape [ ] = { '\"' , '\\\\' , '\\b' , '\\f' , '\\n' , '\\r' , '\\t' , 0 } ; static const char json_subst [ ] = { '\"' , '\\\\' , 'b' , 'f' , 'n' , 'r' , 't' , 0 } ; const char * p ; for ( p = src ; * p ; p ++ ) { char * s = strchr ( json_escape , * p ) ; if ( s ) { av_bprint_chars ( dst , '\\\\' , 1 ) ; av_bprint_chars ( dst , json_subst [ s - json_escape ] , 1 ) ; } else if ( ( unsigned char ) * p < 32 ) { av_bprintf ( dst , \"\\\\u00%02x\" , * p & 0xff ) ; } else { av_bprint_chars ( dst , * p , 1 ) ; } } return dst -> str ; } # define JSON_INDENT ( ) writer_printf ( wctx , \"%*c\" , json -> indent_level * 4 , ' ' ) static void json_print_section_header ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; AVBPrint buf ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_put_str ( wctx , \",\\n\" ) ; if ( section -> flags & SECTION_FLAG_IS_WRAPPER ) { writer_put_str ( wctx , \"{\\n\" ) ; json -> indent_level ++ ; } else { av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; json_escape_str ( & buf , section -> name , wctx ) ; JSON_INDENT ( ) ; json -> indent_level ++ ; if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { writer_printf ( wctx , \"\\\"%s\\\": [\\n\" , buf . str ) ; } else if ( parent_section && ! ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) ) { writer_printf ( wctx , \"\\\"%s\\\": {%s\" , buf . str , json -> item_start_end ) ; } else { writer_printf ( wctx , \"{%s\" , json -> item_start_end ) ; /* this is required so the parser can distinguish between packets and frames */ if ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) { if ( ! json -> compact ) JSON_INDENT ( ) ; writer_printf ( wctx , \"\\\"type\\\": \\\"%s\\\"\" , section -> name ) ; wctx -> nb_item [ wctx -> level ] ++ ; } } av_bprint_finalize ( & buf , NULL ) ; } } static void json_print_section_footer ( WriterContext * wctx ) { JSONContext * json = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; if ( wctx -> level == 0 ) { json -> indent_level -- ; writer_put_str ( wctx , \"\\n}\\n\" ) ; } else if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { writer_w8 ( wctx , '\\n' ) ; json -> indent_level -- ; JSON_INDENT ( ) ; writer_w8 ( wctx , ']' ) ; } else { writer_put_str ( wctx , json -> item_start_end ) ; json -> indent_level -- ; if ( ! json -> compact ) JSON_INDENT ( ) ; writer_w8 ( wctx , '}' ) ; } } static inline void json_print_item_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"\\\"%s\\\":\" , json_escape_str ( & buf , key , wctx ) ) ; av_bprint_clear ( & buf ) ; writer_printf ( wctx , \" \\\"%s\\\"\" , json_escape_str ( & buf , value , wctx ) ) ; av_bprint_finalize ( & buf , NULL ) ; } static void json_print_str ( WriterContext * wctx , const char * key , const char * value ) { JSONContext * json = wctx -> priv ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> nb_item [ wctx -> level ] || ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) ) writer_put_str ( wctx , json -> item_sep ) ; if ( ! json -> compact ) JSON_INDENT ( ) ; json_print_item_str ( wctx , key , value ) ; } static void json_print_int ( WriterContext * wctx , const char * key , long long int value ) { JSONContext * json = wctx -> priv ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; AVBPrint buf ; if ( wctx -> nb_item [ wctx -> level ] || ( parent_section && parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ) ) writer_put_str ( wctx , json -> item_sep ) ; if ( ! json -> compact ) JSON_INDENT ( ) ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_printf ( wctx , \"\\\"%s\\\": %lld\" , json_escape_str ( & buf , key , wctx ) , value ) ; av_bprint_finalize ( & buf , NULL ) ; } static const Writer json_writer = { . name = \"json\" , . priv_size = sizeof ( JSONContext ) , . init = json_init , . print_section_header = json_print_section_header , . print_section_footer = json_print_section_footer , . print_integer = json_print_int , . print_string = json_print_str , . flags = WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER , . priv_class = & json_class , } ; /* XML output */ typedef struct XMLContext { const AVClass * class ; int within_tag ; int indent_level ; int fully_qualified ; int xsd_strict ; } XMLContext ; # undef OFFSET # define OFFSET ( x ) offsetof ( XMLContext , x ) static const AVOption xml_options [ ] = { { \"fully_qualified\" , \"specify if the output should be fully qualified\" , OFFSET ( fully_qualified ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"q\" , \"specify if the output should be fully qualified\" , OFFSET ( fully_qualified ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"xsd_strict\" , \"ensure that the output is XSD compliant\" , OFFSET ( xsd_strict ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { \"x\" , \"ensure that the output is XSD compliant\" , OFFSET ( xsd_strict ) , AV_OPT_TYPE_BOOL , { . i64 = 0 } , 0 , 1 } , { NULL } , } ; DEFINE_WRITER_CLASS ( xml )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@xml_init": "static av_cold int xml_init ( WriterContext * wctx ) { XMLContext * xml = wctx -> priv ; if ( xml -> xsd_strict ) { xml -> fully_qualified = 1 ; # define CHECK_COMPLIANCE ( opt , opt_name ) if ( opt ) { av_log ( wctx , AV_LOG_ERROR , \"XSD-compliant output selected but option '%s' was selected, XML output may be non-compliant.\\n\" \"You need to disable such option with '-no%s'\\n\" , opt_name , opt_name ) ; return AVERROR ( EINVAL ) ; } CHECK_COMPLIANCE ( show_private_data , \"private\" ) ; CHECK_COMPLIANCE ( show_value_unit , \"unit\" ) ; CHECK_COMPLIANCE ( use_value_prefix , \"prefix\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@xml_print_section_header": "static void xml_print_section_header ( WriterContext * wctx ) { XMLContext * xml = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ; if ( wctx -> level == 0 ) { const char * qual = \" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" \" \"xmlns:ffprobe=\\\"http://www.ffmpeg.org/schema/ffprobe\\\" \" \"xsi:schemaLocation=\\\"http://www.ffmpeg.org/schema/ffprobe ffprobe.xsd\\\"\" ; writer_put_str ( wctx , \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" ) ; writer_printf ( wctx , \"<%sffprobe%s>\\n\" , xml -> fully_qualified ? \"ffprobe:\" : \"\" , xml -> fully_qualified ? qual : \"\" ) ; return ; } if ( xml -> within_tag ) { xml -> within_tag = 0 ; writer_put_str ( wctx , \">\\n\" ) ; } if ( section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ) { xml -> indent_level ++ ; } else { if ( parent_section && ( parent_section -> flags & SECTION_FLAG_IS_WRAPPER ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) writer_w8 ( wctx , '\\n' ) ; xml -> indent_level ++ ; if ( section -> flags & SECTION_FLAG_IS_ARRAY ) { XML_INDENT ( ) ; writer_printf ( wctx , \"<%s>\\n\" , section -> name ) ; } else { XML_INDENT ( ) ; writer_printf ( wctx , \"<%s \" , section -> name ) ; xml -> within_tag = 1 ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@xml_print_section_footer": "static void xml_print_section_footer ( WriterContext * wctx ) { XMLContext * xml = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; if ( wctx -> level == 0 ) { writer_printf ( wctx , \"</%sffprobe>\\n\" , xml -> fully_qualified ? \"ffprobe:\" : \"\" ) ; } else if ( xml -> within_tag ) { xml -> within_tag = 0 ; writer_put_str ( wctx , \"/>\\n\" ) ; xml -> indent_level -- ; } else if ( section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ) { xml -> indent_level -- ; } else { XML_INDENT ( ) ; writer_printf ( wctx , \"</%s>\\n\" , section -> name ) ; xml -> indent_level -- ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@xml_print_str": "static void xml_print_str ( WriterContext * wctx , const char * key , const char * value ) { AVBPrint buf ; XMLContext * xml = wctx -> priv ; const struct section * section = wctx -> section [ wctx -> level ] ; av_bprint_init ( & buf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; if ( section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ) { XML_INDENT ( ) ; av_bprint_escape ( & buf , key , NULL , AV_ESCAPE_MODE_XML , AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES ) ; writer_printf ( wctx , \"<%s key=\\\"%s\\\"\" , section -> element_name , buf . str ) ; av_bprint_clear ( & buf ) ; av_bprint_escape ( & buf , value , NULL , AV_ESCAPE_MODE_XML , AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES ) ; writer_printf ( wctx , \" value=\\\"%s\\\"/>\\n\" , buf . str ) ; } else { if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , ' ' ) ; av_bprint_escape ( & buf , value , NULL , AV_ESCAPE_MODE_XML , AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES ) ; writer_printf ( wctx , \"%s=\\\"%s\\\"\" , key , buf . str ) ; } av_bprint_finalize ( & buf , NULL ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@xml_print_int": "static void xml_print_int ( WriterContext * wctx , const char * key , long long int value ) { if ( wctx -> nb_item [ wctx -> level ] ) writer_w8 ( wctx , ' ' ) ; writer_printf ( wctx , \"%s=\\\"%lld\\\"\" , key , value ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@writer_register_all": "static void writer_register_all ( void ) { writer_register ( & default_writer ) ; writer_register ( & compact_writer ) ; writer_register ( & csv_writer ) ; writer_register ( & flat_writer ) ; writer_register ( & ini_writer ) ; writer_register ( & json_writer ) ; writer_register ( & xml_writer ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_tags": "static inline int show_tags ( WriterContext * w , AVDictionary * tags , int section_id ) { const AVDictionaryEntry * tag = NULL ; int ret = 0 ; if ( ! tags ) return 0 ; writer_print_section_header ( w , section_id ) ; while ( ( tag = av_dict_iterate ( tags , tag ) ) ) { if ( ( ret = print_str_validate ( tag -> key , tag -> value ) ) < 0 ) break ; } writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@print_dovi_metadata": "static void print_dovi_metadata ( WriterContext * w , const AVDOVIMetadata * dovi ) { if ( ! dovi ) return ; { const AVDOVIRpuDataHeader * hdr = av_dovi_get_header ( dovi ) ; const AVDOVIDataMapping * mapping = av_dovi_get_mapping ( dovi ) ; const AVDOVIColorMetadata * color = av_dovi_get_color ( dovi ) ; AVBPrint pbuf ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; // header print_int ( \"rpu_type\" , hdr -> rpu_type ) ; print_int ( \"rpu_format\" , hdr -> rpu_format ) ; print_int ( \"vdr_rpu_profile\" , hdr -> vdr_rpu_profile ) ; print_int ( \"vdr_rpu_level\" , hdr -> vdr_rpu_level ) ; print_int ( \"chroma_resampling_explicit_filter_flag\" , hdr -> chroma_resampling_explicit_filter_flag ) ; print_int ( \"coef_data_type\" , hdr -> coef_data_type ) ; print_int ( \"coef_log2_denom\" , hdr -> coef_log2_denom ) ; print_int ( \"vdr_rpu_normalized_idc\" , hdr -> vdr_rpu_normalized_idc ) ; print_int ( \"bl_video_full_range_flag\" , hdr -> bl_video_full_range_flag ) ; print_int ( \"bl_bit_depth\" , hdr -> bl_bit_depth ) ; print_int ( \"el_bit_depth\" , hdr -> el_bit_depth ) ; print_int ( \"vdr_bit_depth\" , hdr -> vdr_bit_depth ) ; print_int ( \"spatial_resampling_filter_flag\" , hdr -> spatial_resampling_filter_flag ) ; print_int ( \"el_spatial_resampling_filter_flag\" , hdr -> el_spatial_resampling_filter_flag ) ; print_int ( \"disable_residual_flag\" , hdr -> disable_residual_flag ) ; // data mapping values print_int ( \"vdr_rpu_id\" , mapping -> vdr_rpu_id ) ; print_int ( \"mapping_color_space\" , mapping -> mapping_color_space ) ; print_int ( \"mapping_chroma_format_idc\" , mapping -> mapping_chroma_format_idc ) ; print_int ( \"nlq_method_idc\" , mapping -> nlq_method_idc ) ; switch ( mapping -> nlq_method_idc ) { case AV_DOVI_NLQ_NONE : print_str ( \"nlq_method_idc_name\" , \"none\" ) ; break ; case AV_DOVI_NLQ_LINEAR_DZ : print_str ( \"nlq_method_idc_name\" , \"linear_dz\" ) ; break ; default : print_str ( \"nlq_method_idc_name\" , \"unknown\" ) ; break ; } print_int ( \"num_x_partitions\" , mapping -> num_x_partitions ) ; print_int ( \"num_y_partitions\" , mapping -> num_y_partitions ) ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_COMPONENT_LIST ) ; for ( int c = 0 ; c < 3 ; c ++ ) { const AVDOVIReshapingCurve * curve = & mapping -> curves [ c ] ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_COMPONENT ) ; print_list_fmt ( \"pivots\" , \"%\" PRIu16 , curve -> num_pivots , 1 , curve -> pivots [ idx ] ) ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_PIECE_LIST ) ; for ( int i = 0 ; i < curve -> num_pivots - 1 ; i ++ ) { writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_PIECE ) ; print_int ( \"mapping_idc\" , curve -> mapping_idc [ i ] ) ; switch ( curve -> mapping_idc [ i ] ) { case AV_DOVI_MAPPING_POLYNOMIAL : print_str ( \"mapping_idc_name\" , \"polynomial\" ) ; print_int ( \"poly_order\" , curve -> poly_order [ i ] ) ; print_list_fmt ( \"poly_coef\" , \"%\" PRIi64 , curve -> poly_order [ i ] + 1 , 1 , curve -> poly_coef [ i ] [ idx ] ) ; break ; case AV_DOVI_MAPPING_MMR : print_str ( \"mapping_idc_name\" , \"mmr\" ) ; print_int ( \"mmr_order\" , curve -> mmr_order [ i ] ) ; print_int ( \"mmr_constant\" , curve -> mmr_constant [ i ] ) ; print_list_fmt ( \"mmr_coef\" , \"%\" PRIi64 , curve -> mmr_order [ i ] , 7 , curve -> mmr_coef [ i ] [ idx ] [ idx2 ] ) ; break ; default : print_str ( \"mapping_idc_name\" , \"unknown\" ) ; break ; } // SECTION_ID_FRAME_SIDE_DATA_PIECE writer_print_section_footer ( w ) ; } // SECTION_ID_FRAME_SIDE_DATA_PIECE_LIST writer_print_section_footer ( w ) ; if ( mapping -> nlq_method_idc != AV_DOVI_NLQ_NONE ) { const AVDOVINLQParams * nlq = & mapping -> nlq [ c ] ; print_int ( \"nlq_offset\" , nlq -> nlq_offset ) ; print_int ( \"vdr_in_max\" , nlq -> vdr_in_max ) ; switch ( mapping -> nlq_method_idc ) { case AV_DOVI_NLQ_LINEAR_DZ : print_int ( \"linear_deadzone_slope\" , nlq -> linear_deadzone_slope ) ; print_int ( \"linear_deadzone_threshold\" , nlq -> linear_deadzone_threshold ) ; break ; } } // SECTION_ID_FRAME_SIDE_DATA_COMPONENT writer_print_section_footer ( w ) ; } // SECTION_ID_FRAME_SIDE_DATA_COMPONENT_LIST writer_print_section_footer ( w ) ; // color metadata print_int ( \"dm_metadata_id\" , color -> dm_metadata_id ) ; print_int ( \"scene_refresh_flag\" , color -> scene_refresh_flag ) ; print_list_fmt ( \"ycc_to_rgb_matrix\" , \"%d/%d\" , FF_ARRAY_ELEMS ( color -> ycc_to_rgb_matrix ) , 1 , color -> ycc_to_rgb_matrix [ idx ] . num , color -> ycc_to_rgb_matrix [ idx ] . den ) ; print_list_fmt ( \"ycc_to_rgb_offset\" , \"%d/%d\" , FF_ARRAY_ELEMS ( color -> ycc_to_rgb_offset ) , 1 , color -> ycc_to_rgb_offset [ idx ] . num , color -> ycc_to_rgb_offset [ idx ] . den ) ; print_list_fmt ( \"rgb_to_lms_matrix\" , \"%d/%d\" , FF_ARRAY_ELEMS ( color -> rgb_to_lms_matrix ) , 1 , color -> rgb_to_lms_matrix [ idx ] . num , color -> rgb_to_lms_matrix [ idx ] . den ) ; print_int ( \"signal_eotf\" , color -> signal_eotf ) ; print_int ( \"signal_eotf_param0\" , color -> signal_eotf_param0 ) ; print_int ( \"signal_eotf_param1\" , color -> signal_eotf_param1 ) ; print_int ( \"signal_eotf_param2\" , color -> signal_eotf_param2 ) ; print_int ( \"signal_bit_depth\" , color -> signal_bit_depth ) ; print_int ( \"signal_color_space\" , color -> signal_color_space ) ; print_int ( \"signal_chroma_format\" , color -> signal_chroma_format ) ; print_int ( \"signal_full_range_flag\" , color -> signal_full_range_flag ) ; print_int ( \"source_min_pq\" , color -> source_min_pq ) ; print_int ( \"source_max_pq\" , color -> source_max_pq ) ; print_int ( \"source_diagonal\" , color -> source_diagonal ) ; av_bprint_finalize ( & pbuf , NULL ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@print_dynamic_hdr10_plus": "static void print_dynamic_hdr10_plus ( WriterContext * w , const AVDynamicHDRPlus * metadata ) { if ( ! metadata ) return ; print_int ( \"application version\" , metadata -> application_version ) ; print_int ( \"num_windows\" , metadata -> num_windows ) ; for ( int n = 1 ; n < metadata -> num_windows ; n ++ ) { const AVHDRPlusColorTransformParams * params = & metadata -> params [ n ] ; print_q ( \"window_upper_left_corner_x\" , params -> window_upper_left_corner_x , '/' ) ; print_q ( \"window_upper_left_corner_y\" , params -> window_upper_left_corner_y , '/' ) ; print_q ( \"window_lower_right_corner_x\" , params -> window_lower_right_corner_x , '/' ) ; print_q ( \"window_lower_right_corner_y\" , params -> window_lower_right_corner_y , '/' ) ; print_q ( \"window_upper_left_corner_x\" , params -> window_upper_left_corner_x , '/' ) ; print_q ( \"window_upper_left_corner_y\" , params -> window_upper_left_corner_y , '/' ) ; print_int ( \"center_of_ellipse_x\" , params -> center_of_ellipse_x ) ; print_int ( \"center_of_ellipse_y\" , params -> center_of_ellipse_y ) ; print_int ( \"rotation_angle\" , params -> rotation_angle ) ; print_int ( \"semimajor_axis_internal_ellipse\" , params -> semimajor_axis_internal_ellipse ) ; print_int ( \"semimajor_axis_external_ellipse\" , params -> semimajor_axis_external_ellipse ) ; print_int ( \"semiminor_axis_external_ellipse\" , params -> semiminor_axis_external_ellipse ) ; print_int ( \"overlap_process_option\" , params -> overlap_process_option ) ; } print_q ( \"targeted_system_display_maximum_luminance\" , metadata -> targeted_system_display_maximum_luminance , '/' ) ; if ( metadata -> targeted_system_display_actual_peak_luminance_flag ) { print_int ( \"num_rows_targeted_system_display_actual_peak_luminance\" , metadata -> num_rows_targeted_system_display_actual_peak_luminance ) ; print_int ( \"num_cols_targeted_system_display_actual_peak_luminance\" , metadata -> num_cols_targeted_system_display_actual_peak_luminance ) ; for ( int i = 0 ; i < metadata -> num_rows_targeted_system_display_actual_peak_luminance ; i ++ ) { for ( int j = 0 ; j < metadata -> num_cols_targeted_system_display_actual_peak_luminance ; j ++ ) { print_q ( \"targeted_system_display_actual_peak_luminance\" , metadata -> targeted_system_display_actual_peak_luminance [ i ] [ j ] , '/' ) ; } } } for ( int n = 0 ; n < metadata -> num_windows ; n ++ ) { const AVHDRPlusColorTransformParams * params = & metadata -> params [ n ] ; for ( int i = 0 ; i < 3 ; i ++ ) { print_q ( \"maxscl\" , params -> maxscl [ i ] , '/' ) ; } print_q ( \"average_maxrgb\" , params -> average_maxrgb , '/' ) ; print_int ( \"num_distribution_maxrgb_percentiles\" , params -> num_distribution_maxrgb_percentiles ) ; for ( int i = 0 ; i < params -> num_distribution_maxrgb_percentiles ; i ++ ) { print_int ( \"distribution_maxrgb_percentage\" , params -> distribution_maxrgb [ i ] . percentage ) ; print_q ( \"distribution_maxrgb_percentile\" , params -> distribution_maxrgb [ i ] . percentile , '/' ) ; } print_q ( \"fraction_bright_pixels\" , params -> fraction_bright_pixels , '/' ) ; } if ( metadata -> mastering_display_actual_peak_luminance_flag ) { print_int ( \"num_rows_mastering_display_actual_peak_luminance\" , metadata -> num_rows_mastering_display_actual_peak_luminance ) ; print_int ( \"num_cols_mastering_display_actual_peak_luminance\" , metadata -> num_cols_mastering_display_actual_peak_luminance ) ; for ( int i = 0 ; i < metadata -> num_rows_mastering_display_actual_peak_luminance ; i ++ ) { for ( int j = 0 ; j < metadata -> num_cols_mastering_display_actual_peak_luminance ; j ++ ) { print_q ( \"mastering_display_actual_peak_luminance\" , metadata -> mastering_display_actual_peak_luminance [ i ] [ j ] , '/' ) ; } } } for ( int n = 0 ; n < metadata -> num_windows ; n ++ ) { const AVHDRPlusColorTransformParams * params = & metadata -> params [ n ] ; if ( params -> tone_mapping_flag ) { print_q ( \"knee_point_x\" , params -> knee_point_x , '/' ) ; print_q ( \"knee_point_y\" , params -> knee_point_y , '/' ) ; print_int ( \"num_bezier_curve_anchors\" , params -> num_bezier_curve_anchors ) ; for ( int i = 0 ; i < params -> num_bezier_curve_anchors ; i ++ ) { print_q ( \"bezier_curve_anchors\" , params -> bezier_curve_anchors [ i ] , '/' ) ; } } if ( params -> color_saturation_mapping_flag ) { print_q ( \"color_saturation_weight\" , params -> color_saturation_weight , '/' ) ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@print_dynamic_hdr_vivid": "static void print_dynamic_hdr_vivid ( WriterContext * w , const AVDynamicHDRVivid * metadata ) { if ( ! metadata ) return ; print_int ( \"system_start_code\" , metadata -> system_start_code ) ; print_int ( \"num_windows\" , metadata -> num_windows ) ; for ( int n = 0 ; n < metadata -> num_windows ; n ++ ) { const AVHDRVividColorTransformParams * params = & metadata -> params [ n ] ; print_q ( \"minimum_maxrgb\" , params -> minimum_maxrgb , '/' ) ; print_q ( \"average_maxrgb\" , params -> average_maxrgb , '/' ) ; print_q ( \"variance_maxrgb\" , params -> variance_maxrgb , '/' ) ; print_q ( \"maximum_maxrgb\" , params -> maximum_maxrgb , '/' ) ; } for ( int n = 0 ; n < metadata -> num_windows ; n ++ ) { const AVHDRVividColorTransformParams * params = & metadata -> params [ n ] ; print_int ( \"tone_mapping_mode_flag\" , params -> tone_mapping_mode_flag ) ; print_int ( \"tone_mapping_param_num\" , params -> tone_mapping_param_num ) ; if ( params -> tone_mapping_mode_flag ) { for ( int i = 0 ; i < params -> tone_mapping_param_num ; i ++ ) { const AVHDRVividColorToneMappingParams * tm_params = & params -> tm_params [ i ] ; print_q ( \"targeted_system_display_maximum_luminance\" , tm_params -> targeted_system_display_maximum_luminance , '/' ) ; print_int ( \"base_enable_flag\" , tm_params -> base_enable_flag ) ; if ( tm_params -> base_enable_flag ) { print_q ( \"base_param_m_p\" , tm_params -> base_param_m_p , '/' ) ; print_q ( \"base_param_m_m\" , tm_params -> base_param_m_m , '/' ) ; print_q ( \"base_param_m_a\" , tm_params -> base_param_m_a , '/' ) ; print_q ( \"base_param_m_b\" , tm_params -> base_param_m_b , '/' ) ; print_q ( \"base_param_m_n\" , tm_params -> base_param_m_n , '/' ) ; print_int ( \"base_param_k1\" , tm_params -> base_param_k1 ) ; print_int ( \"base_param_k2\" , tm_params -> base_param_k2 ) ; print_int ( \"base_param_k3\" , tm_params -> base_param_k3 ) ; print_int ( \"base_param_Delta_enable_mode\" , tm_params -> base_param_Delta_enable_mode ) ; print_q ( \"base_param_Delta\" , tm_params -> base_param_Delta , '/' ) ; } print_int ( \"3Spline_enable_flag\" , tm_params -> three_Spline_enable_flag ) ; if ( tm_params -> three_Spline_enable_flag ) { print_int ( \"3Spline_num\" , tm_params -> three_Spline_num ) ; print_int ( \"3Spline_TH_mode\" , tm_params -> three_Spline_TH_mode ) ; for ( int j = 0 ; j < tm_params -> three_Spline_num ; j ++ ) { print_q ( \"3Spline_TH_enable_MB\" , tm_params -> three_Spline_TH_enable_MB , '/' ) ; print_q ( \"3Spline_TH_enable\" , tm_params -> three_Spline_TH_enable , '/' ) ; print_q ( \"3Spline_TH_Delta1\" , tm_params -> three_Spline_TH_Delta1 , '/' ) ; print_q ( \"3Spline_TH_Delta2\" , tm_params -> three_Spline_TH_Delta2 , '/' ) ; print_q ( \"3Spline_enable_Strength\" , tm_params -> three_Spline_enable_Strength , '/' ) ; } } } } print_int ( \"color_saturation_mapping_flag\" , params -> color_saturation_mapping_flag ) ; if ( params -> color_saturation_mapping_flag ) { print_int ( \"color_saturation_num\" , params -> color_saturation_num ) ; for ( int i = 0 ; i < params -> color_saturation_num ; i ++ ) { print_q ( \"color_saturation_gain\" , params -> color_saturation_gain [ i ] , '/' ) ; } } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@print_ambient_viewing_environment": "static void print_ambient_viewing_environment ( WriterContext * w , const AVAmbientViewingEnvironment * env ) { if ( ! env ) return ; print_q ( \"ambient_illuminance\" , env -> ambient_illuminance , '/' ) ; print_q ( \"ambient_light_x\" , env -> ambient_light_x , '/' ) ; print_q ( \"ambient_light_y\" , env -> ambient_light_y , '/' ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@print_pkt_side_data": "static void print_pkt_side_data ( WriterContext * w , AVCodecParameters * par , const AVPacketSideData * side_data , int nb_side_data , SectionID id_data_list , SectionID id_data ) { int i ; writer_print_section_header ( w , id_data_list ) ; for ( i = 0 ; i < nb_side_data ; i ++ ) { const AVPacketSideData * sd = & side_data [ i ] ; const char * name = av_packet_side_data_name ( sd -> type ) ; writer_print_section_header ( w , id_data ) ; print_str ( \"side_data_type\" , name ? name : \"unknown\" ) ; if ( sd -> type == AV_PKT_DATA_DISPLAYMATRIX && sd -> size >= 9 * 4 ) { double rotation = av_display_rotation_get ( ( int32_t * ) sd -> data ) ; if ( isnan ( rotation ) ) rotation = 0 ; writer_print_integers ( w , \"displaymatrix\" , sd -> data , 9 , \" %11d\" , 3 , 4 , 1 ) ; print_int ( \"rotation\" , rotation ) ; } else if ( sd -> type == AV_PKT_DATA_STEREO3D ) { const AVStereo3D * stereo = ( AVStereo3D * ) sd -> data ; print_str ( \"type\" , av_stereo3d_type_name ( stereo -> type ) ) ; print_int ( \"inverted\" , ! ! ( stereo -> flags & AV_STEREO3D_FLAG_INVERT ) ) ; } else if ( sd -> type == AV_PKT_DATA_SPHERICAL ) { const AVSphericalMapping * spherical = ( AVSphericalMapping * ) sd -> data ; print_str ( \"projection\" , av_spherical_projection_name ( spherical -> projection ) ) ; if ( spherical -> projection == AV_SPHERICAL_CUBEMAP ) { print_int ( \"padding\" , spherical -> padding ) ; } else if ( spherical -> projection == AV_SPHERICAL_EQUIRECTANGULAR_TILE ) { size_t l , t , r , b ; av_spherical_tile_bounds ( spherical , par -> width , par -> height , & l , & t , & r , & b ) ; print_int ( \"bound_left\" , l ) ; print_int ( \"bound_top\" , t ) ; print_int ( \"bound_right\" , r ) ; print_int ( \"bound_bottom\" , b ) ; } print_int ( \"yaw\" , ( double ) spherical -> yaw / ( 1 << 16 ) ) ; print_int ( \"pitch\" , ( double ) spherical -> pitch / ( 1 << 16 ) ) ; print_int ( \"roll\" , ( double ) spherical -> roll / ( 1 << 16 ) ) ; } else if ( sd -> type == AV_PKT_DATA_SKIP_SAMPLES && sd -> size == 10 ) { print_int ( \"skip_samples\" , AV_RL32 ( sd -> data ) ) ; print_int ( \"discard_padding\" , AV_RL32 ( sd -> data + 4 ) ) ; print_int ( \"skip_reason\" , AV_RL8 ( sd -> data + 8 ) ) ; print_int ( \"discard_reason\" , AV_RL8 ( sd -> data + 9 ) ) ; } else if ( sd -> type == AV_PKT_DATA_MASTERING_DISPLAY_METADATA ) { AVMasteringDisplayMetadata * metadata = ( AVMasteringDisplayMetadata * ) sd -> data ; if ( metadata -> has_primaries ) { print_q ( \"red_x\" , metadata -> display_primaries [ 0 ] [ 0 ] , '/' ) ; print_q ( \"red_y\" , metadata -> display_primaries [ 0 ] [ 1 ] , '/' ) ; print_q ( \"green_x\" , metadata -> display_primaries [ 1 ] [ 0 ] , '/' ) ; print_q ( \"green_y\" , metadata -> display_primaries [ 1 ] [ 1 ] , '/' ) ; print_q ( \"blue_x\" , metadata -> display_primaries [ 2 ] [ 0 ] , '/' ) ; print_q ( \"blue_y\" , metadata -> display_primaries [ 2 ] [ 1 ] , '/' ) ; print_q ( \"white_point_x\" , metadata -> white_point [ 0 ] , '/' ) ; print_q ( \"white_point_y\" , metadata -> white_point [ 1 ] , '/' ) ; } if ( metadata -> has_luminance ) { print_q ( \"min_luminance\" , metadata -> min_luminance , '/' ) ; print_q ( \"max_luminance\" , metadata -> max_luminance , '/' ) ; } } else if ( sd -> type == AV_PKT_DATA_CONTENT_LIGHT_LEVEL ) { AVContentLightMetadata * metadata = ( AVContentLightMetadata * ) sd -> data ; print_int ( \"max_content\" , metadata -> MaxCLL ) ; print_int ( \"max_average\" , metadata -> MaxFALL ) ; } else if ( sd -> type == AV_PKT_DATA_DOVI_CONF ) { AVDOVIDecoderConfigurationRecord * dovi = ( AVDOVIDecoderConfigurationRecord * ) sd -> data ; print_int ( \"dv_version_major\" , dovi -> dv_version_major ) ; print_int ( \"dv_version_minor\" , dovi -> dv_version_minor ) ; print_int ( \"dv_profile\" , dovi -> dv_profile ) ; print_int ( \"dv_level\" , dovi -> dv_level ) ; print_int ( \"rpu_present_flag\" , dovi -> rpu_present_flag ) ; print_int ( \"el_present_flag\" , dovi -> el_present_flag ) ; print_int ( \"bl_present_flag\" , dovi -> bl_present_flag ) ; print_int ( \"dv_bl_signal_compatibility_id\" , dovi -> dv_bl_signal_compatibility_id ) ; } else if ( sd -> type == AV_PKT_DATA_AUDIO_SERVICE_TYPE ) { enum AVAudioServiceType * t = ( enum AVAudioServiceType * ) sd -> data ; print_int ( \"service_type\" , * t ) ; } else if ( sd -> type == AV_PKT_DATA_MPEGTS_STREAM_ID ) { print_int ( \"id\" , * sd -> data ) ; } else if ( sd -> type == AV_PKT_DATA_CPB_PROPERTIES ) { const AVCPBProperties * prop = ( AVCPBProperties * ) sd -> data ; print_int ( \"max_bitrate\" , prop -> max_bitrate ) ; print_int ( \"min_bitrate\" , prop -> min_bitrate ) ; print_int ( \"avg_bitrate\" , prop -> avg_bitrate ) ; print_int ( \"buffer_size\" , prop -> buffer_size ) ; print_int ( \"vbv_delay\" , prop -> vbv_delay ) ; } else if ( sd -> type == AV_PKT_DATA_WEBVTT_IDENTIFIER || sd -> type == AV_PKT_DATA_WEBVTT_SETTINGS ) { if ( do_show_data ) writer_print_data ( w , \"data\" , sd -> data , sd -> size ) ; writer_print_data_hash ( w , \"data_hash\" , sd -> data , sd -> size ) ; } else if ( sd -> type == AV_PKT_DATA_AFD && sd -> size > 0 ) { print_int ( \"active_format\" , * sd -> data ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@print_color_range": "static void print_color_range ( WriterContext * w , enum AVColorRange color_range ) { const char * val = av_color_range_name ( color_range ) ; if ( ! val || color_range == AVCOL_RANGE_UNSPECIFIED ) { print_str_opt ( \"color_range\" , \"unknown\" ) ; } else { print_str ( \"color_range\" , val ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@print_color_space": "static void print_color_space ( WriterContext * w , enum AVColorSpace color_space ) { const char * val = av_color_space_name ( color_space ) ; if ( ! val || color_space == AVCOL_SPC_UNSPECIFIED ) { print_str_opt ( \"color_space\" , \"unknown\" ) ; } else { print_str ( \"color_space\" , val ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@print_primaries": "static void print_primaries ( WriterContext * w , enum AVColorPrimaries color_primaries ) { const char * val = av_color_primaries_name ( color_primaries ) ; if ( ! val || color_primaries == AVCOL_PRI_UNSPECIFIED ) { print_str_opt ( \"color_primaries\" , \"unknown\" ) ; } else { print_str ( \"color_primaries\" , val ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@print_color_trc": "static void print_color_trc ( WriterContext * w , enum AVColorTransferCharacteristic color_trc ) { const char * val = av_color_transfer_name ( color_trc ) ; if ( ! val || color_trc == AVCOL_TRC_UNSPECIFIED ) { print_str_opt ( \"color_transfer\" , \"unknown\" ) ; } else { print_str ( \"color_transfer\" , val ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@print_chroma_location": "static void print_chroma_location ( WriterContext * w , enum AVChromaLocation chroma_location ) { const char * val = av_chroma_location_name ( chroma_location ) ; if ( ! val || chroma_location == AVCHROMA_LOC_UNSPECIFIED ) { print_str_opt ( \"chroma_location\" , \"unspecified\" ) ; } else { print_str ( \"chroma_location\" , val ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@clear_log": "static void clear_log ( int need_lock ) { int i ; if ( need_lock ) pthread_mutex_lock ( & log_mutex ) ; for ( i = 0 ; i < log_buffer_size ; i ++ ) { av_freep ( & log_buffer [ i ] . context_name ) ; av_freep ( & log_buffer [ i ] . parent_name ) ; av_freep ( & log_buffer [ i ] . log_message ) ; } log_buffer_size = 0 ; if ( need_lock ) pthread_mutex_unlock ( & log_mutex ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_log": "static int show_log ( WriterContext * w , int section_ids , int section_id , int log_level ) { int i ; pthread_mutex_lock ( & log_mutex ) ; if ( ! log_buffer_size ) { pthread_mutex_unlock ( & log_mutex ) ; return 0 ; } writer_print_section_header ( w , section_ids ) ; for ( i = 0 ; i < log_buffer_size ; i ++ ) { if ( log_buffer [ i ] . log_level <= log_level ) { writer_print_section_header ( w , section_id ) ; print_str ( \"context\" , log_buffer [ i ] . context_name ) ; print_int ( \"level\" , log_buffer [ i ] . log_level ) ; print_int ( \"category\" , log_buffer [ i ] . category ) ; if ( log_buffer [ i ] . parent_name ) { print_str ( \"parent_context\" , log_buffer [ i ] . parent_name ) ; print_int ( \"parent_category\" , log_buffer [ i ] . parent_category ) ; } else { print_str_opt ( \"parent_context\" , \"N/A\" ) ; print_str_opt ( \"parent_category\" , \"N/A\" ) ; } print_str ( \"message\" , log_buffer [ i ] . log_message ) ; writer_print_section_footer ( w ) ; } } clear_log ( 0 ) ; pthread_mutex_unlock ( & log_mutex ) ; writer_print_section_footer ( w ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_packet": "static void show_packet ( WriterContext * w , InputFile * ifile , AVPacket * pkt , int packet_idx ) { char val_str [ 128 ] ; AVStream * st = ifile -> streams [ pkt -> stream_index ] . st ; AVBPrint pbuf ; const char * s ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_PACKET ) ; s = av_get_media_type_string ( st -> codecpar -> codec_type ) ; if ( s ) print_str ( \"codec_type\" , s ) ; else print_str_opt ( \"codec_type\" , \"unknown\" ) ; print_int ( \"stream_index\" , pkt -> stream_index ) ; print_ts ( \"pts\" , pkt -> pts ) ; print_time ( \"pts_time\" , pkt -> pts , & st -> time_base ) ; print_ts ( \"dts\" , pkt -> dts ) ; print_time ( \"dts_time\" , pkt -> dts , & st -> time_base ) ; print_duration_ts ( \"duration\" , pkt -> duration ) ; print_duration_time ( \"duration_time\" , pkt -> duration , & st -> time_base ) ; print_val ( \"size\" , pkt -> size , unit_byte_str ) ; if ( pkt -> pos != - 1 ) print_fmt ( \"pos\" , \"%\" PRId64 , pkt -> pos ) ; else print_str_opt ( \"pos\" , \"N/A\" ) ; print_fmt ( \"flags\" , \"%c%c%c\" , pkt -> flags & AV_PKT_FLAG_KEY ? 'K' : '_' , pkt -> flags & AV_PKT_FLAG_DISCARD ? 'D' : '_' , pkt -> flags & AV_PKT_FLAG_CORRUPT ? 'C' : '_' ) ; if ( do_show_data ) writer_print_data ( w , \"data\" , pkt -> data , pkt -> size ) ; writer_print_data_hash ( w , \"data_hash\" , pkt -> data , pkt -> size ) ; if ( pkt -> side_data_elems ) { size_t size ; const uint8_t * side_metadata ; side_metadata = av_packet_get_side_data ( pkt , AV_PKT_DATA_STRINGS_METADATA , & size ) ; if ( side_metadata && size && do_show_packet_tags ) { AVDictionary * dict = NULL ; if ( av_packet_unpack_dictionary ( side_metadata , size , & dict ) >= 0 ) show_tags ( w , dict , SECTION_ID_PACKET_TAGS ) ; av_dict_free ( & dict ) ; } print_pkt_side_data ( w , st -> codecpar , pkt -> side_data , pkt -> side_data_elems , SECTION_ID_PACKET_SIDE_DATA_LIST , SECTION_ID_PACKET_SIDE_DATA ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_subtitle": "static void show_subtitle ( WriterContext * w , AVSubtitle * sub , AVStream * stream , AVFormatContext * fmt_ctx ) { AVBPrint pbuf ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_SUBTITLE ) ; print_str ( \"media_type\" , \"subtitle\" ) ; print_ts ( \"pts\" , sub -> pts ) ; print_time ( \"pts_time\" , sub -> pts , & AV_TIME_BASE_Q ) ; print_int ( \"format\" , sub -> format ) ; print_int ( \"start_display_time\" , sub -> start_display_time ) ; print_int ( \"end_display_time\" , sub -> end_display_time ) ; print_int ( \"num_rects\" , sub -> num_rects ) ; writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_frame": "static void show_frame ( WriterContext * w , AVFrame * frame , AVStream * stream , AVFormatContext * fmt_ctx ) { AVBPrint pbuf ; char val_str [ 128 ] ; const char * s ; int i ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_FRAME ) ; s = av_get_media_type_string ( stream -> codecpar -> codec_type ) ; if ( s ) print_str ( \"media_type\" , s ) ; else print_str_opt ( \"media_type\" , \"unknown\" ) ; print_int ( \"stream_index\" , stream -> index ) ; print_int ( \"key_frame\" , frame -> key_frame ) ; print_ts ( \"pts\" , frame -> pts ) ; print_time ( \"pts_time\" , frame -> pts , & stream -> time_base ) ; print_ts ( \"pkt_dts\" , frame -> pkt_dts ) ; print_time ( \"pkt_dts_time\" , frame -> pkt_dts , & stream -> time_base ) ; print_ts ( \"best_effort_timestamp\" , frame -> best_effort_timestamp ) ; print_time ( \"best_effort_timestamp_time\" , frame -> best_effort_timestamp , & stream -> time_base ) ; # if LIBAVUTIL_VERSION_MAJOR < 59 AV_NOWARN_DEPRECATED ( print_duration_ts ( \"pkt_duration\" , frame -> pkt_duration ) ; print_duration_time ( \"pkt_duration_time\" , frame -> pkt_duration , & stream -> time_base ) ; ) # endif print_duration_ts ( \"duration\" , frame -> duration ) ; print_duration_time ( \"duration_time\" , frame -> duration , & stream -> time_base ) ; if ( frame -> pkt_pos != - 1 ) print_fmt ( \"pkt_pos\" , \"%\" PRId64 , frame -> pkt_pos ) ; else print_str_opt ( \"pkt_pos\" , \"N/A\" ) ; if ( frame -> pkt_size != - 1 ) print_val ( \"pkt_size\" , frame -> pkt_size , unit_byte_str ) ; else print_str_opt ( \"pkt_size\" , \"N/A\" ) ; switch ( stream -> codecpar -> codec_type ) { AVRational sar ; case AVMEDIA_TYPE_VIDEO : print_int ( \"width\" , frame -> width ) ; print_int ( \"height\" , frame -> height ) ; s = av_get_pix_fmt_name ( frame -> format ) ; if ( s ) print_str ( \"pix_fmt\" , s ) ; else print_str_opt ( \"pix_fmt\" , \"unknown\" ) ; sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , frame ) ; if ( sar . num ) { print_q ( \"sample_aspect_ratio\" , sar , ':' ) ; } else { print_str_opt ( \"sample_aspect_ratio\" , \"N/A\" ) ; } print_fmt ( \"pict_type\" , \"%c\" , av_get_picture_type_char ( frame -> pict_type ) ) ; # if LIBAVUTIL_VERSION_MAJOR < 59 AV_NOWARN_DEPRECATED ( print_int ( \"coded_picture_number\" , frame -> coded_picture_number ) ; print_int ( \"display_picture_number\" , frame -> display_picture_number ) ; ) # endif print_int ( \"interlaced_frame\" , frame -> interlaced_frame ) ; print_int ( \"top_field_first\" , frame -> top_field_first ) ; print_int ( \"repeat_pict\" , frame -> repeat_pict ) ; print_color_range ( w , frame -> color_range ) ; print_color_space ( w , frame -> colorspace ) ; print_primaries ( w , frame -> color_primaries ) ; print_color_trc ( w , frame -> color_trc ) ; print_chroma_location ( w , frame -> chroma_location ) ; break ; case AVMEDIA_TYPE_AUDIO : s = av_get_sample_fmt_name ( frame -> format ) ; if ( s ) print_str ( \"sample_fmt\" , s ) ; else print_str_opt ( \"sample_fmt\" , \"unknown\" ) ; print_int ( \"nb_samples\" , frame -> nb_samples ) ; print_int ( \"channels\" , frame -> ch_layout . nb_channels ) ; if ( frame -> ch_layout . order != AV_CHANNEL_ORDER_UNSPEC ) { av_channel_layout_describe ( & frame -> ch_layout , val_str , sizeof ( val_str ) ) ; print_str ( \"channel_layout\" , val_str ) ; } else print_str_opt ( \"channel_layout\" , \"unknown\" ) ; break ; } if ( do_show_frame_tags ) show_tags ( w , frame -> metadata , SECTION_ID_FRAME_TAGS ) ; if ( do_show_log ) show_log ( w , SECTION_ID_FRAME_LOGS , SECTION_ID_FRAME_LOG , do_show_log ) ; if ( frame -> nb_side_data ) { writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_LIST ) ; for ( i = 0 ; i < frame -> nb_side_data ; i ++ ) { AVFrameSideData * sd = frame -> side_data [ i ] ; const char * name ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA ) ; name = av_frame_side_data_name ( sd -> type ) ; print_str ( \"side_data_type\" , name ? name : \"unknown\" ) ; if ( sd -> type == AV_FRAME_DATA_DISPLAYMATRIX && sd -> size >= 9 * 4 ) { double rotation = av_display_rotation_get ( ( int32_t * ) sd -> data ) ; if ( isnan ( rotation ) ) rotation = 0 ; writer_print_integers ( w , \"displaymatrix\" , sd -> data , 9 , \" %11d\" , 3 , 4 , 1 ) ; print_int ( \"rotation\" , rotation ) ; } else if ( sd -> type == AV_FRAME_DATA_AFD && sd -> size > 0 ) { print_int ( \"active_format\" , * sd -> data ) ; } else if ( sd -> type == AV_FRAME_DATA_GOP_TIMECODE && sd -> size >= 8 ) { char tcbuf [ AV_TIMECODE_STR_SIZE ] ; av_timecode_make_mpeg_tc_string ( tcbuf , * ( int64_t * ) ( sd -> data ) ) ; print_str ( \"timecode\" , tcbuf ) ; } else if ( sd -> type == AV_FRAME_DATA_S12M_TIMECODE && sd -> size == 16 ) { uint32_t * tc = ( uint32_t * ) sd -> data ; int m = FFMIN ( tc [ 0 ] , 3 ) ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_TIMECODE_LIST ) ; for ( int j = 1 ; j <= m ; j ++ ) { char tcbuf [ AV_TIMECODE_STR_SIZE ] ; av_timecode_make_smpte_tc_string2 ( tcbuf , stream -> avg_frame_rate , tc [ j ] , 0 , 0 ) ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_TIMECODE ) ; print_str ( \"value\" , tcbuf ) ; writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } else if ( sd -> type == AV_FRAME_DATA_MASTERING_DISPLAY_METADATA ) { AVMasteringDisplayMetadata * metadata = ( AVMasteringDisplayMetadata * ) sd -> data ; if ( metadata -> has_primaries ) { print_q ( \"red_x\" , metadata -> display_primaries [ 0 ] [ 0 ] , '/' ) ; print_q ( \"red_y\" , metadata -> display_primaries [ 0 ] [ 1 ] , '/' ) ; print_q ( \"green_x\" , metadata -> display_primaries [ 1 ] [ 0 ] , '/' ) ; print_q ( \"green_y\" , metadata -> display_primaries [ 1 ] [ 1 ] , '/' ) ; print_q ( \"blue_x\" , metadata -> display_primaries [ 2 ] [ 0 ] , '/' ) ; print_q ( \"blue_y\" , metadata -> display_primaries [ 2 ] [ 1 ] , '/' ) ; print_q ( \"white_point_x\" , metadata -> white_point [ 0 ] , '/' ) ; print_q ( \"white_point_y\" , metadata -> white_point [ 1 ] , '/' ) ; } if ( metadata -> has_luminance ) { print_q ( \"min_luminance\" , metadata -> min_luminance , '/' ) ; print_q ( \"max_luminance\" , metadata -> max_luminance , '/' ) ; } } else if ( sd -> type == AV_FRAME_DATA_DYNAMIC_HDR_PLUS ) { AVDynamicHDRPlus * metadata = ( AVDynamicHDRPlus * ) sd -> data ; print_dynamic_hdr10_plus ( w , metadata ) ; } else if ( sd -> type == AV_FRAME_DATA_CONTENT_LIGHT_LEVEL ) { AVContentLightMetadata * metadata = ( AVContentLightMetadata * ) sd -> data ; print_int ( \"max_content\" , metadata -> MaxCLL ) ; print_int ( \"max_average\" , metadata -> MaxFALL ) ; } else if ( sd -> type == AV_FRAME_DATA_ICC_PROFILE ) { const AVDictionaryEntry * tag = av_dict_get ( sd -> metadata , \"name\" , NULL , AV_DICT_MATCH_CASE ) ; if ( tag ) print_str ( tag -> key , tag -> value ) ; print_int ( \"size\" , sd -> size ) ; } else if ( sd -> type == AV_FRAME_DATA_DOVI_METADATA ) { print_dovi_metadata ( w , ( const AVDOVIMetadata * ) sd -> data ) ; } else if ( sd -> type == AV_FRAME_DATA_DYNAMIC_HDR_VIVID ) { AVDynamicHDRVivid * metadata = ( AVDynamicHDRVivid * ) sd -> data ; print_dynamic_hdr_vivid ( w , metadata ) ; } else if ( sd -> type == AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT ) { print_ambient_viewing_environment ( w , ( const AVAmbientViewingEnvironment * ) sd -> data ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@process_frame": "static av_always_inline int process_frame ( WriterContext * w , InputFile * ifile , AVFrame * frame , const AVPacket * pkt , int * packet_new ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; AVCodecContext * dec_ctx = ifile -> streams [ pkt -> stream_index ] . dec_ctx ; AVCodecParameters * par = ifile -> streams [ pkt -> stream_index ] . st -> codecpar ; AVSubtitle sub ; int ret = 0 , got_frame = 0 ; clear_log ( 1 ) ; if ( dec_ctx ) { switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : case AVMEDIA_TYPE_AUDIO : if ( * packet_new ) { ret = avcodec_send_packet ( dec_ctx , pkt ) ; if ( ret == AVERROR ( EAGAIN ) ) { ret = 0 ; } else if ( ret >= 0 || ret == AVERROR_EOF ) { ret = 0 ; * packet_new = 0 ; } } if ( ret >= 0 ) { ret = avcodec_receive_frame ( dec_ctx , frame ) ; if ( ret >= 0 ) { got_frame = 1 ; } else if ( ret == AVERROR ( EAGAIN ) || ret == AVERROR_EOF ) { ret = 0 ; } } break ; case AVMEDIA_TYPE_SUBTITLE : if ( * packet_new ) ret = avcodec_decode_subtitle2 ( dec_ctx , & sub , & got_frame , pkt ) ; * packet_new = 0 ; break ; default : * packet_new = 0 ; } } else { * packet_new = 0 ; } if ( ret < 0 ) return ret ; if ( got_frame ) { int is_sub = ( par -> codec_type == AVMEDIA_TYPE_SUBTITLE ) ; nb_streams_frames [ pkt -> stream_index ] ++ ; if ( do_show_frames ) { if ( is_sub ) { show_subtitle ( w , & sub , ifile -> streams [ pkt -> stream_index ] . st , fmt_ctx ) ; } else { show_frame ( w , frame , ifile -> streams [ pkt -> stream_index ] . st , fmt_ctx ) ; } } if ( is_sub ) { avsubtitle_free ( & sub ) ; } } return got_frame || * packet_new ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@log_read_interval": "static void log_read_interval ( const ReadInterval * interval , void * log_ctx , int log_level ) { av_log ( log_ctx , log_level , \"id:%d\" , interval -> id ) ; if ( interval -> has_start ) { av_log ( log_ctx , log_level , \" start:%s%s\" , interval -> start_is_offset ? \"+\" : \"\" , av_ts2timestr ( interval -> start , & AV_TIME_BASE_Q ) ) ; } else { av_log ( log_ctx , log_level , \" start:N/A\" ) ; } if ( interval -> has_end ) { av_log ( log_ctx , log_level , \" end:%s\" , interval -> end_is_offset ? \"+\" : \"\" ) ; if ( interval -> duration_frames ) av_log ( log_ctx , log_level , \"#%\" PRId64 , interval -> end ) ; else av_log ( log_ctx , log_level , \"%s\" , av_ts2timestr ( interval -> end , & AV_TIME_BASE_Q ) ) ; } else { av_log ( log_ctx , log_level , \" end:N/A\" ) ; } av_log ( log_ctx , log_level , \"\\n\" ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@read_interval_packets": "static int read_interval_packets ( WriterContext * w , InputFile * ifile , const ReadInterval * interval , int64_t * cur_ts ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; AVPacket * pkt = NULL ; AVFrame * frame = NULL ; int ret = 0 , i = 0 , frame_count = 0 ; int64_t start = - INT64_MAX , end = interval -> end ; int has_start = 0 , has_end = interval -> has_end && ! interval -> end_is_offset ; av_log ( NULL , AV_LOG_VERBOSE , \"Processing read interval \" ) ; log_read_interval ( interval , NULL , AV_LOG_VERBOSE ) ; if ( interval -> has_start ) { int64_t target ; if ( interval -> start_is_offset ) { if ( * cur_ts == AV_NOPTS_VALUE ) { av_log ( NULL , AV_LOG_ERROR , \"Could not seek to relative position since current \" \"timestamp is not defined\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto end ; } target = * cur_ts + interval -> start ; } else { target = interval -> start ; } av_log ( NULL , AV_LOG_VERBOSE , \"Seeking to read interval start point %s\\n\" , av_ts2timestr ( target , & AV_TIME_BASE_Q ) ) ; if ( ( ret = avformat_seek_file ( fmt_ctx , - 1 , - INT64_MAX , target , INT64_MAX , 0 ) ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Could not seek to position %\" PRId64 \": %s\\n\" , interval -> start , av_err2str ( ret ) ) ; goto end ; } } frame = av_frame_alloc ( ) ; if ( ! frame ) { ret = AVERROR ( ENOMEM ) ; goto end ; } pkt = av_packet_alloc ( ) ; if ( ! pkt ) { ret = AVERROR ( ENOMEM ) ; goto end ; } while ( ! av_read_frame ( fmt_ctx , pkt ) ) { if ( fmt_ctx -> nb_streams > nb_streams ) { REALLOCZ_ARRAY_STREAM ( nb_streams_frames , nb_streams , fmt_ctx -> nb_streams ) ; REALLOCZ_ARRAY_STREAM ( nb_streams_packets , nb_streams , fmt_ctx -> nb_streams ) ; REALLOCZ_ARRAY_STREAM ( selected_streams , nb_streams , fmt_ctx -> nb_streams ) ; nb_streams = fmt_ctx -> nb_streams ; } if ( selected_streams [ pkt -> stream_index ] ) { AVRational tb = ifile -> streams [ pkt -> stream_index ] . st -> time_base ; int64_t pts = pkt -> pts != AV_NOPTS_VALUE ? pkt -> pts : pkt -> dts ; if ( pts != AV_NOPTS_VALUE ) * cur_ts = av_rescale_q ( pts , tb , AV_TIME_BASE_Q ) ; if ( ! has_start && * cur_ts != AV_NOPTS_VALUE ) { start = * cur_ts ; has_start = 1 ; } if ( has_start && ! has_end && interval -> end_is_offset ) { end = start + interval -> end ; has_end = 1 ; } if ( interval -> end_is_offset && interval -> duration_frames ) { if ( frame_count >= interval -> end ) break ; } else if ( has_end && * cur_ts != AV_NOPTS_VALUE && * cur_ts >= end ) { break ; } frame_count ++ ; if ( do_read_packets ) { if ( do_show_packets ) show_packet ( w , ifile , pkt , i ++ ) ; nb_streams_packets [ pkt -> stream_index ] ++ ; } if ( do_read_frames ) { int packet_new = 1 ; while ( process_frame ( w , ifile , frame , pkt , & packet_new ) > 0 ) ; } } av_packet_unref ( pkt ) ; } av_packet_unref ( pkt ) ; //Flush remaining frames that are cached in the decoder for ( i = 0 ; i < ifile -> nb_streams ; i ++ ) { pkt -> stream_index = i ; if ( do_read_frames ) { while ( process_frame ( w , ifile , frame , pkt , & ( int ) { 1 } ) > 0 ) ; if ( ifile -> streams [ i ] . dec_ctx ) avcodec_flush_buffers ( ifile -> streams [ i ] . dec_ctx ) ; } } end : av_frame_free ( & frame ) ; av_packet_free ( & pkt ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Could not read packets in interval \" ) ; log_read_interval ( interval , NULL , AV_LOG_ERROR ) ; } return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@read_packets": "static int read_packets ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; int64_t cur_ts = fmt_ctx -> start_time ; if ( read_intervals_nb == 0 ) { ReadInterval interval = ( ReadInterval ) { . has_start = 0 , . has_end = 0 } ; ret = read_interval_packets ( w , ifile , & interval , & cur_ts ) ; } else { for ( i = 0 ; i < read_intervals_nb ; i ++ ) { ret = read_interval_packets ( w , ifile , & read_intervals [ i ] , & cur_ts ) ; if ( ret < 0 ) break ; } } return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_stream": "static int show_stream ( WriterContext * w , AVFormatContext * fmt_ctx , int stream_idx , InputStream * ist , int in_program ) { AVStream * stream = ist -> st ; AVCodecParameters * par ; AVCodecContext * dec_ctx ; char val_str [ 128 ] ; const char * s ; AVRational sar , dar ; AVBPrint pbuf ; const AVCodecDescriptor * cd ; int ret = 0 ; const char * profile = NULL ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM ) ; print_int ( \"index\" , stream -> index ) ; par = stream -> codecpar ; dec_ctx = ist -> dec_ctx ; if ( ( cd = avcodec_descriptor_get ( par -> codec_id ) ) ) { print_str ( \"codec_name\" , cd -> name ) ; if ( ! do_bitexact ) { print_str ( \"codec_long_name\" , cd -> long_name ? cd -> long_name : \"unknown\" ) ; } } else { print_str_opt ( \"codec_name\" , \"unknown\" ) ; if ( ! do_bitexact ) { print_str_opt ( \"codec_long_name\" , \"unknown\" ) ; } } if ( ! do_bitexact && ( profile = avcodec_profile_name ( par -> codec_id , par -> profile ) ) ) print_str ( \"profile\" , profile ) ; else { if ( par -> profile != FF_PROFILE_UNKNOWN ) { char profile_num [ 12 ] ; snprintf ( profile_num , sizeof ( profile_num ) , \"%d\" , par -> profile ) ; print_str ( \"profile\" , profile_num ) ; } else print_str_opt ( \"profile\" , \"unknown\" ) ; } s = av_get_media_type_string ( par -> codec_type ) ; if ( s ) print_str ( \"codec_type\" , s ) ; else print_str_opt ( \"codec_type\" , \"unknown\" ) ; /* print AVI/FourCC tag */ print_str ( \"codec_tag_string\" , av_fourcc2str ( par -> codec_tag ) ) ; print_fmt ( \"codec_tag\" , \"0x%04\" PRIx32 , par -> codec_tag ) ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : print_int ( \"width\" , par -> width ) ; print_int ( \"height\" , par -> height ) ; if ( dec_ctx ) { print_int ( \"coded_width\" , dec_ctx -> coded_width ) ; print_int ( \"coded_height\" , dec_ctx -> coded_height ) ; print_int ( \"closed_captions\" , ! ! ( dec_ctx -> properties & FF_CODEC_PROPERTY_CLOSED_CAPTIONS ) ) ; print_int ( \"film_grain\" , ! ! ( dec_ctx -> properties & FF_CODEC_PROPERTY_FILM_GRAIN ) ) ; } print_int ( \"has_b_frames\" , par -> video_delay ) ; sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , NULL ) ; if ( sar . num ) { print_q ( \"sample_aspect_ratio\" , sar , ':' ) ; av_reduce ( & dar . num , & dar . den , par -> width * sar . num , par -> height * sar . den , 1024 * 1024 ) ; print_q ( \"display_aspect_ratio\" , dar , ':' ) ; } else { print_str_opt ( \"sample_aspect_ratio\" , \"N/A\" ) ; print_str_opt ( \"display_aspect_ratio\" , \"N/A\" ) ; } s = av_get_pix_fmt_name ( par -> format ) ; if ( s ) print_str ( \"pix_fmt\" , s ) ; else print_str_opt ( \"pix_fmt\" , \"unknown\" ) ; print_int ( \"level\" , par -> level ) ; print_color_range ( w , par -> color_range ) ; print_color_space ( w , par -> color_space ) ; print_color_trc ( w , par -> color_trc ) ; print_primaries ( w , par -> color_primaries ) ; print_chroma_location ( w , par -> chroma_location ) ; if ( par -> field_order == AV_FIELD_PROGRESSIVE ) print_str ( \"field_order\" , \"progressive\" ) ; else if ( par -> field_order == AV_FIELD_TT ) print_str ( \"field_order\" , \"tt\" ) ; else if ( par -> field_order == AV_FIELD_BB ) print_str ( \"field_order\" , \"bb\" ) ; else if ( par -> field_order == AV_FIELD_TB ) print_str ( \"field_order\" , \"tb\" ) ; else if ( par -> field_order == AV_FIELD_BT ) print_str ( \"field_order\" , \"bt\" ) ; else print_str_opt ( \"field_order\" , \"unknown\" ) ; if ( dec_ctx ) print_int ( \"refs\" , dec_ctx -> refs ) ; break ; case AVMEDIA_TYPE_AUDIO : s = av_get_sample_fmt_name ( par -> format ) ; if ( s ) print_str ( \"sample_fmt\" , s ) ; else print_str_opt ( \"sample_fmt\" , \"unknown\" ) ; print_val ( \"sample_rate\" , par -> sample_rate , unit_hertz_str ) ; print_int ( \"channels\" , par -> ch_layout . nb_channels ) ; if ( par -> ch_layout . order != AV_CHANNEL_ORDER_UNSPEC ) { av_channel_layout_describe ( & par -> ch_layout , val_str , sizeof ( val_str ) ) ; print_str ( \"channel_layout\" , val_str ) ; } else { print_str_opt ( \"channel_layout\" , \"unknown\" ) ; } print_int ( \"bits_per_sample\" , av_get_bits_per_sample ( par -> codec_id ) ) ; print_int ( \"initial_padding\" , par -> initial_padding ) ; break ; case AVMEDIA_TYPE_SUBTITLE : if ( par -> width ) print_int ( \"width\" , par -> width ) ; else print_str_opt ( \"width\" , \"N/A\" ) ; if ( par -> height ) print_int ( \"height\" , par -> height ) ; else print_str_opt ( \"height\" , \"N/A\" ) ; break ; } if ( dec_ctx && dec_ctx -> codec -> priv_class && show_private_data ) { const AVOption * opt = NULL ; while ( ( opt = av_opt_next ( dec_ctx -> priv_data , opt ) ) ) { uint8_t * str ; if ( ! ( opt -> flags & AV_OPT_FLAG_EXPORT ) ) continue ; if ( av_opt_get ( dec_ctx -> priv_data , opt -> name , 0 , & str ) >= 0 ) { print_str ( opt -> name , str ) ; av_free ( str ) ; } } } if ( fmt_ctx -> iformat -> flags & AVFMT_SHOW_IDS ) print_fmt ( \"id\" , \"0x%x\" , stream -> id ) ; else print_str_opt ( \"id\" , \"N/A\" ) ; print_q ( \"r_frame_rate\" , stream -> r_frame_rate , '/' ) ; print_q ( \"avg_frame_rate\" , stream -> avg_frame_rate , '/' ) ; print_q ( \"time_base\" , stream -> time_base , '/' ) ; print_ts ( \"start_pts\" , stream -> start_time ) ; print_time ( \"start_time\" , stream -> start_time , & stream -> time_base ) ; print_ts ( \"duration_ts\" , stream -> duration ) ; print_time ( \"duration\" , stream -> duration , & stream -> time_base ) ; if ( par -> bit_rate > 0 ) print_val ( \"bit_rate\" , par -> bit_rate , unit_bit_per_second_str ) ; else print_str_opt ( \"bit_rate\" , \"N/A\" ) ; if ( dec_ctx && dec_ctx -> rc_max_rate > 0 ) print_val ( \"max_bit_rate\" , dec_ctx -> rc_max_rate , unit_bit_per_second_str ) ; else print_str_opt ( \"max_bit_rate\" , \"N/A\" ) ; if ( dec_ctx && dec_ctx -> bits_per_raw_sample > 0 ) print_fmt ( \"bits_per_raw_sample\" , \"%d\" , dec_ctx -> bits_per_raw_sample ) ; else print_str_opt ( \"bits_per_raw_sample\" , \"N/A\" ) ; if ( stream -> nb_frames ) print_fmt ( \"nb_frames\" , \"%\" PRId64 , stream -> nb_frames ) ; else print_str_opt ( \"nb_frames\" , \"N/A\" ) ; if ( nb_streams_frames [ stream_idx ] ) print_fmt ( \"nb_read_frames\" , \"%\" PRIu64 , nb_streams_frames [ stream_idx ] ) ; else print_str_opt ( \"nb_read_frames\" , \"N/A\" ) ; if ( nb_streams_packets [ stream_idx ] ) print_fmt ( \"nb_read_packets\" , \"%\" PRIu64 , nb_streams_packets [ stream_idx ] ) ; else print_str_opt ( \"nb_read_packets\" , \"N/A\" ) ; if ( do_show_data ) writer_print_data ( w , \"extradata\" , par -> extradata , par -> extradata_size ) ; if ( par -> extradata_size > 0 ) { print_int ( \"extradata_size\" , par -> extradata_size ) ; writer_print_data_hash ( w , \"extradata_hash\" , par -> extradata , par -> extradata_size ) ; } /* Print disposition information */ # define PRINT_DISPOSITION ( flagname , name ) do { print_int ( name , ! ! ( stream -> disposition & AV_DISPOSITION_ ## flagname ) ) ; } while ( 0 ) if ( do_show_stream_disposition ) { writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION ) ; PRINT_DISPOSITION ( DEFAULT , \"default\" ) ; PRINT_DISPOSITION ( DUB , \"dub\" ) ; PRINT_DISPOSITION ( ORIGINAL , \"original\" ) ; PRINT_DISPOSITION ( COMMENT , \"comment\" ) ; PRINT_DISPOSITION ( LYRICS , \"lyrics\" ) ; PRINT_DISPOSITION ( KARAOKE , \"karaoke\" ) ; PRINT_DISPOSITION ( FORCED , \"forced\" ) ; PRINT_DISPOSITION ( HEARING_IMPAIRED , \"hearing_impaired\" ) ; PRINT_DISPOSITION ( VISUAL_IMPAIRED , \"visual_impaired\" ) ; PRINT_DISPOSITION ( CLEAN_EFFECTS , \"clean_effects\" ) ; PRINT_DISPOSITION ( ATTACHED_PIC , \"attached_pic\" ) ; PRINT_DISPOSITION ( TIMED_THUMBNAILS , \"timed_thumbnails\" ) ; PRINT_DISPOSITION ( CAPTIONS , \"captions\" ) ; PRINT_DISPOSITION ( DESCRIPTIONS , \"descriptions\" ) ; PRINT_DISPOSITION ( METADATA , \"metadata\" ) ; PRINT_DISPOSITION ( DEPENDENT , \"dependent\" ) ; PRINT_DISPOSITION ( STILL_IMAGE , \"still_image\" ) ; writer_print_section_footer ( w ) ; } if ( do_show_stream_tags ) ret = show_tags ( w , stream -> metadata , in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS ) ; if ( stream -> nb_side_data ) { print_pkt_side_data ( w , stream -> codecpar , stream -> side_data , stream -> nb_side_data , SECTION_ID_STREAM_SIDE_DATA_LIST , SECTION_ID_STREAM_SIDE_DATA ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_streams": "static int show_streams ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; writer_print_section_header ( w , SECTION_ID_STREAMS ) ; for ( i = 0 ; i < ifile -> nb_streams ; i ++ ) if ( selected_streams [ i ] ) { ret = show_stream ( w , fmt_ctx , i , & ifile -> streams [ i ] , 0 ) ; if ( ret < 0 ) break ; } writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_program": "static int show_program ( WriterContext * w , InputFile * ifile , AVProgram * program ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; writer_print_section_header ( w , SECTION_ID_PROGRAM ) ; print_int ( \"program_id\" , program -> id ) ; print_int ( \"program_num\" , program -> program_num ) ; print_int ( \"nb_streams\" , program -> nb_stream_indexes ) ; print_int ( \"pmt_pid\" , program -> pmt_pid ) ; print_int ( \"pcr_pid\" , program -> pcr_pid ) ; if ( do_show_program_tags ) ret = show_tags ( w , program -> metadata , SECTION_ID_PROGRAM_TAGS ) ; if ( ret < 0 ) goto end ; writer_print_section_header ( w , SECTION_ID_PROGRAM_STREAMS ) ; for ( i = 0 ; i < program -> nb_stream_indexes ; i ++ ) { if ( selected_streams [ program -> stream_index [ i ] ] ) { ret = show_stream ( w , fmt_ctx , program -> stream_index [ i ] , & ifile -> streams [ program -> stream_index [ i ] ] , 1 ) ; if ( ret < 0 ) break ; } } writer_print_section_footer ( w ) ; end : writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_programs": "static int show_programs ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; writer_print_section_header ( w , SECTION_ID_PROGRAMS ) ; for ( i = 0 ; i < fmt_ctx -> nb_programs ; i ++ ) { AVProgram * program = fmt_ctx -> programs [ i ] ; if ( ! program ) continue ; ret = show_program ( w , ifile , program ) ; if ( ret < 0 ) break ; } writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_chapters": "static int show_chapters ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; int i , ret = 0 ; writer_print_section_header ( w , SECTION_ID_CHAPTERS ) ; for ( i = 0 ; i < fmt_ctx -> nb_chapters ; i ++ ) { AVChapter * chapter = fmt_ctx -> chapters [ i ] ; writer_print_section_header ( w , SECTION_ID_CHAPTER ) ; print_int ( \"id\" , chapter -> id ) ; print_q ( \"time_base\" , chapter -> time_base , '/' ) ; print_int ( \"start\" , chapter -> start ) ; print_time ( \"start_time\" , chapter -> start , & chapter -> time_base ) ; print_int ( \"end\" , chapter -> end ) ; print_time ( \"end_time\" , chapter -> end , & chapter -> time_base ) ; if ( do_show_chapter_tags ) ret = show_tags ( w , chapter -> metadata , SECTION_ID_CHAPTER_TAGS ) ; writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_format": "static int show_format ( WriterContext * w , InputFile * ifile ) { AVFormatContext * fmt_ctx = ifile -> fmt_ctx ; char val_str [ 128 ] ; int64_t size = fmt_ctx -> pb ? avio_size ( fmt_ctx -> pb ) : - 1 ; int ret = 0 ; writer_print_section_header ( w , SECTION_ID_FORMAT ) ; print_str_validate ( \"filename\" , fmt_ctx -> url ) ; print_int ( \"nb_streams\" , fmt_ctx -> nb_streams ) ; print_int ( \"nb_programs\" , fmt_ctx -> nb_programs ) ; print_str ( \"format_name\" , fmt_ctx -> iformat -> name ) ; if ( ! do_bitexact ) { if ( fmt_ctx -> iformat -> long_name ) print_str ( \"format_long_name\" , fmt_ctx -> iformat -> long_name ) ; else print_str_opt ( \"format_long_name\" , \"unknown\" ) ; } print_time ( \"start_time\" , fmt_ctx -> start_time , & AV_TIME_BASE_Q ) ; print_time ( \"duration\" , fmt_ctx -> duration , & AV_TIME_BASE_Q ) ; if ( size >= 0 ) print_val ( \"size\" , size , unit_byte_str ) ; else print_str_opt ( \"size\" , \"N/A\" ) ; if ( fmt_ctx -> bit_rate > 0 ) print_val ( \"bit_rate\" , fmt_ctx -> bit_rate , unit_bit_per_second_str ) ; else print_str_opt ( \"bit_rate\" , \"N/A\" ) ; print_int ( \"probe_score\" , fmt_ctx -> probe_score ) ; if ( do_show_format_tags ) ret = show_tags ( w , fmt_ctx -> metadata , SECTION_ID_FORMAT_TAGS ) ; writer_print_section_footer ( w ) ; fflush ( stdout ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_error": "static void show_error ( WriterContext * w , int err ) { writer_print_section_header ( w , SECTION_ID_ERROR ) ; print_int ( \"code\" , err ) ; print_str ( \"string\" , av_err2str ( err ) ) ; writer_print_section_footer ( w ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@open_input_file": "static int open_input_file ( InputFile * ifile , const char * filename , const char * print_filename ) { int err , i ; AVFormatContext * fmt_ctx = NULL ; const AVDictionaryEntry * t = NULL ; int scan_all_pmts_set = 0 ; fmt_ctx = avformat_alloc_context ( ) ; if ( ! fmt_ctx ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( ! av_dict_get ( format_opts , \"scan_all_pmts\" , NULL , AV_DICT_MATCH_CASE ) ) { av_dict_set ( & format_opts , \"scan_all_pmts\" , \"1\" , AV_DICT_DONT_OVERWRITE ) ; scan_all_pmts_set = 1 ; } if ( ( err = avformat_open_input ( & fmt_ctx , filename , iformat , & format_opts ) ) < 0 ) { print_error ( filename , err ) ; return err ; } if ( print_filename ) { av_freep ( & fmt_ctx -> url ) ; fmt_ctx -> url = av_strdup ( print_filename ) ; } ifile -> fmt_ctx = fmt_ctx ; if ( scan_all_pmts_set ) av_dict_set ( & format_opts , \"scan_all_pmts\" , NULL , AV_DICT_MATCH_CASE ) ; while ( ( t = av_dict_iterate ( format_opts , t ) ) ) av_log ( NULL , AV_LOG_WARNING , \"Option %s skipped - not known to demuxer.\\n\" , t -> key ) ; if ( find_stream_info ) { AVDictionary * * opts = setup_find_stream_info_opts ( fmt_ctx , codec_opts ) ; int orig_nb_streams = fmt_ctx -> nb_streams ; err = avformat_find_stream_info ( fmt_ctx , opts ) ; for ( i = 0 ; i < orig_nb_streams ; i ++ ) av_dict_free ( & opts [ i ] ) ; av_freep ( & opts ) ; if ( err < 0 ) { print_error ( filename , err ) ; return err ; } } av_dump_format ( fmt_ctx , 0 , filename , 0 ) ; ifile -> streams = av_calloc ( fmt_ctx -> nb_streams , sizeof ( * ifile -> streams ) ) ; if ( ! ifile -> streams ) exit ( 1 ) ; ifile -> nb_streams = fmt_ctx -> nb_streams ; /* bind a decoder to each input stream */ for ( i = 0 ; i < fmt_ctx -> nb_streams ; i ++ ) { InputStream * ist = & ifile -> streams [ i ] ; AVStream * stream = fmt_ctx -> streams [ i ] ; const AVCodec * codec ; ist -> st = stream ; if ( stream -> codecpar -> codec_id == AV_CODEC_ID_PROBE ) { av_log ( NULL , AV_LOG_WARNING , \"Failed to probe codec for input stream %d\\n\" , stream -> index ) ; continue ; } codec = avcodec_find_decoder ( stream -> codecpar -> codec_id ) ; if ( ! codec ) { av_log ( NULL , AV_LOG_WARNING , \"Unsupported codec with id %d for input stream %d\\n\" , stream -> codecpar -> codec_id , stream -> index ) ; continue ; } { AVDictionary * opts = filter_codec_opts ( codec_opts , stream -> codecpar -> codec_id , fmt_ctx , stream , codec ) ; ist -> dec_ctx = avcodec_alloc_context3 ( codec ) ; if ( ! ist -> dec_ctx ) exit ( 1 ) ; err = avcodec_parameters_to_context ( ist -> dec_ctx , stream -> codecpar ) ; if ( err < 0 ) exit ( 1 ) ; if ( do_show_log ) { // For loging it is needed to disable at least frame threads as otherwise // the log information would need to be reordered and matches up to contexts and frames // That is in fact possible but not trivial av_dict_set ( & codec_opts , \"threads\" , \"1\" , 0 ) ; } ist -> dec_ctx -> pkt_timebase = stream -> time_base ; if ( avcodec_open2 ( ist -> dec_ctx , codec , & opts ) < 0 ) { av_log ( NULL , AV_LOG_WARNING , \"Could not open codec for input stream %d\\n\" , stream -> index ) ; exit ( 1 ) ; } if ( ( t = av_dict_get ( opts , \"\" , NULL , AV_DICT_IGNORE_SUFFIX ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"Option %s for input stream %d not found\\n\" , t -> key , stream -> index ) ; return AVERROR_OPTION_NOT_FOUND ; } } } ifile -> fmt_ctx = fmt_ctx ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@close_input_file": "static void close_input_file ( InputFile * ifile ) { int i ; /* close decoder for each stream */ for ( i = 0 ; i < ifile -> nb_streams ; i ++ ) avcodec_free_context ( & ifile -> streams [ i ] . dec_ctx ) ; av_freep ( & ifile -> streams ) ; ifile -> nb_streams = 0 ; avformat_close_input ( & ifile -> fmt_ctx ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@probe_file": "static int probe_file ( WriterContext * wctx , const char * filename , const char * print_filename ) { InputFile ifile = { 0 } ; int ret , i ; int section_id ; do_read_frames = do_show_frames || do_count_frames ; do_read_packets = do_show_packets || do_count_packets ; ret = open_input_file ( & ifile , filename , print_filename ) ; if ( ret < 0 ) goto end ; # define CHECK_END if ( ret < 0 ) goto end nb_streams = ifile . fmt_ctx -> nb_streams ; REALLOCZ_ARRAY_STREAM ( nb_streams_frames , 0 , ifile . fmt_ctx -> nb_streams ) ; REALLOCZ_ARRAY_STREAM ( nb_streams_packets , 0 , ifile . fmt_ctx -> nb_streams ) ; REALLOCZ_ARRAY_STREAM ( selected_streams , 0 , ifile . fmt_ctx -> nb_streams ) ; for ( i = 0 ; i < ifile . fmt_ctx -> nb_streams ; i ++ ) { if ( stream_specifier ) { ret = avformat_match_stream_specifier ( ifile . fmt_ctx , ifile . fmt_ctx -> streams [ i ] , stream_specifier ) ; CHECK_END ; else selected_streams [ i ] = ret ; ret = 0 ; } else { selected_streams [ i ] = 1 ; } if ( ! selected_streams [ i ] ) ifile . fmt_ctx -> streams [ i ] -> discard = AVDISCARD_ALL ; } if ( do_read_frames || do_read_packets ) { if ( do_show_frames && do_show_packets && wctx -> writer -> flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER ) section_id = SECTION_ID_PACKETS_AND_FRAMES ; else if ( do_show_packets && ! do_show_frames ) section_id = SECTION_ID_PACKETS ; else // (!do_show_packets && do_show_frames) section_id = SECTION_ID_FRAMES ; if ( do_show_frames || do_show_packets ) writer_print_section_header ( wctx , section_id ) ; ret = read_packets ( wctx , & ifile ) ; if ( do_show_frames || do_show_packets ) writer_print_section_footer ( wctx ) ; CHECK_END ; } if ( do_show_programs ) { ret = show_programs ( wctx , & ifile ) ; CHECK_END ; } if ( do_show_streams ) { ret = show_streams ( wctx , & ifile ) ; CHECK_END ; } if ( do_show_chapters ) { ret = show_chapters ( wctx , & ifile ) ; CHECK_END ; } if ( do_show_format ) { ret = show_format ( wctx , & ifile ) ; CHECK_END ; } end : if ( ifile . fmt_ctx ) close_input_file ( & ifile ) ; av_freep ( & nb_streams_frames ) ; av_freep ( & nb_streams_packets ) ; av_freep ( & selected_streams ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_usage": "static void show_usage ( void ) { av_log ( NULL , AV_LOG_INFO , \"Simple multimedia streams analyzer\\n\" ) ; av_log ( NULL , AV_LOG_INFO , \"usage: %s [OPTIONS] INPUT_FILE\\n\" , program_name ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@ffprobe_show_program_version": "static void ffprobe_show_program_version ( WriterContext * w ) { AVBPrint pbuf ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_PROGRAM_VERSION ) ; print_str ( \"version\" , FFMPEG_VERSION ) ; print_fmt ( \"copyright\" , \"Copyright (c) %d-%d the FFmpeg developers\" , program_birth_year , CONFIG_THIS_YEAR ) ; print_str ( \"compiler_ident\" , CC_IDENT ) ; print_str ( \"configuration\" , FFMPEG_CONFIGURATION ) ; writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@ffprobe_show_library_versions": "static void ffprobe_show_library_versions ( WriterContext * w ) { writer_print_section_header ( w , SECTION_ID_LIBRARY_VERSIONS ) ; SHOW_LIB_VERSION ( avutil , AVUTIL ) ; SHOW_LIB_VERSION ( avcodec , AVCODEC ) ; SHOW_LIB_VERSION ( avformat , AVFORMAT ) ; SHOW_LIB_VERSION ( avdevice , AVDEVICE ) ; SHOW_LIB_VERSION ( avfilter , AVFILTER ) ; SHOW_LIB_VERSION ( swscale , SWSCALE ) ; SHOW_LIB_VERSION ( swresample , SWRESAMPLE ) ; writer_print_section_footer ( w ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@ffprobe_show_pixel_formats": "static void ffprobe_show_pixel_formats ( WriterContext * w ) { const AVPixFmtDescriptor * pixdesc = NULL ; int i , n ; writer_print_section_header ( w , SECTION_ID_PIXEL_FORMATS ) ; while ( ( pixdesc = av_pix_fmt_desc_next ( pixdesc ) ) ) { writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT ) ; print_str ( \"name\" , pixdesc -> name ) ; print_int ( \"nb_components\" , pixdesc -> nb_components ) ; if ( ( pixdesc -> nb_components >= 3 ) && ! ( pixdesc -> flags & AV_PIX_FMT_FLAG_RGB ) ) { print_int ( \"log2_chroma_w\" , pixdesc -> log2_chroma_w ) ; print_int ( \"log2_chroma_h\" , pixdesc -> log2_chroma_h ) ; } else { print_str_opt ( \"log2_chroma_w\" , \"N/A\" ) ; print_str_opt ( \"log2_chroma_h\" , \"N/A\" ) ; } n = av_get_bits_per_pixel ( pixdesc ) ; if ( n ) print_int ( \"bits_per_pixel\" , n ) ; else print_str_opt ( \"bits_per_pixel\" , \"N/A\" ) ; if ( do_show_pixel_format_flags ) { writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_FLAGS ) ; PRINT_PIX_FMT_FLAG ( BE , \"big_endian\" ) ; PRINT_PIX_FMT_FLAG ( PAL , \"palette\" ) ; PRINT_PIX_FMT_FLAG ( BITSTREAM , \"bitstream\" ) ; PRINT_PIX_FMT_FLAG ( HWACCEL , \"hwaccel\" ) ; PRINT_PIX_FMT_FLAG ( PLANAR , \"planar\" ) ; PRINT_PIX_FMT_FLAG ( RGB , \"rgb\" ) ; PRINT_PIX_FMT_FLAG ( ALPHA , \"alpha\" ) ; writer_print_section_footer ( w ) ; } if ( do_show_pixel_format_components && ( pixdesc -> nb_components > 0 ) ) { writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_COMPONENTS ) ; for ( i = 0 ; i < pixdesc -> nb_components ; i ++ ) { writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_COMPONENT ) ; print_int ( \"index\" , i + 1 ) ; print_int ( \"bit_depth\" , pixdesc -> comp [ i ] . depth ) ; writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_show_optional_fields": "static int opt_show_optional_fields ( void * optctx , const char * opt , const char * arg ) { if ( ! av_strcasecmp ( arg , \"always\" ) ) show_optional_fields = SHOW_OPTIONAL_FIELDS_ALWAYS ; else if ( ! av_strcasecmp ( arg , \"never\" ) ) show_optional_fields = SHOW_OPTIONAL_FIELDS_NEVER ; else if ( ! av_strcasecmp ( arg , \"auto\" ) ) show_optional_fields = SHOW_OPTIONAL_FIELDS_AUTO ; if ( show_optional_fields == SHOW_OPTIONAL_FIELDS_AUTO && av_strcasecmp ( arg , \"auto\" ) ) show_optional_fields = parse_number_or_die ( \"show_optional_fields\" , arg , OPT_INT , SHOW_OPTIONAL_FIELDS_AUTO , SHOW_OPTIONAL_FIELDS_ALWAYS ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_format": "static int opt_format ( void * optctx , const char * opt , const char * arg ) { iformat = av_find_input_format ( arg ) ; if ( ! iformat ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown input format: %s\\n\" , arg ) ; return AVERROR ( EINVAL ) ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@mark_section_show_entries": "static inline void mark_section_show_entries ( SectionID section_id , int show_all_entries , AVDictionary * entries ) { struct section * section = & sections [ section_id ] ; section -> show_all_entries = show_all_entries ; if ( show_all_entries ) { SectionID * id ; for ( id = section -> children_ids ; * id != - 1 ; id ++ ) mark_section_show_entries ( * id , show_all_entries , entries ) ; } else { av_dict_copy ( & section -> entries_to_show , entries , 0 ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@match_section": "static int match_section ( const char * section_name , int show_all_entries , AVDictionary * entries ) { int i , ret = 0 ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( sections ) ; i ++ ) { const struct section * section = & sections [ i ] ; if ( ! strcmp ( section_name , section -> name ) || ( section -> unique_name && ! strcmp ( section_name , section -> unique_name ) ) ) { av_log ( NULL , AV_LOG_DEBUG , \"'%s' matches section with unique name '%s'\\n\" , section_name , ( char * ) av_x_if_null ( section -> unique_name , section -> name ) ) ; ret ++ ; mark_section_show_entries ( section -> id , show_all_entries , entries ) ; } } return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_show_entries": "static int opt_show_entries ( void * optctx , const char * opt , const char * arg ) { const char * p = arg ; int ret = 0 ; while ( * p ) { AVDictionary * entries = NULL ; char * section_name = av_get_token ( & p , \"=:\" ) ; int show_all_entries = 0 ; if ( ! section_name ) { av_log ( NULL , AV_LOG_ERROR , \"Missing section name for option '%s'\\n\" , opt ) ; return AVERROR ( EINVAL ) ; } if ( * p == '=' ) { p ++ ; while ( * p && * p != ':' ) { char * entry = av_get_token ( & p , \",:\" ) ; if ( ! entry ) break ; av_log ( NULL , AV_LOG_VERBOSE , \"Adding '%s' to the entries to show in section '%s'\\n\" , entry , section_name ) ; av_dict_set ( & entries , entry , \"\" , AV_DICT_DONT_STRDUP_KEY ) ; if ( * p == ',' ) p ++ ; } } else { show_all_entries = 1 ; } ret = match_section ( section_name , show_all_entries , entries ) ; if ( ret == 0 ) { av_log ( NULL , AV_LOG_ERROR , \"No match for section '%s'\\n\" , section_name ) ; ret = AVERROR ( EINVAL ) ; } av_dict_free ( & entries ) ; av_free ( section_name ) ; if ( ret <= 0 ) break ; if ( * p ) p ++ ; } return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_input_file": "static void opt_input_file ( void * optctx , const char * arg ) { if ( input_filename ) { av_log ( NULL , AV_LOG_ERROR , \"Argument '%s' provided as input filename, but '%s' was already specified.\\n\" , arg , input_filename ) ; exit_program ( 1 ) ; } if ( ! strcmp ( arg , \"-\" ) ) arg = \"fd:\" ; input_filename = arg ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_input_file_i": "static int opt_input_file_i ( void * optctx , const char * opt , const char * arg ) { opt_input_file ( optctx , arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_output_file": "static void opt_output_file ( void * optctx , const char * arg ) { if ( output_filename ) { av_log ( NULL , AV_LOG_ERROR , \"Argument '%s' provided as output filename, but '%s' was already specified.\\n\" , arg , output_filename ) ; exit_program ( 1 ) ; } if ( ! strcmp ( arg , \"-\" ) ) arg = \"fd:\" ; output_filename = arg ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_output_file_o": "static int opt_output_file_o ( void * optctx , const char * opt , const char * arg ) { opt_output_file ( optctx , arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_print_filename": "static int opt_print_filename ( void * optctx , const char * opt , const char * arg ) { print_input_filename = arg ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@show_help_default_ffprobe": "void show_help_default_ffprobe ( const char * opt , const char * arg ) { show_usage ( ) ; show_help_options ( ffprobe_options , \"Main options:\" , 0 , 0 , 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; show_help_children ( avformat_get_class ( ) , AV_OPT_FLAG_DECODING_PARAM ) ; show_help_children ( avcodec_get_class ( ) , AV_OPT_FLAG_DECODING_PARAM ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@parse_read_interval": "static int parse_read_interval ( const char * interval_spec , ReadInterval * interval ) { int ret = 0 ; char * next , * p , * spec = av_strdup ( interval_spec ) ; if ( ! spec ) return AVERROR ( ENOMEM ) ; if ( ! * spec ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid empty interval specification\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto end ; } p = spec ; next = strchr ( spec , '%' ) ; if ( next ) * next ++ = 0 ; /* parse first part */ if ( * p ) { interval -> has_start = 1 ; if ( * p == '+' ) { interval -> start_is_offset = 1 ; p ++ ; } else { interval -> start_is_offset = 0 ; } ret = av_parse_time ( & interval -> start , p , 1 ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid interval start specification '%s'\\n\" , p ) ; goto end ; } } else { interval -> has_start = 0 ; } /* parse second part */ p = next ; if ( p && * p ) { int64_t us ; interval -> has_end = 1 ; if ( * p == '+' ) { interval -> end_is_offset = 1 ; p ++ ; } else { interval -> end_is_offset = 0 ; } if ( interval -> end_is_offset && * p == '#' ) { long long int lli ; char * tail ; interval -> duration_frames = 1 ; p ++ ; lli = strtoll ( p , & tail , 10 ) ; if ( * tail || lli < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid or negative value '%s' for duration number of frames\\n\" , p ) ; goto end ; } interval -> end = lli ; } else { interval -> duration_frames = 0 ; ret = av_parse_time ( & us , p , 1 ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid interval end/duration specification '%s'\\n\" , p ) ; goto end ; } interval -> end = us ; } } else { interval -> has_end = 0 ; } end : av_free ( spec ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@parse_read_intervals": "static int parse_read_intervals ( const char * intervals_spec ) { int ret , n , i ; char * p , * spec = av_strdup ( intervals_spec ) ; if ( ! spec ) return AVERROR ( ENOMEM ) ; /* preparse specification, get number of intervals */ for ( n = 0 , p = spec ; * p ; p ++ ) if ( * p == ',' ) n ++ ; n ++ ; read_intervals = av_malloc_array ( n , sizeof ( * read_intervals ) ) ; if ( ! read_intervals ) { ret = AVERROR ( ENOMEM ) ; goto end ; } read_intervals_nb = n ; /* parse intervals */ p = spec ; for ( i = 0 ; p ; i ++ ) { char * next ; av_assert0 ( i < read_intervals_nb ) ; next = strchr ( p , ',' ) ; if ( next ) * next ++ = 0 ; read_intervals [ i ] . id = i ; ret = parse_read_interval ( p , & read_intervals [ i ] ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing read interval #%d '%s'\\n\" , i , p ) ; goto end ; } av_log ( NULL , AV_LOG_VERBOSE , \"Parsed log interval \" ) ; log_read_interval ( & read_intervals [ i ] , NULL , AV_LOG_VERBOSE ) ; p = next ; } av_assert0 ( i == read_intervals_nb ) ; end : av_free ( spec ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_read_intervals": "static int opt_read_intervals ( void * optctx , const char * opt , const char * arg ) { return parse_read_intervals ( arg ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_pretty": "static int opt_pretty ( void * optctx , const char * opt , const char * arg ) { show_value_unit = 1 ; use_value_prefix = 1 ; use_byte_value_binary_prefix = 1 ; use_value_sexagesimal_format = 1 ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@print_section": "static void print_section ( SectionID id , int level ) { const SectionID * pid ; const struct section * section = & sections [ id ] ; av_log ( NULL , AV_LOG_STDERR , \"%c%c%c\" , section -> flags & SECTION_FLAG_IS_WRAPPER ? 'W' : '.' , section -> flags & SECTION_FLAG_IS_ARRAY ? 'A' : '.' , section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ? 'V' : '.' ) ; av_log ( NULL , AV_LOG_STDERR , \"%*c  %s\" , level * 4 , ' ' , section -> name ) ; if ( section -> unique_name ) av_log ( NULL , AV_LOG_STDERR , \"/%s\" , section -> unique_name ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; for ( pid = section -> children_ids ; * pid != - 1 ; pid ++ ) print_section ( * pid , level + 1 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_sections": "static int opt_sections ( void * optctx , const char * opt , const char * arg ) { av_log ( NULL , AV_LOG_STDERR , \"Sections:\\n\" \"W.. = Section is a wrapper (contains other sections, no local entries)\\n\" \".A. = Section contains an array of elements of the same type\\n\" \"..V = Section may contain a variable number of fields with variable keys\\n\" \"FLAGS NAME/UNIQUE_NAME\\n\" \"---\\n\" ) ; print_section ( SECTION_ID_ROOT , 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_show_versions": "static int opt_show_versions ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_PROGRAM_VERSION , 1 , NULL ) ; mark_section_show_entries ( SECTION_ID_LIBRARY_VERSION , 1 , NULL ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_show_chapters": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_show_error": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_show_format": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_show_frames": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_show_library_versions": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_show_packets": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_show_pixel_formats": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_show_program_version": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS ) DEFINE_OPT_SHOW_SECTION ( program_version , PROGRAM_VERSION )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_show_streams": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS ) DEFINE_OPT_SHOW_SECTION ( program_version , PROGRAM_VERSION ) DEFINE_OPT_SHOW_SECTION ( streams , STREAMS )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@opt_show_programs": "static int opt_show_ ## section ( void * optctx , const char * opt , const char * arg ) { mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ; return 0 ; } DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS ) DEFINE_OPT_SHOW_SECTION ( program_version , PROGRAM_VERSION ) DEFINE_OPT_SHOW_SECTION ( streams , STREAMS ) DEFINE_OPT_SHOW_SECTION ( programs , PROGRAMS )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@check_section_show_entries": "static inline int check_section_show_entries ( int section_id ) { int * id ; struct section * section = & sections [ section_id ] ; if ( sections [ section_id ] . show_all_entries || sections [ section_id ] . entries_to_show ) return 1 ; for ( id = section -> children_ids ; * id != - 1 ; id ++ ) if ( check_section_show_entries ( * id ) ) return 1 ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@ffprobe_var_cleanup": "void ffprobe_var_cleanup ( ) { main_ffprobe_return_code = 0 ; longjmp_value = 0 ; do_bitexact = 0 ; do_count_frames = 0 ; do_count_packets = 0 ; do_read_frames = 0 ; do_read_packets = 0 ; do_show_chapters = 0 ; do_show_error = 0 ; do_show_format = 0 ; do_show_frames = 0 ; do_show_packets = 0 ; do_show_programs = 0 ; do_show_streams = 0 ; do_show_stream_disposition = 0 ; do_show_data = 0 ; do_show_program_version = 0 ; do_show_library_versions = 0 ; do_show_pixel_formats = 0 ; do_show_pixel_format_flags = 0 ; do_show_pixel_format_components = 0 ; do_show_log = 0 ; do_show_chapter_tags = 0 ; do_show_format_tags = 0 ; do_show_frame_tags = 0 ; do_show_program_tags = 0 ; do_show_stream_tags = 0 ; do_show_packet_tags = 0 ; show_value_unit = 0 ; use_value_prefix = 0 ; use_byte_value_binary_prefix = 0 ; use_value_sexagesimal_format = 0 ; show_private_data = 1 ; print_format = NULL ; stream_specifier = NULL ; show_data_hash = NULL ; read_intervals = NULL ; read_intervals_nb = 0 ; find_stream_info = 1 ; ffprobe_options = NULL ; input_filename = NULL ; print_input_filename = NULL ; iformat = NULL ; hash = NULL ; main_ffprobe_return_code = 0 ; nb_streams = 0 ; nb_streams_packets = NULL ; nb_streams_frames = NULL ; selected_streams = NULL ; log_buffer = NULL ; log_buffer_size = 0 ; for ( int i = 0 ; i < FF_ARRAY_ELEMS ( sections ) ; i ++ ) { sections [ i ] . show_all_entries = 0 ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffprobe.c@ffprobe_execute": "int ffprobe_execute ( int argc , char * * argv ) { char _program_name [ ] = \"ffprobe\" ; program_name = ( char * ) & _program_name ; program_birth_year = 2007 ; OptionDef options [ ] = { { \"L\" , OPT_EXIT , { . func_arg = show_license } , \"show license\" } , { \"h\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"?\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"help\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"-help\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"version\" , OPT_EXIT , { . func_arg = show_version } , \"show version\" } , { \"buildconf\" , OPT_EXIT , { . func_arg = show_buildconf } , \"show build configuration\" } , { \"formats\" , OPT_EXIT , { . func_arg = show_formats } , \"show available formats\" } , { \"muxers\" , OPT_EXIT , { . func_arg = show_muxers } , \"show available muxers\" } , { \"demuxers\" , OPT_EXIT , { . func_arg = show_demuxers } , \"show available demuxers\" } , { \"devices\" , OPT_EXIT , { . func_arg = show_devices } , \"show available devices\" } , { \"codecs\" , OPT_EXIT , { . func_arg = show_codecs } , \"show available codecs\" } , { \"decoders\" , OPT_EXIT , { . func_arg = show_decoders } , \"show available decoders\" } , { \"encoders\" , OPT_EXIT , { . func_arg = show_encoders } , \"show available encoders\" } , { \"bsfs\" , OPT_EXIT , { . func_arg = show_bsfs } , \"show available bit stream filters\" } , { \"protocols\" , OPT_EXIT , { . func_arg = show_protocols } , \"show available protocols\" } , { \"filters\" , OPT_EXIT , { . func_arg = show_filters } , \"show available filters\" } , { \"pix_fmts\" , OPT_EXIT , { . func_arg = show_pix_fmts } , \"show available pixel formats\" } , { \"layouts\" , OPT_EXIT , { . func_arg = show_layouts } , \"show standard channel layouts\" } , { \"sample_fmts\" , OPT_EXIT , { . func_arg = show_sample_fmts } , \"show available audio sample formats\" } , { \"dispositions\" , OPT_EXIT , { . func_arg = show_dispositions } , \"show available stream dispositions\" } , { \"colors\" , OPT_EXIT , { . func_arg = show_colors } , \"show available color names\" } , { \"loglevel\" , HAS_ARG , { . func_arg = opt_loglevel } , \"set logging level\" , \"loglevel\" } , { \"v\" , HAS_ARG , { . func_arg = opt_loglevel } , \"set logging level\" , \"loglevel\" } , { \"report\" , 0 , { . func_arg = opt_report } , \"generate a report\" } , { \"max_alloc\" , HAS_ARG , { . func_arg = opt_max_alloc } , \"set maximum size of a single allocated block\" , \"bytes\" } , { \"cpuflags\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_cpuflags } , \"force specific cpu flags\" , \"flags\" } , { \"cpucount\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_cpucount } , \"force specific cpu count\" , \"count\" } , { \"hide_banner\" , OPT_BOOL | OPT_EXPERT , { & hide_banner } , \"do not show program banner\" , \"hide_banner\" } , # if CONFIG_AVDEVICE { \"sources\" , OPT_EXIT | HAS_ARG , { . func_arg = show_sources } , \"list sources of the input device\" , \"device\" } , { \"sinks\" , OPT_EXIT | HAS_ARG , { . func_arg = show_sinks } , \"list sinks of the output device\" , \"device\" } , # endif { \"f\" , HAS_ARG , { . func_arg = opt_format } , \"force format\" , \"format\" } , { \"unit\" , OPT_BOOL , { & show_value_unit } , \"show unit of the displayed values\" } , { \"prefix\" , OPT_BOOL , { & use_value_prefix } , \"use SI prefixes for the displayed values\" } , { \"byte_binary_prefix\" , OPT_BOOL , { & use_byte_value_binary_prefix } , \"use binary prefixes for byte units\" } , { \"sexagesimal\" , OPT_BOOL , { & use_value_sexagesimal_format } , \"use sexagesimal format HOURS:MM:SS.MICROSECONDS for time units\" } , { \"pretty\" , 0 , { . func_arg = opt_pretty } , \"prettify the format of displayed values, make it more human readable\" } , { \"print_format\" , OPT_STRING | HAS_ARG , { & print_format } , \"set the output printing format (available formats are: default, compact, csv, flat, ini, json, xml)\" , \"format\" } , { \"of\" , OPT_STRING | HAS_ARG , { & print_format } , \"alias for -print_format\" , \"format\" } , { \"select_streams\" , OPT_STRING | HAS_ARG , { & stream_specifier } , \"select the specified streams\" , \"stream_specifier\" } , { \"sections\" , OPT_EXIT , { . func_arg = opt_sections } , \"print sections structure and section information, and exit\" } , { \"show_data\" , OPT_BOOL , { & do_show_data } , \"show packets data\" } , { \"show_data_hash\" , OPT_STRING | HAS_ARG , { & show_data_hash } , \"show packets data hash\" } , { \"show_error\" , 0 , { . func_arg = & opt_show_error } , \"show probing error\" } , { \"show_format\" , 0 , { . func_arg = & opt_show_format } , \"show format/container info\" } , { \"show_frames\" , 0 , { . func_arg = & opt_show_frames } , \"show frames info\" } , { \"show_entries\" , HAS_ARG , { . func_arg = opt_show_entries } , \"show a set of specified entries\" , \"entry_list\" } , # if HAVE_THREADS { \"show_log\" , OPT_INT | HAS_ARG , { & do_show_log } , \"show log\" } , # endif { \"show_packets\" , 0 , { . func_arg = & opt_show_packets } , \"show packets info\" } , { \"show_programs\" , 0 , { . func_arg = & opt_show_programs } , \"show programs info\" } , { \"show_streams\" , 0 , { . func_arg = & opt_show_streams } , \"show streams info\" } , { \"show_chapters\" , 0 , { . func_arg = & opt_show_chapters } , \"show chapters info\" } , { \"count_frames\" , OPT_BOOL , { & do_count_frames } , \"count the number of frames per stream\" } , { \"count_packets\" , OPT_BOOL , { & do_count_packets } , \"count the number of packets per stream\" } , { \"show_program_version\" , 0 , { . func_arg = & opt_show_program_version } , \"show ffprobe version\" } , { \"show_library_versions\" , 0 , { . func_arg = & opt_show_library_versions } , \"show library versions\" } , { \"show_versions\" , 0 , { . func_arg = & opt_show_versions } , \"show program and library versions\" } , { \"show_pixel_formats\" , 0 , { . func_arg = & opt_show_pixel_formats } , \"show pixel format descriptions\" } , { \"show_optional_fields\" , HAS_ARG , { . func_arg = & opt_show_optional_fields } , \"show optional fields\" } , { \"show_private_data\" , OPT_BOOL , { & show_private_data } , \"show private data\" } , { \"private\" , OPT_BOOL , { & show_private_data } , \"same as show_private_data\" } , { \"bitexact\" , OPT_BOOL , { & do_bitexact } , \"force bitexact output\" } , { \"read_intervals\" , HAS_ARG , { . func_arg = opt_read_intervals } , \"set read intervals\" , \"read_intervals\" } , { \"i\" , HAS_ARG , { . func_arg = opt_input_file_i } , \"read specified file\" , \"input_file\" } , { \"o\" , HAS_ARG , { . func_arg = opt_output_file_o } , \"write to specified output\" , \"output_file\" } , { \"print_filename\" , HAS_ARG , { . func_arg = opt_print_filename } , \"override the printed input filename\" , \"print_file\" } , { \"find_stream_info\" , OPT_BOOL | OPT_INPUT | OPT_EXPERT , { & find_stream_info } , \"read and decode the streams to fill missing information with heuristics\" } , { NULL , } , } ; const Writer * w ; WriterContext * wctx ; char * buf ; char * w_name = NULL , * w_args = NULL ; int ret , input_ret , i ; int savedCode = setjmp ( ex_buf__ ) ; if ( savedCode == 0 ) { ffprobe_var_cleanup ( ) ; init_dynload ( ) ; # if HAVE_THREADS ret = pthread_mutex_init ( & log_mutex , NULL ) ; if ( ret != 0 ) { goto end ; } # endif av_log_set_flags ( AV_LOG_SKIP_REPEATED ) ; register_exit ( ffprobe_cleanup ) ; ffprobe_options = options ; parse_loglevel ( argc , argv , options ) ; avformat_network_init ( ) ; # if CONFIG_AVDEVICE avdevice_register_all ( ) ; # endif show_banner ( argc , argv , options ) ; parse_options ( NULL , argc , argv , options , opt_input_file ) ; if ( do_show_log ) av_log_set_callback ( log_callback ) ; /* mark things to show, based on -show_entries */ SET_DO_SHOW ( CHAPTERS , chapters ) ; SET_DO_SHOW ( ERROR , error ) ; SET_DO_SHOW ( FORMAT , format ) ; SET_DO_SHOW ( FRAMES , frames ) ; SET_DO_SHOW ( LIBRARY_VERSIONS , library_versions ) ; SET_DO_SHOW ( PACKETS , packets ) ; SET_DO_SHOW ( PIXEL_FORMATS , pixel_formats ) ; SET_DO_SHOW ( PIXEL_FORMAT_FLAGS , pixel_format_flags ) ; SET_DO_SHOW ( PIXEL_FORMAT_COMPONENTS , pixel_format_components ) ; SET_DO_SHOW ( PROGRAM_VERSION , program_version ) ; SET_DO_SHOW ( PROGRAMS , programs ) ; SET_DO_SHOW ( STREAMS , streams ) ; SET_DO_SHOW ( STREAM_DISPOSITION , stream_disposition ) ; SET_DO_SHOW ( PROGRAM_STREAM_DISPOSITION , stream_disposition ) ; SET_DO_SHOW ( CHAPTER_TAGS , chapter_tags ) ; SET_DO_SHOW ( FORMAT_TAGS , format_tags ) ; SET_DO_SHOW ( FRAME_TAGS , frame_tags ) ; SET_DO_SHOW ( PROGRAM_TAGS , program_tags ) ; SET_DO_SHOW ( STREAM_TAGS , stream_tags ) ; SET_DO_SHOW ( PROGRAM_STREAM_TAGS , stream_tags ) ; SET_DO_SHOW ( PACKET_TAGS , packet_tags ) ; if ( do_bitexact && ( do_show_program_version || do_show_library_versions ) ) { av_log ( NULL , AV_LOG_ERROR , \"-bitexact and -show_program_version or -show_library_versions \" \"options are incompatible\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto end ; } writer_register_all ( ) ; if ( ! print_format ) print_format = av_strdup ( \"default\" ) ; if ( ! print_format ) { ret = AVERROR ( ENOMEM ) ; goto end ; } w_name = av_strtok ( print_format , \"=\" , & buf ) ; if ( ! w_name ) { av_log ( NULL , AV_LOG_ERROR , \"No name specified for the output format\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto end ; } w_args = buf ; if ( show_data_hash ) { if ( ( ret = av_hash_alloc ( & hash , show_data_hash ) ) < 0 ) { if ( ret == AVERROR ( EINVAL ) ) { const char * n ; av_log ( NULL , AV_LOG_ERROR , \"Unknown hash algorithm '%s'\\nKnown algorithms:\" , show_data_hash ) ; for ( i = 0 ; ( n = av_hash_names ( i ) ) ; i ++ ) av_log ( NULL , AV_LOG_ERROR , \" %s\" , n ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } goto end ; } } w = writer_get_by_name ( w_name ) ; if ( ! w ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown output format with name '%s'\\n\" , w_name ) ; ret = AVERROR ( EINVAL ) ; goto end ; } if ( ( ret = writer_open ( & wctx , w , w_args , sections , FF_ARRAY_ELEMS ( sections ) , output_filename ) ) >= 0 ) { if ( w == & xml_writer ) wctx -> string_validation_utf8_flags |= AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES ; writer_print_section_header ( wctx , SECTION_ID_ROOT ) ; if ( do_show_program_version ) ffprobe_show_program_version ( wctx ) ; if ( do_show_library_versions ) ffprobe_show_library_versions ( wctx ) ; if ( do_show_pixel_formats ) ffprobe_show_pixel_formats ( wctx ) ; if ( ! input_filename && ( ( do_show_format || do_show_programs || do_show_streams || do_show_chapters || do_show_packets || do_show_error ) || ( ! do_show_program_version && ! do_show_library_versions && ! do_show_pixel_formats ) ) ) { show_usage ( ) ; av_log ( NULL , AV_LOG_ERROR , \"You have to specify one input file.\\n\" ) ; av_log ( NULL , AV_LOG_ERROR , \"Use -h to get full help or, even better, run 'man %s'.\\n\" , program_name ) ; ret = AVERROR ( EINVAL ) ; } else if ( input_filename ) { ret = probe_file ( wctx , input_filename , print_input_filename ) ; if ( ret < 0 && do_show_error ) show_error ( wctx , ret ) ; } input_ret = ret ; writer_print_section_footer ( wctx ) ; ret = writer_close ( & wctx ) ; if ( ret < 0 ) av_log ( NULL , AV_LOG_ERROR , \"Writing output failed: %s\\n\" , av_err2str ( ret ) ) ; ret = FFMIN ( ret , input_ret ) ; } main_ffprobe_return_code = ret < 0 ; } else { main_ffprobe_return_code = longjmp_value ; } end : av_freep ( & print_format ) ; av_freep ( & read_intervals ) ; av_hash_freep ( & hash ) ; uninit_opts ( ) ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( sections ) ; i ++ ) av_dict_free ( & ( sections [ i ] . entries_to_show ) ) ; avformat_network_deinit ( ) ; return main_ffprobe_return_code ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@avutil_log_get_level_str": "static const char * avutil_log_get_level_str ( int level ) { switch ( level ) { case AV_LOG_STDERR : return \"stderr\" ; case AV_LOG_QUIET : return \"quiet\" ; case AV_LOG_DEBUG : return \"debug\" ; case AV_LOG_VERBOSE : return \"verbose\" ; case AV_LOG_INFO : return \"info\" ; case AV_LOG_WARNING : return \"warning\" ; case AV_LOG_ERROR : return \"error\" ; case AV_LOG_FATAL : return \"fatal\" ; case AV_LOG_PANIC : return \"panic\" ; default : return \"\" ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@avutil_log_format_line": "static void avutil_log_format_line ( void * avcl , int level , const char * fmt , va_list vl , AVBPrint part [ 4 ] , int * print_prefix ) { int flags = av_log_get_flags ( ) ; AVClass * avc = avcl ? * ( AVClass * * ) avcl : NULL ; av_bprint_init ( part + 0 , 0 , 1 ) ; av_bprint_init ( part + 1 , 0 , 1 ) ; av_bprint_init ( part + 2 , 0 , 1 ) ; av_bprint_init ( part + 3 , 0 , 65536 ) ; if ( * print_prefix && avc ) { if ( avc -> parent_log_context_offset ) { AVClass * * parent = * ( AVClass * * * ) ( ( ( uint8_t * ) avcl ) + avc -> parent_log_context_offset ) ; if ( parent && * parent ) { av_bprintf ( part + 0 , \"[%s @ %p] \" , ( * parent ) -> item_name ( parent ) , parent ) ; } } av_bprintf ( part + 1 , \"[%s @ %p] \" , avc -> item_name ( avcl ) , avcl ) ; } if ( * print_prefix && ( level > AV_LOG_QUIET ) && ( flags & AV_LOG_PRINT_LEVEL ) ) av_bprintf ( part + 2 , \"[%s] \" , avutil_log_get_level_str ( level ) ) ; av_vbprintf ( part + 3 , fmt , vl ) ; if ( * part [ 0 ] . str || * part [ 1 ] . str || * part [ 2 ] . str || * part [ 3 ] . str ) { char lastc = part [ 3 ] . len && part [ 3 ] . len <= part [ 3 ] . size ? part [ 3 ] . str [ part [ 3 ] . len - 1 ] : 0 ; * print_prefix = lastc == '\\n' || lastc == '\\r' ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@avutil_log_sanitize": "static void avutil_log_sanitize ( uint8_t * line ) { while ( * line ) { if ( * line < 0x08 || ( * line > 0x0D && * line < 0x20 ) ) * line = '?' ; line ++ ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@mutexInit": "void mutexInit ( ) { pthread_mutexattr_t attributes ; pthread_mutexattr_init ( & attributes ) ; pthread_mutexattr_settype ( & attributes , PTHREAD_MUTEX_RECURSIVE_NP ) ; pthread_mutex_init ( & lockMutex , & attributes ) ; pthread_mutexattr_destroy ( & attributes ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@monitorInit": "void monitorInit ( ) { pthread_mutexattr_t attributes ; pthread_mutexattr_init ( & attributes ) ; pthread_mutexattr_settype ( & attributes , PTHREAD_MUTEX_RECURSIVE_NP ) ; pthread_condattr_t cattributes ; pthread_condattr_init ( & cattributes ) ; pthread_condattr_setpshared ( & cattributes , PTHREAD_PROCESS_PRIVATE ) ; pthread_mutex_init ( & monitorMutex , & attributes ) ; pthread_mutexattr_destroy ( & attributes ) ; pthread_cond_init ( & monitorCondition , & cattributes ) ; pthread_condattr_destroy ( & cattributes ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@mutexUnInit": "void mutexUnInit ( ) { pthread_mutex_destroy ( & lockMutex ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@monitorUnInit": "void monitorUnInit ( ) { pthread_mutex_destroy ( & monitorMutex ) ; pthread_cond_destroy ( & monitorCondition ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@mutexLock": "void mutexLock ( ) { pthread_mutex_lock ( & lockMutex ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@mutexUnlock": "void mutexUnlock ( ) { pthread_mutex_unlock ( & lockMutex ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@monitorWait": "void monitorWait ( int milliSeconds ) { struct timeval tp ; struct timespec ts ; int rc ; rc = gettimeofday ( & tp , NULL ) ; if ( rc ) { return ; } ts . tv_sec = tp . tv_sec ; ts . tv_nsec = tp . tv_usec * 1000 ; ts . tv_sec += milliSeconds / 1000 ; ts . tv_nsec += ( milliSeconds % 1000 ) * 1000000 ; ts . tv_sec += ts . tv_nsec / 1000000000L ; ts . tv_nsec = ts . tv_nsec % 1000000000L ; pthread_mutex_lock ( & monitorMutex ) ; pthread_cond_timedwait ( & monitorCondition , & monitorMutex , & ts ) ; pthread_mutex_unlock ( & monitorMutex ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@monitorNotify": "void monitorNotify ( ) { pthread_mutex_lock ( & monitorMutex ) ; pthread_cond_signal ( & monitorCondition ) ; pthread_mutex_unlock ( & monitorMutex ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@logCallbackDataAdd": "void logCallbackDataAdd ( int level , AVBPrint * data ) { // CREATE DATA STRUCT FIRST struct CallbackData * newData = ( struct CallbackData * ) av_malloc ( sizeof ( struct CallbackData ) ) ; newData -> type = LogType ; newData -> sessionId = globalSessionId ; newData -> logLevel = level ; av_bprint_init ( & newData -> logData , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; av_bprintf ( & newData -> logData , \"%s\" , data -> str ) ; newData -> next = NULL ; mutexLock ( ) ; // INSERT IT TO THE END OF QUEUE if ( callbackDataTail == NULL ) { callbackDataTail = newData ; if ( callbackDataHead != NULL ) { LOGE ( \"Dangling callback data head detected. This can cause memory leak.\" ) ; } else { callbackDataHead = newData ; } } else { struct CallbackData * oldTail = callbackDataTail ; oldTail -> next = newData ; callbackDataTail = newData ; } mutexUnlock ( ) ; monitorNotify ( ) ; atomic_fetch_add ( & sessionInTransitMessageCountMap [ globalSessionId % SESSION_MAP_SIZE ] , 1 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@statisticsCallbackDataAdd": "void statisticsCallbackDataAdd ( int frameNumber , float fps , float quality , int64_t size , double time , double bitrate , double speed ) { // CREATE DATA STRUCT FIRST struct CallbackData * newData = ( struct CallbackData * ) av_malloc ( sizeof ( struct CallbackData ) ) ; newData -> type = StatisticsType ; newData -> sessionId = globalSessionId ; newData -> statisticsFrameNumber = frameNumber ; newData -> statisticsFps = fps ; newData -> statisticsQuality = quality ; newData -> statisticsSize = size ; newData -> statisticsTime = time ; newData -> statisticsBitrate = bitrate ; newData -> statisticsSpeed = speed ; newData -> next = NULL ; mutexLock ( ) ; // INSERT IT TO THE END OF QUEUE if ( callbackDataTail == NULL ) { callbackDataTail = newData ; if ( callbackDataHead != NULL ) { LOGE ( \"Dangling callback data head detected. This can cause memory leak.\" ) ; } else { callbackDataHead = newData ; } } else { struct CallbackData * oldTail = callbackDataTail ; oldTail -> next = newData ; callbackDataTail = newData ; } mutexUnlock ( ) ; monitorNotify ( ) ; atomic_fetch_add ( & sessionInTransitMessageCountMap [ globalSessionId % SESSION_MAP_SIZE ] , 1 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@addSession": "void addSession ( long id ) { atomic_store ( & sessionMap [ id % SESSION_MAP_SIZE ] , 1 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@callbackDataRemove": "struct CallbackData * callbackDataRemove ( ) { struct CallbackData * currentData ; mutexLock ( ) ; if ( callbackDataHead == NULL ) { currentData = NULL ; } else { currentData = callbackDataHead ; struct CallbackData * nextHead = currentData -> next ; if ( nextHead == NULL ) { if ( callbackDataHead != callbackDataTail ) { LOGE ( \"Head and tail callback data pointers do not match for single callback data element. This can cause memory leak.\" ) ; } else { callbackDataTail = NULL ; } callbackDataHead = NULL ; } else { callbackDataHead = nextHead ; } } mutexUnlock ( ) ; return currentData ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@removeSession": "void removeSession ( long id ) { atomic_store ( & sessionMap [ id % SESSION_MAP_SIZE ] , 0 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@cancelSession": "void cancelSession ( long id ) { atomic_store ( & sessionMap [ id % SESSION_MAP_SIZE ] , 2 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@cancelRequested": "int cancelRequested ( long id ) { if ( atomic_load ( & sessionMap [ id % SESSION_MAP_SIZE ] ) == 2 ) { return 1 ; } else { return 0 ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@resetMessagesInTransmit": "void resetMessagesInTransmit ( long id ) { atomic_store ( & sessionInTransitMessageCountMap [ id % SESSION_MAP_SIZE ] , 0 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@ffmpegkit_log_callback_function": "void ffmpegkit_log_callback_function ( void * ptr , int level , const char * format , va_list vargs ) { AVBPrint fullLine ; AVBPrint part [ 4 ] ; int print_prefix = 1 ; if ( level >= 0 ) { level &= 0xff ; } int activeLogLevel = av_log_get_level ( ) ; // AV_LOG_STDERR logs are always redirected if ( ( activeLogLevel == AV_LOG_QUIET && level != AV_LOG_STDERR ) || ( level > activeLogLevel ) ) { return ; } av_bprint_init ( & fullLine , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; avutil_log_format_line ( ptr , level , format , vargs , part , & print_prefix ) ; avutil_log_sanitize ( part [ 0 ] . str ) ; avutil_log_sanitize ( part [ 1 ] . str ) ; avutil_log_sanitize ( part [ 2 ] . str ) ; avutil_log_sanitize ( part [ 3 ] . str ) ; // COMBINE ALL 4 LOG PARTS av_bprintf ( & fullLine , \"%s%s%s%s\" , part [ 0 ] . str , part [ 1 ] . str , part [ 2 ] . str , part [ 3 ] . str ) ; if ( fullLine . len > 0 ) { logCallbackDataAdd ( level , & fullLine ) ; } av_bprint_finalize ( part , NULL ) ; av_bprint_finalize ( part + 1 , NULL ) ; av_bprint_finalize ( part + 2 , NULL ) ; av_bprint_finalize ( part + 3 , NULL ) ; av_bprint_finalize ( & fullLine , NULL ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@ffmpegkit_statistics_callback_function": "void ffmpegkit_statistics_callback_function ( int frameNumber , float fps , float quality , int64_t size , double time , double bitrate , double speed ) { statisticsCallbackDataAdd ( frameNumber , fps , quality , size , time , bitrate , speed ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@callbackThreadFunction": "void * callbackThreadFunction ( ) { JNIEnv * env ; jint getEnvRc = ( * globalVm ) -> GetEnv ( globalVm , ( void * * ) & env , JNI_VERSION_1_6 ) ; if ( getEnvRc != JNI_OK ) { if ( getEnvRc != JNI_EDETACHED ) { LOGE ( \"Callback thread failed to GetEnv for class %s with rc %d.\\n\" , configClassName , getEnvRc ) ; return NULL ; } if ( ( * globalVm ) -> AttachCurrentThread ( globalVm , & env , NULL ) != 0 ) { LOGE ( \"Callback thread failed to AttachCurrentThread for class %s.\\n\" , configClassName ) ; return NULL ; } } LOGD ( \"Async callback block started.\\n\" ) ; while ( redirectionEnabled ) { struct CallbackData * callbackData = callbackDataRemove ( ) ; if ( callbackData != NULL ) { if ( callbackData -> type == LogType ) { // LOG CALLBACK int size = callbackData -> logData . len ; jbyteArray byteArray = ( jbyteArray ) ( * env ) -> NewByteArray ( env , size ) ; ( * env ) -> SetByteArrayRegion ( env , byteArray , 0 , size , callbackData -> logData . str ) ; ( * env ) -> CallStaticVoidMethod ( env , configClass , logMethod , ( jlong ) callbackData -> sessionId , callbackData -> logLevel , byteArray ) ; ( * env ) -> DeleteLocalRef ( env , byteArray ) ; // CLEAN LOG DATA av_bprint_finalize ( & callbackData -> logData , NULL ) ; } else { // STATISTICS CALLBACK ( * env ) -> CallStaticVoidMethod ( env , configClass , statisticsMethod , ( jlong ) callbackData -> sessionId , callbackData -> statisticsFrameNumber , callbackData -> statisticsFps , callbackData -> statisticsQuality , callbackData -> statisticsSize , callbackData -> statisticsTime , callbackData -> statisticsBitrate , callbackData -> statisticsSpeed ) ; } atomic_fetch_sub ( & sessionInTransitMessageCountMap [ callbackData -> sessionId % SESSION_MAP_SIZE ] , 1 ) ; // CLEAN STRUCT callbackData -> next = NULL ; av_free ( callbackData ) ; } else { monitorWait ( 100 ) ; } } ( * globalVm ) -> DetachCurrentThread ( globalVm ) ; LOGD ( \"Async callback block stopped.\\n\" ) ; return NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@saf_open": "int saf_open ( int safId ) { JNIEnv * env = NULL ; ( * globalVm ) -> GetEnv ( globalVm , ( void * * ) & env , JNI_VERSION_1_6 ) ; return ( * env ) -> CallStaticIntMethod ( env , configClass , safOpenMethod , safId ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@saf_close": "int saf_close ( int fd ) { JNIEnv * env = NULL ; ( * globalVm ) -> GetEnv ( globalVm , ( void * * ) & env , JNI_VERSION_1_6 ) ; return ( * env ) -> CallStaticIntMethod ( env , configClass , safCloseMethod , fd ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@enableNativeRedirection": "static void enableNativeRedirection ( ) { mutexLock ( ) ; if ( redirectionEnabled != 0 ) { mutexUnlock ( ) ; return ; } redirectionEnabled = 1 ; mutexUnlock ( ) ; int rc = pthread_create ( & callbackThread , 0 , callbackThreadFunction , 0 ) ; if ( rc != 0 ) { LOGE ( \"Failed to create callback thread (rc=%d).\\n\" , rc ) ; return ; } av_log_set_callback ( ffmpegkit_log_callback_function ) ; set_report_callback ( ffmpegkit_statistics_callback_function ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit.c@JNI_OnLoad": "jint JNI_OnLoad ( JavaVM * vm , void * reserved ) { JNIEnv * env ; if ( ( * vm ) -> GetEnv ( vm , ( void * * ) ( & env ) , JNI_VERSION_1_6 ) != JNI_OK ) { LOGE ( \"OnLoad failed to GetEnv for class %s.\\n\" , configClassName ) ; return JNI_FALSE ; } jclass localConfigClass = ( * env ) -> FindClass ( env , configClassName ) ; if ( localConfigClass == NULL ) { LOGE ( \"OnLoad failed to FindClass %s.\\n\" , configClassName ) ; return JNI_FALSE ; } if ( ( * env ) -> RegisterNatives ( env , localConfigClass , configMethods , 14 ) < 0 ) { LOGE ( \"OnLoad failed to RegisterNatives for class %s.\\n\" , configClassName ) ; return JNI_FALSE ; } jclass localStringClass = ( * env ) -> FindClass ( env , stringClassName ) ; if ( localStringClass == NULL ) { LOGE ( \"OnLoad failed to FindClass %s.\\n\" , stringClassName ) ; return JNI_FALSE ; } ( * env ) -> GetJavaVM ( env , & globalVm ) ; logMethod = ( * env ) -> GetStaticMethodID ( env , localConfigClass , \"log\" , \"(JI[B)V\" ) ; if ( logMethod == NULL ) { LOGE ( \"OnLoad thread failed to GetStaticMethodID for %s.\\n\" , \"log\" ) ; return JNI_FALSE ; } statisticsMethod = ( * env ) -> GetStaticMethodID ( env , localConfigClass , \"statistics\" , \"(JIFFJDDD)V\" ) ; if ( statisticsMethod == NULL ) { LOGE ( \"OnLoad thread failed to GetStaticMethodID for %s.\\n\" , \"statistics\" ) ; return JNI_FALSE ; } safOpenMethod = ( * env ) -> GetStaticMethodID ( env , localConfigClass , \"safOpen\" , \"(I)I\" ) ; if ( safOpenMethod == NULL ) { LOGE ( \"OnLoad thread failed to GetStaticMethodID for %s.\\n\" , \"safOpen\" ) ; return JNI_FALSE ; } safCloseMethod = ( * env ) -> GetStaticMethodID ( env , localConfigClass , \"safClose\" , \"(I)I\" ) ; if ( safCloseMethod == NULL ) { LOGE ( \"OnLoad thread failed to GetStaticMethodID for %s.\\n\" , \"safClose\" ) ; return JNI_FALSE ; } stringConstructor = ( * env ) -> GetMethodID ( env , localStringClass , \"<init>\" , \"([BLjava/lang/String;)V\" ) ; if ( stringConstructor == NULL ) { LOGE ( \"OnLoad thread failed to GetMethodID for %s.\\n\" , \"<init>\" ) ; return JNI_FALSE ; } av_jni_set_java_vm ( vm , NULL ) ; configClass = ( jclass ) ( ( * env ) -> NewGlobalRef ( env , localConfigClass ) ) ; stringClass = ( jclass ) ( ( * env ) -> NewGlobalRef ( env , localStringClass ) ) ; callbackDataHead = NULL ; callbackDataTail = NULL ; for ( int i = 0 ; i < SESSION_MAP_SIZE ; i ++ ) { atomic_init ( & sessionMap [ i ] , 0 ) ; atomic_init ( & sessionInTransitMessageCountMap [ i ] , 0 ) ; } mutexInit ( ) ; monitorInit ( ) ; redirectionEnabled = 0 ; av_set_saf_open ( saf_open ) ; av_set_saf_close ( saf_close ) ; enableNativeRedirection ( ) ; return JNI_VERSION_1_6 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@uninit_options": "void uninit_options ( OptionsContext * o ) { const OptionDef * po = ffmpeg_options ; int i ; /* all OPT_SPEC and OPT_STRING can be freed in generic way */ while ( po -> name ) { void * dst = ( uint8_t * ) o + po -> u . off ; if ( po -> flags & OPT_SPEC ) { SpecifierOpt * * so = dst ; int i , * count = ( int * ) ( so + 1 ) ; for ( i = 0 ; i < * count ; i ++ ) { av_freep ( & ( * so ) [ i ] . specifier ) ; if ( po -> flags & OPT_STRING ) av_freep ( & ( * so ) [ i ] . u . str ) ; } av_freep ( so ) ; * count = 0 ; } else if ( po -> flags & OPT_OFFSET && po -> flags & OPT_STRING ) av_freep ( dst ) ; po ++ ; } for ( i = 0 ; i < o -> nb_stream_maps ; i ++ ) av_freep ( & o -> stream_maps [ i ] . linklabel ) ; av_freep ( & o -> stream_maps ) ; # if FFMPEG_OPT_MAP_CHANNEL av_freep ( & o -> audio_channel_maps ) ; # endif av_freep ( & o -> streamid_map ) ; av_freep ( & o -> attachments ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@init_options": "void init_options ( OptionsContext * o ) { memset ( o , 0 , sizeof ( * o ) ) ; o -> stop_time = INT64_MAX ; o -> mux_max_delay = 0.7 ; o -> start_time = AV_NOPTS_VALUE ; o -> start_time_eof = AV_NOPTS_VALUE ; o -> recording_time = INT64_MAX ; o -> limit_filesize = INT64_MAX ; o -> chapters_input_file = INT_MAX ; o -> accurate_seek = 1 ; o -> thread_queue_size = - 1 ; o -> input_sync_ref = - 1 ; o -> find_stream_info = 1 ; o -> shortest_buf_duration = 10.f ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@show_hwaccels": "int show_hwaccels ( void * optctx , const char * opt , const char * arg ) { enum AVHWDeviceType type = AV_HWDEVICE_TYPE_NONE ; av_log ( NULL , AV_LOG_STDERR , \"Hardware acceleration methods:\\n\" ) ; while ( ( type = av_hwdevice_iterate_types ( type ) ) != AV_HWDEVICE_TYPE_NONE ) av_log ( NULL , AV_LOG_STDERR , \"%s\\n\" , av_hwdevice_get_type_name ( type ) ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@strip_specifiers": "AVDictionary * strip_specifiers ( const AVDictionary * dict ) { const AVDictionaryEntry * e = NULL ; AVDictionary * ret = NULL ; while ( ( e = av_dict_iterate ( dict , e ) ) ) { char * p = strchr ( e -> key , ':' ) ; if ( p ) * p = 0 ; av_dict_set ( & ret , e -> key , e -> value , 0 ) ; if ( p ) * p = ':' ; } return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@parse_and_set_vsync": "int parse_and_set_vsync ( const char * arg , int * vsync_var , int file_idx , int st_idx , int is_global ) { if ( ! av_strcasecmp ( arg , \"cfr\" ) ) * vsync_var = VSYNC_CFR ; else if ( ! av_strcasecmp ( arg , \"vfr\" ) ) * vsync_var = VSYNC_VFR ; else if ( ! av_strcasecmp ( arg , \"passthrough\" ) ) * vsync_var = VSYNC_PASSTHROUGH ; else if ( ! av_strcasecmp ( arg , \"drop\" ) ) * vsync_var = VSYNC_DROP ; else if ( ! is_global && ! av_strcasecmp ( arg , \"auto\" ) ) * vsync_var = VSYNC_AUTO ; else if ( ! is_global ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid value %s specified for fps_mode of #%d:%d.\\n\" , arg , file_idx , st_idx ) ; exit_program ( 1 ) ; } if ( is_global && * vsync_var == VSYNC_AUTO ) { video_sync_method = parse_number_or_die ( \"vsync\" , arg , OPT_INT , VSYNC_AUTO , VSYNC_VFR ) ; av_log ( NULL , AV_LOG_WARNING , \"Passing a number to -vsync is deprecated,\" \" use a string argument as described in the manual.\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@correct_input_start_times": "void correct_input_start_times ( void ) { for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * ifile = input_files [ i ] ; AVFormatContext * is = ifile -> ctx ; int64_t new_start_time = INT64_MAX , diff , abs_start_seek ; ifile -> start_time_effective = is -> start_time ; if ( is -> start_time == AV_NOPTS_VALUE || ! ( is -> iformat -> flags & AVFMT_TS_DISCONT ) ) continue ; for ( int j = 0 ; j < is -> nb_streams ; j ++ ) { AVStream * st = is -> streams [ j ] ; if ( st -> discard == AVDISCARD_ALL || st -> start_time == AV_NOPTS_VALUE ) continue ; new_start_time = FFMIN ( new_start_time , av_rescale_q ( st -> start_time , st -> time_base , AV_TIME_BASE_Q ) ) ; } diff = new_start_time - is -> start_time ; if ( diff ) { av_log ( NULL , AV_LOG_VERBOSE , \"Correcting start time of Input #%d by %\" PRId64 \" us.\\n\" , i , diff ) ; ifile -> start_time_effective = new_start_time ; if ( copy_ts && start_at_zero ) ifile -> ts_offset = - new_start_time ; else if ( ! copy_ts ) { abs_start_seek = is -> start_time + ( ( ifile -> start_time != AV_NOPTS_VALUE ) ? ifile -> start_time : 0 ) ; ifile -> ts_offset = abs_start_seek > new_start_time ? - abs_start_seek : - new_start_time ; } else if ( copy_ts ) ifile -> ts_offset = 0 ; ifile -> ts_offset += ifile -> input_ts_offset ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@apply_sync_offsets": "int apply_sync_offsets ( void ) { for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * ref , * self = input_files [ i ] ; int64_t adjustment ; int64_t self_start_time , ref_start_time , self_seek_start , ref_seek_start ; int start_times_set = 1 ; if ( self -> input_sync_ref == - 1 || self -> input_sync_ref == i ) continue ; if ( self -> input_sync_ref >= nb_input_files || self -> input_sync_ref < - 1 ) { av_log ( NULL , AV_LOG_FATAL , \"-isync for input %d references non-existent input %d.\\n\" , i , self -> input_sync_ref ) ; exit_program ( 1 ) ; } if ( copy_ts && ! start_at_zero ) { av_log ( NULL , AV_LOG_FATAL , \"Use of -isync requires that start_at_zero be set if copyts is set.\\n\" ) ; exit_program ( 1 ) ; } ref = input_files [ self -> input_sync_ref ] ; if ( ref -> input_sync_ref != - 1 && ref -> input_sync_ref != self -> input_sync_ref ) { av_log ( NULL , AV_LOG_ERROR , \"-isync for input %d references a resynced input %d. Sync not set.\\n\" , i , self -> input_sync_ref ) ; continue ; } if ( self -> ctx -> start_time_realtime != AV_NOPTS_VALUE && ref -> ctx -> start_time_realtime != AV_NOPTS_VALUE ) { self_start_time = self -> ctx -> start_time_realtime ; ref_start_time = ref -> ctx -> start_time_realtime ; } else if ( self -> start_time_effective != AV_NOPTS_VALUE && ref -> start_time_effective != AV_NOPTS_VALUE ) { self_start_time = self -> start_time_effective ; ref_start_time = ref -> start_time_effective ; } else { start_times_set = 0 ; } if ( start_times_set ) { self_seek_start = self -> start_time == AV_NOPTS_VALUE ? 0 : self -> start_time ; ref_seek_start = ref -> start_time == AV_NOPTS_VALUE ? 0 : ref -> start_time ; adjustment = ( self_start_time - ref_start_time ) + ! copy_ts * ( self_seek_start - ref_seek_start ) + ref -> input_ts_offset ; self -> ts_offset += adjustment ; av_log ( NULL , AV_LOG_INFO , \"Adjusted ts offset for Input #%d by %\" PRId64 \" us to sync with Input #%d.\\n\" , i , adjustment , self -> input_sync_ref ) ; } else { av_log ( NULL , AV_LOG_INFO , \"Unable to identify start times for Inputs #%d and %d both. No sync adjustment made.\\n\" , i , self -> input_sync_ref ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_filter_threads": "int opt_filter_threads ( void * optctx , const char * opt , const char * arg ) { av_free ( filter_nbthreads ) ; filter_nbthreads = av_strdup ( arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_abort_on": "int opt_abort_on ( void * optctx , const char * opt , const char * arg ) { static const AVOption opts [ ] = { { \"abort_on\" , NULL , 0 , AV_OPT_TYPE_FLAGS , { . i64 = 0 } , INT64_MIN , ( double ) INT64_MAX , . unit = \"flags\" } , { \"empty_output\" , NULL , 0 , AV_OPT_TYPE_CONST , { . i64 = ABORT_ON_FLAG_EMPTY_OUTPUT } , . unit = \"flags\" } , { \"empty_output_stream\" , NULL , 0 , AV_OPT_TYPE_CONST , { . i64 = ABORT_ON_FLAG_EMPTY_OUTPUT_STREAM } , . unit = \"flags\" } , { NULL } , } ; static const AVClass class = { . class_name = \"\" , . item_name = av_default_item_name , . option = opts , . version = LIBAVUTIL_VERSION_INT , } ; const AVClass * pclass = & class ; return av_opt_eval_flags ( & pclass , & opts [ 0 ] , arg , & abort_on_flags ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_stats_period": "int opt_stats_period ( void * optctx , const char * opt , const char * arg ) { int64_t user_stats_period = parse_time_or_die ( opt , arg , 1 ) ; if ( user_stats_period <= 0 ) { av_log ( NULL , AV_LOG_ERROR , \"stats_period %s must be positive.\\n\" , arg ) ; return AVERROR ( EINVAL ) ; } stats_period = user_stats_period ; av_log ( NULL , AV_LOG_INFO , \"ffmpeg stats and -progress period set to %s.\\n\" , arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_audio_codec": "int opt_audio_codec ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"codec:a\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_video_codec": "int opt_video_codec ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"codec:v\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_subtitle_codec": "int opt_subtitle_codec ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"codec:s\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_data_codec": "int opt_data_codec ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"codec:d\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_map": "int opt_map ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; StreamMap * m = NULL ; int i , negative = 0 , file_idx , disabled = 0 ; # if FFMPEG_OPT_MAP_SYNC char * sync ; # endif char * map , * p ; char * allow_unused ; if ( * arg == '-' ) { negative = 1 ; arg ++ ; } map = av_strdup ( arg ) ; if ( ! map ) return AVERROR ( ENOMEM ) ; # if FFMPEG_OPT_MAP_SYNC /* parse sync stream first, just pick first matching stream */ if ( ( sync = strchr ( map , ',' ) ) ) { * sync = 0 ; av_log ( NULL , AV_LOG_WARNING , \"Specifying a sync stream is deprecated and has no effect\\n\" ) ; } # endif if ( map [ 0 ] == '[' ) { /* this mapping refers to lavfi output */ const char * c = map + 1 ; GROW_ARRAY ( o -> stream_maps , o -> nb_stream_maps ) ; m = & o -> stream_maps [ o -> nb_stream_maps - 1 ] ; m -> linklabel = av_get_token ( & c , \"]\" ) ; if ( ! m -> linklabel ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid output link label: %s.\\n\" , map ) ; exit_program ( 1 ) ; } } else { if ( ( allow_unused = strchr ( map , '?' ) ) ) * allow_unused = 0 ; file_idx = strtol ( map , & p , 0 ) ; if ( file_idx >= nb_input_files || file_idx < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid input file index: %d.\\n\" , file_idx ) ; exit_program ( 1 ) ; } if ( negative ) /* disable some already defined maps */ for ( i = 0 ; i < o -> nb_stream_maps ; i ++ ) { m = & o -> stream_maps [ i ] ; if ( file_idx == m -> file_index && check_stream_specifier ( input_files [ m -> file_index ] -> ctx , input_files [ m -> file_index ] -> ctx -> streams [ m -> stream_index ] , * p == ':' ? p + 1 : p ) > 0 ) m -> disabled = 1 ; } else for ( i = 0 ; i < input_files [ file_idx ] -> nb_streams ; i ++ ) { if ( check_stream_specifier ( input_files [ file_idx ] -> ctx , input_files [ file_idx ] -> ctx -> streams [ i ] , * p == ':' ? p + 1 : p ) <= 0 ) continue ; if ( input_files [ file_idx ] -> streams [ i ] -> user_set_discard == AVDISCARD_ALL ) { disabled = 1 ; continue ; } GROW_ARRAY ( o -> stream_maps , o -> nb_stream_maps ) ; m = & o -> stream_maps [ o -> nb_stream_maps - 1 ] ; m -> file_index = file_idx ; m -> stream_index = i ; } } if ( ! m ) { if ( allow_unused ) { av_log ( NULL , AV_LOG_VERBOSE , \"Stream map '%s' matches no streams; ignoring.\\n\" , arg ) ; } else if ( disabled ) { av_log ( NULL , AV_LOG_FATAL , \"Stream map '%s' matches disabled streams.\\n\" \"To ignore this, add a trailing '?' to the map.\\n\" , arg ) ; exit_program ( 1 ) ; } else { av_log ( NULL , AV_LOG_FATAL , \"Stream map '%s' matches no streams.\\n\" \"To ignore this, add a trailing '?' to the map.\\n\" , arg ) ; exit_program ( 1 ) ; } } av_freep ( & map ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_attach": "int opt_attach ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; GROW_ARRAY ( o -> attachments , o -> nb_attachments ) ; o -> attachments [ o -> nb_attachments - 1 ] = arg ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_map_channel": "int opt_map_channel ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; int n ; AVStream * st ; AudioChannelMap * m ; char * allow_unused ; char * mapchan ; av_log ( NULL , AV_LOG_WARNING , \"The -%s option is deprecated and will be removed. \" \"It can be replaced by the 'pan' filter, or in some cases by \" \"combinations of 'channelsplit', 'channelmap', 'amerge' filters.\\n\" , opt ) ; mapchan = av_strdup ( arg ) ; if ( ! mapchan ) return AVERROR ( ENOMEM ) ; GROW_ARRAY ( o -> audio_channel_maps , o -> nb_audio_channel_maps ) ; m = & o -> audio_channel_maps [ o -> nb_audio_channel_maps - 1 ] ; /* muted channel syntax */ n = sscanf ( arg , \"%d:%d.%d\" , & m -> channel_idx , & m -> ofile_idx , & m -> ostream_idx ) ; if ( ( n == 1 || n == 3 ) && m -> channel_idx == - 1 ) { m -> file_idx = m -> stream_idx = - 1 ; if ( n == 1 ) m -> ofile_idx = m -> ostream_idx = - 1 ; av_free ( mapchan ) ; return 0 ; } /* normal syntax */ n = sscanf ( arg , \"%d.%d.%d:%d.%d\" , & m -> file_idx , & m -> stream_idx , & m -> channel_idx , & m -> ofile_idx , & m -> ostream_idx ) ; if ( n != 3 && n != 5 ) { av_log ( NULL , AV_LOG_FATAL , \"Syntax error, mapchan usage: \" \"[file.stream.channel|-1][:syncfile:syncstream]\\n\" ) ; exit_program ( 1 ) ; } if ( n != 5 ) // only file.stream.channel specified m -> ofile_idx = m -> ostream_idx = - 1 ; /* check input */ if ( m -> file_idx < 0 || m -> file_idx >= nb_input_files ) { av_log ( NULL , AV_LOG_FATAL , \"mapchan: invalid input file index: %d\\n\" , m -> file_idx ) ; exit_program ( 1 ) ; } if ( m -> stream_idx < 0 || m -> stream_idx >= input_files [ m -> file_idx ] -> nb_streams ) { av_log ( NULL , AV_LOG_FATAL , \"mapchan: invalid input file stream index #%d.%d\\n\" , m -> file_idx , m -> stream_idx ) ; exit_program ( 1 ) ; } st = input_files [ m -> file_idx ] -> ctx -> streams [ m -> stream_idx ] ; if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_FATAL , \"mapchan: stream #%d.%d is not an audio stream.\\n\" , m -> file_idx , m -> stream_idx ) ; exit_program ( 1 ) ; } /* allow trailing ? to map_channel */ if ( ( allow_unused = strchr ( mapchan , '?' ) ) ) * allow_unused = 0 ; if ( m -> channel_idx < 0 || m -> channel_idx >= st -> codecpar -> ch_layout . nb_channels || input_files [ m -> file_idx ] -> streams [ m -> stream_idx ] -> user_set_discard == AVDISCARD_ALL ) { if ( allow_unused ) { av_log ( NULL , AV_LOG_VERBOSE , \"mapchan: invalid audio channel #%d.%d.%d\\n\" , m -> file_idx , m -> stream_idx , m -> channel_idx ) ; } else { av_log ( NULL , AV_LOG_FATAL , \"mapchan: invalid audio channel #%d.%d.%d\\n\" \"To ignore this, add a trailing '?' to the map_channel.\\n\" , m -> file_idx , m -> stream_idx , m -> channel_idx ) ; exit_program ( 1 ) ; } } av_free ( mapchan ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_sdp_file": "int opt_sdp_file ( void * optctx , const char * opt , const char * arg ) { av_free ( sdp_filename ) ; sdp_filename = av_strdup ( arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_init_hw_device": "int opt_init_hw_device ( void * optctx , const char * opt , const char * arg ) { if ( ! strcmp ( arg , \"list\" ) ) { enum AVHWDeviceType type = AV_HWDEVICE_TYPE_NONE ; av_log ( NULL , AV_LOG_STDERR , \"Supported hardware device types:\\n\" ) ; while ( ( type = av_hwdevice_iterate_types ( type ) ) != AV_HWDEVICE_TYPE_NONE ) av_log ( NULL , AV_LOG_STDERR , \"%s\\n\" , av_hwdevice_get_type_name ( type ) ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; exit_program ( 0 ) ; } else { return hw_device_init_from_string ( arg , NULL ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_filter_hw_device": "int opt_filter_hw_device ( void * optctx , const char * opt , const char * arg ) { if ( filter_hw_device ) { av_log ( NULL , AV_LOG_ERROR , \"Only one filter device can be used.\\n\" ) ; return AVERROR ( EINVAL ) ; } filter_hw_device = hw_device_get_by_name ( arg ) ; if ( ! filter_hw_device ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid filter device %s.\\n\" , arg ) ; return AVERROR ( EINVAL ) ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_recording_timestamp": "int opt_recording_timestamp ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; char buf [ 128 ] ; int64_t recording_timestamp = parse_time_or_die ( opt , arg , 0 ) / 1E6 ; struct tm time = * gmtime ( ( time_t * ) & recording_timestamp ) ; if ( ! strftime ( buf , sizeof ( buf ) , \"creation_time=%Y-%m-%dT%H:%M:%S%z\" , & time ) ) return - 1 ; parse_option ( o , \"metadata\" , buf , ffmpeg_options ) ; av_log ( NULL , AV_LOG_WARNING , \"%s is deprecated, set the 'creation_time' metadata \" \"tag instead.\\n\" , opt ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@find_codec_or_die": "const AVCodec * find_codec_or_die ( void * logctx , const char * name , enum AVMediaType type , int encoder ) { const AVCodecDescriptor * desc ; const char * codec_string = encoder ? \"encoder\" : \"decoder\" ; const AVCodec * codec ; codec = encoder ? avcodec_find_encoder_by_name ( name ) : avcodec_find_decoder_by_name ( name ) ; if ( ! codec && ( desc = avcodec_descriptor_get_by_name ( name ) ) ) { codec = encoder ? avcodec_find_encoder ( desc -> id ) : avcodec_find_decoder ( desc -> id ) ; if ( codec ) av_log ( logctx , AV_LOG_VERBOSE , \"Matched %s '%s' for codec '%s'.\\n\" , codec_string , codec -> name , desc -> name ) ; } if ( ! codec ) { av_log ( logctx , AV_LOG_FATAL , \"Unknown %s '%s'\\n\" , codec_string , name ) ; exit_program ( 1 ) ; } if ( codec -> type != type && ! recast_media ) { av_log ( logctx , AV_LOG_FATAL , \"Invalid %s type '%s'\\n\" , codec_string , name ) ; exit_program ( 1 ) ; } return codec ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@assert_file_overwrite": "void assert_file_overwrite ( const char * filename ) { const char * proto_name = avio_find_protocol_name ( filename ) ; if ( file_overwrite && no_file_overwrite ) { av_log ( NULL , AV_LOG_FATAL , \"Error, both -y and -n supplied. Exiting.\\n\" ) ; exit_program ( 1 ) ; } if ( ! file_overwrite ) { if ( proto_name && ! strcmp ( proto_name , \"file\" ) && avio_check ( filename , 0 ) == 0 ) { if ( stdin_interaction && ! no_file_overwrite ) { av_log ( NULL , AV_LOG_FATAL , \"File '%s' already exists. Overwrite? [y/N] \" , filename ) ; term_exit ( ) ; signal ( SIGINT , SIG_DFL ) ; if ( ! read_yesno ( ) ) { av_log ( NULL , AV_LOG_FATAL , \"Not overwriting - exiting\\n\" ) ; exit_program ( 1 ) ; } term_init ( ) ; } else { av_log ( NULL , AV_LOG_FATAL , \"File '%s' already exists. Exiting.\\n\" , filename ) ; exit_program ( 1 ) ; } } } if ( proto_name && ! strcmp ( proto_name , \"file\" ) ) { for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * file = input_files [ i ] ; if ( file -> ctx -> iformat -> flags & AVFMT_NOFILE ) continue ; if ( ! strcmp ( filename , file -> ctx -> url ) ) { av_log ( NULL , AV_LOG_FATAL , \"Output %s same as Input #%d - exiting\\n\" , filename , i ) ; av_log ( NULL , AV_LOG_WARNING , \"FFmpeg cannot edit existing files in-place.\\n\" ) ; exit_program ( 1 ) ; } } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@file_read": "char * file_read ( const char * filename ) { AVIOContext * pb = NULL ; int ret = avio_open ( & pb , filename , AVIO_FLAG_READ ) ; AVBPrint bprint ; char * str ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error opening file %s.\\n\" , filename ) ; return NULL ; } av_bprint_init ( & bprint , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; ret = avio_read_to_bprint ( pb , & bprint , SIZE_MAX ) ; avio_closep ( & pb ) ; if ( ret < 0 ) { av_bprint_finalize ( & bprint , NULL ) ; return NULL ; } ret = av_bprint_finalize ( & bprint , & str ) ; if ( ret < 0 ) return NULL ; return str ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_streamid": "int opt_streamid ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; int idx ; char * p ; char idx_str [ 16 ] ; av_strlcpy ( idx_str , arg , sizeof ( idx_str ) ) ; p = strchr ( idx_str , ':' ) ; if ( ! p ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid value '%s' for option '%s', required syntax is 'index:value'\\n\" , arg , opt ) ; exit_program ( 1 ) ; } * p ++ = '\\0' ; idx = parse_number_or_die ( opt , idx_str , OPT_INT , 0 , MAX_STREAMS - 1 ) ; o -> streamid_map = grow_array ( o -> streamid_map , sizeof ( * o -> streamid_map ) , & o -> nb_streamid_map , idx + 1 ) ; o -> streamid_map [ idx ] = parse_number_or_die ( opt , p , OPT_INT , 0 , INT_MAX ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@init_complex_filters": "int init_complex_filters ( void ) { int i , ret = 0 ; for ( i = 0 ; i < nb_filtergraphs ; i ++ ) { ret = init_complex_filtergraph ( filtergraphs [ i ] ) ; if ( ret < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_target": "int opt_target ( void * optctx , const char * opt , const char * arg ) { const OptionDef * options = ffmpeg_options ; OptionsContext * o = optctx ; enum { PAL , NTSC , FILM , UNKNOWN } norm = UNKNOWN ; static const char * const frame_rates [ ] = { \"25\" , \"30000/1001\" , \"24000/1001\" } ; if ( ! strncmp ( arg , \"pal-\" , 4 ) ) { norm = PAL ; arg += 4 ; } else if ( ! strncmp ( arg , \"ntsc-\" , 5 ) ) { norm = NTSC ; arg += 5 ; } else if ( ! strncmp ( arg , \"film-\" , 5 ) ) { norm = FILM ; arg += 5 ; } else { /* Try to determine PAL/NTSC by peeking in the input files */ if ( nb_input_files ) { int i , j ; for ( j = 0 ; j < nb_input_files ; j ++ ) { for ( i = 0 ; i < input_files [ j ] -> nb_streams ; i ++ ) { AVStream * st = input_files [ j ] -> ctx -> streams [ i ] ; int64_t fr ; if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_VIDEO ) continue ; fr = st -> time_base . den * 1000LL / st -> time_base . num ; if ( fr == 25000 ) { norm = PAL ; break ; } else if ( ( fr == 29970 ) || ( fr == 23976 ) ) { norm = NTSC ; break ; } } if ( norm != UNKNOWN ) break ; } } if ( norm != UNKNOWN ) av_log ( NULL , AV_LOG_INFO , \"Assuming %s for target.\\n\" , norm == PAL ? \"PAL\" : \"NTSC\" ) ; } if ( norm == UNKNOWN ) { av_log ( NULL , AV_LOG_FATAL , \"Could not determine norm (PAL/NTSC/NTSC-Film) for target.\\n\" ) ; av_log ( NULL , AV_LOG_FATAL , \"Please prefix target with \\\"pal-\\\", \\\"ntsc-\\\" or \\\"film-\\\",\\n\" ) ; av_log ( NULL , AV_LOG_FATAL , \"or set a framerate with \\\"-r xxx\\\".\\n\" ) ; exit_program ( 1 ) ; } if ( ! strcmp ( arg , \"vcd\" ) ) { opt_video_codec ( o , \"c:v\" , \"mpeg1video\" ) ; opt_audio_codec ( o , \"c:a\" , \"mp2\" ) ; parse_option ( o , \"f\" , \"vcd\" , options ) ; parse_option ( o , \"s\" , norm == PAL ? \"352x288\" : \"352x240\" , options ) ; parse_option ( o , \"r\" , frame_rates [ norm ] , options ) ; opt_default ( NULL , \"g\" , norm == PAL ? \"15\" : \"18\" ) ; opt_default ( NULL , \"b:v\" , \"1150000\" ) ; opt_default ( NULL , \"maxrate:v\" , \"1150000\" ) ; opt_default ( NULL , \"minrate:v\" , \"1150000\" ) ; opt_default ( NULL , \"bufsize:v\" , \"327680\" ) ; // 40*1024*8; opt_default ( NULL , \"b:a\" , \"224000\" ) ; parse_option ( o , \"ar\" , \"44100\" , options ) ; parse_option ( o , \"ac\" , \"2\" , options ) ; opt_default ( NULL , \"packetsize\" , \"2324\" ) ; opt_default ( NULL , \"muxrate\" , \"1411200\" ) ; // 2352 * 75 * 8; /* We have to offset the PTS, so that it is consistent with the SCR.\n           SCR starts at 36000, but the first two packs contain only padding\n           and the first pack from the other stream, respectively, may also have\n           been written before.\n           So the real data starts at SCR 36000+3*1200. */ o -> mux_preload = ( 36000 + 3 * 1200 ) / 90000.0 ; // 0.44 } else if ( ! strcmp ( arg , \"svcd\" ) ) { opt_video_codec ( o , \"c:v\" , \"mpeg2video\" ) ; opt_audio_codec ( o , \"c:a\" , \"mp2\" ) ; parse_option ( o , \"f\" , \"svcd\" , options ) ; parse_option ( o , \"s\" , norm == PAL ? \"480x576\" : \"480x480\" , options ) ; parse_option ( o , \"r\" , frame_rates [ norm ] , options ) ; parse_option ( o , \"pix_fmt\" , \"yuv420p\" , options ) ; opt_default ( NULL , \"g\" , norm == PAL ? \"15\" : \"18\" ) ; opt_default ( NULL , \"b:v\" , \"2040000\" ) ; opt_default ( NULL , \"maxrate:v\" , \"2516000\" ) ; opt_default ( NULL , \"minrate:v\" , \"0\" ) ; // 1145000; opt_default ( NULL , \"bufsize:v\" , \"1835008\" ) ; // 224*1024*8; opt_default ( NULL , \"scan_offset\" , \"1\" ) ; opt_default ( NULL , \"b:a\" , \"224000\" ) ; parse_option ( o , \"ar\" , \"44100\" , options ) ; opt_default ( NULL , \"packetsize\" , \"2324\" ) ; } else if ( ! strcmp ( arg , \"dvd\" ) ) { opt_video_codec ( o , \"c:v\" , \"mpeg2video\" ) ; opt_audio_codec ( o , \"c:a\" , \"ac3\" ) ; parse_option ( o , \"f\" , \"dvd\" , options ) ; parse_option ( o , \"s\" , norm == PAL ? \"720x576\" : \"720x480\" , options ) ; parse_option ( o , \"r\" , frame_rates [ norm ] , options ) ; parse_option ( o , \"pix_fmt\" , \"yuv420p\" , options ) ; opt_default ( NULL , \"g\" , norm == PAL ? \"15\" : \"18\" ) ; opt_default ( NULL , \"b:v\" , \"6000000\" ) ; opt_default ( NULL , \"maxrate:v\" , \"9000000\" ) ; opt_default ( NULL , \"minrate:v\" , \"0\" ) ; // 1500000; opt_default ( NULL , \"bufsize:v\" , \"1835008\" ) ; // 224*1024*8; opt_default ( NULL , \"packetsize\" , \"2048\" ) ; // from www.mpucoder.com: DVD sectors contain 2048 bytes of data, this is also the size of one pack. opt_default ( NULL , \"muxrate\" , \"10080000\" ) ; // from mplex project: data_rate = 1260000. mux_rate = data_rate * 8 opt_default ( NULL , \"b:a\" , \"448000\" ) ; parse_option ( o , \"ar\" , \"48000\" , options ) ; } else if ( ! strncmp ( arg , \"dv\" , 2 ) ) { parse_option ( o , \"f\" , \"dv\" , options ) ; parse_option ( o , \"s\" , norm == PAL ? \"720x576\" : \"720x480\" , options ) ; parse_option ( o , \"pix_fmt\" , ! strncmp ( arg , \"dv50\" , 4 ) ? \"yuv422p\" : norm == PAL ? \"yuv420p\" : \"yuv411p\" , options ) ; parse_option ( o , \"r\" , frame_rates [ norm ] , options ) ; parse_option ( o , \"ar\" , \"48000\" , options ) ; parse_option ( o , \"ac\" , \"2\" , options ) ; } else { av_log ( NULL , AV_LOG_ERROR , \"Unknown target: %s\\n\" , arg ) ; return AVERROR ( EINVAL ) ; } av_dict_copy ( & o -> g -> codec_opts , codec_opts , AV_DICT_DONT_OVERWRITE ) ; av_dict_copy ( & o -> g -> format_opts , format_opts , AV_DICT_DONT_OVERWRITE ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_vstats_file": "int opt_vstats_file ( void * optctx , const char * opt , const char * arg ) { av_free ( vstats_filename ) ; vstats_filename = av_strdup ( arg ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_vstats": "int opt_vstats ( void * optctx , const char * opt , const char * arg ) { char filename [ 40 ] ; time_t today2 = time ( NULL ) ; struct tm * today = localtime ( & today2 ) ; if ( ! today ) { // maybe tomorrow av_log ( NULL , AV_LOG_FATAL , \"Unable to get current time: %s\\n\" , strerror ( errno ) ) ; exit_program ( 1 ) ; } snprintf ( filename , sizeof ( filename ) , \"vstats_%02d%02d%02d.log\" , today -> tm_hour , today -> tm_min , today -> tm_sec ) ; return opt_vstats_file ( NULL , opt , filename ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_video_frames": "int opt_video_frames ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"frames:v\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_audio_frames": "int opt_audio_frames ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"frames:a\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_data_frames": "int opt_data_frames ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"frames:d\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_default_new": "int opt_default_new ( OptionsContext * o , const char * opt , const char * arg ) { int ret ; AVDictionary * cbak = codec_opts ; AVDictionary * fbak = format_opts ; codec_opts = NULL ; format_opts = NULL ; ret = opt_default ( NULL , opt , arg ) ; av_dict_copy ( & o -> g -> codec_opts , codec_opts , 0 ) ; av_dict_copy ( & o -> g -> format_opts , format_opts , 0 ) ; av_dict_free ( & codec_opts ) ; av_dict_free ( & format_opts ) ; codec_opts = cbak ; format_opts = fbak ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_preset": "int opt_preset ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; FILE * f = NULL ; char filename [ 1000 ] , line [ 1000 ] , tmp_line [ 1000 ] ; const char * codec_name = NULL ; tmp_line [ 0 ] = * opt ; tmp_line [ 1 ] = 0 ; MATCH_PER_TYPE_OPT ( codec_names , str , codec_name , NULL , tmp_line ) ; if ( ! ( f = get_preset_file ( filename , sizeof ( filename ) , arg , * opt == 'f' , codec_name ) ) ) { if ( ! strncmp ( arg , \"libx264-lossless\" , strlen ( \"libx264-lossless\" ) ) ) { av_log ( NULL , AV_LOG_FATAL , \"Please use -preset <speed> -qp 0\\n\" ) ; } else av_log ( NULL , AV_LOG_FATAL , \"File for preset '%s' not found\\n\" , arg ) ; exit_program ( 1 ) ; } while ( fgets ( line , sizeof ( line ) , f ) ) { char * key = tmp_line , * value , * endptr ; if ( strcspn ( line , \"#\\n\\r\" ) == 0 ) continue ; av_strlcpy ( tmp_line , line , sizeof ( tmp_line ) ) ; if ( ! av_strtok ( key , \"=\" , & value ) || ! av_strtok ( value , \"\\r\\n\" , & endptr ) ) { av_log ( NULL , AV_LOG_FATAL , \"%s: Invalid syntax: '%s'\\n\" , filename , line ) ; exit_program ( 1 ) ; } av_log ( NULL , AV_LOG_DEBUG , \"ffpreset[%s]: set '%s' = '%s'\\n\" , filename , key , value ) ; if ( ! strcmp ( key , \"acodec\" ) ) opt_audio_codec ( o , key , value ) ; else if ( ! strcmp ( key , \"vcodec\" ) ) opt_video_codec ( o , key , value ) ; else if ( ! strcmp ( key , \"scodec\" ) ) opt_subtitle_codec ( o , key , value ) ; else if ( ! strcmp ( key , \"dcodec\" ) ) opt_data_codec ( o , key , value ) ; else if ( opt_default_new ( o , key , value ) < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"%s: Invalid option or argument: '%s', parsed as '%s' = '%s'\\n\" , filename , line , key , value ) ; exit_program ( 1 ) ; } } fclose ( f ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_old2new": "int opt_old2new ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; int ret ; char * s = av_asprintf ( \"%s:%c\" , opt + 1 , * opt ) ; if ( ! s ) return AVERROR ( ENOMEM ) ; ret = parse_option ( o , s , arg , ffmpeg_options ) ; av_free ( s ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_bitrate": "int opt_bitrate ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; if ( ! strcmp ( opt , \"ab\" ) ) { av_dict_set ( & o -> g -> codec_opts , \"b:a\" , arg , 0 ) ; return 0 ; } else if ( ! strcmp ( opt , \"b\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"Please use -b:a or -b:v, -b is ambiguous\\n\" ) ; av_dict_set ( & o -> g -> codec_opts , \"b:v\" , arg , 0 ) ; return 0 ; } av_dict_set ( & o -> g -> codec_opts , opt , arg , 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_qscale": "int opt_qscale ( void * optctx , const char * opt , const char * arg ) { OptionDef * options = ffmpeg_options ; OptionsContext * o = optctx ; char * s ; int ret ; if ( ! strcmp ( opt , \"qscale\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"Please use -q:a or -q:v, -qscale is ambiguous\\n\" ) ; return parse_option ( o , \"q:v\" , arg , options ) ; } s = av_asprintf ( \"q%s\" , opt + 6 ) ; if ( ! s ) return AVERROR ( ENOMEM ) ; ret = parse_option ( o , s , arg , options ) ; av_free ( s ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_profile": "int opt_profile ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; if ( ! strcmp ( opt , \"profile\" ) ) { av_log ( NULL , AV_LOG_WARNING , \"Please use -profile:a or -profile:v, -profile is ambiguous\\n\" ) ; av_dict_set ( & o -> g -> codec_opts , \"profile:v\" , arg , 0 ) ; return 0 ; } av_dict_set ( & o -> g -> codec_opts , opt , arg , 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_video_filters": "int opt_video_filters ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"filter:v\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_audio_filters": "int opt_audio_filters ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"filter:a\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_vsync": "int opt_vsync ( void * optctx , const char * opt , const char * arg ) { av_log ( NULL , AV_LOG_WARNING , \"-vsync is deprecated. Use -fps_mode\\n\" ) ; parse_and_set_vsync ( arg , & video_sync_method , - 1 , - 1 , 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_timecode": "int opt_timecode ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; int ret ; char * tcr = av_asprintf ( \"timecode=%s\" , arg ) ; if ( ! tcr ) return AVERROR ( ENOMEM ) ; ret = parse_option ( o , \"metadata:g\" , tcr , ffmpeg_options ) ; if ( ret >= 0 ) ret = av_dict_set ( & o -> g -> codec_opts , \"gop_timecode\" , arg , 0 ) ; av_free ( tcr ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_audio_qscale": "int opt_audio_qscale ( void * optctx , const char * opt , const char * arg ) { OptionsContext * o = optctx ; return parse_option ( o , \"q:a\" , arg , ffmpeg_options ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_filter_complex": "int opt_filter_complex ( void * optctx , const char * opt , const char * arg ) { FilterGraph * fg = ALLOC_ARRAY_ELEM ( filtergraphs , nb_filtergraphs ) ; fg -> index = nb_filtergraphs - 1 ; fg -> graph_desc = av_strdup ( arg ) ; if ( ! fg -> graph_desc ) return AVERROR ( ENOMEM ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_filter_complex_script": "int opt_filter_complex_script ( void * optctx , const char * opt , const char * arg ) { FilterGraph * fg ; char * graph_desc = file_read ( arg ) ; if ( ! graph_desc ) return AVERROR ( EINVAL ) ; fg = ALLOC_ARRAY_ELEM ( filtergraphs , nb_filtergraphs ) ; fg -> index = nb_filtergraphs - 1 ; fg -> graph_desc = graph_desc ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@show_help_default_ffmpeg": "void show_help_default_ffmpeg ( const char * opt , const char * arg ) { OptionDef * options = ffmpeg_options ; /* per-file options have at least one of those set */ const int per_file = OPT_SPEC | OPT_OFFSET | OPT_PERFILE ; int show_advanced = 0 , show_avoptions = 0 ; if ( opt && * opt ) { if ( ! strcmp ( opt , \"long\" ) ) show_advanced = 1 ; else if ( ! strcmp ( opt , \"full\" ) ) show_advanced = show_avoptions = 1 ; else av_log ( NULL , AV_LOG_ERROR , \"Unknown help option '%s'.\\n\" , opt ) ; } show_usage ( ) ; av_log ( NULL , AV_LOG_STDERR , \"Getting help:\\n\" \"    -h      -- print basic options\\n\" \"    -h long -- print more options\\n\" \"    -h full -- print all options (including all format and codec specific options, very long)\\n\" \"    -h type=name -- print all options for the named decoder/encoder/demuxer/muxer/filter/bsf/protocol\\n\" \"    See man %s for detailed description of the options.\\n\" \"\\n\" , program_name ) ; show_help_options ( options , \"Print help / information / capabilities:\" , OPT_EXIT , 0 , 0 ) ; show_help_options ( options , \"Global options (affect whole program \" \"instead of just one file):\" , 0 , per_file | OPT_EXIT | OPT_EXPERT , 0 ) ; if ( show_advanced ) show_help_options ( options , \"Advanced global options:\" , OPT_EXPERT , per_file | OPT_EXIT , 0 ) ; show_help_options ( options , \"Per-file main options:\" , 0 , OPT_EXPERT | OPT_AUDIO | OPT_VIDEO | OPT_SUBTITLE | OPT_EXIT , per_file ) ; if ( show_advanced ) show_help_options ( options , \"Advanced per-file options:\" , OPT_EXPERT , OPT_AUDIO | OPT_VIDEO | OPT_SUBTITLE , per_file ) ; show_help_options ( options , \"Video options:\" , OPT_VIDEO , OPT_EXPERT | OPT_AUDIO , 0 ) ; if ( show_advanced ) show_help_options ( options , \"Advanced Video options:\" , OPT_EXPERT | OPT_VIDEO , OPT_AUDIO , 0 ) ; show_help_options ( options , \"Audio options:\" , OPT_AUDIO , OPT_EXPERT | OPT_VIDEO , 0 ) ; if ( show_advanced ) show_help_options ( options , \"Advanced Audio options:\" , OPT_EXPERT | OPT_AUDIO , OPT_VIDEO , 0 ) ; show_help_options ( options , \"Subtitle options:\" , OPT_SUBTITLE , 0 , 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; if ( show_avoptions ) { int flags = AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_ENCODING_PARAM ; show_help_children ( avcodec_get_class ( ) , flags ) ; show_help_children ( avformat_get_class ( ) , flags ) ; # if CONFIG_SWSCALE show_help_children ( sws_get_class ( ) , flags ) ; # endif # if CONFIG_SWRESAMPLE show_help_children ( swr_get_class ( ) , AV_OPT_FLAG_AUDIO_PARAM ) ; # endif show_help_children ( avfilter_get_class ( ) , AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM ) ; show_help_children ( av_bsf_get_class ( ) , AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_BSF_PARAM ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@show_usage": "void show_usage ( void ) { av_log ( NULL , AV_LOG_INFO , \"Hyper fast Audio and Video encoder\\n\" ) ; av_log ( NULL , AV_LOG_INFO , \"usage: %s [options] [[infile options] -i infile]... {[outfile options] outfile}...\\n\" , program_name ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@open_files": "int open_files ( OptionGroupList * l , const char * inout , int ( * open_file ) ( const OptionsContext * , const char * ) ) { int i , ret ; for ( i = 0 ; i < l -> nb_groups ; i ++ ) { OptionGroup * g = & l -> groups [ i ] ; OptionsContext o ; init_options ( & o ) ; o . g = g ; ret = parse_optgroup ( & o , g ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error parsing options for %s file \" \"%s.\\n\" , inout , g -> arg ) ; uninit_options ( & o ) ; return ret ; } av_log ( NULL , AV_LOG_DEBUG , \"Opening an %s file: %s.\\n\" , inout , g -> arg ) ; ret = open_file ( & o , g -> arg ) ; uninit_options ( & o ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error opening %s file %s.\\n\" , inout , g -> arg ) ; return ret ; } av_log ( NULL , AV_LOG_DEBUG , \"Successfully opened the file.\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@ffmpeg_parse_options": "int ffmpeg_parse_options ( int argc , char * * argv ) { OptionParseContext octx ; int ret ; memset ( & octx , 0 , sizeof ( octx ) ) ; /* split the commandline into an internal representation */ ret = split_commandline ( & octx , argc , argv , ffmpeg_options , groups , FF_ARRAY_ELEMS ( groups ) ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error splitting the argument list: \" ) ; goto fail ; } /* apply global options */ ret = parse_optgroup ( NULL , & octx . global_opts ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error parsing global options: \" ) ; goto fail ; } /* configure terminal and setup signal handlers */ term_init ( ) ; /* open input files */ ret = open_files ( & octx . groups [ GROUP_INFILE ] , \"input\" , ifile_open ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error opening input files: \" ) ; goto fail ; } /* create the complex filtergraphs */ ret = init_complex_filters ( ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error initializing complex filters.\\n\" ) ; goto fail ; } /* open output files */ ret = open_files ( & octx . groups [ GROUP_OUTFILE ] , \"output\" , of_open ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error opening output files: \" ) ; goto fail ; } correct_input_start_times ( ) ; apply_sync_offsets ( ) ; check_filter_outputs ( ) ; fail : uninit_parse_context ( & octx ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"%s\\n\" , av_err2str ( ret ) ) ; } return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_progress": "int opt_progress ( void * optctx , const char * opt , const char * arg ) { AVIOContext * avio = NULL ; int ret ; if ( ! strcmp ( arg , \"-\" ) ) arg = \"pipe:\" ; ret = avio_open2 ( & avio , arg , AVIO_FLAG_WRITE , & int_cb , NULL ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Failed to open progress URL \\\"%s\\\": %s\\n\" , arg , av_err2str ( ret ) ) ; return ret ; } progress_avio = avio ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_opt.c@opt_timelimit": "int opt_timelimit ( void * optctx , const char * opt , const char * arg ) { # if HAVE_SETRLIMIT int lim = parse_number_or_die ( opt , arg , OPT_INT64 , 0 , INT_MAX ) ; struct rlimit rl = { lim , lim + 1 } ; if ( setrlimit ( RLIMIT_CPU , & rl ) ) perror ( \"setrlimit\" ) ; # else av_log ( NULL , AV_LOG_WARNING , \"-%s not implemented on this OS\\n\" , opt ) ; # endif return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_license": "int show_license ( void * optctx , const char * opt , const char * arg ) { # if CONFIG_NONFREE av_log ( NULL , AV_LOG_ERROR , \"This version of %s has nonfree parts compiled in.\\n\" \"Therefore it is not legally redistributable.\\n\" , program_name ) ; # elif CONFIG_GPLV3 av_log ( NULL , AV_LOG_ERROR , \"%s is free software; you can redistribute it and/or modify\\n\" \"it under the terms of the GNU General Public License as published by\\n\" \"the Free Software Foundation; either version 3 of the License, or\\n\" \"(at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\" \"GNU General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU General Public License\\n\" \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\" , program_name , program_name , program_name ) ; # elif CONFIG_GPL av_log ( NULL , AV_LOG_ERROR , \"%s is free software; you can redistribute it and/or modify\\n\" \"it under the terms of the GNU General Public License as published by\\n\" \"the Free Software Foundation; either version 2 of the License, or\\n\" \"(at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\" \"GNU General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU General Public License\\n\" \"along with %s; if not, write to the Free Software\\n\" \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\" , program_name , program_name , program_name ) ; # elif CONFIG_LGPLV3 av_log ( NULL , AV_LOG_ERROR , \"%s is free software; you can redistribute it and/or modify\\n\" \"it under the terms of the GNU Lesser General Public License as published by\\n\" \"the Free Software Foundation; either version 3 of the License, or\\n\" \"(at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\" \"GNU Lesser General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU Lesser General Public License\\n\" \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\" , program_name , program_name , program_name ) ; # else av_log ( NULL , AV_LOG_ERROR , \"%s is free software; you can redistribute it and/or\\n\" \"modify it under the terms of the GNU Lesser General Public\\n\" \"License as published by the Free Software Foundation; either\\n\" \"version 2.1 of the License, or (at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\n\" \"Lesser General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU Lesser General Public\\n\" \"License along with %s; if not, write to the Free Software\\n\" \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\" , program_name , program_name , program_name ) ; # endif return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@print_all_libs_info": "static void print_all_libs_info ( int flags , int level ) { PRINT_LIB_INFO ( avutil , AVUTIL , flags , level ) ; PRINT_LIB_INFO ( avcodec , AVCODEC , flags , level ) ; PRINT_LIB_INFO ( avformat , AVFORMAT , flags , level ) ; PRINT_LIB_INFO ( avdevice , AVDEVICE , flags , level ) ; PRINT_LIB_INFO ( avfilter , AVFILTER , flags , level ) ; PRINT_LIB_INFO ( swscale , SWSCALE , flags , level ) ; PRINT_LIB_INFO ( swresample , SWRESAMPLE , flags , level ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@print_program_info": "static void print_program_info ( int flags , int level ) { const char * indent = flags & INDENT ? \"  \" : \"\" ; av_log ( NULL , level , \"%s version \" FFMPEG_VERSION , program_name ) ; if ( flags & SHOW_COPYRIGHT ) av_log ( NULL , level , \" Copyright (c) %d-%d the FFmpeg developers\" , program_birth_year , CONFIG_THIS_YEAR ) ; av_log ( NULL , level , \"\\n\" ) ; av_log ( NULL , level , \"%sbuilt with %s\\n\" , indent , CC_IDENT ) ; av_log ( NULL , level , \"%sconfiguration: \" FFMPEG_CONFIGURATION \"\\n\" , indent ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@print_buildconf": "static void print_buildconf ( int flags , int level ) { const char * indent = flags & INDENT ? \"  \" : \"\" ; char str [ ] = { FFMPEG_CONFIGURATION } ; char * conflist , * remove_tilde , * splitconf ; // Change all the ' --' strings to '~--' so that // they can be identified as tokens. while ( ( conflist = strstr ( str , \" --\" ) ) != NULL ) { conflist [ 0 ] = '~' ; } // Compensate for the weirdness this would cause // when passing 'pkg-config --static'. while ( ( remove_tilde = strstr ( str , \"pkg-config~\" ) ) != NULL ) { remove_tilde [ sizeof ( \"pkg-config~\" ) - 2 ] = ' ' ; } splitconf = strtok ( str , \"~\" ) ; av_log ( NULL , level , \"\\n%sconfiguration:\\n\" , indent ) ; while ( splitconf != NULL ) { av_log ( NULL , level , \"%s%s%s\\n\" , indent , indent , splitconf ) ; splitconf = strtok ( NULL , \"~\" ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_banner": "void show_banner ( int argc , char * * argv , const OptionDef * options ) { int idx = locate_option ( argc , argv , options , \"version\" ) ; if ( hide_banner || idx ) return ; print_program_info ( INDENT | SHOW_COPYRIGHT , AV_LOG_INFO ) ; print_all_libs_info ( INDENT | SHOW_CONFIG , AV_LOG_INFO ) ; print_all_libs_info ( INDENT | SHOW_VERSION , AV_LOG_INFO ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_version": "int show_version ( void * optctx , const char * opt , const char * arg ) { print_program_info ( SHOW_COPYRIGHT , AV_LOG_INFO ) ; print_all_libs_info ( SHOW_VERSION , AV_LOG_INFO ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_buildconf": "int show_buildconf ( void * optctx , const char * opt , const char * arg ) { print_buildconf ( INDENT | 0 , AV_LOG_INFO ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@print_codec": "static void print_codec ( const AVCodec * c ) { int encoder = av_codec_is_encoder ( c ) ; av_log ( NULL , AV_LOG_ERROR , \"%s %s [%s]:\\n\" , encoder ? \"Encoder\" : \"Decoder\" , c -> name , c -> long_name ? c -> long_name : \"\" ) ; av_log ( NULL , AV_LOG_ERROR , \"    General capabilities: \" ) ; if ( c -> capabilities & AV_CODEC_CAP_DRAW_HORIZ_BAND ) av_log ( NULL , AV_LOG_ERROR , \"horizband \" ) ; if ( c -> capabilities & AV_CODEC_CAP_DR1 ) av_log ( NULL , AV_LOG_ERROR , \"dr1 \" ) ; if ( c -> capabilities & AV_CODEC_CAP_DELAY ) av_log ( NULL , AV_LOG_ERROR , \"delay \" ) ; if ( c -> capabilities & AV_CODEC_CAP_SMALL_LAST_FRAME ) av_log ( NULL , AV_LOG_ERROR , \"small \" ) ; if ( c -> capabilities & AV_CODEC_CAP_SUBFRAMES ) av_log ( NULL , AV_LOG_ERROR , \"subframes \" ) ; if ( c -> capabilities & AV_CODEC_CAP_EXPERIMENTAL ) av_log ( NULL , AV_LOG_ERROR , \"exp \" ) ; if ( c -> capabilities & AV_CODEC_CAP_CHANNEL_CONF ) av_log ( NULL , AV_LOG_ERROR , \"chconf \" ) ; if ( c -> capabilities & AV_CODEC_CAP_PARAM_CHANGE ) av_log ( NULL , AV_LOG_ERROR , \"paramchange \" ) ; if ( c -> capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE ) av_log ( NULL , AV_LOG_ERROR , \"variable \" ) ; if ( c -> capabilities & ( AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_OTHER_THREADS ) ) av_log ( NULL , AV_LOG_ERROR , \"threads \" ) ; if ( c -> capabilities & AV_CODEC_CAP_AVOID_PROBING ) av_log ( NULL , AV_LOG_ERROR , \"avoidprobe \" ) ; if ( c -> capabilities & AV_CODEC_CAP_HARDWARE ) av_log ( NULL , AV_LOG_ERROR , \"hardware \" ) ; if ( c -> capabilities & AV_CODEC_CAP_HYBRID ) av_log ( NULL , AV_LOG_ERROR , \"hybrid \" ) ; if ( ! c -> capabilities ) av_log ( NULL , AV_LOG_ERROR , \"none\" ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; if ( c -> type == AVMEDIA_TYPE_VIDEO || c -> type == AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_ERROR , \"    Threading capabilities: \" ) ; switch ( c -> capabilities & ( AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_OTHER_THREADS ) ) { case AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS : av_log ( NULL , AV_LOG_ERROR , \"frame and slice\" ) ; break ; case AV_CODEC_CAP_FRAME_THREADS : av_log ( NULL , AV_LOG_ERROR , \"frame\" ) ; break ; case AV_CODEC_CAP_SLICE_THREADS : av_log ( NULL , AV_LOG_ERROR , \"slice\" ) ; break ; case AV_CODEC_CAP_OTHER_THREADS : av_log ( NULL , AV_LOG_ERROR , \"other\" ) ; break ; default : av_log ( NULL , AV_LOG_ERROR , \"none\" ) ; break ; } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } if ( avcodec_get_hw_config ( c , 0 ) ) { av_log ( NULL , AV_LOG_ERROR , \"    Supported hardware devices: \" ) ; for ( int i = 0 ; ; i ++ ) { const AVCodecHWConfig * config = avcodec_get_hw_config ( c , i ) ; if ( ! config ) break ; av_log ( NULL , AV_LOG_ERROR , \"%s \" , av_hwdevice_get_type_name ( config -> device_type ) ) ; } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } if ( c -> supported_framerates ) { const AVRational * fps = c -> supported_framerates ; av_log ( NULL , AV_LOG_ERROR , \"    Supported framerates:\" ) ; while ( fps -> num ) { av_log ( NULL , AV_LOG_ERROR , \" %d/%d\" , fps -> num , fps -> den ) ; fps ++ ; } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } PRINT_CODEC_SUPPORTED ( c , pix_fmts , enum AVPixelFormat , \"pixel formats\" , AV_PIX_FMT_NONE , GET_PIX_FMT_NAME ) ; PRINT_CODEC_SUPPORTED ( c , supported_samplerates , int , \"sample rates\" , 0 , GET_SAMPLE_RATE_NAME ) ; PRINT_CODEC_SUPPORTED ( c , sample_fmts , enum AVSampleFormat , \"sample formats\" , AV_SAMPLE_FMT_NONE , GET_SAMPLE_FMT_NAME ) ; if ( c -> ch_layouts ) { const AVChannelLayout * p = c -> ch_layouts ; av_log ( NULL , AV_LOG_ERROR , \"    Supported channel layouts:\" ) ; while ( p -> nb_channels ) { char name [ 128 ] ; av_channel_layout_describe ( p , name , sizeof ( name ) ) ; av_log ( NULL , AV_LOG_ERROR , \" %s\" , name ) ; p ++ ; } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } if ( c -> priv_class ) { show_help_children ( c -> priv_class , AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_DECODING_PARAM ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@next_codec_for_id": "static const AVCodec * next_codec_for_id ( enum AVCodecID id , void * * iter , int encoder ) { const AVCodec * c ; while ( ( c = av_codec_iterate ( iter ) ) ) { if ( c -> id == id && ( encoder ? av_codec_is_encoder ( c ) : av_codec_is_decoder ( c ) ) ) return c ; } return NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_help_codec": "static void show_help_codec ( const char * name , int encoder ) { const AVCodecDescriptor * desc ; const AVCodec * codec ; if ( ! name ) { av_log ( NULL , AV_LOG_ERROR , \"No codec name specified.\\n\" ) ; return ; } codec = encoder ? avcodec_find_encoder_by_name ( name ) : avcodec_find_decoder_by_name ( name ) ; if ( codec ) print_codec ( codec ) ; else if ( ( desc = avcodec_descriptor_get_by_name ( name ) ) ) { void * iter = NULL ; int printed = 0 ; while ( ( codec = next_codec_for_id ( desc -> id , & iter , encoder ) ) ) { printed = 1 ; print_codec ( codec ) ; } if ( ! printed ) { av_log ( NULL , AV_LOG_ERROR , \"Codec '%s' is known to FFmpeg, \" \"but no %s for it are available. FFmpeg might need to be \" \"recompiled with additional external libraries.\\n\" , name , encoder ? \"encoders\" : \"decoders\" ) ; } } else { av_log ( NULL , AV_LOG_ERROR , \"Codec '%s' is not recognized by FFmpeg.\\n\" , name ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_help_demuxer": "static void show_help_demuxer ( const char * name ) { const AVInputFormat * fmt = av_find_input_format ( name ) ; if ( ! fmt ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown format '%s'.\\n\" , name ) ; return ; } av_log ( NULL , AV_LOG_ERROR , \"Demuxer %s [%s]:\\n\" , fmt -> name , fmt -> long_name ) ; if ( fmt -> extensions ) av_log ( NULL , AV_LOG_ERROR , \"    Common extensions: %s.\\n\" , fmt -> extensions ) ; if ( fmt -> priv_class ) show_help_children ( fmt -> priv_class , AV_OPT_FLAG_DECODING_PARAM ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_help_protocol": "static void show_help_protocol ( const char * name ) { const AVClass * proto_class ; if ( ! name ) { av_log ( NULL , AV_LOG_ERROR , \"No protocol name specified.\\n\" ) ; return ; } proto_class = avio_protocol_get_class ( name ) ; if ( ! proto_class ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown protocol '%s'.\\n\" , name ) ; return ; } show_help_children ( proto_class , AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_ENCODING_PARAM ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_help_muxer": "static void show_help_muxer ( const char * name ) { const AVCodecDescriptor * desc ; const AVOutputFormat * fmt = av_guess_format ( name , NULL , NULL ) ; if ( ! fmt ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown format '%s'.\\n\" , name ) ; return ; } av_log ( NULL , AV_LOG_ERROR , \"Muxer %s [%s]:\\n\" , fmt -> name , fmt -> long_name ) ; if ( fmt -> extensions ) av_log ( NULL , AV_LOG_ERROR , \"    Common extensions: %s.\\n\" , fmt -> extensions ) ; if ( fmt -> mime_type ) av_log ( NULL , AV_LOG_ERROR , \"    Mime type: %s.\\n\" , fmt -> mime_type ) ; if ( fmt -> video_codec != AV_CODEC_ID_NONE && ( desc = avcodec_descriptor_get ( fmt -> video_codec ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"    Default video codec: %s.\\n\" , desc -> name ) ; } if ( fmt -> audio_codec != AV_CODEC_ID_NONE && ( desc = avcodec_descriptor_get ( fmt -> audio_codec ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"    Default audio codec: %s.\\n\" , desc -> name ) ; } if ( fmt -> subtitle_codec != AV_CODEC_ID_NONE && ( desc = avcodec_descriptor_get ( fmt -> subtitle_codec ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"    Default subtitle codec: %s.\\n\" , desc -> name ) ; } if ( fmt -> priv_class ) show_help_children ( fmt -> priv_class , AV_OPT_FLAG_ENCODING_PARAM ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_help_bsf": "static void show_help_bsf ( const char * name ) { const AVBitStreamFilter * bsf = av_bsf_get_by_name ( name ) ; if ( ! name ) { av_log ( NULL , AV_LOG_ERROR , \"No bitstream filter name specified.\\n\" ) ; return ; } else if ( ! bsf ) { av_log ( NULL , AV_LOG_ERROR , \"Unknown bit stream filter '%s'.\\n\" , name ) ; return ; } av_log ( NULL , AV_LOG_ERROR , \"Bit stream filter %s\\n\" , bsf -> name ) ; PRINT_CODEC_SUPPORTED ( bsf , codec_ids , enum AVCodecID , \"codecs\" , AV_CODEC_ID_NONE , GET_CODEC_NAME ) ; if ( bsf -> priv_class ) show_help_children ( bsf -> priv_class , AV_OPT_FLAG_BSF_PARAM ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_help": "int show_help ( void * optctx , const char * opt , const char * arg ) { char * topic , * par ; topic = av_strdup ( arg ? arg : \"\" ) ; if ( ! topic ) return AVERROR ( ENOMEM ) ; par = strchr ( topic , '=' ) ; if ( par ) * par ++ = 0 ; if ( ! * topic ) { if ( program_name && ! strcmp ( program_name , \"ffmpeg\" ) ) { show_help_default_ffmpeg ( topic , par ) ; } else { show_help_default_ffprobe ( topic , par ) ; } } else if ( ! strcmp ( topic , \"decoder\" ) ) { show_help_codec ( par , 0 ) ; } else if ( ! strcmp ( topic , \"encoder\" ) ) { show_help_codec ( par , 1 ) ; } else if ( ! strcmp ( topic , \"demuxer\" ) ) { show_help_demuxer ( par ) ; } else if ( ! strcmp ( topic , \"muxer\" ) ) { show_help_muxer ( par ) ; } else if ( ! strcmp ( topic , \"protocol\" ) ) { show_help_protocol ( par ) ; # if CONFIG_AVFILTER } else if ( ! strcmp ( topic , \"filter\" ) ) { show_help_filter ( par ) ; # endif } else if ( ! strcmp ( topic , \"bsf\" ) ) { show_help_bsf ( par ) ; } else { if ( program_name && ! strcmp ( program_name , \"ffmpeg\" ) ) { show_help_default_ffmpeg ( topic , par ) ; } else { show_help_default_ffprobe ( topic , par ) ; } } av_freep ( & topic ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@print_codecs_for_id": "static void print_codecs_for_id ( enum AVCodecID id , int encoder ) { void * iter = NULL ; const AVCodec * codec ; av_log ( NULL , AV_LOG_ERROR , \" (%s: \" , encoder ? \"encoders\" : \"decoders\" ) ; while ( ( codec = next_codec_for_id ( id , & iter , encoder ) ) ) av_log ( NULL , AV_LOG_ERROR , \"%s \" , codec -> name ) ; av_log ( NULL , AV_LOG_ERROR , \")\" ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@compare_codec_desc": "static int compare_codec_desc ( const void * a , const void * b ) { const AVCodecDescriptor * const * da = a ; const AVCodecDescriptor * const * db = b ; return ( * da ) -> type != ( * db ) -> type ? FFDIFFSIGN ( ( * da ) -> type , ( * db ) -> type ) : strcmp ( ( * da ) -> name , ( * db ) -> name ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@get_codecs_sorted": "static unsigned get_codecs_sorted ( const AVCodecDescriptor * * * rcodecs ) { const AVCodecDescriptor * desc = NULL ; const AVCodecDescriptor * * codecs ; unsigned nb_codecs = 0 , i = 0 ; while ( ( desc = avcodec_descriptor_next ( desc ) ) ) nb_codecs ++ ; if ( ! ( codecs = av_calloc ( nb_codecs , sizeof ( * codecs ) ) ) ) { av_log ( NULL , AV_LOG_ERROR , \"Out of memory\\n\" ) ; exit_program ( 1 ) ; } desc = NULL ; while ( ( desc = avcodec_descriptor_next ( desc ) ) ) codecs [ i ++ ] = desc ; av_assert0 ( i == nb_codecs ) ; qsort ( codecs , nb_codecs , sizeof ( * codecs ) , compare_codec_desc ) ; * rcodecs = codecs ; return nb_codecs ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@get_media_type_char": "static char get_media_type_char ( enum AVMediaType type ) { switch ( type ) { case AVMEDIA_TYPE_VIDEO : return 'V' ; case AVMEDIA_TYPE_AUDIO : return 'A' ; case AVMEDIA_TYPE_DATA : return 'D' ; case AVMEDIA_TYPE_SUBTITLE : return 'S' ; case AVMEDIA_TYPE_ATTACHMENT : return 'T' ; default : return '?' ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_codecs": "int show_codecs ( void * optctx , const char * opt , const char * arg ) { const AVCodecDescriptor * * codecs ; unsigned i , nb_codecs = get_codecs_sorted ( & codecs ) ; av_log ( NULL , AV_LOG_ERROR , \"Codecs:\\n\" \" D..... = Decoding supported\\n\" \" .E.... = Encoding supported\\n\" \" ..V... = Video codec\\n\" \" ..A... = Audio codec\\n\" \" ..S... = Subtitle codec\\n\" \" ..D... = Data codec\\n\" \" ..T... = Attachment codec\\n\" \" ...I.. = Intra frame-only codec\\n\" \" ....L. = Lossy compression\\n\" \" .....S = Lossless compression\\n\" \" -------\\n\" ) ; for ( i = 0 ; i < nb_codecs ; i ++ ) { const AVCodecDescriptor * desc = codecs [ i ] ; const AVCodec * codec ; void * iter = NULL ; if ( strstr ( desc -> name , \"_deprecated\" ) ) continue ; av_log ( NULL , AV_LOG_ERROR , \" \" ) ; av_log ( NULL , AV_LOG_ERROR , avcodec_find_decoder ( desc -> id ) ? \"D\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , avcodec_find_encoder ( desc -> id ) ? \"E\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , \"%c\" , get_media_type_char ( desc -> type ) ) ; av_log ( NULL , AV_LOG_ERROR , ( desc -> props & AV_CODEC_PROP_INTRA_ONLY ) ? \"I\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( desc -> props & AV_CODEC_PROP_LOSSY ) ? \"L\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( desc -> props & AV_CODEC_PROP_LOSSLESS ) ? \"S\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , \" %-20s %s\" , desc -> name , desc -> long_name ? desc -> long_name : \"\" ) ; /* print decoders/encoders when there's more than one or their\n         * names are different from codec name */ while ( ( codec = next_codec_for_id ( desc -> id , & iter , 0 ) ) ) { if ( strcmp ( codec -> name , desc -> name ) ) { print_codecs_for_id ( desc -> id , 0 ) ; break ; } } iter = NULL ; while ( ( codec = next_codec_for_id ( desc -> id , & iter , 1 ) ) ) { if ( strcmp ( codec -> name , desc -> name ) ) { print_codecs_for_id ( desc -> id , 1 ) ; break ; } } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } av_free ( codecs ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@print_codecs": "static void print_codecs ( int encoder ) { const AVCodecDescriptor * * codecs ; unsigned i , nb_codecs = get_codecs_sorted ( & codecs ) ; av_log ( NULL , AV_LOG_ERROR , \"%s:\\n\" \" V..... = Video\\n\" \" A..... = Audio\\n\" \" S..... = Subtitle\\n\" \" .F.... = Frame-level multithreading\\n\" \" ..S... = Slice-level multithreading\\n\" \" ...X.. = Codec is experimental\\n\" \" ....B. = Supports draw_horiz_band\\n\" \" .....D = Supports direct rendering method 1\\n\" \" ------\\n\" , encoder ? \"Encoders\" : \"Decoders\" ) ; for ( i = 0 ; i < nb_codecs ; i ++ ) { const AVCodecDescriptor * desc = codecs [ i ] ; const AVCodec * codec ; void * iter = NULL ; while ( ( codec = next_codec_for_id ( desc -> id , & iter , encoder ) ) ) { av_log ( NULL , AV_LOG_ERROR , \" %c\" , get_media_type_char ( desc -> type ) ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_FRAME_THREADS ) ? \"F\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_SLICE_THREADS ) ? \"S\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_EXPERIMENTAL ) ? \"X\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_DRAW_HORIZ_BAND ) ? \"B\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , ( codec -> capabilities & AV_CODEC_CAP_DR1 ) ? \"D\" : \".\" ) ; av_log ( NULL , AV_LOG_ERROR , \" %-20s %s\" , codec -> name , codec -> long_name ? codec -> long_name : \"\" ) ; if ( strcmp ( codec -> name , desc -> name ) ) av_log ( NULL , AV_LOG_ERROR , \" (codec %s)\" , desc -> name ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } } av_free ( codecs ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_decoders": "int show_decoders ( void * optctx , const char * opt , const char * arg ) { print_codecs ( 0 ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_encoders": "int show_encoders ( void * optctx , const char * opt , const char * arg ) { print_codecs ( 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_bsfs": "int show_bsfs ( void * optctx , const char * opt , const char * arg ) { const AVBitStreamFilter * bsf = NULL ; void * opaque = NULL ; av_log ( NULL , AV_LOG_ERROR , \"Bitstream filters:\\n\" ) ; while ( ( bsf = av_bsf_iterate ( & opaque ) ) ) av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" , bsf -> name ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_filters": "int show_filters ( void * optctx , const char * opt , const char * arg ) { # if CONFIG_AVFILTER const AVFilter * filter = NULL ; char descr [ 64 ] , * descr_cur ; void * opaque = NULL ; int i , j ; const AVFilterPad * pad ; av_log ( NULL , AV_LOG_ERROR , \"Filters:\\n\" \"  T.. = Timeline support\\n\" \"  .S. = Slice threading\\n\" \"  ..C = Command support\\n\" \"  A = Audio input/output\\n\" \"  V = Video input/output\\n\" \"  N = Dynamic number and/or type of input/output\\n\" \"  | = Source or sink filter\\n\" ) ; while ( ( filter = av_filter_iterate ( & opaque ) ) ) { descr_cur = descr ; for ( i = 0 ; i < 2 ; i ++ ) { unsigned nb_pads ; if ( i ) { * ( descr_cur ++ ) = '-' ; * ( descr_cur ++ ) = '>' ; } pad = i ? filter -> outputs : filter -> inputs ; nb_pads = avfilter_filter_pad_count ( filter , i ) ; for ( j = 0 ; j < nb_pads ; j ++ ) { if ( descr_cur >= descr + sizeof ( descr ) - 4 ) break ; * ( descr_cur ++ ) = get_media_type_char ( avfilter_pad_get_type ( pad , j ) ) ; } if ( ! j ) * ( descr_cur ++ ) = ( ( ! i && ( filter -> flags & AVFILTER_FLAG_DYNAMIC_INPUTS ) ) || ( i && ( filter -> flags & AVFILTER_FLAG_DYNAMIC_OUTPUTS ) ) ) ? 'N' : '|' ; } * descr_cur = 0 ; av_log ( NULL , AV_LOG_ERROR , \" %c%c%c %-17s %-10s %s\\n\" , filter -> flags & AVFILTER_FLAG_SUPPORT_TIMELINE ? 'T' : '.' , filter -> flags & AVFILTER_FLAG_SLICE_THREADS ? 'S' : '.' , filter -> process_command ? 'C' : '.' , filter -> name , descr , filter -> description ) ; } # else av_log ( NULL , AV_LOG_ERROR , \"No filters available: libavfilter disabled\\n\" ) ; # endif return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@is_device": "static int is_device ( const AVClass * avclass ) { if ( ! avclass ) return 0 ; return AV_IS_INPUT_DEVICE ( avclass -> category ) || AV_IS_OUTPUT_DEVICE ( avclass -> category ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_formats_devices": "static int show_formats_devices ( void * optctx , const char * opt , const char * arg , int device_only , int muxdemuxers ) { void * ifmt_opaque = NULL ; const AVInputFormat * ifmt = NULL ; void * ofmt_opaque = NULL ; const AVOutputFormat * ofmt = NULL ; const char * last_name ; int is_dev ; av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" \" D. = Demuxing supported\\n\" \" .E = Muxing supported\\n\" \" --\\n\" , device_only ? \"Devices:\" : \"File formats:\" ) ; last_name = \"000\" ; for ( ; ; ) { int decode = 0 ; int encode = 0 ; const char * name = NULL ; const char * long_name = NULL ; if ( muxdemuxers != SHOW_DEMUXERS ) { ofmt_opaque = NULL ; while ( ( ofmt = av_muxer_iterate ( & ofmt_opaque ) ) ) { is_dev = is_device ( ofmt -> priv_class ) ; if ( ! is_dev && device_only ) continue ; if ( ( ! name || strcmp ( ofmt -> name , name ) < 0 ) && strcmp ( ofmt -> name , last_name ) > 0 ) { name = ofmt -> name ; long_name = ofmt -> long_name ; encode = 1 ; } } } if ( muxdemuxers != SHOW_MUXERS ) { ifmt_opaque = NULL ; while ( ( ifmt = av_demuxer_iterate ( & ifmt_opaque ) ) ) { is_dev = is_device ( ifmt -> priv_class ) ; if ( ! is_dev && device_only ) continue ; if ( ( ! name || strcmp ( ifmt -> name , name ) < 0 ) && strcmp ( ifmt -> name , last_name ) > 0 ) { name = ifmt -> name ; long_name = ifmt -> long_name ; encode = 0 ; } if ( name && strcmp ( ifmt -> name , name ) == 0 ) decode = 1 ; } } if ( ! name ) break ; last_name = name ; av_log ( NULL , AV_LOG_ERROR , \" %c%c %-15s %s\\n\" , decode ? 'D' : ' ' , encode ? 'E' : ' ' , name , long_name ? long_name : \" \" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_formats": "int show_formats ( void * optctx , const char * opt , const char * arg ) { return show_formats_devices ( optctx , opt , arg , 0 , SHOW_DEFAULT ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_muxers": "int show_muxers ( void * optctx , const char * opt , const char * arg ) { return show_formats_devices ( optctx , opt , arg , 0 , SHOW_MUXERS ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_demuxers": "int show_demuxers ( void * optctx , const char * opt , const char * arg ) { return show_formats_devices ( optctx , opt , arg , 0 , SHOW_DEMUXERS ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_devices": "int show_devices ( void * optctx , const char * opt , const char * arg ) { return show_formats_devices ( optctx , opt , arg , 1 , SHOW_DEFAULT ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_protocols": "int show_protocols ( void * optctx , const char * opt , const char * arg ) { void * opaque = NULL ; const char * name ; av_log ( NULL , AV_LOG_ERROR , \"Supported file protocols:\\n\" \"Input:\\n\" ) ; while ( ( name = avio_enum_protocols ( & opaque , 0 ) ) ) av_log ( NULL , AV_LOG_ERROR , \"  %s\\n\" , name ) ; av_log ( NULL , AV_LOG_ERROR , \"Output:\\n\" ) ; while ( ( name = avio_enum_protocols ( & opaque , 1 ) ) ) av_log ( NULL , AV_LOG_ERROR , \"  %s\\n\" , name ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_colors": "int show_colors ( void * optctx , const char * opt , const char * arg ) { const char * name ; const uint8_t * rgb ; int i ; av_log ( NULL , AV_LOG_ERROR , \"%-32s #RRGGBB\\n\" , \"name\" ) ; for ( i = 0 ; ( name = av_get_known_color_name ( i , & rgb ) ) ; i ++ ) av_log ( NULL , AV_LOG_ERROR , \"%-32s #%02x%02x%02x\\n\" , name , rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_pix_fmts": "int show_pix_fmts ( void * optctx , const char * opt , const char * arg ) { const AVPixFmtDescriptor * pix_desc = NULL ; av_log ( NULL , AV_LOG_ERROR , \"Pixel formats:\\n\" \"I.... = Supported Input  format for conversion\\n\" \".O... = Supported Output format for conversion\\n\" \"..H.. = Hardware accelerated format\\n\" \"...P. = Paletted format\\n\" \"....B = Bitstream format\\n\" \"FLAGS NAME            NB_COMPONENTS BITS_PER_PIXEL BIT_DEPTHS\\n\" \"-----\\n\" ) ; # if ! CONFIG_SWSCALE # define sws_isSupportedInput ( x ) 0 # define sws_isSupportedOutput ( x ) 0 # endif while ( ( pix_desc = av_pix_fmt_desc_next ( pix_desc ) ) ) { enum AVPixelFormat av_unused pix_fmt = av_pix_fmt_desc_get_id ( pix_desc ) ; av_log ( NULL , AV_LOG_ERROR , \"%c%c%c%c%c %-16s       %d            %3d      %d\" , sws_isSupportedInput ( pix_fmt ) ? 'I' : '.' , sws_isSupportedOutput ( pix_fmt ) ? 'O' : '.' , pix_desc -> flags & AV_PIX_FMT_FLAG_HWACCEL ? 'H' : '.' , pix_desc -> flags & AV_PIX_FMT_FLAG_PAL ? 'P' : '.' , pix_desc -> flags & AV_PIX_FMT_FLAG_BITSTREAM ? 'B' : '.' , pix_desc -> name , pix_desc -> nb_components , av_get_bits_per_pixel ( pix_desc ) , pix_desc -> comp [ 0 ] . depth ) ; for ( unsigned i = 1 ; i < pix_desc -> nb_components ; i ++ ) av_log ( NULL , AV_LOG_ERROR , \"-%d\" , pix_desc -> comp [ i ] . depth ) ; av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_layouts": "int show_layouts ( void * optctx , const char * opt , const char * arg ) { const AVChannelLayout * ch_layout ; void * iter = NULL ; char buf [ 128 ] , buf2 [ 128 ] ; int i = 0 ; av_log ( NULL , AV_LOG_ERROR , \"Individual channels:\\n\" \"NAME           DESCRIPTION\\n\" ) ; for ( i = 0 ; i < 63 ; i ++ ) { av_channel_name ( buf , sizeof ( buf ) , i ) ; if ( strstr ( buf , \"USR\" ) ) continue ; av_channel_description ( buf2 , sizeof ( buf2 ) , i ) ; av_log ( NULL , AV_LOG_ERROR , \"%-14s %s\\n\" , buf , buf2 ) ; } av_log ( NULL , AV_LOG_ERROR , \"\\nStandard channel layouts:\\n\" \"NAME           DECOMPOSITION\\n\" ) ; while ( ( ch_layout = av_channel_layout_standard ( & iter ) ) ) { av_channel_layout_describe ( ch_layout , buf , sizeof ( buf ) ) ; av_log ( NULL , AV_LOG_ERROR , \"%-14s \" , buf ) ; for ( i = 0 ; i < 63 ; i ++ ) { int idx = av_channel_layout_index_from_channel ( ch_layout , i ) ; if ( idx >= 0 ) { av_channel_name ( buf2 , sizeof ( buf2 ) , i ) ; av_log ( NULL , AV_LOG_ERROR , \"%s%s\" , idx ? \"+\" : \"\" , buf2 ) ; } } av_log ( NULL , AV_LOG_ERROR , \"\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_sample_fmts": "int show_sample_fmts ( void * optctx , const char * opt , const char * arg ) { int i ; char fmt_str [ 128 ] ; for ( i = - 1 ; i < AV_SAMPLE_FMT_NB ; i ++ ) av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" , av_get_sample_fmt_string ( fmt_str , sizeof ( fmt_str ) , i ) ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@show_dispositions": "int show_dispositions ( void * optctx , const char * opt , const char * arg ) { for ( int i = 0 ; i < 32 ; i ++ ) { const char * str = av_disposition_to_string ( 1U << i ) ; if ( str ) av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" , str ) ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@opt_cpuflags": "int opt_cpuflags ( void * optctx , const char * opt , const char * arg ) { int ret ; unsigned flags = av_get_cpu_flags ( ) ; if ( ( ret = av_parse_cpu_caps ( & flags , arg ) ) < 0 ) return ret ; av_force_cpu_flags ( flags ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@opt_cpucount": "int opt_cpucount ( void * optctx , const char * opt , const char * arg ) { int ret ; int count ; static const AVOption opts [ ] = { { \"count\" , NULL , 0 , AV_OPT_TYPE_INT , { . i64 = - 1 } , - 1 , INT_MAX } , { NULL } , } ; static const AVClass class = { . class_name = \"cpucount\" , . item_name = av_default_item_name , . option = opts , . version = LIBAVUTIL_VERSION_INT , } ; const AVClass * pclass = & class ; ret = av_opt_eval_int ( & pclass , opts , arg , & count ) ; if ( ! ret ) { av_cpu_force_count ( count ) ; } return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@expand_filename_template": "static void expand_filename_template ( AVBPrint * bp , const char * template , struct tm * tm ) { int c ; while ( ( c = * ( template ++ ) ) ) { if ( c == '%' ) { if ( ! ( c = * ( template ++ ) ) ) break ; switch ( c ) { case 'p' : av_bprintf ( bp , \"%s\" , program_name ) ; break ; case 't' : av_bprintf ( bp , \"%04d%02d%02d-%02d%02d%02d\" , tm -> tm_year + 1900 , tm -> tm_mon + 1 , tm -> tm_mday , tm -> tm_hour , tm -> tm_min , tm -> tm_sec ) ; break ; case '%' : av_bprint_chars ( bp , c , 1 ) ; break ; } } else { av_bprint_chars ( bp , c , 1 ) ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@log_callback_report": "static void log_callback_report ( void * ptr , int level , const char * fmt , va_list vl ) { va_list vl2 ; char line [ 1024 ] ; static int print_prefix = 1 ; va_copy ( vl2 , vl ) ; if ( report_callback == NULL ) { av_log_default_callback ( ptr , level , fmt , vl ) ; } else { ffmpegkit_log_callback_function ( ptr , level , fmt , vl ) ; } av_log_format_line ( ptr , level , fmt , vl2 , line , sizeof ( line ) , & print_prefix ) ; va_end ( vl2 ) ; if ( report_file && report_file_level >= level ) { fputs ( line , report_file ) ; fflush ( report_file ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@init_report": "int init_report ( const char * env , FILE * * file ) { char * filename_template = NULL ; char * key , * val ; int ret , count = 0 ; int prog_loglevel , envlevel = 0 ; time_t now ; struct tm * tm ; AVBPrint filename ; if ( report_file ) /* already opened */ return 0 ; time ( & now ) ; tm = localtime ( & now ) ; while ( env && * env ) { if ( ( ret = av_opt_get_key_value ( & env , \"=\" , \":\" , 0 , & key , & val ) ) < 0 ) { if ( count ) av_log ( NULL , AV_LOG_ERROR , \"Failed to parse FFREPORT environment variable: %s\\n\" , av_err2str ( ret ) ) ; break ; } if ( * env ) env ++ ; count ++ ; if ( ! strcmp ( key , \"file\" ) ) { av_free ( filename_template ) ; filename_template = val ; val = NULL ; } else if ( ! strcmp ( key , \"level\" ) ) { char * tail ; report_file_level = strtol ( val , & tail , 10 ) ; if ( * tail ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid report file level\\n\" ) ; exit_program ( 1 ) ; } envlevel = 1 ; } else { av_log ( NULL , AV_LOG_ERROR , \"Unknown key '%s' in FFREPORT\\n\" , key ) ; } av_free ( val ) ; av_free ( key ) ; } av_bprint_init ( & filename , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; expand_filename_template ( & filename , av_x_if_null ( filename_template , \"%p-%t.log\" ) , tm ) ; av_free ( filename_template ) ; if ( ! av_bprint_is_complete ( & filename ) ) { av_log ( NULL , AV_LOG_ERROR , \"Out of memory building report file name\\n\" ) ; return AVERROR ( ENOMEM ) ; } prog_loglevel = av_log_get_level ( ) ; if ( ! envlevel ) report_file_level = FFMAX ( report_file_level , prog_loglevel ) ; report_file = fopen ( filename . str , \"w\" ) ; if ( ! report_file ) { int ret = AVERROR ( errno ) ; av_log ( NULL , AV_LOG_ERROR , \"Failed to open report \\\"%s\\\": %s\\n\" , filename . str , strerror ( errno ) ) ; return ret ; } av_log_set_callback ( log_callback_report ) ; av_log ( NULL , AV_LOG_INFO , \"%s started on %04d-%02d-%02d at %02d:%02d:%02d\\n\" \"Report written to \\\"%s\\\"\\n\" \"Log level: %d\\n\" , program_name , tm -> tm_year + 1900 , tm -> tm_mon + 1 , tm -> tm_mday , tm -> tm_hour , tm -> tm_min , tm -> tm_sec , filename . str , report_file_level ) ; av_bprint_finalize ( & filename , NULL ) ; if ( file ) * file = report_file ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@opt_report": "int opt_report ( void * optctx , const char * opt , const char * arg ) { return init_report ( NULL , NULL ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@opt_max_alloc": "int opt_max_alloc ( void * optctx , const char * opt , const char * arg ) { char * tail ; size_t max ; max = strtol ( arg , & tail , 10 ) ; if ( * tail ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid max_alloc \\\"%s\\\".\\n\" , arg ) ; exit_program ( 1 ) ; } av_max_alloc ( max ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_opt_common.c@opt_loglevel": "int opt_loglevel ( void * optctx , const char * opt , const char * arg ) { const struct { const char * name ; int level ; } log_levels [ ] = { { \"quiet\" , AV_LOG_QUIET } , { \"panic\" , AV_LOG_PANIC } , { \"fatal\" , AV_LOG_FATAL } , { \"error\" , AV_LOG_ERROR } , { \"warning\" , AV_LOG_WARNING } , { \"info\" , AV_LOG_INFO } , { \"verbose\" , AV_LOG_VERBOSE } , { \"debug\" , AV_LOG_DEBUG } , { \"trace\" , AV_LOG_TRACE } , } ; const char * token ; char * tail ; int flags = av_log_get_flags ( ) ; int level = av_log_get_level ( ) ; int cmd , i = 0 ; av_assert0 ( arg ) ; while ( * arg ) { token = arg ; if ( * token == '+' || * token == '-' ) { cmd = * token ++ ; } else { cmd = 0 ; } if ( ! i && ! cmd ) { flags = 0 ; /* missing relative prefix, build absolute value */ } if ( av_strstart ( token , \"repeat\" , & arg ) ) { if ( cmd == '-' ) { flags |= AV_LOG_SKIP_REPEATED ; } else { flags &= ~ AV_LOG_SKIP_REPEATED ; } } else if ( av_strstart ( token , \"level\" , & arg ) ) { if ( cmd == '-' ) { flags &= ~ AV_LOG_PRINT_LEVEL ; } else { flags |= AV_LOG_PRINT_LEVEL ; } } else { break ; } i ++ ; } if ( ! * arg ) { goto end ; } else if ( * arg == '+' ) { arg ++ ; } else if ( ! i ) { flags = av_log_get_flags ( ) ; /* level value without prefix, reset flags */ } for ( i = 0 ; i < FF_ARRAY_ELEMS ( log_levels ) ; i ++ ) { if ( ! strcmp ( log_levels [ i ] . name , arg ) ) { level = log_levels [ i ] . level ; goto end ; } } level = strtol ( arg , & tail , 10 ) ; if ( * tail ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid loglevel \\\"%s\\\". \" \"Possible levels are numbers or:\\n\" , arg ) ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( log_levels ) ; i ++ ) av_log ( NULL , AV_LOG_FATAL , \"\\\"%s\\\"\\n\" , log_levels [ i ] . name ) ; exit_program ( 1 ) ; } end : av_log_set_flags ( flags ) ; av_log_set_level ( level ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/android_lts_support.c@posix_memalign": "int posix_memalign ( void * * memptr , size_t alignment , size_t size ) { if ( ( alignment & ( alignment - 1 ) ) != 0 || alignment == 0 ) { return EINVAL ; } if ( alignment % sizeof ( void * ) != 0 ) { return EINVAL ; } * memptr = memalign ( alignment , size ) ; if ( * memptr == NULL ) { return errno ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/android_lts_support.c@log2": "double log2 ( double x ) { return ( log ( x ) / M_LN2 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/android_lts_support.c@log2f": "float log2f ( float x ) { return ( float ) log2 ( ( double ) x ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@sub2video_get_blank_frame": "static int sub2video_get_blank_frame ( InputStream * ist ) { int ret ; AVFrame * frame = ist -> sub2video . frame ; av_frame_unref ( frame ) ; ist -> sub2video . frame -> width = ist -> dec_ctx -> width ? ist -> dec_ctx -> width : ist -> sub2video . w ; ist -> sub2video . frame -> height = ist -> dec_ctx -> height ? ist -> dec_ctx -> height : ist -> sub2video . h ; ist -> sub2video . frame -> format = AV_PIX_FMT_RGB32 ; if ( ( ret = av_frame_get_buffer ( frame , 0 ) ) < 0 ) return ret ; memset ( frame -> data [ 0 ] , 0 , frame -> height * frame -> linesize [ 0 ] ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@sub2video_copy_rect": "static void sub2video_copy_rect ( uint8_t * dst , int dst_linesize , int w , int h , AVSubtitleRect * r ) { uint32_t * pal , * dst2 ; uint8_t * src , * src2 ; int x , y ; if ( r -> type != SUBTITLE_BITMAP ) { av_log ( NULL , AV_LOG_WARNING , \"sub2video: non-bitmap subtitle\\n\" ) ; return ; } if ( r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h ) { av_log ( NULL , AV_LOG_WARNING , \"sub2video: rectangle (%d %d %d %d) overflowing %d %d\\n\" , r -> x , r -> y , r -> w , r -> h , w , h ) ; return ; } dst += r -> y * dst_linesize + r -> x * 4 ; src = r -> data [ 0 ] ; pal = ( uint32_t * ) r -> data [ 1 ] ; for ( y = 0 ; y < r -> h ; y ++ ) { dst2 = ( uint32_t * ) dst ; src2 = src ; for ( x = 0 ; x < r -> w ; x ++ ) * ( dst2 ++ ) = pal [ * ( src2 ++ ) ] ; dst += dst_linesize ; src += r -> linesize [ 0 ] ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@sub2video_push_ref": "static void sub2video_push_ref ( InputStream * ist , int64_t pts ) { AVFrame * frame = ist -> sub2video . frame ; int i ; int ret ; av_assert1 ( frame -> data [ 0 ] ) ; ist -> sub2video . last_pts = frame -> pts = pts ; for ( i = 0 ; i < ist -> nb_filters ; i ++ ) { ret = av_buffersrc_add_frame_flags ( ist -> filters [ i ] -> filter , frame , AV_BUFFERSRC_FLAG_KEEP_REF | AV_BUFFERSRC_FLAG_PUSH ) ; if ( ret != AVERROR_EOF && ret < 0 ) av_log ( NULL , AV_LOG_WARNING , \"Error while add the frame to buffer source(%s).\\n\" , av_err2str ( ret ) ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@sub2video_update": "void sub2video_update ( InputStream * ist , int64_t heartbeat_pts , AVSubtitle * sub ) { AVFrame * frame = ist -> sub2video . frame ; int8_t * dst ; int dst_linesize ; int num_rects , i ; int64_t pts , end_pts ; if ( ! frame ) return ; if ( sub ) { pts = av_rescale_q ( sub -> pts + sub -> start_display_time * 1000LL , AV_TIME_BASE_Q , ist -> st -> time_base ) ; end_pts = av_rescale_q ( sub -> pts + sub -> end_display_time * 1000LL , AV_TIME_BASE_Q , ist -> st -> time_base ) ; num_rects = sub -> num_rects ; } else { /* If we are initializing the system, utilize current heartbeat\n           PTS as the start time, and show until the following subpicture\n           is received. Otherwise, utilize the previous subpicture's end time\n           as the fall-back value. */ pts = ist -> sub2video . initialize ? heartbeat_pts : ist -> sub2video . end_pts ; end_pts = INT64_MAX ; num_rects = 0 ; } if ( sub2video_get_blank_frame ( ist ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Impossible to get a blank canvas.\\n\" ) ; return ; } dst = frame -> data [ 0 ] ; dst_linesize = frame -> linesize [ 0 ] ; for ( i = 0 ; i < num_rects ; i ++ ) sub2video_copy_rect ( dst , dst_linesize , frame -> width , frame -> height , sub -> rects [ i ] ) ; sub2video_push_ref ( ist , pts ) ; ist -> sub2video . end_pts = end_pts ; ist -> sub2video . initialize = 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@sub2video_heartbeat": "static void sub2video_heartbeat ( InputStream * ist , int64_t pts ) { InputFile * infile = input_files [ ist -> file_index ] ; int i , j , nb_reqs ; int64_t pts2 ; /* When a frame is read from a file, examine all sub2video streams in\n       the same file and send the sub2video frame again. Otherwise, decoded\n       video frames could be accumulating in the filter graph while a filter\n       (possibly overlay) is desperately waiting for a subtitle frame. */ for ( i = 0 ; i < infile -> nb_streams ; i ++ ) { InputStream * ist2 = infile -> streams [ i ] ; if ( ! ist2 -> sub2video . frame ) continue ; /* subtitles seem to be usually muxed ahead of other streams;\n           if not, subtracting a larger time here is necessary */ pts2 = av_rescale_q ( pts , ist -> st -> time_base , ist2 -> st -> time_base ) - 1 ; /* do not send the heartbeat frame if the subtitle is already ahead */ if ( pts2 <= ist2 -> sub2video . last_pts ) continue ; if ( pts2 >= ist2 -> sub2video . end_pts || ist2 -> sub2video . initialize ) /* if we have hit the end of the current displayed subpicture,\n               or if we need to initialize the system, update the\n               overlayed subpicture and its start/end times */ sub2video_update ( ist2 , pts2 + 1 , NULL ) ; for ( j = 0 , nb_reqs = 0 ; j < ist2 -> nb_filters ; j ++ ) nb_reqs += av_buffersrc_get_nb_failed_requests ( ist2 -> filters [ j ] -> filter ) ; if ( nb_reqs ) sub2video_push_ref ( ist2 , pts2 ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@sub2video_flush": "static void sub2video_flush ( InputStream * ist ) { int i ; int ret ; if ( ist -> sub2video . end_pts < INT64_MAX ) sub2video_update ( ist , INT64_MAX , NULL ) ; for ( i = 0 ; i < ist -> nb_filters ; i ++ ) { ret = av_buffersrc_add_frame ( ist -> filters [ i ] -> filter , NULL ) ; if ( ret != AVERROR_EOF && ret < 0 ) av_log ( NULL , AV_LOG_WARNING , \"Flush the frame error.\\n\" ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@term_exit_sigsafe": "static void term_exit_sigsafe ( void ) { # if HAVE_TERMIOS_H if ( restore_tty ) tcsetattr ( 0 , TCSANOW , & oldtty ) ; # endif }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@term_exit": "void term_exit ( void ) { av_log ( NULL , AV_LOG_QUIET , \"%s\" , \"\" ) ; term_exit_sigsafe ( ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@sigterm_handler": "static void sigterm_handler ( int sig ) { // int ret; received_sigterm = sig ; received_nb_signals ++ ; term_exit_sigsafe ( ) ; // FFmpegKit - Hard Exit Disabled // if(received_nb_signals > 3) { //     ret = write(2/*STDERR_FILENO*/, \"Received > 3 system signals, hard exiting\\n\", //                 strlen(\"Received > 3 system signals, hard exiting\\n\")); //     if (ret < 0) { /* Do nothing */ }; //     exit(123); // } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@term_init": "void term_init ( void ) { # if defined __linux__ # if defined __aarch64__ || defined __amd64__ || defined __x86_64__ struct sigaction action = { 0 } ; # else struct sigaction action = { { 0 } } ; # endif action . sa_handler = sigterm_handler ; /* block other interrupts while processing this one */ sigfillset ( & action . sa_mask ) ; /* restart interruptible functions (i.e. don't fail with EINTR)  */ action . sa_flags = SA_RESTART ; # endif # if HAVE_TERMIOS_H if ( stdin_interaction ) { struct termios tty ; if ( tcgetattr ( 0 , & tty ) == 0 ) { oldtty = tty ; restore_tty = 1 ; tty . c_iflag &= ~ ( IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL | IXON ) ; tty . c_oflag |= OPOST ; tty . c_lflag &= ~ ( ECHO | ECHONL | ICANON | IEXTEN ) ; tty . c_cflag &= ~ ( CSIZE | PARENB ) ; tty . c_cflag |= CS8 ; tty . c_cc [ VMIN ] = 1 ; tty . c_cc [ VTIME ] = 0 ; tcsetattr ( 0 , TCSANOW , & tty ) ; } if ( handleSIGQUIT == 1 ) { SIGNAL ( SIGQUIT , sigterm_handler ) ; /* Quit (POSIX).  */ } } # endif if ( handleSIGINT == 1 ) { SIGNAL ( SIGINT , sigterm_handler ) ; /* Interrupt (ANSI).    */ } if ( handleSIGTERM == 1 ) { SIGNAL ( SIGTERM , sigterm_handler ) ; /* Termination (ANSI).  */ } # ifdef SIGXCPU if ( handleSIGXCPU == 1 ) { SIGNAL ( SIGXCPU , sigterm_handler ) ; } # endif # ifdef SIGPIPE if ( handleSIGPIPE == 1 ) { SIGNAL ( SIGPIPE , SIG_IGN ) ; /* Broken pipe (POSIX). */ } # endif # if HAVE_SETCONSOLECTRLHANDLER SetConsoleCtrlHandler ( ( PHANDLER_ROUTINE ) CtrlHandler , TRUE ) ; # endif }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@read_key": "static int read_key ( void ) { unsigned char ch ; # if HAVE_TERMIOS_H int n = 1 ; struct timeval tv ; fd_set rfds ; FD_ZERO ( & rfds ) ; FD_SET ( 0 , & rfds ) ; tv . tv_sec = 0 ; tv . tv_usec = 0 ; n = select ( 1 , & rfds , NULL , NULL , & tv ) ; if ( n > 0 ) { n = read ( 0 , & ch , 1 ) ; if ( n == 1 ) return ch ; return n ; } # elif HAVE_KBHIT # if HAVE_PEEKNAMEDPIPE static int is_pipe ; static HANDLE input_handle ; DWORD dw , nchars ; if ( ! input_handle ) { input_handle = GetStdHandle ( STD_INPUT_HANDLE ) ; is_pipe = ! GetConsoleMode ( input_handle , & dw ) ; } if ( is_pipe ) { /* When running under a GUI, you will end here. */ if ( ! PeekNamedPipe ( input_handle , NULL , 0 , NULL , & nchars , NULL ) ) { // input pipe may have been closed by the program that ran ffmpeg return - 1 ; } //Read it if ( nchars != 0 ) { read ( 0 , & ch , 1 ) ; return ch ; } else { return - 1 ; } } # endif if ( kbhit ( ) ) return ( getch ( ) ) ; # endif return - 1 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@decode_interrupt_cb": "int decode_interrupt_cb ( void * ctx ) { return received_nb_signals > atomic_load ( & transcode_init_done ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@ffmpeg_cleanup": "static void ffmpeg_cleanup ( int ret ) { int i , j ; if ( do_benchmark ) { int maxrss = getmaxrss ( ) / 1024 ; av_log ( NULL , AV_LOG_INFO , \"bench: maxrss=%ikB\\n\" , maxrss ) ; } for ( i = 0 ; i < nb_filtergraphs ; i ++ ) { FilterGraph * fg = filtergraphs [ i ] ; avfilter_graph_free ( & fg -> graph ) ; for ( j = 0 ; j < fg -> nb_inputs ; j ++ ) { InputFilter * ifilter = fg -> inputs [ j ] ; struct InputStream * ist = ifilter -> ist ; if ( ifilter -> frame_queue ) { AVFrame * frame ; while ( av_fifo_read ( ifilter -> frame_queue , & frame , 1 ) >= 0 ) av_frame_free ( & frame ) ; av_fifo_freep2 ( & ifilter -> frame_queue ) ; } av_freep ( & ifilter -> displaymatrix ) ; if ( ist -> sub2video . sub_queue ) { AVSubtitle sub ; while ( av_fifo_read ( ist -> sub2video . sub_queue , & sub , 1 ) >= 0 ) avsubtitle_free ( & sub ) ; av_fifo_freep2 ( & ist -> sub2video . sub_queue ) ; } av_buffer_unref ( & ifilter -> hw_frames_ctx ) ; av_freep ( & ifilter -> name ) ; av_freep ( & fg -> inputs [ j ] ) ; } av_freep ( & fg -> inputs ) ; for ( j = 0 ; j < fg -> nb_outputs ; j ++ ) { OutputFilter * ofilter = fg -> outputs [ j ] ; avfilter_inout_free ( & ofilter -> out_tmp ) ; av_freep ( & ofilter -> name ) ; av_channel_layout_uninit ( & ofilter -> ch_layout ) ; av_freep ( & fg -> outputs [ j ] ) ; } av_freep ( & fg -> outputs ) ; av_freep ( & fg -> graph_desc ) ; av_freep ( & filtergraphs [ i ] ) ; } av_freep ( & filtergraphs ) ; /* close files */ for ( i = 0 ; i < nb_output_files ; i ++ ) of_close ( & output_files [ i ] ) ; for ( i = 0 ; i < nb_input_files ; i ++ ) ifile_close ( & input_files [ i ] ) ; if ( vstats_file ) { if ( fclose ( vstats_file ) ) av_log ( NULL , AV_LOG_ERROR , \"Error closing vstats file, loss of information possible: %s\\n\" , av_err2str ( AVERROR ( errno ) ) ) ; } av_freep ( & vstats_filename ) ; of_enc_stats_close ( ) ; av_freep ( & filter_nbthreads ) ; av_freep ( & input_files ) ; av_freep ( & output_files ) ; uninit_opts ( ) ; avformat_network_deinit ( ) ; if ( received_sigterm ) { av_log ( NULL , AV_LOG_INFO , \"Exiting normally, received signal %d.\\n\" , ( int ) received_sigterm ) ; } else if ( cancelRequested ( globalSessionId ) ) { av_log ( NULL , AV_LOG_INFO , \"Exiting normally, received cancel request.\\n\" ) ; } else if ( ret && atomic_load ( & transcode_init_done ) ) { av_log ( NULL , AV_LOG_INFO , \"Conversion failed!\\n\" ) ; } term_exit ( ) ; ffmpeg_exited = 1 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@ost_iter": "static OutputStream * ost_iter ( OutputStream * prev ) { int of_idx = prev ? prev -> file_index : 0 ; int ost_idx = prev ? prev -> index + 1 : 0 ; for ( ; of_idx < nb_output_files ; of_idx ++ ) { OutputFile * of = output_files [ of_idx ] ; if ( ost_idx < of -> nb_streams ) return of -> streams [ ost_idx ] ; ost_idx = 0 ; } return NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@ist_iter": "InputStream * ist_iter ( InputStream * prev ) { int if_idx = prev ? prev -> file_index : 0 ; int ist_idx = prev ? prev -> st -> index + 1 : 0 ; for ( ; if_idx < nb_input_files ; if_idx ++ ) { InputFile * f = input_files [ if_idx ] ; if ( ist_idx < f -> nb_streams ) return f -> streams [ ist_idx ] ; ist_idx = 0 ; } return NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@remove_avoptions": "void remove_avoptions ( AVDictionary * * a , AVDictionary * b ) { const AVDictionaryEntry * t = NULL ; while ( ( t = av_dict_iterate ( b , t ) ) ) { av_dict_set ( a , t -> key , NULL , AV_DICT_MATCH_CASE ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@assert_avoptions": "void assert_avoptions ( AVDictionary * m ) { const AVDictionaryEntry * t ; if ( ( t = av_dict_get ( m , \"\" , NULL , AV_DICT_IGNORE_SUFFIX ) ) ) { av_log ( NULL , AV_LOG_FATAL , \"Option %s not found.\\n\" , t -> key ) ; exit_program ( 1 ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@abort_codec_experimental": "static void abort_codec_experimental ( const AVCodec * c , int encoder ) { exit_program ( 1 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@update_benchmark": "static void update_benchmark ( const char * fmt , ... ) { if ( do_benchmark_all ) { BenchmarkTimeStamps t = get_benchmark_time_stamps ( ) ; va_list va ; char buf [ 1024 ] ; if ( fmt ) { va_start ( va , fmt ) ; vsnprintf ( buf , sizeof ( buf ) , fmt , va ) ; va_end ( va ) ; av_log ( NULL , AV_LOG_INFO , \"bench: %8\" PRIu64 \" user %8\" PRIu64 \" sys %8\" PRIu64 \" real %s \\n\" , t . user_usec - current_time . user_usec , t . sys_usec - current_time . sys_usec , t . real_usec - current_time . real_usec , buf ) ; } current_time = t ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@close_output_stream": "static void close_output_stream ( OutputStream * ost ) { OutputFile * of = output_files [ ost -> file_index ] ; ost -> finished |= ENCODER_FINISHED ; if ( ost -> sq_idx_encode >= 0 ) sq_send ( of -> sq_encode , ost -> sq_idx_encode , SQFRAME ( NULL ) ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@check_recording_time": "static int check_recording_time ( OutputStream * ost , int64_t ts , AVRational tb ) { OutputFile * of = output_files [ ost -> file_index ] ; if ( of -> recording_time != INT64_MAX && av_compare_ts ( ts , tb , of -> recording_time , AV_TIME_BASE_Q ) >= 0 ) { close_output_stream ( ost ) ; return 0 ; } return 1 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@adjust_frame_pts_to_encoder_tb": "static double adjust_frame_pts_to_encoder_tb ( OutputFile * of , OutputStream * ost , AVFrame * frame ) { double float_pts = AV_NOPTS_VALUE ; // this is identical to frame.pts but with higher precision const int64_t start_time = ( of -> start_time == AV_NOPTS_VALUE ) ? 0 : of -> start_time ; AVCodecContext * const enc = ost -> enc_ctx ; AVRational tb = enc -> time_base ; AVRational filter_tb = frame -> time_base ; const int extra_bits = av_clip ( 29 - av_log2 ( tb . den ) , 0 , 16 ) ; if ( frame -> pts == AV_NOPTS_VALUE ) goto early_exit ; tb . den <<= extra_bits ; float_pts = av_rescale_q ( frame -> pts , filter_tb , tb ) - av_rescale_q ( start_time , AV_TIME_BASE_Q , tb ) ; float_pts /= 1 << extra_bits ; // avoid exact midoints to reduce the chance of rounding differences, this // can be removed in case the fps code is changed to work with integers float_pts += FFSIGN ( float_pts ) * 1.0 / ( 1 << 17 ) ; frame -> pts = av_rescale_q ( frame -> pts , filter_tb , enc -> time_base ) - av_rescale_q ( start_time , AV_TIME_BASE_Q , enc -> time_base ) ; frame -> time_base = enc -> time_base ; early_exit : if ( debug_ts ) { av_log ( NULL , AV_LOG_INFO , \"filter -> pts:%s pts_time:%s exact:%f time_base:%d/%d\\n\" , frame ? av_ts2str ( frame -> pts ) : \"NULL\" , ( enc && frame ) ? av_ts2timestr ( frame -> pts , & enc -> time_base ) : \"NULL\" , float_pts , enc ? enc -> time_base . num : - 1 , enc ? enc -> time_base . den : - 1 ) ; } return float_pts ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@init_output_stream_wrapper": "static int init_output_stream_wrapper ( OutputStream * ost , AVFrame * frame , unsigned int fatal ) { int ret = AVERROR_BUG ; char error [ 1024 ] = { 0 } ; if ( ost -> initialized ) return 0 ; ret = init_output_stream ( ost , frame , error , sizeof ( error ) ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error initializing output stream: %s\\n\" , error ) ; if ( fatal ) exit_program ( 1 ) ; } return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@psnr": "static double psnr ( double d ) { return - 10.0 * log10 ( d ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@update_video_stats": "static void update_video_stats ( OutputStream * ost , const AVPacket * pkt , int write_vstats ) { const uint8_t * sd = av_packet_get_side_data ( pkt , AV_PKT_DATA_QUALITY_STATS , NULL ) ; AVCodecContext * enc = ost -> enc_ctx ; int64_t frame_number ; double ti1 , bitrate , avg_bitrate ; ost -> quality = sd ? AV_RL32 ( sd ) : - 1 ; ost -> pict_type = sd ? sd [ 4 ] : AV_PICTURE_TYPE_NONE ; for ( int i = 0 ; i < FF_ARRAY_ELEMS ( ost -> error ) ; i ++ ) { if ( sd && i < sd [ 5 ] ) ost -> error [ i ] = AV_RL64 ( sd + 8 + 8 * i ) ; else ost -> error [ i ] = - 1 ; } if ( ! write_vstats ) return ; /* this is executed just the first time update_video_stats is called */ if ( ! vstats_file ) { vstats_file = fopen ( vstats_filename , \"w\" ) ; if ( ! vstats_file ) { perror ( \"fopen\" ) ; exit_program ( 1 ) ; } } frame_number = ost -> packets_encoded ; if ( vstats_version <= 1 ) { fprintf ( vstats_file , \"frame= %5\" PRId64 \" q= %2.1f \" , frame_number , ost -> quality / ( float ) FF_QP2LAMBDA ) ; } else { fprintf ( vstats_file , \"out= %2d st= %2d frame= %5\" PRId64 \" q= %2.1f \" , ost -> file_index , ost -> index , frame_number , ost -> quality / ( float ) FF_QP2LAMBDA ) ; } if ( ost -> error [ 0 ] >= 0 && ( enc -> flags & AV_CODEC_FLAG_PSNR ) ) fprintf ( vstats_file , \"PSNR= %6.2f \" , psnr ( ost -> error [ 0 ] / ( enc -> width * enc -> height * 255.0 * 255.0 ) ) ) ; fprintf ( vstats_file , \"f_size= %6d \" , pkt -> size ) ; /* compute pts value */ ti1 = pkt -> dts * av_q2d ( pkt -> time_base ) ; if ( ti1 < 0.01 ) ti1 = 0.01 ; bitrate = ( pkt -> size * 8 ) / av_q2d ( enc -> time_base ) / 1000.0 ; avg_bitrate = ( double ) ( ost -> data_size_enc * 8 ) / ti1 / 1000.0 ; fprintf ( vstats_file , \"s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s \" , ( double ) ost -> data_size_enc / 1024 , ti1 , bitrate , avg_bitrate ) ; fprintf ( vstats_file , \"type= %c\\n\" , av_get_picture_type_char ( ost -> pict_type ) ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@enc_stats_write": "void enc_stats_write ( OutputStream * ost , EncStats * es , const AVFrame * frame , const AVPacket * pkt , uint64_t frame_num ) { AVIOContext * io = es -> io ; AVRational tb = frame ? frame -> time_base : pkt -> time_base ; int64_t pts = frame ? frame -> pts : pkt -> pts ; AVRational tbi = ( AVRational ) { 0 , 1 } ; int64_t ptsi = INT64_MAX ; const FrameData * fd ; if ( ( frame && frame -> opaque_ref ) || ( pkt && pkt -> opaque_ref ) ) { fd = ( const FrameData * ) ( frame ? frame -> opaque_ref -> data : pkt -> opaque_ref -> data ) ; tbi = fd -> tb ; ptsi = fd -> pts ; } for ( size_t i = 0 ; i < es -> nb_components ; i ++ ) { const EncStatsComponent * c = & es -> components [ i ] ; switch ( c -> type ) { case ENC_STATS_LITERAL : avio_write ( io , c -> str , c -> str_len ) ; continue ; case ENC_STATS_FILE_IDX : avio_printf ( io , \"%d\" , ost -> file_index ) ; continue ; case ENC_STATS_STREAM_IDX : avio_printf ( io , \"%d\" , ost -> index ) ; continue ; case ENC_STATS_TIMEBASE : avio_printf ( io , \"%d/%d\" , tb . num , tb . den ) ; continue ; case ENC_STATS_TIMEBASE_IN : avio_printf ( io , \"%d/%d\" , tbi . num , tbi . den ) ; continue ; case ENC_STATS_PTS : avio_printf ( io , \"%\" PRId64 , pts ) ; continue ; case ENC_STATS_PTS_IN : avio_printf ( io , \"%\" PRId64 , ptsi ) ; continue ; case ENC_STATS_PTS_TIME : avio_printf ( io , \"%g\" , pts * av_q2d ( tb ) ) ; continue ; case ENC_STATS_PTS_TIME_IN : avio_printf ( io , \"%g\" , ptsi == INT64_MAX ? INFINITY : ptsi * av_q2d ( tbi ) ) ; continue ; case ENC_STATS_FRAME_NUM : avio_printf ( io , \"%\" PRIu64 , frame_num ) ; continue ; case ENC_STATS_FRAME_NUM_IN : avio_printf ( io , \"%\" PRIu64 , fd ? fd -> idx : - 1 ) ; continue ; } if ( frame ) { switch ( c -> type ) { case ENC_STATS_SAMPLE_NUM : avio_printf ( io , \"%\" PRIu64 , ost -> samples_encoded ) ; continue ; case ENC_STATS_NB_SAMPLES : avio_printf ( io , \"%d\" , frame -> nb_samples ) ; continue ; default : av_assert0 ( 0 ) ; } } else { switch ( c -> type ) { case ENC_STATS_DTS : avio_printf ( io , \"%\" PRId64 , pkt -> dts ) ; continue ; case ENC_STATS_DTS_TIME : avio_printf ( io , \"%g\" , pkt -> dts * av_q2d ( tb ) ) ; continue ; case ENC_STATS_PKT_SIZE : avio_printf ( io , \"%d\" , pkt -> size ) ; continue ; case ENC_STATS_BITRATE : { double duration = FFMAX ( pkt -> duration , 1 ) * av_q2d ( tb ) ; avio_printf ( io , \"%g\" , 8.0 * pkt -> size / duration ) ; continue ; } case ENC_STATS_AVG_BITRATE : { double duration = pkt -> dts * av_q2d ( tb ) ; avio_printf ( io , \"%g\" , duration > 0 ? 8.0 * ost -> data_size_enc / duration : - 1. ) ; continue ; } default : av_assert0 ( 0 ) ; } } } avio_w8 ( io , '\\n' ) ; avio_flush ( io ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@encode_frame": "static int encode_frame ( OutputFile * of , OutputStream * ost , AVFrame * frame ) { AVCodecContext * enc = ost -> enc_ctx ; AVPacket * pkt = ost -> pkt ; const char * type_desc = av_get_media_type_string ( enc -> codec_type ) ; const char * action = frame ? \"encode\" : \"flush\" ; int ret ; if ( frame ) { if ( ost -> enc_stats_pre . io ) enc_stats_write ( ost , & ost -> enc_stats_pre , frame , NULL , ost -> frames_encoded ) ; ost -> frames_encoded ++ ; ost -> samples_encoded += frame -> nb_samples ; if ( debug_ts ) { av_log ( ost , AV_LOG_INFO , \"encoder <- type:%s \" \"frame_pts:%s frame_pts_time:%s time_base:%d/%d\\n\" , type_desc , av_ts2str ( frame -> pts ) , av_ts2timestr ( frame -> pts , & enc -> time_base ) , enc -> time_base . num , enc -> time_base . den ) ; } } update_benchmark ( NULL ) ; ret = avcodec_send_frame ( enc , frame ) ; if ( ret < 0 && ! ( ret == AVERROR_EOF && ! frame ) ) { av_log ( ost , AV_LOG_ERROR , \"Error submitting %s frame to the encoder\\n\" , type_desc ) ; return ret ; } while ( 1 ) { ret = avcodec_receive_packet ( enc , pkt ) ; update_benchmark ( \"%s_%s %d.%d\" , action , type_desc , ost -> file_index , ost -> index ) ; pkt -> time_base = enc -> time_base ; /* if two pass, output log on success and EOF */ if ( ( ret >= 0 || ret == AVERROR_EOF ) && ost -> logfile && enc -> stats_out ) fprintf ( ost -> logfile , \"%s\" , enc -> stats_out ) ; if ( ret == AVERROR ( EAGAIN ) ) { av_assert0 ( frame ) ; // should never happen during flushing return 0 ; } else if ( ret == AVERROR_EOF ) { of_output_packet ( of , pkt , ost , 1 ) ; return ret ; } else if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"%s encoding failed\\n\" , type_desc ) ; return ret ; } if ( enc -> codec_type == AVMEDIA_TYPE_VIDEO ) update_video_stats ( ost , pkt , ! ! vstats_filename ) ; if ( ost -> enc_stats_post . io ) enc_stats_write ( ost , & ost -> enc_stats_post , NULL , pkt , ost -> packets_encoded ) ; if ( debug_ts ) { av_log ( ost , AV_LOG_INFO , \"encoder -> type:%s \" \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s \" \"duration:%s duration_time:%s\\n\" , type_desc , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & enc -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & enc -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & enc -> time_base ) ) ; } av_packet_rescale_ts ( pkt , pkt -> time_base , ost -> mux_timebase ) ; pkt -> time_base = ost -> mux_timebase ; if ( debug_ts ) { av_log ( ost , AV_LOG_INFO , \"encoder -> type:%s \" \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s \" \"duration:%s duration_time:%s\\n\" , type_desc , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & enc -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & enc -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & enc -> time_base ) ) ; } if ( ( ret = trigger_fix_sub_duration_heartbeat ( ost , pkt ) ) < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Subtitle heartbeat logic failed in %s! (%s)\\n\" , __func__ , av_err2str ( ret ) ) ; exit_program ( 1 ) ; } ost -> data_size_enc += pkt -> size ; ost -> packets_encoded ++ ; of_output_packet ( of , pkt , ost , 0 ) ; } av_assert0 ( 0 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@submit_encode_frame": "static int submit_encode_frame ( OutputFile * of , OutputStream * ost , AVFrame * frame ) { int ret ; if ( ost -> sq_idx_encode < 0 ) return encode_frame ( of , ost , frame ) ; if ( frame ) { ret = av_frame_ref ( ost -> sq_frame , frame ) ; if ( ret < 0 ) return ret ; frame = ost -> sq_frame ; } ret = sq_send ( of -> sq_encode , ost -> sq_idx_encode , SQFRAME ( frame ) ) ; if ( ret < 0 ) { if ( frame ) av_frame_unref ( frame ) ; if ( ret != AVERROR_EOF ) return ret ; } while ( 1 ) { AVFrame * enc_frame = ost -> sq_frame ; ret = sq_receive ( of -> sq_encode , ost -> sq_idx_encode , SQFRAME ( enc_frame ) ) ; if ( ret == AVERROR_EOF ) { enc_frame = NULL ; } else if ( ret < 0 ) { return ( ret == AVERROR ( EAGAIN ) ) ? 0 : ret ; } ret = encode_frame ( of , ost , enc_frame ) ; if ( enc_frame ) av_frame_unref ( enc_frame ) ; if ( ret < 0 ) { if ( ret == AVERROR_EOF ) close_output_stream ( ost ) ; return ret ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@do_audio_out": "static void do_audio_out ( OutputFile * of , OutputStream * ost , AVFrame * frame ) { AVCodecContext * enc = ost -> enc_ctx ; int ret ; if ( frame -> pts == AV_NOPTS_VALUE ) frame -> pts = ost -> next_pts ; else { int64_t start_time = ( of -> start_time == AV_NOPTS_VALUE ) ? 0 : of -> start_time ; frame -> pts = av_rescale_q ( frame -> pts , frame -> time_base , enc -> time_base ) - av_rescale_q ( start_time , AV_TIME_BASE_Q , enc -> time_base ) ; } frame -> time_base = enc -> time_base ; if ( ! check_recording_time ( ost , frame -> pts , frame -> time_base ) ) return ; ost -> next_pts = frame -> pts + frame -> nb_samples ; ret = submit_encode_frame ( of , ost , frame ) ; if ( ret < 0 && ret != AVERROR_EOF ) exit_program ( 1 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@do_subtitle_out": "static void do_subtitle_out ( OutputFile * of , OutputStream * ost , AVSubtitle * sub ) { int subtitle_out_max_size = 1024 * 1024 ; int subtitle_out_size , nb , i , ret ; AVCodecContext * enc ; AVPacket * pkt = ost -> pkt ; int64_t pts ; if ( sub -> pts == AV_NOPTS_VALUE ) { av_log ( ost , AV_LOG_ERROR , \"Subtitle packets must have a pts\\n\" ) ; if ( exit_on_error ) exit_program ( 1 ) ; return ; } enc = ost -> enc_ctx ; /* Note: DVB subtitle need one packet to draw them and one other\n       packet to clear them */ /* XXX: signal it in the codec context ? */ if ( enc -> codec_id == AV_CODEC_ID_DVB_SUBTITLE ) nb = 2 ; else nb = 1 ; /* shift timestamp to honor -ss and make check_recording_time() work with -t */ pts = sub -> pts ; if ( output_files [ ost -> file_index ] -> start_time != AV_NOPTS_VALUE ) pts -= output_files [ ost -> file_index ] -> start_time ; for ( i = 0 ; i < nb ; i ++ ) { unsigned save_num_rects = sub -> num_rects ; if ( ! check_recording_time ( ost , pts , AV_TIME_BASE_Q ) ) return ; ret = av_new_packet ( pkt , subtitle_out_max_size ) ; if ( ret < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; sub -> pts = pts ; // start_display_time is required to be 0 sub -> pts += av_rescale_q ( sub -> start_display_time , ( AVRational ) { 1 , 1000 } , AV_TIME_BASE_Q ) ; sub -> end_display_time -= sub -> start_display_time ; sub -> start_display_time = 0 ; if ( i == 1 ) sub -> num_rects = 0 ; ost -> frames_encoded ++ ; subtitle_out_size = avcodec_encode_subtitle ( enc , pkt -> data , pkt -> size , sub ) ; if ( i == 1 ) sub -> num_rects = save_num_rects ; if ( subtitle_out_size < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Subtitle encoding failed\\n\" ) ; exit_program ( 1 ) ; } av_shrink_packet ( pkt , subtitle_out_size ) ; pkt -> time_base = ost -> mux_timebase ; pkt -> pts = av_rescale_q ( sub -> pts , AV_TIME_BASE_Q , pkt -> time_base ) ; pkt -> duration = av_rescale_q ( sub -> end_display_time , ( AVRational ) { 1 , 1000 } , pkt -> time_base ) ; if ( enc -> codec_id == AV_CODEC_ID_DVB_SUBTITLE ) { /* XXX: the pts correction is handled here. Maybe handling\n               it in the codec would be better */ if ( i == 0 ) pkt -> pts += av_rescale_q ( sub -> start_display_time , ( AVRational ) { 1 , 1000 } , pkt -> time_base ) ; else pkt -> pts += av_rescale_q ( sub -> end_display_time , ( AVRational ) { 1 , 1000 } , pkt -> time_base ) ; } pkt -> dts = pkt -> pts ; of_output_packet ( of , pkt , ost , 0 ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@video_sync_process": "static void video_sync_process ( OutputFile * of , OutputStream * ost , AVFrame * next_picture , double duration , int64_t * nb_frames , int64_t * nb_frames_prev ) { double delta0 , delta ; double sync_ipts = adjust_frame_pts_to_encoder_tb ( of , ost , next_picture ) ; /* delta0 is the \"drift\" between the input frame (next_picture) and\n     * where it would fall in the output. */ delta0 = sync_ipts - ost -> next_pts ; delta = delta0 + duration ; // tracks the number of times the PREVIOUS frame should be duplicated, // mostly for variable framerate (VFR) * nb_frames_prev = 0 ; /* by default, we output a single frame */ * nb_frames = 1 ; if ( delta0 < 0 && delta > 0 && ost -> vsync_method != VSYNC_PASSTHROUGH && ost -> vsync_method != VSYNC_DROP ) { if ( delta0 < - 0.6 ) { av_log ( ost , AV_LOG_VERBOSE , \"Past duration %f too large\\n\" , - delta0 ) ; } else av_log ( ost , AV_LOG_DEBUG , \"Clipping frame in rate conversion by %f\\n\" , - delta0 ) ; sync_ipts = ost -> next_pts ; duration += delta0 ; delta0 = 0 ; } switch ( ost -> vsync_method ) { case VSYNC_VSCFR : if ( ost -> vsync_frame_number == 0 && delta0 >= 0.5 ) { av_log ( ost , AV_LOG_DEBUG , \"Not duplicating %d initial frames\\n\" , ( int ) lrintf ( delta0 ) ) ; delta = duration ; delta0 = 0 ; ost -> next_pts = llrint ( sync_ipts ) ; } case VSYNC_CFR : // FIXME set to 0.5 after we fix some dts/pts bugs like in avidec.c if ( frame_drop_threshold && delta < frame_drop_threshold && ost -> vsync_frame_number ) { * nb_frames = 0 ; } else if ( delta < - 1.1 ) * nb_frames = 0 ; else if ( delta > 1.1 ) { * nb_frames = llrintf ( delta ) ; if ( delta0 > 1.1 ) * nb_frames_prev = llrintf ( delta0 - 0.6 ) ; } next_picture -> duration = 1 ; break ; case VSYNC_VFR : if ( delta <= - 0.6 ) * nb_frames = 0 ; else if ( delta > 0.6 ) ost -> next_pts = llrint ( sync_ipts ) ; next_picture -> duration = duration ; break ; case VSYNC_DROP : case VSYNC_PASSTHROUGH : next_picture -> duration = duration ; ost -> next_pts = llrint ( sync_ipts ) ; break ; default : av_assert0 ( 0 ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@forced_kf_apply": "enum AVPictureType forced_kf_apply ( void * logctx , KeyframeForceCtx * kf , AVRational tb , const AVFrame * in_picture , int dup_idx ) { double pts_time ; if ( kf -> ref_pts == AV_NOPTS_VALUE ) kf -> ref_pts = in_picture -> pts ; pts_time = ( in_picture -> pts - kf -> ref_pts ) * av_q2d ( tb ) ; if ( kf -> index < kf -> nb_pts && av_compare_ts ( in_picture -> pts , tb , kf -> pts [ kf -> index ] , AV_TIME_BASE_Q ) >= 0 ) { kf -> index ++ ; goto force_keyframe ; } else if ( kf -> pexpr ) { double res ; kf -> expr_const_values [ FKF_T ] = pts_time ; res = av_expr_eval ( kf -> pexpr , kf -> expr_const_values , NULL ) ; ff_dlog ( NULL , \"force_key_frame: n:%f n_forced:%f prev_forced_n:%f t:%f prev_forced_t:%f -> res:%f\\n\" , kf -> expr_const_values [ FKF_N ] , kf -> expr_const_values [ FKF_N_FORCED ] , kf -> expr_const_values [ FKF_PREV_FORCED_N ] , kf -> expr_const_values [ FKF_T ] , kf -> expr_const_values [ FKF_PREV_FORCED_T ] , res ) ; kf -> expr_const_values [ FKF_N ] += 1 ; if ( res ) { kf -> expr_const_values [ FKF_PREV_FORCED_N ] = kf -> expr_const_values [ FKF_N ] - 1 ; kf -> expr_const_values [ FKF_PREV_FORCED_T ] = kf -> expr_const_values [ FKF_T ] ; kf -> expr_const_values [ FKF_N_FORCED ] += 1 ; goto force_keyframe ; } } else if ( kf -> type == KF_FORCE_SOURCE && in_picture -> key_frame == 1 && ! dup_idx ) { goto force_keyframe ; } else if ( kf -> type == KF_FORCE_SOURCE_NO_DROP && ! dup_idx ) { kf -> dropped_keyframe = 0 ; if ( ( in_picture -> key_frame == 1 ) || kf -> dropped_keyframe ) goto force_keyframe ; } return AV_PICTURE_TYPE_NONE ; force_keyframe : av_log ( logctx , AV_LOG_DEBUG , \"Forced keyframe at time %f\\n\" , pts_time ) ; return AV_PICTURE_TYPE_I ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@do_video_out": "static void do_video_out ( OutputFile * of , OutputStream * ost , AVFrame * next_picture ) { int ret ; AVCodecContext * enc = ost -> enc_ctx ; AVRational frame_rate ; int64_t nb_frames , nb_frames_prev , i ; double duration = 0 ; InputStream * ist = ost -> ist ; AVFilterContext * filter = ost -> filter -> filter ; init_output_stream_wrapper ( ost , next_picture , 1 ) ; frame_rate = av_buffersink_get_frame_rate ( filter ) ; if ( frame_rate . num > 0 && frame_rate . den > 0 ) duration = 1 / ( av_q2d ( frame_rate ) * av_q2d ( enc -> time_base ) ) ; if ( ist && ist -> st -> start_time != AV_NOPTS_VALUE && ist -> first_dts != AV_NOPTS_VALUE && ost -> frame_rate . num ) duration = FFMIN ( duration , 1 / ( av_q2d ( ost -> frame_rate ) * av_q2d ( enc -> time_base ) ) ) ; if ( ! ost -> filters_script && ! ost -> filters && ( nb_filtergraphs == 0 || ! filtergraphs [ 0 ] -> graph_desc ) && next_picture && ist && lrintf ( next_picture -> duration * av_q2d ( ist -> st -> time_base ) / av_q2d ( enc -> time_base ) ) > 0 ) { duration = lrintf ( next_picture -> duration * av_q2d ( ist -> st -> time_base ) / av_q2d ( enc -> time_base ) ) ; } if ( ! next_picture ) { //end, flushing nb_frames_prev = nb_frames = mid_pred ( ost -> last_nb0_frames [ 0 ] , ost -> last_nb0_frames [ 1 ] , ost -> last_nb0_frames [ 2 ] ) ; } else { video_sync_process ( of , ost , next_picture , duration , & nb_frames , & nb_frames_prev ) ; } memmove ( ost -> last_nb0_frames + 1 , ost -> last_nb0_frames , sizeof ( ost -> last_nb0_frames [ 0 ] ) * ( FF_ARRAY_ELEMS ( ost -> last_nb0_frames ) - 1 ) ) ; ost -> last_nb0_frames [ 0 ] = nb_frames_prev ; if ( nb_frames_prev == 0 && ost -> last_dropped ) { nb_frames_drop ++ ; av_log ( ost , AV_LOG_VERBOSE , \"*** dropping frame %\" PRId64 \" at ts %\" PRId64 \"\\n\" , ost -> vsync_frame_number , ost -> last_frame -> pts ) ; } if ( nb_frames > ( nb_frames_prev && ost -> last_dropped ) + ( nb_frames > nb_frames_prev ) ) { if ( nb_frames > dts_error_threshold * 30 ) { av_log ( ost , AV_LOG_ERROR , \"%\" PRId64 \" frame duplication too large, skipping\\n\" , nb_frames - 1 ) ; nb_frames_drop ++ ; return ; } nb_frames_dup += nb_frames - ( nb_frames_prev && ost -> last_dropped ) - ( nb_frames > nb_frames_prev ) ; av_log ( ost , AV_LOG_VERBOSE , \"*** %\" PRId64 \" dup!\\n\" , nb_frames - 1 ) ; if ( nb_frames_dup > dup_warning ) { av_log ( ost , AV_LOG_WARNING , \"More than %\" PRIu64 \" frames duplicated\\n\" , dup_warning ) ; dup_warning *= 10 ; } } ost -> last_dropped = nb_frames == nb_frames_prev && next_picture ; ost -> kf . dropped_keyframe = ost -> last_dropped && next_picture && next_picture -> key_frame ; /* duplicates frame if needed */ for ( i = 0 ; i < nb_frames ; i ++ ) { AVFrame * in_picture ; if ( i < nb_frames_prev && ost -> last_frame -> buf [ 0 ] ) { in_picture = ost -> last_frame ; } else in_picture = next_picture ; if ( ! in_picture ) return ; in_picture -> pts = ost -> next_pts ; if ( ! check_recording_time ( ost , in_picture -> pts , ost -> enc_ctx -> time_base ) ) return ; in_picture -> quality = enc -> global_quality ; in_picture -> pict_type = forced_kf_apply ( ost , & ost -> kf , enc -> time_base , in_picture , i ) ; ret = submit_encode_frame ( of , ost , in_picture ) ; if ( ret == AVERROR_EOF ) break ; else if ( ret < 0 ) exit_program ( 1 ) ; ost -> next_pts ++ ; ost -> vsync_frame_number ++ ; } av_frame_unref ( ost -> last_frame ) ; if ( next_picture ) av_frame_move_ref ( ost -> last_frame , next_picture ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@reap_filters": "static int reap_filters ( int flush ) { AVFrame * filtered_frame = NULL ; /* Reap all buffers present in the buffer sinks */ for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { OutputFile * of = output_files [ ost -> file_index ] ; AVFilterContext * filter ; AVCodecContext * enc = ost -> enc_ctx ; int ret = 0 ; if ( ! ost -> filter || ! ost -> filter -> graph -> graph ) continue ; filter = ost -> filter -> filter ; /*\n         * Unlike video, with audio the audio frame size matters.\n         * Currently we are fully reliant on the lavfi filter chain to\n         * do the buffering deed for us, and thus the frame size parameter\n         * needs to be set accordingly. Where does one get the required\n         * frame size? From the initialized AVCodecContext of an audio\n         * encoder. Thus, if we have gotten to an audio stream, initialize\n         * the encoder earlier than receiving the first AVFrame.\n         */ if ( av_buffersink_get_type ( filter ) == AVMEDIA_TYPE_AUDIO ) init_output_stream_wrapper ( ost , NULL , 1 ) ; filtered_frame = ost -> filtered_frame ; while ( 1 ) { ret = av_buffersink_get_frame_flags ( filter , filtered_frame , AV_BUFFERSINK_FLAG_NO_REQUEST ) ; if ( ret < 0 ) { if ( ret != AVERROR ( EAGAIN ) && ret != AVERROR_EOF ) { av_log ( NULL , AV_LOG_WARNING , \"Error in av_buffersink_get_frame_flags(): %s\\n\" , av_err2str ( ret ) ) ; } else if ( flush && ret == AVERROR_EOF ) { if ( av_buffersink_get_type ( filter ) == AVMEDIA_TYPE_VIDEO ) do_video_out ( of , ost , NULL ) ; } break ; } if ( ost -> finished ) { av_frame_unref ( filtered_frame ) ; continue ; } if ( filtered_frame -> pts != AV_NOPTS_VALUE ) { AVRational tb = av_buffersink_get_time_base ( filter ) ; ost -> last_filter_pts = av_rescale_q ( filtered_frame -> pts , tb , AV_TIME_BASE_Q ) ; filtered_frame -> time_base = tb ; if ( debug_ts ) av_log ( NULL , AV_LOG_INFO , \"filter_raw -> pts:%s pts_time:%s time_base:%d/%d\\n\" , av_ts2str ( filtered_frame -> pts ) , av_ts2timestr ( filtered_frame -> pts , & tb ) , tb . num , tb . den ) ; } switch ( av_buffersink_get_type ( filter ) ) { case AVMEDIA_TYPE_VIDEO : if ( ! ost -> frame_aspect_ratio . num ) enc -> sample_aspect_ratio = filtered_frame -> sample_aspect_ratio ; do_video_out ( of , ost , filtered_frame ) ; break ; case AVMEDIA_TYPE_AUDIO : if ( ! ( enc -> codec -> capabilities & AV_CODEC_CAP_PARAM_CHANGE ) && enc -> ch_layout . nb_channels != filtered_frame -> ch_layout . nb_channels ) { av_log ( NULL , AV_LOG_ERROR , \"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\" ) ; break ; } do_audio_out ( of , ost , filtered_frame ) ; break ; default : // TODO support subtitle filters av_assert0 ( 0 ) ; } av_frame_unref ( filtered_frame ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@print_final_stats": "static void print_final_stats ( int64_t total_size ) { uint64_t video_size = 0 , audio_size = 0 , extra_size = 0 , other_size = 0 ; uint64_t subtitle_size = 0 ; uint64_t data_size = 0 ; float percent = - 1.0 ; int i , j ; int pass1_used = 1 ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { AVCodecParameters * par = ost -> st -> codecpar ; const uint64_t s = ost -> data_size_mux ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : video_size += s ; break ; case AVMEDIA_TYPE_AUDIO : audio_size += s ; break ; case AVMEDIA_TYPE_SUBTITLE : subtitle_size += s ; break ; default : other_size += s ; break ; } extra_size += par -> extradata_size ; data_size += s ; if ( ost -> enc_ctx && ( ost -> enc_ctx -> flags & ( AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2 ) ) != AV_CODEC_FLAG_PASS1 ) pass1_used = 0 ; } if ( data_size && total_size > 0 && total_size >= data_size ) percent = 100.0 * ( total_size - data_size ) / data_size ; av_log ( NULL , AV_LOG_INFO , \"video:%1.0fkB audio:%1.0fkB subtitle:%1.0fkB other streams:%1.0fkB global headers:%1.0fkB muxing overhead: \" , video_size / 1024.0 , audio_size / 1024.0 , subtitle_size / 1024.0 , other_size / 1024.0 , extra_size / 1024.0 ) ; if ( percent >= 0.0 ) av_log ( NULL , AV_LOG_INFO , \"%f%%\" , percent ) ; else av_log ( NULL , AV_LOG_INFO , \"unknown\" ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; /* print verbose per-stream stats */ for ( i = 0 ; i < nb_input_files ; i ++ ) { InputFile * f = input_files [ i ] ; uint64_t total_packets = 0 , total_size = 0 ; av_log ( NULL , AV_LOG_VERBOSE , \"Input file #%d (%s):\\n\" , i , f -> ctx -> url ) ; for ( j = 0 ; j < f -> nb_streams ; j ++ ) { InputStream * ist = f -> streams [ j ] ; enum AVMediaType type = ist -> par -> codec_type ; total_size += ist -> data_size ; total_packets += ist -> nb_packets ; av_log ( NULL , AV_LOG_VERBOSE , \"  Input stream #%d:%d (%s): \" , i , j , av_get_media_type_string ( type ) ) ; av_log ( NULL , AV_LOG_VERBOSE , \"%\" PRIu64 \" packets read (%\" PRIu64 \" bytes); \" , ist -> nb_packets , ist -> data_size ) ; if ( ist -> decoding_needed ) { av_log ( NULL , AV_LOG_VERBOSE , \"%\" PRIu64 \" frames decoded\" , ist -> frames_decoded ) ; if ( type == AVMEDIA_TYPE_AUDIO ) av_log ( NULL , AV_LOG_VERBOSE , \" (%\" PRIu64 \" samples)\" , ist -> samples_decoded ) ; av_log ( NULL , AV_LOG_VERBOSE , \"; \" ) ; } av_log ( NULL , AV_LOG_VERBOSE , \"\\n\" ) ; } av_log ( NULL , AV_LOG_VERBOSE , \"  Total: %\" PRIu64 \" packets (%\" PRIu64 \" bytes) demuxed\\n\" , total_packets , total_size ) ; } for ( i = 0 ; i < nb_output_files ; i ++ ) { OutputFile * of = output_files [ i ] ; uint64_t total_packets = 0 , total_size = 0 ; av_log ( NULL , AV_LOG_VERBOSE , \"Output file #%d (%s):\\n\" , i , of -> url ) ; for ( j = 0 ; j < of -> nb_streams ; j ++ ) { OutputStream * ost = of -> streams [ j ] ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; total_size += ost -> data_size_mux ; total_packets += atomic_load ( & ost -> packets_written ) ; av_log ( NULL , AV_LOG_VERBOSE , \"  Output stream #%d:%d (%s): \" , i , j , av_get_media_type_string ( type ) ) ; if ( ost -> enc_ctx ) { av_log ( NULL , AV_LOG_VERBOSE , \"%\" PRIu64 \" frames encoded\" , ost -> frames_encoded ) ; if ( type == AVMEDIA_TYPE_AUDIO ) av_log ( NULL , AV_LOG_VERBOSE , \" (%\" PRIu64 \" samples)\" , ost -> samples_encoded ) ; av_log ( NULL , AV_LOG_VERBOSE , \"; \" ) ; } av_log ( NULL , AV_LOG_VERBOSE , \"%\" PRIu64 \" packets muxed (%\" PRIu64 \" bytes); \" , atomic_load ( & ost -> packets_written ) , ost -> data_size_mux ) ; av_log ( NULL , AV_LOG_VERBOSE , \"\\n\" ) ; } av_log ( NULL , AV_LOG_VERBOSE , \"  Total: %\" PRIu64 \" packets (%\" PRIu64 \" bytes) muxed\\n\" , total_packets , total_size ) ; } if ( video_size + data_size + audio_size + subtitle_size + extra_size == 0 ) { av_log ( NULL , AV_LOG_WARNING , \"Output file is empty, nothing was encoded \" ) ; if ( pass1_used ) { av_log ( NULL , AV_LOG_WARNING , \"\\n\" ) ; } else { av_log ( NULL , AV_LOG_WARNING , \"(check -ss / -t / -frames parameters if used)\\n\" ) ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@forward_report": "static void forward_report ( uint64_t frame_number , float fps , float quality , int64_t total_size , int64_t pts , double bitrate , double speed ) { // FORWARD DATA if ( report_callback != NULL ) { double milliseconds = 0 ; if ( pts != AV_NOPTS_VALUE ) { milliseconds = ( ( double ) FFABS64U ( pts ) ) / 1000 ; } if ( pts < 0 ) { report_callback ( frame_number , fps , quality , total_size , 0 - milliseconds , bitrate , speed ) ; } else { report_callback ( frame_number , fps , quality , total_size , milliseconds , bitrate , speed ) ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@print_report": "static void print_report ( int is_last_report , int64_t timer_start , int64_t cur_time ) { AVBPrint buf , buf_script ; int64_t total_size = of_filesize ( output_files [ 0 ] ) ; int vid ; double bitrate ; double speed ; int64_t pts = AV_NOPTS_VALUE ; int mins , secs , us ; int64_t hours ; const char * hours_sign ; int ret ; float t ; // FFmpegKit field declarations int local_print_stats = 1 ; uint64_t frame_number = 0 ; float fps = 0 ; float q = 0 ; if ( ! print_stats && ! is_last_report && ! progress_avio ) local_print_stats = 0 ; if ( ! is_last_report ) { if ( last_time == - 1 ) { last_time = cur_time ; } if ( ( ( cur_time - last_time ) < stats_period && ! first_report ) || ( first_report && nb_output_dumped < nb_output_files ) ) return ; last_time = cur_time ; } t = ( cur_time - timer_start ) / 1000000.0 ; vid = 0 ; if ( local_print_stats ) { av_bprint_init ( & buf , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; av_bprint_init ( & buf_script , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; } for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { const AVCodecContext * const enc = ost -> enc_ctx ; q = enc ? ost -> quality / ( float ) FF_QP2LAMBDA : - 1 ; if ( local_print_stats && vid && ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { av_bprintf ( & buf , \"q=%2.1f \" , q ) ; av_bprintf ( & buf_script , \"stream_%d_%d_q=%.1f\\n\" , ost -> file_index , ost -> index , q ) ; } if ( ! vid && ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { frame_number = atomic_load ( & ost -> packets_written ) ; fps = t > 1 ? frame_number / t : 0 ; if ( local_print_stats ) { av_bprintf ( & buf , \"frame=%5\" PRId64 \" fps=%3.*f q=%3.1f \" , frame_number , fps < 9.95 , fps , q ) ; av_bprintf ( & buf_script , \"frame=%\" PRId64 \"\\n\" , frame_number ) ; av_bprintf ( & buf_script , \"fps=%.2f\\n\" , fps ) ; av_bprintf ( & buf_script , \"stream_%d_%d_q=%.1f\\n\" , ost -> file_index , ost -> index , q ) ; } if ( local_print_stats && is_last_report ) av_bprintf ( & buf , \"L\" ) ; if ( qp_hist ) { int j ; int qp = lrintf ( q ) ; if ( qp >= 0 && qp < FF_ARRAY_ELEMS ( qp_histogram ) ) qp_histogram [ qp ] ++ ; if ( local_print_stats ) { for ( j = 0 ; j < 32 ; j ++ ) av_bprintf ( & buf , \"%X\" , av_log2 ( qp_histogram [ j ] + 1 ) ) ; } } if ( local_print_stats && enc && ( enc -> flags & AV_CODEC_FLAG_PSNR ) && ( ost -> pict_type != AV_PICTURE_TYPE_NONE || is_last_report ) ) { int j ; double error , error_sum = 0 ; double scale , scale_sum = 0 ; double p ; char type [ 3 ] = { 'Y' , 'U' , 'V' } ; av_bprintf ( & buf , \"PSNR=\" ) ; for ( j = 0 ; j < 3 ; j ++ ) { if ( is_last_report ) { error = enc -> error [ j ] ; scale = enc -> width * enc -> height * 255.0 * 255.0 * frame_number ; } else { error = ost -> error [ j ] ; scale = enc -> width * enc -> height * 255.0 * 255.0 ; } if ( j ) scale /= 4 ; error_sum += error ; scale_sum += scale ; p = psnr ( error / scale ) ; av_bprintf ( & buf , \"%c:%2.2f \" , type [ j ] , p ) ; av_bprintf ( & buf_script , \"stream_%d_%d_psnr_%c=%2.2f\\n\" , ost -> file_index , ost -> index , type [ j ] | 32 , p ) ; } p = psnr ( error_sum / scale_sum ) ; av_bprintf ( & buf , \"*:%2.2f \" , psnr ( error_sum / scale_sum ) ) ; av_bprintf ( & buf_script , \"stream_%d_%d_psnr_all=%2.2f\\n\" , ost -> file_index , ost -> index , p ) ; } vid = 1 ; } /* compute min output value */ if ( ost -> last_mux_dts != AV_NOPTS_VALUE ) { if ( pts == AV_NOPTS_VALUE || ost -> last_mux_dts > pts ) pts = ost -> last_mux_dts ; if ( copy_ts ) { if ( copy_ts_first_pts == AV_NOPTS_VALUE && pts > 1 ) copy_ts_first_pts = pts ; if ( copy_ts_first_pts != AV_NOPTS_VALUE ) pts -= copy_ts_first_pts ; } } if ( is_last_report ) nb_frames_drop += ost -> last_dropped ; } us = FFABS64U ( pts ) % AV_TIME_BASE ; secs = FFABS64U ( pts ) / AV_TIME_BASE % 60 ; mins = FFABS64U ( pts ) / AV_TIME_BASE / 60 % 60 ; hours = FFABS64U ( pts ) / AV_TIME_BASE / 3600 ; hours_sign = ( pts < 0 ) ? \"-\" : \"\" ; bitrate = pts != AV_NOPTS_VALUE && pts && total_size >= 0 ? total_size * 8 / ( pts / 1000.0 ) : - 1 ; speed = pts != AV_NOPTS_VALUE && t != 0.0 ? ( double ) pts / AV_TIME_BASE / t : - 1 ; // FFmpegKit forward report forward_report ( frame_number , fps , q , total_size , pts , bitrate , speed ) ; if ( local_print_stats ) { if ( total_size < 0 ) av_bprintf ( & buf , \"size=N/A time=\" ) ; else av_bprintf ( & buf , \"size=%8.0fkB time=\" , total_size / 1024.0 ) ; if ( pts == AV_NOPTS_VALUE ) { av_bprintf ( & buf , \"N/A \" ) ; } else { av_bprintf ( & buf , \"%s%02\" PRId64 \":%02d:%02d.%02d \" , hours_sign , hours , mins , secs , ( 100 * us ) / AV_TIME_BASE ) ; } if ( bitrate < 0 ) { av_bprintf ( & buf , \"bitrate=N/A\" ) ; av_bprintf ( & buf_script , \"bitrate=N/A\\n\" ) ; } else { av_bprintf ( & buf , \"bitrate=%6.1fkbits/s\" , bitrate ) ; av_bprintf ( & buf_script , \"bitrate=%6.1fkbits/s\\n\" , bitrate ) ; } if ( total_size < 0 ) av_bprintf ( & buf_script , \"total_size=N/A\\n\" ) ; else av_bprintf ( & buf_script , \"total_size=%\" PRId64 \"\\n\" , total_size ) ; if ( pts == AV_NOPTS_VALUE ) { av_bprintf ( & buf_script , \"out_time_us=N/A\\n\" ) ; av_bprintf ( & buf_script , \"out_time_ms=N/A\\n\" ) ; av_bprintf ( & buf_script , \"out_time=N/A\\n\" ) ; } else { av_bprintf ( & buf_script , \"out_time_us=%\" PRId64 \"\\n\" , pts ) ; av_bprintf ( & buf_script , \"out_time_ms=%\" PRId64 \"\\n\" , pts ) ; av_bprintf ( & buf_script , \"out_time=%s%02\" PRId64 \":%02d:%02d.%06d\\n\" , hours_sign , hours , mins , secs , us ) ; } if ( nb_frames_dup || nb_frames_drop ) av_bprintf ( & buf , \" dup=%\" PRId64 \" drop=%\" PRId64 , nb_frames_dup , nb_frames_drop ) ; av_bprintf ( & buf_script , \"dup_frames=%\" PRId64 \"\\n\" , nb_frames_dup ) ; av_bprintf ( & buf_script , \"drop_frames=%\" PRId64 \"\\n\" , nb_frames_drop ) ; if ( speed < 0 ) { av_bprintf ( & buf , \" speed=N/A\" ) ; av_bprintf ( & buf_script , \"speed=N/A\\n\" ) ; } else { av_bprintf ( & buf , \" speed=%4.3gx\" , speed ) ; av_bprintf ( & buf_script , \"speed=%4.3gx\\n\" , speed ) ; } if ( print_stats || is_last_report ) { const char end = is_last_report ? '\\n' : '\\r' ; if ( print_stats == 1 && AV_LOG_INFO > av_log_get_level ( ) ) { av_log ( NULL , AV_LOG_STDERR , \"%s    %c\" , buf . str , end ) ; } else av_log ( NULL , AV_LOG_INFO , \"%s    %c\" , buf . str , end ) ; } av_bprint_finalize ( & buf , NULL ) ; if ( progress_avio ) { av_bprintf ( & buf_script , \"progress=%s\\n\" , is_last_report ? \"end\" : \"continue\" ) ; avio_write ( progress_avio , buf_script . str , FFMIN ( buf_script . len , buf_script . size - 1 ) ) ; avio_flush ( progress_avio ) ; av_bprint_finalize ( & buf_script , NULL ) ; if ( is_last_report ) { if ( ( ret = avio_closep ( & progress_avio ) ) < 0 ) av_log ( NULL , AV_LOG_ERROR , \"Error closing progress log, loss of information possible: %s\\n\" , av_err2str ( ret ) ) ; } } first_report = 0 ; if ( is_last_report ) print_final_stats ( total_size ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@ifilter_parameters_from_codecpar": "static int ifilter_parameters_from_codecpar ( InputFilter * ifilter , AVCodecParameters * par ) { int ret ; // We never got any input. Set a fake format, which will // come from libavformat. ifilter -> format = par -> format ; ifilter -> sample_rate = par -> sample_rate ; ifilter -> width = par -> width ; ifilter -> height = par -> height ; ifilter -> sample_aspect_ratio = par -> sample_aspect_ratio ; ret = av_channel_layout_copy ( & ifilter -> ch_layout , & par -> ch_layout ) ; if ( ret < 0 ) return ret ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@flush_encoders": "static void flush_encoders ( void ) { int ret ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { OutputFile * of = output_files [ ost -> file_index ] ; if ( ost -> sq_idx_encode >= 0 ) sq_send ( of -> sq_encode , ost -> sq_idx_encode , SQFRAME ( NULL ) ) ; } for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { AVCodecContext * enc = ost -> enc_ctx ; OutputFile * of = output_files [ ost -> file_index ] ; if ( ! enc ) continue ; // Try to enable encoding with no input frames. // Maybe we should just let encoding fail instead. if ( ! ost -> initialized ) { FilterGraph * fg = ost -> filter -> graph ; av_log ( ost , AV_LOG_WARNING , \"Finishing stream without any data written to it.\\n\" ) ; if ( ost -> filter && ! fg -> graph ) { int x ; for ( x = 0 ; x < fg -> nb_inputs ; x ++ ) { InputFilter * ifilter = fg -> inputs [ x ] ; if ( ifilter -> format < 0 && ifilter_parameters_from_codecpar ( ifilter , ifilter -> ist -> par ) < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error copying paramerets from input stream\\n\" ) ; exit_program ( 1 ) ; } } if ( ! ifilter_has_all_input_formats ( fg ) ) continue ; ret = configure_filtergraph ( fg ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error configuring filter graph\\n\" ) ; exit_program ( 1 ) ; } of_output_packet ( of , ost -> pkt , ost , 1 ) ; } init_output_stream_wrapper ( ost , NULL , 1 ) ; } if ( enc -> codec_type != AVMEDIA_TYPE_VIDEO && enc -> codec_type != AVMEDIA_TYPE_AUDIO ) continue ; ret = submit_encode_frame ( of , ost , NULL ) ; if ( ret != AVERROR_EOF ) exit_program ( 1 ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@check_output_constraints": "static int check_output_constraints ( InputStream * ist , OutputStream * ost ) { OutputFile * of = output_files [ ost -> file_index ] ; if ( ost -> ist != ist ) return 0 ; if ( ost -> finished & MUXER_FINISHED ) return 0 ; if ( of -> start_time != AV_NOPTS_VALUE && ist -> pts < of -> start_time ) return 0 ; return 1 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@do_streamcopy": "static void do_streamcopy ( InputStream * ist , OutputStream * ost , const AVPacket * pkt ) { OutputFile * of = output_files [ ost -> file_index ] ; InputFile * f = input_files [ ist -> file_index ] ; int64_t start_time = ( of -> start_time == AV_NOPTS_VALUE ) ? 0 : of -> start_time ; int64_t ost_tb_start_time = av_rescale_q ( start_time , AV_TIME_BASE_Q , ost -> mux_timebase ) ; AVPacket * opkt = ost -> pkt ; av_packet_unref ( opkt ) ; // EOF: flush output bitstream filters. if ( ! pkt ) { of_output_packet ( of , opkt , ost , 1 ) ; return ; } if ( ! ost -> streamcopy_started && ! ( pkt -> flags & AV_PKT_FLAG_KEY ) && ! ost -> copy_initial_nonkeyframes ) return ; if ( ! ost -> streamcopy_started && ! ost -> copy_prior_start ) { if ( pkt -> pts == AV_NOPTS_VALUE ? ist -> pts < ost -> ts_copy_start : pkt -> pts < av_rescale_q ( ost -> ts_copy_start , AV_TIME_BASE_Q , ist -> st -> time_base ) ) return ; } if ( of -> recording_time != INT64_MAX && ist -> pts >= of -> recording_time + start_time ) { close_output_stream ( ost ) ; return ; } if ( f -> recording_time != INT64_MAX ) { start_time = 0 ; if ( copy_ts ) { start_time += f -> start_time != AV_NOPTS_VALUE ? f -> start_time : 0 ; start_time += start_at_zero ? 0 : f -> start_time_effective ; } if ( ist -> pts >= f -> recording_time + start_time ) { close_output_stream ( ost ) ; return ; } } if ( av_packet_ref ( opkt , pkt ) < 0 ) exit_program ( 1 ) ; opkt -> time_base = ost -> mux_timebase ; if ( pkt -> pts != AV_NOPTS_VALUE ) opkt -> pts = av_rescale_q ( pkt -> pts , ist -> st -> time_base , opkt -> time_base ) - ost_tb_start_time ; if ( pkt -> dts == AV_NOPTS_VALUE ) { opkt -> dts = av_rescale_q ( ist -> dts , AV_TIME_BASE_Q , opkt -> time_base ) ; } else if ( ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { int duration = av_get_audio_frame_duration2 ( ist -> par , pkt -> size ) ; if ( ! duration ) duration = ist -> par -> frame_size ; opkt -> dts = av_rescale_delta ( ist -> st -> time_base , pkt -> dts , ( AVRational ) { 1 , ist -> par -> sample_rate } , duration , & ist -> filter_in_rescale_delta_last , opkt -> time_base ) ; /* dts will be set immediately afterwards to what pts is now */ opkt -> pts = opkt -> dts - ost_tb_start_time ; } else opkt -> dts = av_rescale_q ( pkt -> dts , ist -> st -> time_base , opkt -> time_base ) ; opkt -> dts -= ost_tb_start_time ; opkt -> duration = av_rescale_q ( pkt -> duration , ist -> st -> time_base , opkt -> time_base ) ; { int ret = trigger_fix_sub_duration_heartbeat ( ost , pkt ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Subtitle heartbeat logic failed in %s! (%s)\\n\" , __func__ , av_err2str ( ret ) ) ; exit_program ( 1 ) ; } } of_output_packet ( of , opkt , ost , 0 ) ; ost -> streamcopy_started = 1 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@check_decode_result": "static void check_decode_result ( InputStream * ist , int * got_output , int ret ) { if ( * got_output || ret < 0 ) decode_error_stat [ ret < 0 ] ++ ; if ( ret < 0 && exit_on_error ) exit_program ( 1 ) ; if ( * got_output && ist ) { if ( ist -> decoded_frame -> decode_error_flags || ( ist -> decoded_frame -> flags & AV_FRAME_FLAG_CORRUPT ) ) { av_log ( NULL , exit_on_error ? AV_LOG_FATAL : AV_LOG_WARNING , \"%s: corrupt decoded frame in stream %d\\n\" , input_files [ ist -> file_index ] -> ctx -> url , ist -> st -> index ) ; if ( exit_on_error ) exit_program ( 1 ) ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@ifilter_has_all_input_formats": "static int ifilter_has_all_input_formats ( FilterGraph * fg ) { int i ; for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) { if ( fg -> inputs [ i ] -> format < 0 && ( fg -> inputs [ i ] -> type == AVMEDIA_TYPE_AUDIO || fg -> inputs [ i ] -> type == AVMEDIA_TYPE_VIDEO ) ) return 0 ; } return 1 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@ifilter_send_frame": "static int ifilter_send_frame ( InputFilter * ifilter , AVFrame * frame , int keep_reference ) { FilterGraph * fg = ifilter -> graph ; AVFrameSideData * sd ; int need_reinit , ret ; int buffersrc_flags = AV_BUFFERSRC_FLAG_PUSH ; if ( keep_reference ) buffersrc_flags |= AV_BUFFERSRC_FLAG_KEEP_REF ; /* determine if the parameters for this input changed */ need_reinit = ifilter -> format != frame -> format ; switch ( ifilter -> ist -> par -> codec_type ) { case AVMEDIA_TYPE_AUDIO : need_reinit |= ifilter -> sample_rate != frame -> sample_rate || av_channel_layout_compare ( & ifilter -> ch_layout , & frame -> ch_layout ) ; break ; case AVMEDIA_TYPE_VIDEO : need_reinit |= ifilter -> width != frame -> width || ifilter -> height != frame -> height ; break ; } if ( ! ifilter -> ist -> reinit_filters && fg -> graph ) need_reinit = 0 ; if ( ! ! ifilter -> hw_frames_ctx != ! ! frame -> hw_frames_ctx || ( ifilter -> hw_frames_ctx && ifilter -> hw_frames_ctx -> data != frame -> hw_frames_ctx -> data ) ) need_reinit = 1 ; if ( ( sd = av_frame_get_side_data ( frame , AV_FRAME_DATA_DISPLAYMATRIX ) ) ) { if ( ! ifilter -> displaymatrix || memcmp ( sd -> data , ifilter -> displaymatrix , sizeof ( int32_t ) * 9 ) ) need_reinit = 1 ; } else if ( ifilter -> displaymatrix ) need_reinit = 1 ; if ( need_reinit ) { ret = ifilter_parameters_from_frame ( ifilter , frame ) ; if ( ret < 0 ) return ret ; } /* (re)init the graph if possible, otherwise buffer the frame and return */ if ( need_reinit || ! fg -> graph ) { if ( ! ifilter_has_all_input_formats ( fg ) ) { AVFrame * tmp = av_frame_clone ( frame ) ; if ( ! tmp ) return AVERROR ( ENOMEM ) ; ret = av_fifo_write ( ifilter -> frame_queue , & tmp , 1 ) ; if ( ret < 0 ) av_frame_free ( & tmp ) ; return ret ; } ret = reap_filters ( 1 ) ; if ( ret < 0 && ret != AVERROR_EOF ) { av_log ( NULL , AV_LOG_ERROR , \"Error while filtering: %s\\n\" , av_err2str ( ret ) ) ; return ret ; } ret = configure_filtergraph ( fg ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error reinitializing filters!\\n\" ) ; return ret ; } } ret = av_buffersrc_add_frame_flags ( ifilter -> filter , frame , buffersrc_flags ) ; if ( ret < 0 ) { if ( ret != AVERROR_EOF ) av_log ( NULL , AV_LOG_ERROR , \"Error while filtering: %s\\n\" , av_err2str ( ret ) ) ; return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@ifilter_send_eof": "static int ifilter_send_eof ( InputFilter * ifilter , int64_t pts ) { int ret = 0 ; ifilter -> eof = 1 ; if ( ifilter -> filter ) { /* THIS VALIDATION IS REQUIRED TO COMPLETE CANCELLATION */ if ( ! received_sigterm && ! cancelRequested ( globalSessionId ) ) { ret = av_buffersrc_close ( ifilter -> filter , pts , AV_BUFFERSRC_FLAG_PUSH ) ; } if ( ret < 0 ) return ret ; } else { // the filtergraph was never configured if ( ifilter -> format < 0 ) { ret = ifilter_parameters_from_codecpar ( ifilter , ifilter -> ist -> par ) ; if ( ret < 0 ) return ret ; } if ( ifilter -> format < 0 && ( ifilter -> type == AVMEDIA_TYPE_AUDIO || ifilter -> type == AVMEDIA_TYPE_VIDEO ) ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot determine format of input stream %d:%d after EOF\\n\" , ifilter -> ist -> file_index , ifilter -> ist -> st -> index ) ; return AVERROR_INVALIDDATA ; } } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@decode": "static int decode ( InputStream * ist , AVCodecContext * avctx , AVFrame * frame , int * got_frame , AVPacket * pkt ) { int ret ; * got_frame = 0 ; if ( pkt ) { ret = avcodec_send_packet ( avctx , pkt ) ; // In particular, we don't expect AVERROR(EAGAIN), because we read all // decoded frames with avcodec_receive_frame() until done. if ( ret < 0 && ret != AVERROR_EOF ) return ret ; } ret = avcodec_receive_frame ( avctx , frame ) ; if ( ret < 0 && ret != AVERROR ( EAGAIN ) ) return ret ; if ( ret >= 0 ) { if ( ist -> want_frame_data ) { FrameData * fd ; av_assert0 ( ! frame -> opaque_ref ) ; frame -> opaque_ref = av_buffer_allocz ( sizeof ( * fd ) ) ; if ( ! frame -> opaque_ref ) { av_frame_unref ( frame ) ; return AVERROR ( ENOMEM ) ; } fd = ( FrameData * ) frame -> opaque_ref -> data ; fd -> pts = frame -> pts ; fd -> tb = avctx -> pkt_timebase ; fd -> idx = avctx -> frame_num - 1 ; } * got_frame = 1 ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@send_frame_to_filters": "static int send_frame_to_filters ( InputStream * ist , AVFrame * decoded_frame ) { int i , ret ; av_assert1 ( ist -> nb_filters > 0 ) ; /* ensure ret is initialized */ for ( i = 0 ; i < ist -> nb_filters ; i ++ ) { ret = ifilter_send_frame ( ist -> filters [ i ] , decoded_frame , i < ist -> nb_filters - 1 ) ; if ( ret == AVERROR_EOF ) ret = 0 ; /* ignore */ if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Failed to inject frame into filter network: %s\\n\" , av_err2str ( ret ) ) ; break ; } } return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@decode_audio": "static int decode_audio ( InputStream * ist , AVPacket * pkt , int * got_output , int * decode_failed ) { AVFrame * decoded_frame = ist -> decoded_frame ; AVCodecContext * avctx = ist -> dec_ctx ; int ret , err = 0 ; AVRational decoded_frame_tb ; update_benchmark ( NULL ) ; ret = decode ( ist , avctx , decoded_frame , got_output , pkt ) ; update_benchmark ( \"decode_audio %d.%d\" , ist -> file_index , ist -> st -> index ) ; if ( ret < 0 ) * decode_failed = 1 ; if ( ret != AVERROR_EOF ) check_decode_result ( ist , got_output , ret ) ; if ( ! * got_output || ret < 0 ) return ret ; ist -> samples_decoded += decoded_frame -> nb_samples ; ist -> frames_decoded ++ ; /* increment next_dts to use for the case where the input stream does not\n       have timestamps or there are multiple frames in the packet */ ist -> next_pts += ( ( int64_t ) AV_TIME_BASE * decoded_frame -> nb_samples ) / decoded_frame -> sample_rate ; ist -> next_dts += ( ( int64_t ) AV_TIME_BASE * decoded_frame -> nb_samples ) / decoded_frame -> sample_rate ; if ( decoded_frame -> pts != AV_NOPTS_VALUE ) { decoded_frame_tb = ist -> st -> time_base ; } else if ( pkt && pkt -> pts != AV_NOPTS_VALUE ) { decoded_frame -> pts = pkt -> pts ; decoded_frame_tb = ist -> st -> time_base ; } else { decoded_frame -> pts = ist -> dts ; decoded_frame_tb = AV_TIME_BASE_Q ; } if ( pkt && pkt -> duration && ist -> prev_pkt_pts != AV_NOPTS_VALUE && pkt -> pts != AV_NOPTS_VALUE && pkt -> pts - ist -> prev_pkt_pts > pkt -> duration ) ist -> filter_in_rescale_delta_last = AV_NOPTS_VALUE ; if ( pkt ) ist -> prev_pkt_pts = pkt -> pts ; if ( decoded_frame -> pts != AV_NOPTS_VALUE ) decoded_frame -> pts = av_rescale_delta ( decoded_frame_tb , decoded_frame -> pts , ( AVRational ) { 1 , decoded_frame -> sample_rate } , decoded_frame -> nb_samples , & ist -> filter_in_rescale_delta_last , ( AVRational ) { 1 , decoded_frame -> sample_rate } ) ; ist -> nb_samples = decoded_frame -> nb_samples ; err = send_frame_to_filters ( ist , decoded_frame ) ; av_frame_unref ( decoded_frame ) ; return err < 0 ? err : ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@decode_video": "static int decode_video ( InputStream * ist , AVPacket * pkt , int * got_output , int64_t * duration_pts , int eof , int * decode_failed ) { AVFrame * decoded_frame = ist -> decoded_frame ; int i , ret = 0 , err = 0 ; int64_t best_effort_timestamp ; int64_t dts = AV_NOPTS_VALUE ; // With fate-indeo3-2, we're getting 0-sized packets before EOF for some // reason. This seems like a semi-critical bug. Don't trigger EOF, and // skip the packet. if ( ! eof && pkt && pkt -> size == 0 ) return 0 ; if ( ist -> dts != AV_NOPTS_VALUE ) dts = av_rescale_q ( ist -> dts , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt ) { pkt -> dts = dts ; // ffmpeg.c probably shouldn't do this } // The old code used to set dts on the drain packet, which does not work // with the new API anymore. if ( eof ) { void * new = av_realloc_array ( ist -> dts_buffer , ist -> nb_dts_buffer + 1 , sizeof ( ist -> dts_buffer [ 0 ] ) ) ; if ( ! new ) return AVERROR ( ENOMEM ) ; ist -> dts_buffer = new ; ist -> dts_buffer [ ist -> nb_dts_buffer ++ ] = dts ; } update_benchmark ( NULL ) ; ret = decode ( ist , ist -> dec_ctx , decoded_frame , got_output , pkt ) ; update_benchmark ( \"decode_video %d.%d\" , ist -> file_index , ist -> st -> index ) ; if ( ret < 0 ) * decode_failed = 1 ; // The following line may be required in some cases where there is no parser // or the parser does not has_b_frames correctly if ( ist -> par -> video_delay < ist -> dec_ctx -> has_b_frames ) { if ( ist -> dec_ctx -> codec_id == AV_CODEC_ID_H264 ) { ist -> par -> video_delay = ist -> dec_ctx -> has_b_frames ; } else av_log ( ist -> dec_ctx , AV_LOG_WARNING , \"video_delay is larger in decoder than demuxer %d > %d.\\n\" \"If you want to help, upload a sample \" \"of this file to https://streams.videolan.org/upload/ \" \"and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)\\n\" , ist -> dec_ctx -> has_b_frames , ist -> par -> video_delay ) ; } if ( ret != AVERROR_EOF ) check_decode_result ( ist , got_output , ret ) ; if ( * got_output && ret >= 0 ) { if ( ist -> dec_ctx -> width != decoded_frame -> width || ist -> dec_ctx -> height != decoded_frame -> height || ist -> dec_ctx -> pix_fmt != decoded_frame -> format ) { av_log ( NULL , AV_LOG_DEBUG , \"Frame parameters mismatch context %d,%d,%d != %d,%d,%d\\n\" , decoded_frame -> width , decoded_frame -> height , decoded_frame -> format , ist -> dec_ctx -> width , ist -> dec_ctx -> height , ist -> dec_ctx -> pix_fmt ) ; } } if ( ! * got_output || ret < 0 ) return ret ; if ( ist -> top_field_first >= 0 ) decoded_frame -> top_field_first = ist -> top_field_first ; ist -> frames_decoded ++ ; if ( ist -> hwaccel_retrieve_data && decoded_frame -> format == ist -> hwaccel_pix_fmt ) { err = ist -> hwaccel_retrieve_data ( ist -> dec_ctx , decoded_frame ) ; if ( err < 0 ) goto fail ; } best_effort_timestamp = decoded_frame -> best_effort_timestamp ; * duration_pts = decoded_frame -> duration ; if ( ist -> framerate . num ) best_effort_timestamp = ist -> cfr_next_pts ++ ; if ( eof && best_effort_timestamp == AV_NOPTS_VALUE && ist -> nb_dts_buffer > 0 ) { best_effort_timestamp = ist -> dts_buffer [ 0 ] ; for ( i = 0 ; i < ist -> nb_dts_buffer - 1 ; i ++ ) ist -> dts_buffer [ i ] = ist -> dts_buffer [ i + 1 ] ; ist -> nb_dts_buffer -- ; } if ( best_effort_timestamp != AV_NOPTS_VALUE ) { int64_t ts = av_rescale_q ( decoded_frame -> pts = best_effort_timestamp , ist -> st -> time_base , AV_TIME_BASE_Q ) ; if ( ts != AV_NOPTS_VALUE ) ist -> next_pts = ist -> pts = ts ; } if ( debug_ts ) { av_log ( NULL , AV_LOG_INFO , \"decoder -> ist_index:%d type:video \" \"frame_pts:%s frame_pts_time:%s best_effort_ts:%\" PRId64 \" best_effort_ts_time:%s keyframe:%d frame_type:%d time_base:%d/%d\\n\" , ist -> st -> index , av_ts2str ( decoded_frame -> pts ) , av_ts2timestr ( decoded_frame -> pts , & ist -> st -> time_base ) , best_effort_timestamp , av_ts2timestr ( best_effort_timestamp , & ist -> st -> time_base ) , decoded_frame -> key_frame , decoded_frame -> pict_type , ist -> st -> time_base . num , ist -> st -> time_base . den ) ; } if ( ist -> st -> sample_aspect_ratio . num ) decoded_frame -> sample_aspect_ratio = ist -> st -> sample_aspect_ratio ; err = send_frame_to_filters ( ist , decoded_frame ) ; fail : av_frame_unref ( decoded_frame ) ; return err < 0 ? err : ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@process_subtitle": "static int process_subtitle ( InputStream * ist , AVSubtitle * subtitle , int * got_output ) { int ret = 0 ; int free_sub = 1 ; if ( ist -> fix_sub_duration ) { int end = 1 ; if ( ist -> prev_sub . got_output ) { end = av_rescale ( subtitle -> pts - ist -> prev_sub . subtitle . pts , 1000 , AV_TIME_BASE ) ; if ( end < ist -> prev_sub . subtitle . end_display_time ) { av_log ( NULL , AV_LOG_DEBUG , \"Subtitle duration reduced from %\" PRId32 \" to %d%s\\n\" , ist -> prev_sub . subtitle . end_display_time , end , end <= 0 ? \", dropping it\" : \"\" ) ; ist -> prev_sub . subtitle . end_display_time = end ; } } FFSWAP ( int , * got_output , ist -> prev_sub . got_output ) ; FFSWAP ( int , ret , ist -> prev_sub . ret ) ; FFSWAP ( AVSubtitle , * subtitle , ist -> prev_sub . subtitle ) ; if ( end <= 0 ) goto out ; } if ( ! * got_output ) return ret ; if ( ist -> sub2video . frame ) { sub2video_update ( ist , INT64_MIN , subtitle ) ; } else if ( ist -> nb_filters ) { if ( ! ist -> sub2video . sub_queue ) ist -> sub2video . sub_queue = av_fifo_alloc2 ( 8 , sizeof ( AVSubtitle ) , AV_FIFO_FLAG_AUTO_GROW ) ; if ( ! ist -> sub2video . sub_queue ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ret = av_fifo_write ( ist -> sub2video . sub_queue , subtitle , 1 ) ; if ( ret < 0 ) exit_program ( 1 ) ; free_sub = 0 ; } if ( ! subtitle -> num_rects ) goto out ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ! check_output_constraints ( ist , ost ) || ! ost -> enc_ctx || ost -> enc_ctx -> codec_type != AVMEDIA_TYPE_SUBTITLE ) continue ; do_subtitle_out ( output_files [ ost -> file_index ] , ost , subtitle ) ; } out : if ( free_sub ) avsubtitle_free ( subtitle ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@copy_av_subtitle": "static int copy_av_subtitle ( AVSubtitle * dst , AVSubtitle * src ) { int ret = AVERROR_BUG ; AVSubtitle tmp = { . format = src -> format , . start_display_time = src -> start_display_time , . end_display_time = src -> end_display_time , . num_rects = 0 , . rects = NULL , . pts = src -> pts } ; if ( ! src -> num_rects ) goto success ; if ( ! ( tmp . rects = av_calloc ( src -> num_rects , sizeof ( * tmp . rects ) ) ) ) return AVERROR ( ENOMEM ) ; for ( int i = 0 ; i < src -> num_rects ; i ++ ) { AVSubtitleRect * src_rect = src -> rects [ i ] ; AVSubtitleRect * dst_rect ; if ( ! ( dst_rect = tmp . rects [ i ] = av_mallocz ( sizeof ( * tmp . rects [ 0 ] ) ) ) ) { ret = AVERROR ( ENOMEM ) ; goto cleanup ; } tmp . num_rects ++ ; dst_rect -> type = src_rect -> type ; dst_rect -> flags = src_rect -> flags ; dst_rect -> x = src_rect -> x ; dst_rect -> y = src_rect -> y ; dst_rect -> w = src_rect -> w ; dst_rect -> h = src_rect -> h ; dst_rect -> nb_colors = src_rect -> nb_colors ; if ( src_rect -> text ) if ( ! ( dst_rect -> text = av_strdup ( src_rect -> text ) ) ) { ret = AVERROR ( ENOMEM ) ; goto cleanup ; } if ( src_rect -> ass ) if ( ! ( dst_rect -> ass = av_strdup ( src_rect -> ass ) ) ) { ret = AVERROR ( ENOMEM ) ; goto cleanup ; } for ( int j = 0 ; j < 4 ; j ++ ) { // SUBTITLE_BITMAP images are special in the sense that they // are like PAL8 images. first pointer to data, second to // palette. This makes the size calculation match this. size_t buf_size = src_rect -> type == SUBTITLE_BITMAP && j == 1 ? AVPALETTE_SIZE : src_rect -> h * src_rect -> linesize [ j ] ; if ( ! src_rect -> data [ j ] ) continue ; if ( ! ( dst_rect -> data [ j ] = av_memdup ( src_rect -> data [ j ] , buf_size ) ) ) { ret = AVERROR ( ENOMEM ) ; goto cleanup ; } dst_rect -> linesize [ j ] = src_rect -> linesize [ j ] ; } } success : * dst = tmp ; return 0 ; cleanup : avsubtitle_free ( & tmp ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@fix_sub_duration_heartbeat": "static int fix_sub_duration_heartbeat ( InputStream * ist , int64_t signal_pts ) { int ret = AVERROR_BUG ; int got_output = 1 ; AVSubtitle * prev_subtitle = & ist -> prev_sub . subtitle ; AVSubtitle subtitle ; if ( ! ist -> fix_sub_duration || ! prev_subtitle -> num_rects || signal_pts <= prev_subtitle -> pts ) return 0 ; if ( ( ret = copy_av_subtitle ( & subtitle , prev_subtitle ) ) < 0 ) return ret ; subtitle . pts = signal_pts ; return process_subtitle ( ist , & subtitle , & got_output ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@trigger_fix_sub_duration_heartbeat": "static int trigger_fix_sub_duration_heartbeat ( OutputStream * ost , const AVPacket * pkt ) { OutputFile * of = output_files [ ost -> file_index ] ; int64_t signal_pts = av_rescale_q ( pkt -> pts , pkt -> time_base , AV_TIME_BASE_Q ) ; if ( ! ost -> fix_sub_duration_heartbeat || ! ( pkt -> flags & AV_PKT_FLAG_KEY ) ) // we are only interested in heartbeats on streams configured, and // only on random access points. return 0 ; for ( int i = 0 ; i < of -> nb_streams ; i ++ ) { OutputStream * iter_ost = of -> streams [ i ] ; InputStream * ist = iter_ost -> ist ; int ret = AVERROR_BUG ; if ( iter_ost == ost || ! ist || ! ist -> decoding_needed || ist -> dec_ctx -> codec_type != AVMEDIA_TYPE_SUBTITLE ) // We wish to skip the stream that causes the heartbeat, // output streams without an input stream, streams not decoded // (as fix_sub_duration is only done for decoded subtitles) as // well as non-subtitle streams. continue ; if ( ( ret = fix_sub_duration_heartbeat ( ist , signal_pts ) ) < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@transcode_subtitles": "static int transcode_subtitles ( InputStream * ist , const AVPacket * pkt , int * got_output , int * decode_failed ) { AVSubtitle subtitle ; int ret = avcodec_decode_subtitle2 ( ist -> dec_ctx , & subtitle , got_output , pkt ) ; check_decode_result ( NULL , got_output , ret ) ; if ( ret < 0 || ! * got_output ) { * decode_failed = 1 ; if ( ! pkt -> size ) sub2video_flush ( ist ) ; return ret ; } ist -> frames_decoded ++ ; return process_subtitle ( ist , & subtitle , got_output ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@send_filter_eof": "static int send_filter_eof ( InputStream * ist ) { int i , ret ; /* TODO keep pts also in stream time base to avoid converting back */ int64_t pts = av_rescale_q_rnd ( ist -> pts , AV_TIME_BASE_Q , ist -> st -> time_base , AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX ) ; for ( i = 0 ; i < ist -> nb_filters ; i ++ ) { ret = ifilter_send_eof ( ist -> filters [ i ] , pts ) ; if ( ret < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@process_input_packet": "static int process_input_packet ( InputStream * ist , const AVPacket * pkt , int no_eof ) { const AVCodecParameters * par = ist -> par ; int ret = 0 ; int repeating = 0 ; int eof_reached = 0 ; AVPacket * avpkt = ist -> pkt ; if ( ! ist -> saw_first_ts ) { ist -> first_dts = ist -> dts = ist -> st -> avg_frame_rate . num ? - ist -> dec_ctx -> has_b_frames * AV_TIME_BASE / av_q2d ( ist -> st -> avg_frame_rate ) : 0 ; ist -> pts = 0 ; if ( pkt && pkt -> pts != AV_NOPTS_VALUE && ! ist -> decoding_needed ) { ist -> first_dts = ist -> dts += av_rescale_q ( pkt -> pts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; ist -> pts = ist -> dts ; //unused but better to set it to a value thats not totally wrong } ist -> saw_first_ts = 1 ; } if ( ist -> next_dts == AV_NOPTS_VALUE ) ist -> next_dts = ist -> dts ; if ( ist -> next_pts == AV_NOPTS_VALUE ) ist -> next_pts = ist -> pts ; if ( pkt ) { av_packet_unref ( avpkt ) ; ret = av_packet_ref ( avpkt , pkt ) ; if ( ret < 0 ) return ret ; } if ( pkt && pkt -> dts != AV_NOPTS_VALUE ) { ist -> next_dts = ist -> dts = av_rescale_q ( pkt -> dts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; if ( par -> codec_type != AVMEDIA_TYPE_VIDEO || ! ist -> decoding_needed ) ist -> next_pts = ist -> pts = ist -> dts ; } // while we have more to decode or while the decoder did output something on EOF while ( ist -> decoding_needed ) { int64_t duration_dts = 0 ; int64_t duration_pts = 0 ; int got_output = 0 ; int decode_failed = 0 ; ist -> pts = ist -> next_pts ; ist -> dts = ist -> next_dts ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_AUDIO : ret = decode_audio ( ist , repeating ? NULL : avpkt , & got_output , & decode_failed ) ; av_packet_unref ( avpkt ) ; break ; case AVMEDIA_TYPE_VIDEO : ret = decode_video ( ist , repeating ? NULL : avpkt , & got_output , & duration_pts , ! pkt , & decode_failed ) ; if ( ! repeating || ! pkt || got_output ) { if ( pkt && pkt -> duration ) { duration_dts = av_rescale_q ( pkt -> duration , ist -> st -> time_base , AV_TIME_BASE_Q ) ; } else if ( ist -> dec_ctx -> framerate . num != 0 && ist -> dec_ctx -> framerate . den != 0 ) { int ticks = ist -> last_pkt_repeat_pict >= 0 ? ist -> last_pkt_repeat_pict + 1 : ist -> dec_ctx -> ticks_per_frame ; duration_dts = ( ( int64_t ) AV_TIME_BASE * ist -> dec_ctx -> framerate . den * ticks ) / ist -> dec_ctx -> framerate . num / ist -> dec_ctx -> ticks_per_frame ; } if ( ist -> dts != AV_NOPTS_VALUE && duration_dts ) { ist -> next_dts += duration_dts ; } else ist -> next_dts = AV_NOPTS_VALUE ; } if ( got_output ) { if ( duration_pts > 0 ) { ist -> next_pts += av_rescale_q ( duration_pts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; } else { ist -> next_pts += duration_dts ; } } av_packet_unref ( avpkt ) ; break ; case AVMEDIA_TYPE_SUBTITLE : if ( repeating ) break ; ret = transcode_subtitles ( ist , avpkt , & got_output , & decode_failed ) ; if ( ! pkt && ret >= 0 ) ret = AVERROR_EOF ; av_packet_unref ( avpkt ) ; break ; default : return - 1 ; } if ( ret == AVERROR_EOF ) { eof_reached = 1 ; break ; } if ( ret < 0 ) { if ( decode_failed ) { av_log ( NULL , AV_LOG_ERROR , \"Error while decoding stream #%d:%d: %s\\n\" , ist -> file_index , ist -> st -> index , av_err2str ( ret ) ) ; } else { av_log ( NULL , AV_LOG_FATAL , \"Error while processing the decoded \" \"data for stream #%d:%d\\n\" , ist -> file_index , ist -> st -> index ) ; } if ( ! decode_failed || exit_on_error ) exit_program ( 1 ) ; break ; } if ( got_output ) ist -> got_output = 1 ; if ( ! got_output ) break ; // During draining, we might get multiple output frames in this loop. // ffmpeg.c does not drain the filter chain on configuration changes, // which means if we send multiple frames at once to the filters, and // one of those frames changes configuration, the buffered frames will // be lost. This can upset certain FATE tests. // Decode only 1 frame per call on EOF to appease these FATE tests. // The ideal solution would be to rewrite decoding to use the new // decoding API in a better way. if ( ! pkt ) break ; repeating = 1 ; } /* after flushing, send an EOF on all the filter inputs attached to the stream */ /* except when looping we need to flush but not to send an EOF */ if ( ! pkt && ist -> decoding_needed && eof_reached && ! no_eof ) { int ret = send_filter_eof ( ist ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_FATAL , \"Error marking filters as finished\\n\" ) ; exit_program ( 1 ) ; } } /* handle stream copy */ if ( ! ist -> decoding_needed && pkt ) { ist -> dts = ist -> next_dts ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_AUDIO : av_assert1 ( pkt -> duration >= 0 ) ; if ( par -> sample_rate ) { ist -> next_dts += ( ( int64_t ) AV_TIME_BASE * par -> frame_size ) / par -> sample_rate ; } else { ist -> next_dts += av_rescale_q ( pkt -> duration , ist -> st -> time_base , AV_TIME_BASE_Q ) ; } break ; case AVMEDIA_TYPE_VIDEO : if ( ist -> framerate . num ) { // TODO: Remove work-around for c99-to-c89 issue 7 AVRational time_base_q = AV_TIME_BASE_Q ; int64_t next_dts = av_rescale_q ( ist -> next_dts , time_base_q , av_inv_q ( ist -> framerate ) ) ; ist -> next_dts = av_rescale_q ( next_dts + 1 , av_inv_q ( ist -> framerate ) , time_base_q ) ; } else if ( pkt -> duration ) { ist -> next_dts += av_rescale_q ( pkt -> duration , ist -> st -> time_base , AV_TIME_BASE_Q ) ; } else if ( ist -> dec_ctx -> framerate . num != 0 ) { int ticks = ist -> last_pkt_repeat_pict >= 0 ? ist -> last_pkt_repeat_pict + 1 : ist -> dec_ctx -> ticks_per_frame ; ist -> next_dts += ( ( int64_t ) AV_TIME_BASE * ist -> dec_ctx -> framerate . den * ticks ) / ist -> dec_ctx -> framerate . num / ist -> dec_ctx -> ticks_per_frame ; } break ; } ist -> pts = ist -> dts ; ist -> next_pts = ist -> next_dts ; } else if ( ! ist -> decoding_needed ) eof_reached = 1 ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ! check_output_constraints ( ist , ost ) || ost -> enc_ctx || ( ! pkt && no_eof ) ) continue ; do_streamcopy ( ist , ost , pkt ) ; } return ! eof_reached ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@get_format": "static enum AVPixelFormat get_format ( AVCodecContext * s , const enum AVPixelFormat * pix_fmts ) { InputStream * ist = s -> opaque ; const enum AVPixelFormat * p ; int ret ; for ( p = pix_fmts ; * p != AV_PIX_FMT_NONE ; p ++ ) { const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( * p ) ; const AVCodecHWConfig * config = NULL ; int i ; if ( ! ( desc -> flags & AV_PIX_FMT_FLAG_HWACCEL ) ) break ; if ( ist -> hwaccel_id == HWACCEL_GENERIC || ist -> hwaccel_id == HWACCEL_AUTO ) { for ( i = 0 ; ; i ++ ) { config = avcodec_get_hw_config ( s -> codec , i ) ; if ( ! config ) break ; if ( ! ( config -> methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX ) ) continue ; if ( config -> pix_fmt == * p ) break ; } } if ( config && config -> device_type == ist -> hwaccel_device_type ) { ret = hwaccel_decode_init ( s ) ; if ( ret < 0 ) { if ( ist -> hwaccel_id == HWACCEL_GENERIC ) { av_log ( NULL , AV_LOG_FATAL , \"%s hwaccel requested for input stream #%d:%d, \" \"but cannot be initialized.\\n\" , av_hwdevice_get_type_name ( config -> device_type ) , ist -> file_index , ist -> st -> index ) ; return AV_PIX_FMT_NONE ; } continue ; } ist -> hwaccel_pix_fmt = * p ; break ; } } return * p ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@init_input_stream": "static int init_input_stream ( InputStream * ist , char * error , int error_len ) { int ret ; if ( ist -> decoding_needed ) { const AVCodec * codec = ist -> dec ; if ( ! codec ) { snprintf ( error , error_len , \"Decoder (codec %s) not found for input stream #%d:%d\" , avcodec_get_name ( ist -> dec_ctx -> codec_id ) , ist -> file_index , ist -> st -> index ) ; return AVERROR ( EINVAL ) ; } ist -> dec_ctx -> opaque = ist ; ist -> dec_ctx -> get_format = get_format ; if ( ist -> dec_ctx -> codec_id == AV_CODEC_ID_DVB_SUBTITLE && ( ist -> decoding_needed & DECODING_FOR_OST ) ) { av_dict_set ( & ist -> decoder_opts , \"compute_edt\" , \"1\" , AV_DICT_DONT_OVERWRITE ) ; if ( ist -> decoding_needed & DECODING_FOR_FILTER ) av_log ( NULL , AV_LOG_WARNING , \"Warning using DVB subtitles for filtering and output at the same time is not fully supported, also see -compute_edt [0|1]\\n\" ) ; } /* Useful for subtitles retiming by lavf (FIXME), skipping samples in\n         * audio, and video decoders such as cuvid or mediacodec */ ist -> dec_ctx -> pkt_timebase = ist -> st -> time_base ; if ( ! av_dict_get ( ist -> decoder_opts , \"threads\" , NULL , 0 ) ) av_dict_set ( & ist -> decoder_opts , \"threads\" , \"auto\" , 0 ) ; /* Attached pics are sparse, therefore we would not want to delay their decoding till EOF. */ if ( ist -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) av_dict_set ( & ist -> decoder_opts , \"threads\" , \"1\" , 0 ) ; ret = hw_device_setup_for_decode ( ist ) ; if ( ret < 0 ) { snprintf ( error , error_len , \"Device setup failed for \" \"decoder on input stream #%d:%d : %s\" , ist -> file_index , ist -> st -> index , av_err2str ( ret ) ) ; return ret ; } if ( ( ret = avcodec_open2 ( ist -> dec_ctx , codec , & ist -> decoder_opts ) ) < 0 ) { if ( ret == AVERROR_EXPERIMENTAL ) abort_codec_experimental ( codec , 0 ) ; snprintf ( error , error_len , \"Error while opening decoder for input stream \" \"#%d:%d : %s\" , ist -> file_index , ist -> st -> index , av_err2str ( ret ) ) ; return ret ; } assert_avoptions ( ist -> decoder_opts ) ; } ist -> next_pts = AV_NOPTS_VALUE ; ist -> next_dts = AV_NOPTS_VALUE ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@init_output_stream_streamcopy": "static int init_output_stream_streamcopy ( OutputStream * ost ) { OutputFile * of = output_files [ ost -> file_index ] ; InputStream * ist = ost -> ist ; InputFile * ifile = input_files [ ist -> file_index ] ; AVCodecParameters * par = ost -> st -> codecpar ; AVCodecContext * codec_ctx ; AVRational sar ; int i , ret ; uint32_t codec_tag = par -> codec_tag ; av_assert0 ( ist && ! ost -> filter ) ; codec_ctx = avcodec_alloc_context3 ( NULL ) ; if ( ! codec_ctx ) return AVERROR ( ENOMEM ) ; ret = avcodec_parameters_to_context ( codec_ctx , ist -> par ) ; if ( ret >= 0 ) ret = av_opt_set_dict ( codec_ctx , & ost -> encoder_opts ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Error setting up codec context options.\\n\" ) ; avcodec_free_context ( & codec_ctx ) ; return ret ; } ret = avcodec_parameters_from_context ( par , codec_ctx ) ; avcodec_free_context ( & codec_ctx ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Error getting reference codec parameters.\\n\" ) ; return ret ; } if ( ! codec_tag ) { unsigned int codec_tag_tmp ; if ( ! of -> format -> codec_tag || av_codec_get_id ( of -> format -> codec_tag , par -> codec_tag ) == par -> codec_id || ! av_codec_get_tag2 ( of -> format -> codec_tag , par -> codec_id , & codec_tag_tmp ) ) codec_tag = par -> codec_tag ; } par -> codec_tag = codec_tag ; if ( ! ost -> frame_rate . num ) ost -> frame_rate = ist -> framerate ; if ( ost -> frame_rate . num ) ost -> st -> avg_frame_rate = ost -> frame_rate ; else ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate ; ret = avformat_transfer_internal_stream_timing_info ( of -> format , ost -> st , ist -> st , copy_tb ) ; if ( ret < 0 ) return ret ; // copy timebase while removing common factors if ( ost -> st -> time_base . num <= 0 || ost -> st -> time_base . den <= 0 ) { if ( ost -> frame_rate . num ) ost -> st -> time_base = av_inv_q ( ost -> frame_rate ) ; else ost -> st -> time_base = av_add_q ( av_stream_get_codec_timebase ( ost -> st ) , ( AVRational ) { 0 , 1 } ) ; } // copy estimated duration as a hint to the muxer if ( ost -> st -> duration <= 0 && ist -> st -> duration > 0 ) ost -> st -> duration = av_rescale_q ( ist -> st -> duration , ist -> st -> time_base , ost -> st -> time_base ) ; if ( ! ost -> copy_prior_start ) { ost -> ts_copy_start = ( of -> start_time == AV_NOPTS_VALUE ) ? 0 : of -> start_time ; if ( copy_ts && ifile -> start_time != AV_NOPTS_VALUE ) { ost -> ts_copy_start = FFMAX ( ost -> ts_copy_start , ifile -> start_time + ifile -> ts_offset ) ; } } if ( ist -> st -> nb_side_data ) { for ( i = 0 ; i < ist -> st -> nb_side_data ; i ++ ) { const AVPacketSideData * sd_src = & ist -> st -> side_data [ i ] ; uint8_t * dst_data ; dst_data = av_stream_new_side_data ( ost -> st , sd_src -> type , sd_src -> size ) ; if ( ! dst_data ) return AVERROR ( ENOMEM ) ; memcpy ( dst_data , sd_src -> data , sd_src -> size ) ; } } # if FFMPEG_ROTATION_METADATA if ( ost -> rotate_overridden ) { uint8_t * sd = av_stream_new_side_data ( ost -> st , AV_PKT_DATA_DISPLAYMATRIX , sizeof ( int32_t ) * 9 ) ; if ( sd ) av_display_rotation_set ( ( int32_t * ) sd , - ost -> rotate_override_value ) ; } # endif switch ( par -> codec_type ) { case AVMEDIA_TYPE_AUDIO : if ( ( par -> block_align == 1 || par -> block_align == 1152 || par -> block_align == 576 ) && par -> codec_id == AV_CODEC_ID_MP3 ) par -> block_align = 0 ; if ( par -> codec_id == AV_CODEC_ID_AC3 ) par -> block_align = 0 ; break ; case AVMEDIA_TYPE_VIDEO : if ( ost -> frame_aspect_ratio . num ) { // overridden by the -aspect cli option sar = av_mul_q ( ost -> frame_aspect_ratio , ( AVRational ) { par -> height , par -> width } ) ; av_log ( ost , AV_LOG_WARNING , \"Overriding aspect ratio \" \"with stream copy may produce invalid files\\n\" ) ; } else if ( ist -> st -> sample_aspect_ratio . num ) sar = ist -> st -> sample_aspect_ratio ; else sar = par -> sample_aspect_ratio ; ost -> st -> sample_aspect_ratio = par -> sample_aspect_ratio = sar ; ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate ; ost -> st -> r_frame_rate = ist -> st -> r_frame_rate ; break ; } ost -> mux_timebase = ist -> st -> time_base ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@set_encoder_id": "static void set_encoder_id ( OutputFile * of , OutputStream * ost ) { const char * cname = ost -> enc_ctx -> codec -> name ; uint8_t * encoder_string ; int encoder_string_len ; if ( av_dict_get ( ost -> st -> metadata , \"encoder\" , NULL , 0 ) ) return ; encoder_string_len = sizeof ( LIBAVCODEC_IDENT ) + strlen ( cname ) + 2 ; encoder_string = av_mallocz ( encoder_string_len ) ; if ( ! encoder_string ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( ! of -> bitexact && ! ost -> bitexact ) av_strlcpy ( encoder_string , LIBAVCODEC_IDENT \" \" , encoder_string_len ) ; else av_strlcpy ( encoder_string , \"Lavc \" , encoder_string_len ) ; av_strlcat ( encoder_string , cname , encoder_string_len ) ; av_dict_set ( & ost -> st -> metadata , \"encoder\" , encoder_string , AV_DICT_DONT_STRDUP_VAL | AV_DICT_DONT_OVERWRITE ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@init_encoder_time_base": "static void init_encoder_time_base ( OutputStream * ost , AVRational default_time_base ) { InputStream * ist = ost -> ist ; AVCodecContext * enc_ctx = ost -> enc_ctx ; if ( ost -> enc_timebase . num > 0 ) { enc_ctx -> time_base = ost -> enc_timebase ; return ; } if ( ost -> enc_timebase . num < 0 ) { if ( ist ) { enc_ctx -> time_base = ist -> st -> time_base ; return ; } av_log ( ost , AV_LOG_WARNING , \"Input stream data not available, using default time base\\n\" ) ; } enc_ctx -> time_base = default_time_base ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@init_output_stream_encode": "static int init_output_stream_encode ( OutputStream * ost , AVFrame * frame ) { InputStream * ist = ost -> ist ; AVCodecContext * enc_ctx = ost -> enc_ctx ; AVCodecContext * dec_ctx = NULL ; OutputFile * of = output_files [ ost -> file_index ] ; int ret ; set_encoder_id ( output_files [ ost -> file_index ] , ost ) ; if ( ist ) { dec_ctx = ist -> dec_ctx ; } if ( enc_ctx -> codec_type == AVMEDIA_TYPE_VIDEO ) { if ( ! ost -> frame_rate . num ) ost -> frame_rate = av_buffersink_get_frame_rate ( ost -> filter -> filter ) ; if ( ! ost -> frame_rate . num && ! ost -> max_frame_rate . num ) { ost -> frame_rate = ( AVRational ) { 25 , 1 } ; av_log ( ost , AV_LOG_WARNING , \"No information \" \"about the input framerate is available. Falling \" \"back to a default value of 25fps. Use the -r option \" \"if you want a different framerate.\\n\" ) ; } if ( ost -> max_frame_rate . num && ( av_q2d ( ost -> frame_rate ) > av_q2d ( ost -> max_frame_rate ) || ! ost -> frame_rate . den ) ) ost -> frame_rate = ost -> max_frame_rate ; if ( enc_ctx -> codec -> supported_framerates && ! ost -> force_fps ) { int idx = av_find_nearest_q_idx ( ost -> frame_rate , enc_ctx -> codec -> supported_framerates ) ; ost -> frame_rate = enc_ctx -> codec -> supported_framerates [ idx ] ; } // reduce frame rate for mpeg4 to be within the spec limits if ( enc_ctx -> codec_id == AV_CODEC_ID_MPEG4 ) { av_reduce ( & ost -> frame_rate . num , & ost -> frame_rate . den , ost -> frame_rate . num , ost -> frame_rate . den , 65535 ) ; } } switch ( enc_ctx -> codec_type ) { case AVMEDIA_TYPE_AUDIO : enc_ctx -> sample_fmt = av_buffersink_get_format ( ost -> filter -> filter ) ; enc_ctx -> sample_rate = av_buffersink_get_sample_rate ( ost -> filter -> filter ) ; ret = av_buffersink_get_ch_layout ( ost -> filter -> filter , & enc_ctx -> ch_layout ) ; if ( ret < 0 ) return ret ; if ( ost -> bits_per_raw_sample ) enc_ctx -> bits_per_raw_sample = ost -> bits_per_raw_sample ; else if ( dec_ctx && ost -> filter -> graph -> is_meta ) enc_ctx -> bits_per_raw_sample = FFMIN ( dec_ctx -> bits_per_raw_sample , av_get_bytes_per_sample ( enc_ctx -> sample_fmt ) << 3 ) ; init_encoder_time_base ( ost , av_make_q ( 1 , enc_ctx -> sample_rate ) ) ; break ; case AVMEDIA_TYPE_VIDEO : init_encoder_time_base ( ost , av_inv_q ( ost -> frame_rate ) ) ; if ( ! ( enc_ctx -> time_base . num && enc_ctx -> time_base . den ) ) enc_ctx -> time_base = av_buffersink_get_time_base ( ost -> filter -> filter ) ; if ( av_q2d ( enc_ctx -> time_base ) < 0.001 && ost -> vsync_method != VSYNC_PASSTHROUGH && ( ost -> vsync_method == VSYNC_CFR || ost -> vsync_method == VSYNC_VSCFR || ( ost -> vsync_method == VSYNC_AUTO && ! ( of -> format -> flags & AVFMT_VARIABLE_FPS ) ) ) ) { av_log ( ost , AV_LOG_WARNING , \"Frame rate very high for a muxer not efficiently supporting it.\\n\" \"Please consider specifying a lower framerate, a different muxer or \" \"setting vsync/fps_mode to vfr\\n\" ) ; } enc_ctx -> width = av_buffersink_get_w ( ost -> filter -> filter ) ; enc_ctx -> height = av_buffersink_get_h ( ost -> filter -> filter ) ; enc_ctx -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = ost -> frame_aspect_ratio . num ? // overridden by the -aspect cli option av_mul_q ( ost -> frame_aspect_ratio , ( AVRational ) { enc_ctx -> height , enc_ctx -> width } ) : av_buffersink_get_sample_aspect_ratio ( ost -> filter -> filter ) ; enc_ctx -> pix_fmt = av_buffersink_get_format ( ost -> filter -> filter ) ; if ( ost -> bits_per_raw_sample ) enc_ctx -> bits_per_raw_sample = ost -> bits_per_raw_sample ; else if ( dec_ctx && ost -> filter -> graph -> is_meta ) enc_ctx -> bits_per_raw_sample = FFMIN ( dec_ctx -> bits_per_raw_sample , av_pix_fmt_desc_get ( enc_ctx -> pix_fmt ) -> comp [ 0 ] . depth ) ; if ( frame ) { enc_ctx -> color_range = frame -> color_range ; enc_ctx -> color_primaries = frame -> color_primaries ; enc_ctx -> color_trc = frame -> color_trc ; enc_ctx -> colorspace = frame -> colorspace ; enc_ctx -> chroma_sample_location = frame -> chroma_location ; } enc_ctx -> framerate = ost -> frame_rate ; ost -> st -> avg_frame_rate = ost -> frame_rate ; // Field order: autodetection if ( frame ) { if ( enc_ctx -> flags & ( AV_CODEC_FLAG_INTERLACED_DCT | AV_CODEC_FLAG_INTERLACED_ME ) && ost -> top_field_first >= 0 ) frame -> top_field_first = ! ! ost -> top_field_first ; if ( frame -> interlaced_frame ) { if ( enc_ctx -> codec -> id == AV_CODEC_ID_MJPEG ) enc_ctx -> field_order = frame -> top_field_first ? AV_FIELD_TT : AV_FIELD_BB ; else enc_ctx -> field_order = frame -> top_field_first ? AV_FIELD_TB : AV_FIELD_BT ; } else enc_ctx -> field_order = AV_FIELD_PROGRESSIVE ; } // Field order: override if ( ost -> top_field_first == 0 ) { enc_ctx -> field_order = AV_FIELD_BB ; } else if ( ost -> top_field_first == 1 ) { enc_ctx -> field_order = AV_FIELD_TT ; } break ; case AVMEDIA_TYPE_SUBTITLE : enc_ctx -> time_base = AV_TIME_BASE_Q ; if ( ! enc_ctx -> width ) { enc_ctx -> width = ost -> ist -> par -> width ; enc_ctx -> height = ost -> ist -> par -> height ; } if ( dec_ctx && dec_ctx -> subtitle_header ) { /* ASS code assumes this buffer is null terminated so add extra byte. */ ost -> enc_ctx -> subtitle_header = av_mallocz ( dec_ctx -> subtitle_header_size + 1 ) ; if ( ! ost -> enc_ctx -> subtitle_header ) return AVERROR ( ENOMEM ) ; memcpy ( ost -> enc_ctx -> subtitle_header , dec_ctx -> subtitle_header , dec_ctx -> subtitle_header_size ) ; ost -> enc_ctx -> subtitle_header_size = dec_ctx -> subtitle_header_size ; } if ( ist && ist -> dec -> type == AVMEDIA_TYPE_SUBTITLE && enc_ctx -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { int input_props = 0 , output_props = 0 ; AVCodecDescriptor const * input_descriptor = avcodec_descriptor_get ( ist -> dec -> id ) ; AVCodecDescriptor const * output_descriptor = avcodec_descriptor_get ( ost -> enc_ctx -> codec_id ) ; if ( input_descriptor ) input_props = input_descriptor -> props & ( AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB ) ; if ( output_descriptor ) output_props = output_descriptor -> props & ( AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB ) ; if ( input_props && output_props && input_props != output_props ) { av_log ( ost , AV_LOG_ERROR , \"Subtitle encoding currently only possible from text to text \" \"or bitmap to bitmap\" ) ; return AVERROR_INVALIDDATA ; } } break ; case AVMEDIA_TYPE_DATA : break ; default : abort ( ) ; break ; } if ( ost -> bitexact ) enc_ctx -> flags |= AV_CODEC_FLAG_BITEXACT ; if ( ost -> sq_idx_encode >= 0 ) sq_set_tb ( of -> sq_encode , ost -> sq_idx_encode , enc_ctx -> time_base ) ; ost -> mux_timebase = enc_ctx -> time_base ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@init_output_stream": "static int init_output_stream ( OutputStream * ost , AVFrame * frame , char * error , int error_len ) { int ret = 0 ; if ( ost -> enc_ctx ) { const AVCodec * codec = ost -> enc_ctx -> codec ; InputStream * ist = ost -> ist ; ret = init_output_stream_encode ( ost , frame ) ; if ( ret < 0 ) return ret ; if ( ! av_dict_get ( ost -> encoder_opts , \"threads\" , NULL , 0 ) ) av_dict_set ( & ost -> encoder_opts , \"threads\" , \"auto\" , 0 ) ; if ( codec -> capabilities & AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE ) { ret = av_dict_set ( & ost -> encoder_opts , \"flags\" , \"+copy_opaque\" , AV_DICT_MULTIKEY ) ; if ( ret < 0 ) return ret ; } ret = hw_device_setup_for_encode ( ost ) ; if ( ret < 0 ) { snprintf ( error , error_len , \"Device setup failed for \" \"encoder on output stream #%d:%d : %s\" , ost -> file_index , ost -> index , av_err2str ( ret ) ) ; return ret ; } if ( ( ret = avcodec_open2 ( ost -> enc_ctx , codec , & ost -> encoder_opts ) ) < 0 ) { if ( ret == AVERROR_EXPERIMENTAL ) abort_codec_experimental ( codec , 1 ) ; snprintf ( error , error_len , \"Error while opening encoder for output stream #%d:%d - \" \"maybe incorrect parameters such as bit_rate, rate, width or height\" , ost -> file_index , ost -> index ) ; return ret ; } if ( codec -> type == AVMEDIA_TYPE_AUDIO && ! ( codec -> capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE ) ) av_buffersink_set_frame_size ( ost -> filter -> filter , ost -> enc_ctx -> frame_size ) ; assert_avoptions ( ost -> encoder_opts ) ; if ( ost -> enc_ctx -> bit_rate && ost -> enc_ctx -> bit_rate < 1000 && ost -> enc_ctx -> codec_id != AV_CODEC_ID_CODEC2 /* don't complain about 700 bit/s modes */ ) av_log ( ost , AV_LOG_WARNING , \"The bitrate parameter is set too low.\" \" It takes bits/s as argument, not kbits/s\\n\" ) ; ret = avcodec_parameters_from_context ( ost -> st -> codecpar , ost -> enc_ctx ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Error initializing the output stream codec context.\\n\" ) ; exit_program ( 1 ) ; } if ( ost -> enc_ctx -> nb_coded_side_data ) { int i ; for ( i = 0 ; i < ost -> enc_ctx -> nb_coded_side_data ; i ++ ) { const AVPacketSideData * sd_src = & ost -> enc_ctx -> coded_side_data [ i ] ; uint8_t * dst_data ; dst_data = av_stream_new_side_data ( ost -> st , sd_src -> type , sd_src -> size ) ; if ( ! dst_data ) return AVERROR ( ENOMEM ) ; memcpy ( dst_data , sd_src -> data , sd_src -> size ) ; } } /*\n         * Add global input side data. For now this is naive, and copies it\n         * from the input stream's global side data. All side data should\n         * really be funneled over AVFrame and libavfilter, then added back to\n         * packet side data, and then potentially using the first packet for\n         * global side data.\n         */ if ( ist ) { int i ; for ( i = 0 ; i < ist -> st -> nb_side_data ; i ++ ) { AVPacketSideData * sd = & ist -> st -> side_data [ i ] ; if ( sd -> type != AV_PKT_DATA_CPB_PROPERTIES ) { uint8_t * dst = av_stream_new_side_data ( ost -> st , sd -> type , sd -> size ) ; if ( ! dst ) return AVERROR ( ENOMEM ) ; memcpy ( dst , sd -> data , sd -> size ) ; if ( ist -> autorotate && sd -> type == AV_PKT_DATA_DISPLAYMATRIX ) av_display_rotation_set ( ( int32_t * ) dst , 0 ) ; } } } // copy timebase while removing common factors if ( ost -> st -> time_base . num <= 0 || ost -> st -> time_base . den <= 0 ) ost -> st -> time_base = av_add_q ( ost -> enc_ctx -> time_base , ( AVRational ) { 0 , 1 } ) ; // copy estimated duration as a hint to the muxer if ( ost -> st -> duration <= 0 && ist && ist -> st -> duration > 0 ) ost -> st -> duration = av_rescale_q ( ist -> st -> duration , ist -> st -> time_base , ost -> st -> time_base ) ; } else if ( ost -> ist ) { ret = init_output_stream_streamcopy ( ost ) ; if ( ret < 0 ) return ret ; } ret = of_stream_init ( output_files [ ost -> file_index ] , ost ) ; if ( ret < 0 ) return ret ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@transcode_init": "static int transcode_init ( void ) { int ret = 0 ; char error [ 1024 ] = { 0 } ; /* init framerate emulation */ for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * ifile = input_files [ i ] ; if ( ifile -> readrate || ifile -> rate_emu ) for ( int j = 0 ; j < ifile -> nb_streams ; j ++ ) ifile -> streams [ j ] -> start = av_gettime_relative ( ) ; } /* init input streams */ for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) if ( ( ret = init_input_stream ( ist , error , sizeof ( error ) ) ) < 0 ) goto dump_format ; /*\n     * initialize stream copy and subtitle/data streams.\n     * Encoded AVFrame based streams will get initialized as follows:\n     * - when the first AVFrame is received in do_video_out\n     * - just before the first AVFrame is received in either transcode_step\n     *   or reap_filters due to us requiring the filter chain buffer sink\n     *   to be configured with the correct audio frame size, which is only\n     *   known after the encoder is initialized.\n     */ for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> enc_ctx && ( ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO || ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) ) continue ; ret = init_output_stream_wrapper ( ost , NULL , 0 ) ; if ( ret < 0 ) goto dump_format ; } /* discard unused programs */ for ( int i = 0 ; i < nb_input_files ; i ++ ) { InputFile * ifile = input_files [ i ] ; for ( int j = 0 ; j < ifile -> ctx -> nb_programs ; j ++ ) { AVProgram * p = ifile -> ctx -> programs [ j ] ; int discard = AVDISCARD_ALL ; for ( int k = 0 ; k < p -> nb_stream_indexes ; k ++ ) if ( ! ifile -> streams [ p -> stream_index [ k ] ] -> discard ) { discard = AVDISCARD_DEFAULT ; break ; } p -> discard = discard ; } } dump_format : /* dump the stream mapping */ av_log ( NULL , AV_LOG_INFO , \"Stream mapping:\\n\" ) ; for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) { for ( int j = 0 ; j < ist -> nb_filters ; j ++ ) { if ( ! filtergraph_is_simple ( ist -> filters [ j ] -> graph ) ) { av_log ( NULL , AV_LOG_INFO , \"  Stream #%d:%d (%s) -> %s\" , ist -> file_index , ist -> st -> index , ist -> dec ? ist -> dec -> name : \"?\" , ist -> filters [ j ] -> name ) ; if ( nb_filtergraphs > 1 ) av_log ( NULL , AV_LOG_INFO , \" (graph %d)\" , ist -> filters [ j ] -> graph -> index ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; } } } for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> attachment_filename ) { /* an attached file */ av_log ( NULL , AV_LOG_INFO , \"  File %s -> Stream #%d:%d\\n\" , ost -> attachment_filename , ost -> file_index , ost -> index ) ; continue ; } if ( ost -> filter && ! filtergraph_is_simple ( ost -> filter -> graph ) ) { /* output from a complex graph */ av_log ( NULL , AV_LOG_INFO , \"  %s\" , ost -> filter -> name ) ; if ( nb_filtergraphs > 1 ) av_log ( NULL , AV_LOG_INFO , \" (graph %d)\" , ost -> filter -> graph -> index ) ; av_log ( NULL , AV_LOG_INFO , \" -> Stream #%d:%d (%s)\\n\" , ost -> file_index , ost -> index , ost -> enc_ctx -> codec -> name ) ; continue ; } av_log ( NULL , AV_LOG_INFO , \"  Stream #%d:%d -> #%d:%d\" , ost -> ist -> file_index , ost -> ist -> st -> index , ost -> file_index , ost -> index ) ; if ( ost -> enc_ctx ) { const AVCodec * in_codec = ost -> ist -> dec ; const AVCodec * out_codec = ost -> enc_ctx -> codec ; const char * decoder_name = \"?\" ; const char * in_codec_name = \"?\" ; const char * encoder_name = \"?\" ; const char * out_codec_name = \"?\" ; const AVCodecDescriptor * desc ; if ( in_codec ) { decoder_name = in_codec -> name ; desc = avcodec_descriptor_get ( in_codec -> id ) ; if ( desc ) in_codec_name = desc -> name ; if ( ! strcmp ( decoder_name , in_codec_name ) ) decoder_name = \"native\" ; } if ( out_codec ) { encoder_name = out_codec -> name ; desc = avcodec_descriptor_get ( out_codec -> id ) ; if ( desc ) out_codec_name = desc -> name ; if ( ! strcmp ( encoder_name , out_codec_name ) ) encoder_name = \"native\" ; } av_log ( NULL , AV_LOG_INFO , \" (%s (%s) -> %s (%s))\" , in_codec_name , decoder_name , out_codec_name , encoder_name ) ; } else av_log ( NULL , AV_LOG_INFO , \" (copy)\" ) ; av_log ( NULL , AV_LOG_INFO , \"\\n\" ) ; } if ( ret ) { av_log ( NULL , AV_LOG_ERROR , \"%s\\n\" , error ) ; return ret ; } atomic_store ( & transcode_init_done , 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@need_output": "static int need_output ( void ) { for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> finished ) continue ; return 1 ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@choose_output": "static OutputStream * choose_output ( void ) { int64_t opts_min = INT64_MAX ; OutputStream * ost_min = NULL ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { int64_t opts ; if ( ost -> filter && ost -> last_filter_pts != AV_NOPTS_VALUE ) { opts = ost -> last_filter_pts ; } else { opts = ost -> last_mux_dts == AV_NOPTS_VALUE ? INT64_MIN : ost -> last_mux_dts ; if ( ost -> last_mux_dts == AV_NOPTS_VALUE ) av_log ( ost , AV_LOG_DEBUG , \"cur_dts is invalid [init:%d i_done:%d finish:%d] (this is harmless if it occurs once at the start per stream)\\n\" , ost -> initialized , ost -> inputs_done , ost -> finished ) ; } if ( ! ost -> initialized && ! ost -> inputs_done ) return ost -> unavailable ? NULL : ost ; if ( ! ost -> finished && opts < opts_min ) { opts_min = opts ; ost_min = ost -> unavailable ? NULL : ost ; } } return ost_min ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@set_tty_echo": "static void set_tty_echo ( int on ) { # if HAVE_TERMIOS_H struct termios tty ; if ( tcgetattr ( 0 , & tty ) == 0 ) { if ( on ) tty . c_lflag |= ECHO ; else tty . c_lflag &= ~ ECHO ; tcsetattr ( 0 , TCSANOW , & tty ) ; } # endif }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@check_keyboard_interaction": "static int check_keyboard_interaction ( int64_t cur_time ) { int i , ret , key ; if ( received_nb_signals ) return AVERROR_EXIT ; /* read_key() returns 0 on EOF */ if ( cur_time - keyboard_last_time >= 100000 ) { key = read_key ( ) ; keyboard_last_time = cur_time ; } else key = - 1 ; if ( key == 'q' ) { av_log ( NULL , AV_LOG_INFO , \"\\n\\n[q] command received. Exiting.\\n\\n\" ) ; return AVERROR_EXIT ; } if ( key == '+' ) av_log_set_level ( av_log_get_level ( ) + 10 ) ; if ( key == '-' ) av_log_set_level ( av_log_get_level ( ) - 10 ) ; if ( key == 's' ) qp_hist ^= 1 ; if ( key == 'c' || key == 'C' ) { char buf [ 4096 ] , target [ 64 ] , command [ 256 ] , arg [ 256 ] = { 0 } ; double time ; int k , n = 0 ; av_log ( NULL , AV_LOG_STDERR , \"\\nEnter command: <target>|all <time>|-1 <command>[ <argument>]\\n\" ) ; i = 0 ; set_tty_echo ( 1 ) ; while ( ( k = read_key ( ) ) != '\\n' && k != '\\r' && i < sizeof ( buf ) - 1 ) if ( k > 0 ) buf [ i ++ ] = k ; buf [ i ] = 0 ; set_tty_echo ( 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; if ( k > 0 && ( n = sscanf ( buf , \"%63[^ ] %lf %255[^ ] %255[^\\n]\" , target , & time , command , arg ) ) >= 3 ) { av_log ( NULL , AV_LOG_DEBUG , \"Processing command target:%s time:%f command:%s arg:%s\" , target , time , command , arg ) ; for ( i = 0 ; i < nb_filtergraphs ; i ++ ) { FilterGraph * fg = filtergraphs [ i ] ; if ( fg -> graph ) { if ( time < 0 ) { ret = avfilter_graph_send_command ( fg -> graph , target , command , arg , buf , sizeof ( buf ) , key == 'c' ? AVFILTER_CMD_FLAG_ONE : 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"Command reply for stream %d: ret:%d res:\\n%s\" , i , ret , buf ) ; } else if ( key == 'c' ) { av_log ( NULL , AV_LOG_STDERR , \"Queuing commands only on filters supporting the specific command is unsupported\\n\" ) ; ret = AVERROR_PATCHWELCOME ; } else { ret = avfilter_graph_queue_command ( fg -> graph , target , command , arg , 0 , time ) ; if ( ret < 0 ) av_log ( NULL , AV_LOG_STDERR , \"Queuing command failed with error %s\\n\" , av_err2str ( ret ) ) ; } } } } else { av_log ( NULL , AV_LOG_ERROR , \"Parse error, at least 3 arguments were expected, \" \"only %d given in string '%s'\\n\" , n , buf ) ; } } if ( key == 'd' || key == 'D' ) { int debug = 0 ; if ( key == 'D' ) { InputStream * ist = ist_iter ( NULL ) ; if ( ist ) debug = ist -> dec_ctx -> debug << 1 ; if ( ! debug ) debug = 1 ; while ( debug & FF_DEBUG_DCT_COEFF ) //unsupported, would just crash debug += debug ; } else { char buf [ 32 ] ; int k = 0 ; i = 0 ; set_tty_echo ( 1 ) ; while ( ( k = read_key ( ) ) != '\\n' && k != '\\r' && i < sizeof ( buf ) - 1 ) if ( k > 0 ) buf [ i ++ ] = k ; buf [ i ] = 0 ; set_tty_echo ( 0 ) ; av_log ( NULL , AV_LOG_STDERR , \"\\n\" ) ; if ( k <= 0 || sscanf ( buf , \"%d\" , & debug ) != 1 ) av_log ( NULL , AV_LOG_STDERR , \"error parsing debug value\\n\" ) ; } for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) ist -> dec_ctx -> debug = debug ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> enc_ctx ) ost -> enc_ctx -> debug = debug ; } if ( debug ) av_log_set_level ( AV_LOG_DEBUG ) ; av_log ( NULL , AV_LOG_STDERR , \"debug=%d\\n\" , debug ) ; } if ( key == '?' ) { av_log ( NULL , AV_LOG_STDERR , \"key    function\\n\" \"?      show this help\\n\" \"+      increase verbosity\\n\" \"-      decrease verbosity\\n\" \"c      Send command to first matching filter supporting it\\n\" \"C      Send/Queue command to all matching filters\\n\" \"D      cycle through available debug modes\\n\" \"h      dump packets/hex press to cycle through the 3 states\\n\" \"q      quit\\n\" \"s      Show QP histogram\\n\" ) ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@got_eagain": "static int got_eagain ( void ) { for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) if ( ost -> unavailable ) return 1 ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@reset_eagain": "static void reset_eagain ( void ) { int i ; for ( i = 0 ; i < nb_input_files ; i ++ ) input_files [ i ] -> eagain = 0 ; for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) ost -> unavailable = 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@decode_flush": "static void decode_flush ( InputFile * ifile ) { for ( int i = 0 ; i < ifile -> nb_streams ; i ++ ) { InputStream * ist = ifile -> streams [ i ] ; int ret ; if ( ! ist -> processing_needed ) continue ; do { ret = process_input_packet ( ist , NULL , 1 ) ; } while ( ret > 0 ) ; if ( ist -> decoding_needed ) { /* report last frame duration to the demuxer thread */ if ( ist -> par -> codec_type == AVMEDIA_TYPE_AUDIO ) { LastFrameDuration dur ; dur . stream_idx = i ; dur . duration = av_rescale_q ( ist -> nb_samples , ( AVRational ) { 1 , ist -> dec_ctx -> sample_rate } , ist -> st -> time_base ) ; av_thread_message_queue_send ( ifile -> audio_duration_queue , & dur , 0 ) ; } avcodec_flush_buffers ( ist -> dec_ctx ) ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@ts_discontinuity_detect": "static void ts_discontinuity_detect ( InputFile * ifile , InputStream * ist , AVPacket * pkt ) { const int fmt_is_discont = ifile -> ctx -> iformat -> flags & AVFMT_TS_DISCONT ; int disable_discontinuity_correction = copy_ts ; int64_t pkt_dts = av_rescale_q_rnd ( pkt -> dts , ist -> st -> time_base , AV_TIME_BASE_Q , AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX ) ; if ( copy_ts && ist -> next_dts != AV_NOPTS_VALUE && fmt_is_discont && ist -> st -> pts_wrap_bits < 60 ) { int64_t wrap_dts = av_rescale_q_rnd ( pkt -> dts + ( 1LL << ist -> st -> pts_wrap_bits ) , ist -> st -> time_base , AV_TIME_BASE_Q , AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX ) ; if ( FFABS ( wrap_dts - ist -> next_dts ) < FFABS ( pkt_dts - ist -> next_dts ) / 10 ) disable_discontinuity_correction = 0 ; } if ( ist -> next_dts != AV_NOPTS_VALUE && ! disable_discontinuity_correction ) { int64_t delta = pkt_dts - ist -> next_dts ; if ( fmt_is_discont ) { if ( FFABS ( delta ) > 1LL * dts_delta_threshold * AV_TIME_BASE || pkt_dts + AV_TIME_BASE / 10 < FFMAX ( ist -> pts , ist -> dts ) ) { ifile -> ts_offset_discont -= delta ; av_log ( NULL , AV_LOG_DEBUG , \"timestamp discontinuity for stream #%d:%d \" \"(id=%d, type=%s): %\" PRId64 \", new offset= %\" PRId64 \"\\n\" , ist -> file_index , ist -> st -> index , ist -> st -> id , av_get_media_type_string ( ist -> par -> codec_type ) , delta , ifile -> ts_offset_discont ) ; pkt -> dts -= av_rescale_q ( delta , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts -= av_rescale_q ( delta , AV_TIME_BASE_Q , ist -> st -> time_base ) ; } } else { if ( FFABS ( delta ) > 1LL * dts_error_threshold * AV_TIME_BASE ) { av_log ( NULL , AV_LOG_WARNING , \"DTS %\" PRId64 \", next:%\" PRId64 \" st:%d invalid dropping\\n\" , pkt -> dts , ist -> next_dts , pkt -> stream_index ) ; pkt -> dts = AV_NOPTS_VALUE ; } if ( pkt -> pts != AV_NOPTS_VALUE ) { int64_t pkt_pts = av_rescale_q ( pkt -> pts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; delta = pkt_pts - ist -> next_dts ; if ( FFABS ( delta ) > 1LL * dts_error_threshold * AV_TIME_BASE ) { av_log ( NULL , AV_LOG_WARNING , \"PTS %\" PRId64 \", next:%\" PRId64 \" invalid dropping st:%d\\n\" , pkt -> pts , ist -> next_dts , pkt -> stream_index ) ; pkt -> pts = AV_NOPTS_VALUE ; } } } } else if ( ist -> next_dts == AV_NOPTS_VALUE && ! copy_ts && fmt_is_discont && ifile -> last_ts != AV_NOPTS_VALUE ) { int64_t delta = pkt_dts - ifile -> last_ts ; if ( FFABS ( delta ) > 1LL * dts_delta_threshold * AV_TIME_BASE ) { ifile -> ts_offset_discont -= delta ; av_log ( NULL , AV_LOG_DEBUG , \"Inter stream timestamp discontinuity %\" PRId64 \", new offset= %\" PRId64 \"\\n\" , delta , ifile -> ts_offset_discont ) ; pkt -> dts -= av_rescale_q ( delta , AV_TIME_BASE_Q , ist -> st -> time_base ) ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts -= av_rescale_q ( delta , AV_TIME_BASE_Q , ist -> st -> time_base ) ; } } ifile -> last_ts = av_rescale_q ( pkt -> dts , ist -> st -> time_base , AV_TIME_BASE_Q ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@ts_discontinuity_process": "static void ts_discontinuity_process ( InputFile * ifile , InputStream * ist , AVPacket * pkt ) { int64_t offset = av_rescale_q ( ifile -> ts_offset_discont , AV_TIME_BASE_Q , ist -> st -> time_base ) ; // apply previously-detected timestamp-discontinuity offset // (to all streams, not just audio/video) if ( pkt -> dts != AV_NOPTS_VALUE ) pkt -> dts += offset ; if ( pkt -> pts != AV_NOPTS_VALUE ) pkt -> pts += offset ; // detect timestamp discontinuities for audio/video if ( ( ist -> par -> codec_type == AVMEDIA_TYPE_VIDEO || ist -> par -> codec_type == AVMEDIA_TYPE_AUDIO ) && pkt -> dts != AV_NOPTS_VALUE ) ts_discontinuity_detect ( ifile , ist , pkt ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@process_input": "static int process_input ( int file_index ) { InputFile * ifile = input_files [ file_index ] ; AVFormatContext * is ; InputStream * ist ; AVPacket * pkt ; int ret , i ; is = ifile -> ctx ; ret = ifile_get_packet ( ifile , & pkt ) ; if ( ret == AVERROR ( EAGAIN ) ) { ifile -> eagain = 1 ; return ret ; } if ( ret == 1 ) { /* the input file is looped: flush the decoders */ decode_flush ( ifile ) ; return AVERROR ( EAGAIN ) ; } if ( ret < 0 ) { if ( ret != AVERROR_EOF ) { print_error ( is -> url , ret ) ; if ( exit_on_error ) exit_program ( 1 ) ; } for ( i = 0 ; i < ifile -> nb_streams ; i ++ ) { ist = ifile -> streams [ i ] ; if ( ist -> processing_needed ) { ret = process_input_packet ( ist , NULL , 0 ) ; if ( ret > 0 ) return 0 ; } /* mark all outputs that don't go through lavfi as finished */ for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { if ( ost -> ist == ist && ( ! ost -> enc_ctx || ost -> enc_ctx -> codec_type == AVMEDIA_TYPE_SUBTITLE ) ) { OutputFile * of = output_files [ ost -> file_index ] ; of_output_packet ( of , ost -> pkt , ost , 1 ) ; } } } ifile -> eof_reached = 1 ; return AVERROR ( EAGAIN ) ; } reset_eagain ( ) ; ist = ifile -> streams [ pkt -> stream_index ] ; ist -> data_size += pkt -> size ; ist -> nb_packets ++ ; if ( ist -> discard ) goto discard_packet ; /* add the stream-global side data to the first packet */ if ( ist -> nb_packets == 1 ) { for ( i = 0 ; i < ist -> st -> nb_side_data ; i ++ ) { AVPacketSideData * src_sd = & ist -> st -> side_data [ i ] ; uint8_t * dst_data ; if ( src_sd -> type == AV_PKT_DATA_DISPLAYMATRIX ) continue ; if ( av_packet_get_side_data ( pkt , src_sd -> type , NULL ) ) continue ; dst_data = av_packet_new_side_data ( pkt , src_sd -> type , src_sd -> size ) ; if ( ! dst_data ) report_and_exit ( AVERROR ( ENOMEM ) ) ; memcpy ( dst_data , src_sd -> data , src_sd -> size ) ; } } // detect and try to correct for timestamp discontinuities ts_discontinuity_process ( ifile , ist , pkt ) ; if ( debug_ts ) { av_log ( NULL , AV_LOG_INFO , \"demuxer+ffmpeg -> ist_index:%d:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s off:%s off_time:%s\\n\" , ifile -> index , pkt -> stream_index , av_get_media_type_string ( ist -> par -> codec_type ) , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & ist -> st -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & ist -> st -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & ist -> st -> time_base ) , av_ts2str ( input_files [ ist -> file_index ] -> ts_offset ) , av_ts2timestr ( input_files [ ist -> file_index ] -> ts_offset , & AV_TIME_BASE_Q ) ) ; } sub2video_heartbeat ( ist , pkt -> pts ) ; process_input_packet ( ist , pkt , 0 ) ; discard_packet : av_packet_free ( & pkt ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@transcode_from_filter": "static int transcode_from_filter ( FilterGraph * graph , InputStream * * best_ist ) { int i , ret ; int nb_requests , nb_requests_max = 0 ; InputFilter * ifilter ; InputStream * ist ; * best_ist = NULL ; ret = avfilter_graph_request_oldest ( graph -> graph ) ; if ( ret >= 0 ) return reap_filters ( 0 ) ; if ( ret == AVERROR_EOF ) { ret = reap_filters ( 1 ) ; for ( i = 0 ; i < graph -> nb_outputs ; i ++ ) close_output_stream ( graph -> outputs [ i ] -> ost ) ; return ret ; } if ( ret != AVERROR ( EAGAIN ) ) return ret ; for ( i = 0 ; i < graph -> nb_inputs ; i ++ ) { ifilter = graph -> inputs [ i ] ; ist = ifilter -> ist ; if ( input_files [ ist -> file_index ] -> eagain || input_files [ ist -> file_index ] -> eof_reached ) continue ; nb_requests = av_buffersrc_get_nb_failed_requests ( ifilter -> filter ) ; if ( nb_requests > nb_requests_max ) { nb_requests_max = nb_requests ; * best_ist = ist ; } } if ( ! * best_ist ) for ( i = 0 ; i < graph -> nb_outputs ; i ++ ) graph -> outputs [ i ] -> ost -> unavailable = 1 ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@transcode_step": "static int transcode_step ( void ) { OutputStream * ost ; InputStream * ist = NULL ; int ret ; ost = choose_output ( ) ; if ( ! ost ) { if ( got_eagain ( ) ) { reset_eagain ( ) ; av_usleep ( 10000 ) ; return 0 ; } av_log ( NULL , AV_LOG_VERBOSE , \"No more inputs to read from, finishing.\\n\" ) ; return AVERROR_EOF ; } if ( ost -> filter && ! ost -> filter -> graph -> graph ) { if ( ifilter_has_all_input_formats ( ost -> filter -> graph ) ) { ret = configure_filtergraph ( ost -> filter -> graph ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error reinitializing filters!\\n\" ) ; return ret ; } } } if ( ost -> filter && ost -> filter -> graph -> graph ) { /*\n         * Similar case to the early audio initialization in reap_filters.\n         * Audio is special in ffmpeg.c currently as we depend on lavfi's\n         * audio frame buffering/creation to get the output audio frame size\n         * in samples correct. The audio frame size for the filter chain is\n         * configured during the output stream initialization.\n         *\n         * Apparently avfilter_graph_request_oldest (called in\n         * transcode_from_filter just down the line) peeks. Peeking already\n         * puts one frame \"ready to be given out\", which means that any\n         * update in filter buffer sink configuration afterwards will not\n         * help us. And yes, even if it would be utilized,\n         * av_buffersink_get_samples is affected, as it internally utilizes\n         * the same early exit for peeked frames.\n         *\n         * In other words, if avfilter_graph_request_oldest would not make\n         * further filter chain configuration or usage of\n         * av_buffersink_get_samples useless (by just causing the return\n         * of the peeked AVFrame as-is), we could get rid of this additional\n         * early encoder initialization.\n         */ if ( av_buffersink_get_type ( ost -> filter -> filter ) == AVMEDIA_TYPE_AUDIO ) init_output_stream_wrapper ( ost , NULL , 1 ) ; if ( ( ret = transcode_from_filter ( ost -> filter -> graph , & ist ) ) < 0 ) return ret ; if ( ! ist ) return 0 ; } else if ( ost -> filter ) { int i ; for ( i = 0 ; i < ost -> filter -> graph -> nb_inputs ; i ++ ) { InputFilter * ifilter = ost -> filter -> graph -> inputs [ i ] ; if ( ! ifilter -> ist -> got_output && ! input_files [ ifilter -> ist -> file_index ] -> eof_reached ) { ist = ifilter -> ist ; break ; } } if ( ! ist ) { ost -> inputs_done = 1 ; return 0 ; } } else { ist = ost -> ist ; av_assert0 ( ist ) ; } ret = process_input ( ist -> file_index ) ; if ( ret == AVERROR ( EAGAIN ) ) { if ( input_files [ ist -> file_index ] -> eagain ) ost -> unavailable = 1 ; return 0 ; } if ( ret < 0 ) return ret == AVERROR_EOF ? 0 : ret ; return reap_filters ( 0 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@transcode": "static int transcode ( void ) { int ret , i ; InputStream * ist ; int64_t timer_start ; int64_t total_packets_written = 0 ; ret = transcode_init ( ) ; if ( ret < 0 ) goto fail ; if ( stdin_interaction ) { av_log ( NULL , AV_LOG_INFO , \"Press [q] to stop, [?] for help\\n\" ) ; } timer_start = av_gettime_relative ( ) ; while ( ! received_sigterm && ! cancelRequested ( globalSessionId ) ) { int64_t cur_time = av_gettime_relative ( ) ; /* if 'q' pressed, exits */ if ( stdin_interaction ) if ( check_keyboard_interaction ( cur_time ) < 0 ) break ; /* check if there's any stream where output is still needed */ if ( ! need_output ( ) ) { av_log ( NULL , AV_LOG_VERBOSE , \"No more output streams to write to, finishing.\\n\" ) ; break ; } ret = transcode_step ( ) ; if ( ret < 0 && ret != AVERROR_EOF ) { av_log ( NULL , AV_LOG_ERROR , \"Error while filtering: %s\\n\" , av_err2str ( ret ) ) ; break ; } /* dump report by using the output first video and audio streams */ print_report ( 0 , timer_start , cur_time ) ; } /* at the end of stream, we must flush the decoder buffers */ for ( ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) { if ( ! input_files [ ist -> file_index ] -> eof_reached ) { process_input_packet ( ist , NULL , 0 ) ; } } flush_encoders ( ) ; term_exit ( ) ; /* write the trailer if needed */ for ( i = 0 ; i < nb_output_files ; i ++ ) { ret = of_write_trailer ( output_files [ i ] ) ; if ( ret < 0 && exit_on_error ) exit_program ( 1 ) ; } /* dump report by using the first video and audio streams */ print_report ( 1 , timer_start , av_gettime_relative ( ) ) ; /* close each encoder */ for ( OutputStream * ost = ost_iter ( NULL ) ; ost ; ost = ost_iter ( ost ) ) { uint64_t packets_written ; packets_written = atomic_load ( & ost -> packets_written ) ; total_packets_written += packets_written ; if ( ! packets_written && ( abort_on_flags & ABORT_ON_FLAG_EMPTY_OUTPUT_STREAM ) ) { av_log ( ost , AV_LOG_FATAL , \"Empty output\\n\" ) ; exit_program ( 1 ) ; } } if ( ! total_packets_written && ( abort_on_flags & ABORT_ON_FLAG_EMPTY_OUTPUT ) ) { av_log ( NULL , AV_LOG_FATAL , \"Empty output\\n\" ) ; exit_program ( 1 ) ; } hw_device_free_all ( ) ; /* finished ! */ ret = 0 ; fail : return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@get_benchmark_time_stamps": "static BenchmarkTimeStamps get_benchmark_time_stamps ( void ) { BenchmarkTimeStamps time_stamps = { av_gettime_relative ( ) } ; # if HAVE_GETRUSAGE struct rusage rusage ; getrusage ( RUSAGE_SELF , & rusage ) ; time_stamps . user_usec = ( rusage . ru_utime . tv_sec * 1000000LL ) + rusage . ru_utime . tv_usec ; time_stamps . sys_usec = ( rusage . ru_stime . tv_sec * 1000000LL ) + rusage . ru_stime . tv_usec ; # elif HAVE_GETPROCESSTIMES HANDLE proc ; FILETIME c , e , k , u ; proc = GetCurrentProcess ( ) ; GetProcessTimes ( proc , & c , & e , & k , & u ) ; time_stamps . user_usec = ( ( int64_t ) u . dwHighDateTime << 32 | u . dwLowDateTime ) / 10 ; time_stamps . sys_usec = ( ( int64_t ) k . dwHighDateTime << 32 | k . dwLowDateTime ) / 10 ; # else time_stamps . user_usec = time_stamps . sys_usec = 0 ; # endif return time_stamps ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@getmaxrss": "static int64_t getmaxrss ( void ) { # if HAVE_GETRUSAGE && HAVE_STRUCT_RUSAGE_RU_MAXRSS struct rusage rusage ; getrusage ( RUSAGE_SELF , & rusage ) ; return ( int64_t ) rusage . ru_maxrss * 1024 ; # elif HAVE_GETPROCESSMEMORYINFO HANDLE proc ; PROCESS_MEMORY_COUNTERS memcounters ; proc = GetCurrentProcess ( ) ; memcounters . cb = sizeof ( memcounters ) ; GetProcessMemoryInfo ( proc , & memcounters , sizeof ( memcounters ) ) ; return memcounters . PeakPagefileUsage ; # else return 0 ; # endif }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@ffmpeg_var_cleanup": "void ffmpeg_var_cleanup ( ) { received_sigterm = 0 ; received_nb_signals = 0 ; transcode_init_done = ATOMIC_VAR_INIT ( 0 ) ; ffmpeg_exited = 0 ; main_ffmpeg_return_code = 0 ; copy_ts_first_pts = AV_NOPTS_VALUE ; longjmp_value = 0 ; want_sdp = 1 ; enc_stats_files = NULL ; nb_enc_stats_files = 0 ; vstats_file = NULL ; nb_frames_dup = 0 ; dup_warning = 1000 ; nb_frames_drop = 0 ; decode_error_stat [ 0 ] = 0 ; decode_error_stat [ 1 ] = 0 ; nb_output_dumped = 0 ; progress_avio = NULL ; input_files = NULL ; nb_input_files = 0 ; output_files = NULL ; nb_output_files = 0 ; filtergraphs = NULL ; nb_filtergraphs = 0 ; last_time = - 1 ; keyboard_last_time = 0 ; first_report = 1 ; for ( int i = 0 ; i < FF_ARRAY_ELEMS ( qp_histogram ) ; i ++ ) { qp_histogram [ i ] = 0 ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@set_report_callback": "void set_report_callback ( void ( * callback ) ( int , float , float , int64_t , double , double , double ) ) { report_callback = callback ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@cancel_operation": "void cancel_operation ( long id ) { if ( id == 0 ) { sigterm_handler ( SIGINT ) ; } else { cancelSession ( id ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg.c@ffmpeg_execute": "int ffmpeg_execute ( int argc , char * * argv ) { char _program_name [ ] = \"ffmpeg\" ; program_name = ( char * ) & _program_name ; program_birth_year = 2000 ; # define OFFSET ( x ) offsetof ( OptionsContext , x ) OptionDef options [ ] = { /* main options */ { \"L\" , OPT_EXIT , { . func_arg = show_license } , \"show license\" } , { \"h\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"?\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"help\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"-help\" , OPT_EXIT , { . func_arg = show_help } , \"show help\" , \"topic\" } , { \"version\" , OPT_EXIT , { . func_arg = show_version } , \"show version\" } , { \"buildconf\" , OPT_EXIT , { . func_arg = show_buildconf } , \"show build configuration\" } , { \"formats\" , OPT_EXIT , { . func_arg = show_formats } , \"show available formats\" } , { \"muxers\" , OPT_EXIT , { . func_arg = show_muxers } , \"show available muxers\" } , { \"demuxers\" , OPT_EXIT , { . func_arg = show_demuxers } , \"show available demuxers\" } , { \"devices\" , OPT_EXIT , { . func_arg = show_devices } , \"show available devices\" } , { \"codecs\" , OPT_EXIT , { . func_arg = show_codecs } , \"show available codecs\" } , { \"decoders\" , OPT_EXIT , { . func_arg = show_decoders } , \"show available decoders\" } , { \"encoders\" , OPT_EXIT , { . func_arg = show_encoders } , \"show available encoders\" } , { \"bsfs\" , OPT_EXIT , { . func_arg = show_bsfs } , \"show available bit stream filters\" } , { \"protocols\" , OPT_EXIT , { . func_arg = show_protocols } , \"show available protocols\" } , { \"filters\" , OPT_EXIT , { . func_arg = show_filters } , \"show available filters\" } , { \"pix_fmts\" , OPT_EXIT , { . func_arg = show_pix_fmts } , \"show available pixel formats\" } , { \"layouts\" , OPT_EXIT , { . func_arg = show_layouts } , \"show standard channel layouts\" } , { \"sample_fmts\" , OPT_EXIT , { . func_arg = show_sample_fmts } , \"show available audio sample formats\" } , { \"dispositions\" , OPT_EXIT , { . func_arg = show_dispositions } , \"show available stream dispositions\" } , { \"colors\" , OPT_EXIT , { . func_arg = show_colors } , \"show available color names\" } , { \"loglevel\" , HAS_ARG , { . func_arg = opt_loglevel } , \"set logging level\" , \"loglevel\" } , { \"v\" , HAS_ARG , { . func_arg = opt_loglevel } , \"set logging level\" , \"loglevel\" } , { \"report\" , 0 , { . func_arg = opt_report } , \"generate a report\" } , { \"max_alloc\" , HAS_ARG , { . func_arg = opt_max_alloc } , \"set maximum size of a single allocated block\" , \"bytes\" } , { \"cpuflags\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_cpuflags } , \"force specific cpu flags\" , \"flags\" } , { \"cpucount\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_cpucount } , \"force specific cpu count\" , \"count\" } , { \"hide_banner\" , OPT_BOOL | OPT_EXPERT , { & hide_banner } , \"do not show program banner\" , \"hide_banner\" } , # if CONFIG_AVDEVICE { \"sources\" , OPT_EXIT | HAS_ARG , { . func_arg = show_sources } , \"list sources of the input device\" , \"device\" } , { \"sinks\" , OPT_EXIT | HAS_ARG , { . func_arg = show_sinks } , \"list sinks of the output device\" , \"device\" } , # endif { \"f\" , HAS_ARG | OPT_STRING | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( format ) } , \"force format\" , \"fmt\" } , { \"y\" , OPT_BOOL , { & file_overwrite } , \"overwrite output files\" } , { \"n\" , OPT_BOOL , { & no_file_overwrite } , \"never overwrite output files\" } , { \"ignore_unknown\" , OPT_BOOL , { & ignore_unknown_streams } , \"Ignore unknown stream types\" } , { \"copy_unknown\" , OPT_BOOL | OPT_EXPERT , { & copy_unknown_streams } , \"Copy unknown stream types\" } , { \"recast_media\" , OPT_BOOL | OPT_EXPERT , { & recast_media } , \"allow recasting stream type in order to force a decoder of different media type\" } , { \"c\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( codec_names ) } , \"codec name\" , \"codec\" } , { \"codec\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( codec_names ) } , \"codec name\" , \"codec\" } , { \"pre\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( presets ) } , \"preset name\" , \"preset\" } , { \"map\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_map } , \"set input stream mapping\" , \"[-]input_file_id[:stream_specifier][,sync_file_id[:stream_specifier]]\" } , # if FFMPEG_OPT_MAP_CHANNEL { \"map_channel\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_map_channel } , \"map an audio channel from one stream to another (deprecated)\" , \"file.stream.channel[:syncfile.syncstream]\" } , # endif { \"map_metadata\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( metadata_map ) } , \"set metadata information of outfile from infile\" , \"outfile[,metadata]:infile[,metadata]\" } , { \"map_chapters\" , HAS_ARG | OPT_INT | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( chapters_input_file ) } , \"set chapters mapping\" , \"input_file_index\" } , { \"t\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( recording_time ) } , \"record or transcode \\\"duration\\\" seconds of audio/video\" , \"duration\" } , { \"to\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( stop_time ) } , \"record or transcode stop time\" , \"time_stop\" } , { \"fs\" , HAS_ARG | OPT_INT64 | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( limit_filesize ) } , \"set the limit file size in bytes\" , \"limit_size\" } , { \"ss\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( start_time ) } , \"set the start time offset\" , \"time_off\" } , { \"sseof\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_INPUT , { . off = OFFSET ( start_time_eof ) } , \"set the start time offset relative to EOF\" , \"time_off\" } , { \"seek_timestamp\" , HAS_ARG | OPT_INT | OPT_OFFSET | OPT_INPUT , { . off = OFFSET ( seek_timestamp ) } , \"enable/disable seeking by timestamp with -ss\" } , { \"accurate_seek\" , OPT_BOOL | OPT_OFFSET | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( accurate_seek ) } , \"enable/disable accurate seeking with -ss\" } , { \"isync\" , HAS_ARG | OPT_INT | OPT_OFFSET | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( input_sync_ref ) } , \"Indicate the input index for sync reference\" , \"sync ref\" } , { \"itsoffset\" , HAS_ARG | OPT_TIME | OPT_OFFSET | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( input_ts_offset ) } , \"set the input ts offset\" , \"time_off\" } , { \"itsscale\" , HAS_ARG | OPT_DOUBLE | OPT_SPEC | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( ts_scale ) } , \"set the input ts scale\" , \"scale\" } , { \"timestamp\" , HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_recording_timestamp } , \"set the recording timestamp ('now' to set the current time)\" , \"time\" } , { \"metadata\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( metadata ) } , \"add metadata\" , \"string=string\" } , { \"program\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( program ) } , \"add program with specified streams\" , \"title=string:st=number...\" } , { \"dframes\" , HAS_ARG | OPT_PERFILE | OPT_EXPERT | OPT_OUTPUT , { . func_arg = opt_data_frames } , \"set the number of data frames to output\" , \"number\" } , { \"benchmark\" , OPT_BOOL | OPT_EXPERT , { & do_benchmark } , \"add timings for benchmarking\" } , { \"benchmark_all\" , OPT_BOOL | OPT_EXPERT , { & do_benchmark_all } , \"add timings for each task\" } , { \"progress\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_progress } , \"write program-readable progress information\" , \"url\" } , { \"stdin\" , OPT_BOOL | OPT_EXPERT , { & stdin_interaction } , \"enable or disable interaction on standard input\" } , { \"timelimit\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_timelimit } , \"set max runtime in seconds in CPU user time\" , \"limit\" } , { \"dump\" , OPT_BOOL | OPT_EXPERT , { & do_pkt_dump } , \"dump each input packet\" } , { \"hex\" , OPT_BOOL | OPT_EXPERT , { & do_hex_dump } , \"when dumping packets, also dump the payload\" } , { \"re\" , OPT_BOOL | OPT_EXPERT | OPT_OFFSET | OPT_INPUT , { . off = OFFSET ( rate_emu ) } , \"read input at native frame rate; equivalent to -readrate 1\" , \"\" } , { \"readrate\" , HAS_ARG | OPT_FLOAT | OPT_OFFSET | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( readrate ) } , \"read input at specified rate\" , \"speed\" } , { \"target\" , HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_target } , \"specify target file type (\\\"vcd\\\", \\\"svcd\\\", \\\"dvd\\\", \\\"dv\\\" or \\\"dv50\\\" \" \"with optional prefixes \\\"pal-\\\", \\\"ntsc-\\\" or \\\"film-\\\")\" , \"type\" } , { \"vsync\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_vsync } , \"set video sync method globally; deprecated, use -fps_mode\" , \"\" } , { \"frame_drop_threshold\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT , { & frame_drop_threshold } , \"frame drop threshold\" , \"\" } , { \"adrift_threshold\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT , { & audio_drift_threshold } , \"audio drift threshold\" , \"threshold\" } , { \"copyts\" , OPT_BOOL | OPT_EXPERT , { & copy_ts } , \"copy timestamps\" } , { \"start_at_zero\" , OPT_BOOL | OPT_EXPERT , { & start_at_zero } , \"shift input timestamps to start at 0 when using copyts\" } , { \"copytb\" , HAS_ARG | OPT_INT | OPT_EXPERT , { & copy_tb } , \"copy input stream time base when stream copying\" , \"mode\" } , { \"shortest\" , OPT_BOOL | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( shortest ) } , \"finish encoding within shortest input\" } , { \"shortest_buf_duration\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( shortest_buf_duration ) } , \"maximum buffering duration (in seconds) for the -shortest option\" } , { \"bitexact\" , OPT_BOOL | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT | OPT_INPUT , { . off = OFFSET ( bitexact ) } , \"bitexact mode\" } , { \"apad\" , OPT_STRING | HAS_ARG | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( apad ) } , \"audio pad\" , \"\" } , { \"dts_delta_threshold\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT , { & dts_delta_threshold } , \"timestamp discontinuity delta threshold\" , \"threshold\" } , { \"dts_error_threshold\" , HAS_ARG | OPT_FLOAT | OPT_EXPERT , { & dts_error_threshold } , \"timestamp error delta threshold\" , \"threshold\" } , { \"xerror\" , OPT_BOOL | OPT_EXPERT , { & exit_on_error } , \"exit on error\" , \"error\" } , { \"abort_on\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_abort_on } , \"abort on the specified condition flags\" , \"flags\" } , { \"copyinkf\" , OPT_BOOL | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( copy_initial_nonkeyframes ) } , \"copy initial non-keyframes\" } , { \"copypriorss\" , OPT_INT | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( copy_prior_start ) } , \"copy or discard frames before start time\" } , { \"frames\" , OPT_INT64 | HAS_ARG | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( max_frames ) } , \"set the number of frames to output\" , \"number\" } , { \"tag\" , OPT_STRING | HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_INPUT , { . off = OFFSET ( codec_tags ) } , \"force codec tag/fourcc\" , \"fourcc/tag\" } , { \"q\" , HAS_ARG | OPT_EXPERT | OPT_DOUBLE | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( qscale ) } , \"use fixed quality scale (VBR)\" , \"q\" } , { \"qscale\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_qscale } , \"use fixed quality scale (VBR)\" , \"q\" } , { \"profile\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_profile } , \"set profile\" , \"profile\" } , { \"filter\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( filters ) } , \"set stream filtergraph\" , \"filter_graph\" } , { \"filter_threads\" , HAS_ARG , { . func_arg = opt_filter_threads } , \"number of non-complex filter threads\" } , { \"filter_script\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( filter_scripts ) } , \"read stream filtergraph description from a file\" , \"filename\" } , { \"reinit_filter\" , HAS_ARG | OPT_INT | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( reinit_filters ) } , \"reinit filtergraph on input parameter changes\" , \"\" } , { \"filter_complex\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_filter_complex } , \"create a complex filtergraph\" , \"graph_description\" } , { \"filter_complex_threads\" , HAS_ARG | OPT_INT , { & filter_complex_nbthreads } , \"number of threads for -filter_complex\" } , { \"lavfi\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_filter_complex } , \"create a complex filtergraph\" , \"graph_description\" } , { \"filter_complex_script\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_filter_complex_script } , \"read complex filtergraph description from a file\" , \"filename\" } , { \"auto_conversion_filters\" , OPT_BOOL | OPT_EXPERT , { & auto_conversion_filters } , \"enable automatic conversion filters globally\" } , { \"stats\" , OPT_BOOL , { & print_stats } , \"print progress report during encoding\" , } , { \"stats_period\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_stats_period } , \"set the period at which ffmpeg updates stats and -progress output\" , \"time\" } , { \"attach\" , HAS_ARG | OPT_PERFILE | OPT_EXPERT | OPT_OUTPUT , { . func_arg = opt_attach } , \"add an attachment to the output file\" , \"filename\" } , { \"dump_attachment\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( dump_attachment ) } , \"extract an attachment into a file\" , \"filename\" } , { \"stream_loop\" , OPT_INT | HAS_ARG | OPT_EXPERT | OPT_INPUT | OPT_OFFSET , { . off = OFFSET ( loop ) } , \"set number of times input stream shall be looped\" , \"loop count\" } , { \"debug_ts\" , OPT_BOOL | OPT_EXPERT , { & debug_ts } , \"print timestamp debugging info\" } , { \"max_error_rate\" , HAS_ARG | OPT_FLOAT , { & max_error_rate } , \"ratio of decoding errors (0.0: no errors, 1.0: 100% errors) above which ffmpeg returns an error instead of success.\" , \"maximum error rate\" } , { \"discard\" , OPT_STRING | HAS_ARG | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( discard ) } , \"discard\" , \"\" } , { \"disposition\" , OPT_STRING | HAS_ARG | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( disposition ) } , \"disposition\" , \"\" } , { \"thread_queue_size\" , HAS_ARG | OPT_INT | OPT_OFFSET | OPT_EXPERT | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( thread_queue_size ) } , \"set the maximum number of queued packets from the demuxer\" } , { \"find_stream_info\" , OPT_BOOL | OPT_INPUT | OPT_EXPERT | OPT_OFFSET , { . off = OFFSET ( find_stream_info ) } , \"read and decode the streams to fill missing information with heuristics\" } , { \"bits_per_raw_sample\" , OPT_INT | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( bits_per_raw_sample ) } , \"set the number of bits per raw sample\" , \"number\" } , { \"stats_enc_pre\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( enc_stats_pre ) } , \"write encoding stats before encoding\" } , { \"stats_enc_post\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( enc_stats_post ) } , \"write encoding stats after encoding\" } , { \"stats_mux_pre\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( mux_stats ) } , \"write packets stats before muxing\" } , { \"stats_enc_pre_fmt\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( enc_stats_pre_fmt ) } , \"format of the stats written with -stats_enc_pre\" } , { \"stats_enc_post_fmt\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( enc_stats_post_fmt ) } , \"format of the stats written with -stats_enc_post\" } , { \"stats_mux_pre_fmt\" , HAS_ARG | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT | OPT_STRING , { . off = OFFSET ( mux_stats_fmt ) } , \"format of the stats written with -stats_mux_pre\" } , /* video options */ { \"vframes\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_video_frames } , \"set the number of video frames to output\" , \"number\" } , { \"r\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( frame_rates ) } , \"set frame rate (Hz value, fraction or abbreviation)\" , \"rate\" } , { \"fpsmax\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( max_frame_rates ) } , \"set max frame rate (Hz value, fraction or abbreviation)\" , \"rate\" } , { \"s\" , OPT_VIDEO | HAS_ARG | OPT_SUBTITLE | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( frame_sizes ) } , \"set frame size (WxH or abbreviation)\" , \"size\" } , { \"aspect\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( frame_aspect_ratios ) } , \"set aspect ratio (4:3, 16:9 or 1.3333, 1.7777)\" , \"aspect\" } , { \"pix_fmt\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( frame_pix_fmts ) } , \"set pixel format\" , \"format\" } , { \"display_rotation\" , OPT_VIDEO | HAS_ARG | OPT_DOUBLE | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( display_rotations ) } , \"set pure counter-clockwise rotation in degrees for stream(s)\" , \"angle\" } , { \"display_hflip\" , OPT_VIDEO | OPT_BOOL | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( display_hflips ) } , \"set display horizontal flip for stream(s) \" \"(overrides any display rotation if it is not set)\" } , { \"display_vflip\" , OPT_VIDEO | OPT_BOOL | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( display_vflips ) } , \"set display vertical flip for stream(s) \" \"(overrides any display rotation if it is not set)\" } , { \"vn\" , OPT_VIDEO | OPT_BOOL | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( video_disable ) } , \"disable video\" } , { \"rc_override\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( rc_overrides ) } , \"rate control override for specific intervals\" , \"override\" } , { \"vcodec\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_video_codec } , \"force video codec ('copy' to copy stream)\" , \"codec\" } , { \"timecode\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_timecode } , \"set initial TimeCode value.\" , \"hh:mm:ss[:;.]ff\" } , { \"pass\" , OPT_VIDEO | HAS_ARG | OPT_SPEC | OPT_INT | OPT_OUTPUT , { . off = OFFSET ( pass ) } , \"select the pass number (1 to 3)\" , \"n\" } , { \"passlogfile\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( passlogfiles ) } , \"select two pass log file name prefix\" , \"prefix\" } , # if FFMPEG_OPT_PSNR { \"psnr\" , OPT_VIDEO | OPT_BOOL | OPT_EXPERT , { & do_psnr } , \"calculate PSNR of compressed frames (deprecated, use -flags +psnr)\" } , # endif { \"vstats\" , OPT_VIDEO | OPT_EXPERT , { . func_arg = opt_vstats } , \"dump video coding statistics to file\" } , { \"vstats_file\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT , { . func_arg = opt_vstats_file } , \"dump video coding statistics to file\" , \"file\" } , { \"vstats_version\" , OPT_VIDEO | OPT_INT | HAS_ARG | OPT_EXPERT , { & vstats_version } , \"Version of the vstats format to use.\" } , { \"vf\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_video_filters } , \"set video filters\" , \"filter_graph\" } , { \"intra_matrix\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( intra_matrices ) } , \"specify intra matrix coeffs\" , \"matrix\" } , { \"inter_matrix\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( inter_matrices ) } , \"specify inter matrix coeffs\" , \"matrix\" } , { \"chroma_intra_matrix\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_STRING | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( chroma_intra_matrices ) } , \"specify intra matrix coeffs\" , \"matrix\" } , { \"top\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_INT | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( top_field_first ) } , \"top=1/bottom=0/auto=-1 field first\" , \"\" } , { \"vtag\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_old2new } , \"force video tag/fourcc\" , \"fourcc/tag\" } , { \"qphist\" , OPT_VIDEO | OPT_BOOL | OPT_EXPERT , { & qp_hist } , \"show QP histogram\" } , { \"fps_mode\" , OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( fps_mode ) } , \"set framerate mode for matching video streams; overrides vsync\" } , { \"force_fps\" , OPT_VIDEO | OPT_BOOL | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( force_fps ) } , \"force the selected framerate, disable the best supported framerate selection\" } , { \"streamid\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_streamid } , \"set the value of an outfile streamid\" , \"streamIndex:value\" } , { \"force_key_frames\" , OPT_VIDEO | OPT_STRING | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( forced_key_frames ) } , \"force key frames at specified timestamps\" , \"timestamps\" } , { \"b\" , OPT_VIDEO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_bitrate } , \"video bitrate (please use -b:v)\" , \"bitrate\" } , { \"hwaccel\" , OPT_VIDEO | OPT_STRING | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( hwaccels ) } , \"use HW accelerated decoding\" , \"hwaccel name\" } , { \"hwaccel_device\" , OPT_VIDEO | OPT_STRING | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( hwaccel_devices ) } , \"select a device for HW acceleration\" , \"devicename\" } , { \"hwaccel_output_format\" , OPT_VIDEO | OPT_STRING | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( hwaccel_output_formats ) } , \"select output format used with HW accelerated decoding\" , \"format\" } , { \"hwaccels\" , OPT_EXIT , { . func_arg = show_hwaccels } , \"show available HW acceleration methods\" } , { \"autorotate\" , HAS_ARG | OPT_BOOL | OPT_SPEC | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( autorotate ) } , \"automatically insert correct rotate filters\" } , { \"autoscale\" , HAS_ARG | OPT_BOOL | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT , { . off = OFFSET ( autoscale ) } , \"automatically insert a scale filter at the end of the filter graph\" } , { \"fix_sub_duration_heartbeat\" , OPT_VIDEO | OPT_BOOL | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( fix_sub_duration_heartbeat ) } , \"set this video output stream to be a heartbeat stream for \" \"fix_sub_duration, according to which subtitles should be split at \" \"random access points\" } , /* audio options */ { \"aframes\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_audio_frames } , \"set the number of audio frames to output\" , \"number\" } , { \"aq\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_audio_qscale } , \"set audio quality (codec-specific)\" , \"quality\" , } , { \"ar\" , OPT_AUDIO | HAS_ARG | OPT_INT | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_sample_rate ) } , \"set audio sampling rate (in Hz)\" , \"rate\" } , { \"ac\" , OPT_AUDIO | HAS_ARG | OPT_INT | OPT_SPEC | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_channels ) } , \"set number of audio channels\" , \"channels\" } , { \"an\" , OPT_AUDIO | OPT_BOOL | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_disable ) } , \"disable audio\" } , { \"acodec\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_audio_codec } , \"force audio codec ('copy' to copy stream)\" , \"codec\" } , { \"ab\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_bitrate } , \"audio bitrate (please use -b:a)\" , \"bitrate\" } , { \"atag\" , OPT_AUDIO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_old2new } , \"force audio tag/fourcc\" , \"fourcc/tag\" } , { \"sample_fmt\" , OPT_AUDIO | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_STRING | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( sample_fmts ) } , \"set sample format\" , \"format\" } , { \"channel_layout\" , OPT_AUDIO | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_STRING | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_ch_layouts ) } , \"set channel layout\" , \"layout\" } , { \"ch_layout\" , OPT_AUDIO | HAS_ARG | OPT_EXPERT | OPT_SPEC | OPT_STRING | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( audio_ch_layouts ) } , \"set channel layout\" , \"layout\" } , { \"af\" , OPT_AUDIO | HAS_ARG | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_audio_filters } , \"set audio filters\" , \"filter_graph\" } , { \"guess_layout_max\" , OPT_AUDIO | HAS_ARG | OPT_INT | OPT_SPEC | OPT_EXPERT | OPT_INPUT , { . off = OFFSET ( guess_layout_max ) } , \"set the maximum number of channels to try to guess the channel layout\" } , /* subtitle options */ { \"sn\" , OPT_SUBTITLE | OPT_BOOL | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( subtitle_disable ) } , \"disable subtitle\" } , { \"scodec\" , OPT_SUBTITLE | HAS_ARG | OPT_PERFILE | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_subtitle_codec } , \"force subtitle codec ('copy' to copy stream)\" , \"codec\" } , { \"stag\" , OPT_SUBTITLE | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_old2new } , \"force subtitle tag/fourcc\" , \"fourcc/tag\" } , { \"fix_sub_duration\" , OPT_BOOL | OPT_EXPERT | OPT_SUBTITLE | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( fix_sub_duration ) } , \"fix subtitles duration\" } , { \"canvas_size\" , OPT_SUBTITLE | HAS_ARG | OPT_STRING | OPT_SPEC | OPT_INPUT , { . off = OFFSET ( canvas_sizes ) } , \"set canvas size (WxH or abbreviation)\" , \"size\" } , /* muxer options */ { \"muxdelay\" , OPT_FLOAT | HAS_ARG | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( mux_max_delay ) } , \"set the maximum demux-decode delay\" , \"seconds\" } , { \"muxpreload\" , OPT_FLOAT | HAS_ARG | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT , { . off = OFFSET ( mux_preload ) } , \"set the initial demux-decode delay\" , \"seconds\" } , { \"sdp_file\" , HAS_ARG | OPT_EXPERT | OPT_OUTPUT , { . func_arg = opt_sdp_file } , \"specify a file in which to print sdp information\" , \"file\" } , { \"time_base\" , HAS_ARG | OPT_STRING | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( time_bases ) } , \"set the desired time base hint for output stream (1:24, 1:48000 or 0.04166, 2.0833e-5)\" , \"ratio\" } , { \"enc_time_base\" , HAS_ARG | OPT_STRING | OPT_EXPERT | OPT_SPEC | OPT_OUTPUT , { . off = OFFSET ( enc_time_bases ) } , \"set the desired time base for the encoder (1:24, 1:48000 or 0.04166, 2.0833e-5). \" \"two special values are defined - \" \"0 = use frame rate (video) or sample rate (audio),\" \"-1 = match source time base\" , \"ratio\" } , { \"bsf\" , HAS_ARG | OPT_STRING | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT , { . off = OFFSET ( bitstream_filters ) } , \"A comma-separated list of bitstream filters\" , \"bitstream_filters\" } , { \"absf\" , HAS_ARG | OPT_AUDIO | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_old2new } , \"deprecated\" , \"audio bitstream_filters\" } , { \"vbsf\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_old2new } , \"deprecated\" , \"video bitstream_filters\" } , { \"apre\" , HAS_ARG | OPT_AUDIO | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_preset } , \"set the audio options to the indicated preset\" , \"preset\" } , { \"vpre\" , OPT_VIDEO | HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_preset } , \"set the video options to the indicated preset\" , \"preset\" } , { \"spre\" , HAS_ARG | OPT_SUBTITLE | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_preset } , \"set the subtitle options to the indicated preset\" , \"preset\" } , { \"fpre\" , HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT , { . func_arg = opt_preset } , \"set options from indicated preset file\" , \"filename\" } , { \"max_muxing_queue_size\" , HAS_ARG | OPT_INT | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT , { . off = OFFSET ( max_muxing_queue_size ) } , \"maximum number of packets that can be buffered while waiting for all streams to initialize\" , \"packets\" } , { \"muxing_queue_data_threshold\" , HAS_ARG | OPT_INT | OPT_SPEC | OPT_EXPERT | OPT_OUTPUT , { . off = OFFSET ( muxing_queue_data_threshold ) } , \"set the threshold after which max_muxing_queue_size is taken into account\" , \"bytes\" } , /* data codec support */ { \"dcodec\" , HAS_ARG | OPT_DATA | OPT_PERFILE | OPT_EXPERT | OPT_INPUT | OPT_OUTPUT , { . func_arg = opt_data_codec } , \"force data codec ('copy' to copy stream)\" , \"codec\" } , { \"dn\" , OPT_BOOL | OPT_VIDEO | OPT_OFFSET | OPT_INPUT | OPT_OUTPUT , { . off = OFFSET ( data_disable ) } , \"disable data\" } , # if CONFIG_VAAPI { \"vaapi_device\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_vaapi_device } , \"set VAAPI hardware device (DRM path or X11 display name)\" , \"device\" } , # endif # if CONFIG_QSV { \"qsv_device\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_qsv_device } , \"set QSV hardware device (DirectX adapter index, DRM path or X11 display name)\" , \"device\" } , # endif { \"init_hw_device\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_init_hw_device } , \"initialise hardware device\" , \"args\" } , { \"filter_hw_device\" , HAS_ARG | OPT_EXPERT , { . func_arg = opt_filter_hw_device } , \"set hardware device used when filtering\" , \"device\" } , { NULL , } , } ; ffmpeg_options = options ; int ret ; BenchmarkTimeStamps ti ; int savedCode = setjmp ( ex_buf__ ) ; if ( savedCode == 0 ) { ffmpeg_var_cleanup ( ) ; init_dynload ( ) ; register_exit ( ffmpeg_cleanup ) ; av_log_set_flags ( AV_LOG_SKIP_REPEATED ) ; parse_loglevel ( argc , argv , options ) ; # if CONFIG_AVDEVICE avdevice_register_all ( ) ; # endif avformat_network_init ( ) ; show_banner ( argc , argv , options ) ; /* parse options and open all input/output files */ ret = ffmpeg_parse_options ( argc , argv ) ; if ( ret < 0 ) exit_program ( 1 ) ; if ( nb_output_files <= 0 && nb_input_files == 0 ) { show_usage ( ) ; av_log ( NULL , AV_LOG_WARNING , \"Use -h to get full help or, even better, run 'man %s'\\n\" , program_name ) ; exit_program ( 1 ) ; } /* file converter / grab */ if ( nb_output_files <= 0 ) { av_log ( NULL , AV_LOG_FATAL , \"At least one output file must be specified\\n\" ) ; exit_program ( 1 ) ; } current_time = ti = get_benchmark_time_stamps ( ) ; if ( transcode ( ) < 0 ) exit_program ( 1 ) ; if ( do_benchmark ) { int64_t utime , stime , rtime ; current_time = get_benchmark_time_stamps ( ) ; utime = current_time . user_usec - ti . user_usec ; stime = current_time . sys_usec - ti . sys_usec ; rtime = current_time . real_usec - ti . real_usec ; av_log ( NULL , AV_LOG_INFO , \"bench: utime=%0.3fs stime=%0.3fs rtime=%0.3fs\\n\" , utime / 1000000.0 , stime / 1000000.0 , rtime / 1000000.0 ) ; } av_log ( NULL , AV_LOG_DEBUG , \"%\" PRIu64 \" frames successfully decoded, %\" PRIu64 \" decoding errors\\n\" , decode_error_stat [ 0 ] , decode_error_stat [ 1 ] ) ; if ( ( decode_error_stat [ 0 ] + decode_error_stat [ 1 ] ) * max_error_rate < decode_error_stat [ 1 ] ) exit_program ( 69 ) ; exit_program ( ( received_nb_signals || cancelRequested ( globalSessionId ) ) ? 255 : main_ffmpeg_return_code ) ; } else { main_ffmpeg_return_code = ( received_nb_signals || cancelRequested ( globalSessionId ) ) ? 255 : longjmp_value ; } return main_ffmpeg_return_code ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_hw.c@hw_device_get_by_type": "static HWDevice * hw_device_get_by_type ( enum AVHWDeviceType type ) { HWDevice * found = NULL ; int i ; for ( i = 0 ; i < nb_hw_devices ; i ++ ) { if ( hw_devices [ i ] -> type == type ) { if ( found ) return NULL ; found = hw_devices [ i ] ; } } return found ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_hw.c@hw_device_get_by_name": "HWDevice * hw_device_get_by_name ( const char * name ) { int i ; for ( i = 0 ; i < nb_hw_devices ; i ++ ) { if ( ! strcmp ( hw_devices [ i ] -> name , name ) ) return hw_devices [ i ] ; } return NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_hw.c@hw_device_add": "static HWDevice * hw_device_add ( void ) { int err ; err = av_reallocp_array ( & hw_devices , nb_hw_devices + 1 , sizeof ( * hw_devices ) ) ; if ( err ) { nb_hw_devices = 0 ; return NULL ; } hw_devices [ nb_hw_devices ] = av_mallocz ( sizeof ( HWDevice ) ) ; if ( ! hw_devices [ nb_hw_devices ] ) return NULL ; return hw_devices [ nb_hw_devices ++ ] ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_hw.c@hw_device_default_name": "static char * hw_device_default_name ( enum AVHWDeviceType type ) { // Make an automatic name of the form \"type%d\".  We arbitrarily // limit at 1000 anonymous devices of the same type - there is // probably something else very wrong if you get to this limit. const char * type_name = av_hwdevice_get_type_name ( type ) ; char * name ; size_t index_pos ; int index , index_limit = 1000 ; index_pos = strlen ( type_name ) ; name = av_malloc ( index_pos + 4 ) ; if ( ! name ) return NULL ; for ( index = 0 ; index < index_limit ; index ++ ) { snprintf ( name , index_pos + 4 , \"%s%d\" , type_name , index ) ; if ( ! hw_device_get_by_name ( name ) ) break ; } if ( index >= index_limit ) { av_freep ( & name ) ; return NULL ; } return name ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_hw.c@hw_device_init_from_string": "int hw_device_init_from_string ( const char * arg , HWDevice * * dev_out ) { // \"type=name\" // \"type=name,key=value,key2=value2\" // \"type=name:device,key=value,key2=value2\" // \"type:device,key=value,key2=value2\" // -> av_hwdevice_ctx_create() // \"type=name@name\" // \"type@name\" // -> av_hwdevice_ctx_create_derived() AVDictionary * options = NULL ; const char * type_name = NULL , * name = NULL , * device = NULL ; enum AVHWDeviceType type ; HWDevice * dev , * src ; AVBufferRef * device_ref = NULL ; int err ; const char * errmsg , * p , * q ; size_t k ; k = strcspn ( arg , \":=@\" ) ; p = arg + k ; type_name = av_strndup ( arg , k ) ; if ( ! type_name ) { err = AVERROR ( ENOMEM ) ; goto fail ; } type = av_hwdevice_find_type_by_name ( type_name ) ; if ( type == AV_HWDEVICE_TYPE_NONE ) { errmsg = \"unknown device type\" ; goto invalid ; } if ( * p == '=' ) { k = strcspn ( p + 1 , \":@,\" ) ; name = av_strndup ( p + 1 , k ) ; if ( ! name ) { err = AVERROR ( ENOMEM ) ; goto fail ; } if ( hw_device_get_by_name ( name ) ) { errmsg = \"named device already exists\" ; goto invalid ; } p += 1 + k ; } else { name = hw_device_default_name ( type ) ; if ( ! name ) { err = AVERROR ( ENOMEM ) ; goto fail ; } } if ( ! * p ) { // New device with no parameters. err = av_hwdevice_ctx_create ( & device_ref , type , NULL , NULL , 0 ) ; if ( err < 0 ) goto fail ; } else if ( * p == ':' ) { // New device with some parameters. ++ p ; q = strchr ( p , ',' ) ; if ( q ) { if ( q - p > 0 ) { device = av_strndup ( p , q - p ) ; if ( ! device ) { err = AVERROR ( ENOMEM ) ; goto fail ; } } err = av_dict_parse_string ( & options , q + 1 , \"=\" , \",\" , 0 ) ; if ( err < 0 ) { errmsg = \"failed to parse options\" ; goto invalid ; } } err = av_hwdevice_ctx_create ( & device_ref , type , q ? device : p [ 0 ] ? p : NULL , options , 0 ) ; if ( err < 0 ) goto fail ; } else if ( * p == '@' ) { // Derive from existing device. src = hw_device_get_by_name ( p + 1 ) ; if ( ! src ) { errmsg = \"invalid source device name\" ; goto invalid ; } err = av_hwdevice_ctx_create_derived ( & device_ref , type , src -> device_ref , 0 ) ; if ( err < 0 ) goto fail ; } else if ( * p == ',' ) { err = av_dict_parse_string ( & options , p + 1 , \"=\" , \",\" , 0 ) ; if ( err < 0 ) { errmsg = \"failed to parse options\" ; goto invalid ; } err = av_hwdevice_ctx_create ( & device_ref , type , NULL , options , 0 ) ; if ( err < 0 ) goto fail ; } else { errmsg = \"parse error\" ; goto invalid ; } dev = hw_device_add ( ) ; if ( ! dev ) { err = AVERROR ( ENOMEM ) ; goto fail ; } dev -> name = name ; dev -> type = type ; dev -> device_ref = device_ref ; if ( dev_out ) * dev_out = dev ; name = NULL ; err = 0 ; done : av_freep ( & type_name ) ; av_freep ( & name ) ; av_freep ( & device ) ; av_dict_free ( & options ) ; return err ; invalid : av_log ( NULL , AV_LOG_ERROR , \"Invalid device specification \\\"%s\\\": %s\\n\" , arg , errmsg ) ; err = AVERROR ( EINVAL ) ; goto done ; fail : av_log ( NULL , AV_LOG_ERROR , \"Device creation failed: %d.\\n\" , err ) ; av_buffer_unref ( & device_ref ) ; goto done ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_hw.c@hw_device_init_from_type": "static int hw_device_init_from_type ( enum AVHWDeviceType type , const char * device , HWDevice * * dev_out ) { AVBufferRef * device_ref = NULL ; HWDevice * dev ; char * name ; int err ; name = hw_device_default_name ( type ) ; if ( ! name ) { err = AVERROR ( ENOMEM ) ; goto fail ; } err = av_hwdevice_ctx_create ( & device_ref , type , device , NULL , 0 ) ; if ( err < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Device creation failed: %d.\\n\" , err ) ; goto fail ; } dev = hw_device_add ( ) ; if ( ! dev ) { err = AVERROR ( ENOMEM ) ; goto fail ; } dev -> name = name ; dev -> type = type ; dev -> device_ref = device_ref ; if ( dev_out ) * dev_out = dev ; return 0 ; fail : av_freep ( & name ) ; av_buffer_unref ( & device_ref ) ; return err ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_hw.c@hw_device_free_all": "void hw_device_free_all ( void ) { int i ; for ( i = 0 ; i < nb_hw_devices ; i ++ ) { av_freep ( & hw_devices [ i ] -> name ) ; av_buffer_unref ( & hw_devices [ i ] -> device_ref ) ; av_freep ( & hw_devices [ i ] ) ; } av_freep ( & hw_devices ) ; nb_hw_devices = 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_hw.c@hw_device_match_by_codec": "static HWDevice * hw_device_match_by_codec ( const AVCodec * codec ) { const AVCodecHWConfig * config ; HWDevice * dev ; int i ; for ( i = 0 ; ; i ++ ) { config = avcodec_get_hw_config ( codec , i ) ; if ( ! config ) return NULL ; if ( ! ( config -> methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX ) ) continue ; dev = hw_device_get_by_type ( config -> device_type ) ; if ( dev ) return dev ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_hw.c@hw_device_setup_for_decode": "int hw_device_setup_for_decode ( InputStream * ist ) { const AVCodecHWConfig * config ; enum AVHWDeviceType type ; HWDevice * dev = NULL ; int err , auto_device = 0 ; if ( ist -> hwaccel_device ) { dev = hw_device_get_by_name ( ist -> hwaccel_device ) ; if ( ! dev ) { if ( ist -> hwaccel_id == HWACCEL_AUTO ) { auto_device = 1 ; } else if ( ist -> hwaccel_id == HWACCEL_GENERIC ) { type = ist -> hwaccel_device_type ; err = hw_device_init_from_type ( type , ist -> hwaccel_device , & dev ) ; } else { // This will be dealt with by API-specific initialisation // (using hwaccel_device), so nothing further needed here. return 0 ; } } else { if ( ist -> hwaccel_id == HWACCEL_AUTO ) { ist -> hwaccel_device_type = dev -> type ; } else if ( ist -> hwaccel_device_type != dev -> type ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid hwaccel device \" \"specified for decoder: device %s of type %s is not \" \"usable with hwaccel %s.\\n\" , dev -> name , av_hwdevice_get_type_name ( dev -> type ) , av_hwdevice_get_type_name ( ist -> hwaccel_device_type ) ) ; return AVERROR ( EINVAL ) ; } } } else { if ( ist -> hwaccel_id == HWACCEL_AUTO ) { auto_device = 1 ; } else if ( ist -> hwaccel_id == HWACCEL_GENERIC ) { type = ist -> hwaccel_device_type ; dev = hw_device_get_by_type ( type ) ; // When \"-qsv_device device\" is used, an internal QSV device named // as \"__qsv_device\" is created. Another QSV device is created too // if \"-init_hw_device qsv=name:device\" is used. There are 2 QSV devices // if both \"-qsv_device device\" and \"-init_hw_device qsv=name:device\" // are used, hw_device_get_by_type(AV_HWDEVICE_TYPE_QSV) returns NULL. // To keep back-compatibility with the removed ad-hoc libmfx setup code, // call hw_device_get_by_name(\"__qsv_device\") to select the internal QSV // device. if ( ! dev && type == AV_HWDEVICE_TYPE_QSV ) dev = hw_device_get_by_name ( \"__qsv_device\" ) ; if ( ! dev ) err = hw_device_init_from_type ( type , NULL , & dev ) ; } else { dev = hw_device_match_by_codec ( ist -> dec ) ; if ( ! dev ) { // No device for this codec, but not using generic hwaccel // and therefore may well not need one - ignore. return 0 ; } } } if ( auto_device ) { int i ; if ( ! avcodec_get_hw_config ( ist -> dec , 0 ) ) { // Decoder does not support any hardware devices. return 0 ; } for ( i = 0 ; ! dev ; i ++ ) { config = avcodec_get_hw_config ( ist -> dec , i ) ; if ( ! config ) break ; type = config -> device_type ; dev = hw_device_get_by_type ( type ) ; if ( dev ) { av_log ( NULL , AV_LOG_INFO , \"Using auto \" \"hwaccel type %s with existing device %s.\\n\" , av_hwdevice_get_type_name ( type ) , dev -> name ) ; } } for ( i = 0 ; ! dev ; i ++ ) { config = avcodec_get_hw_config ( ist -> dec , i ) ; if ( ! config ) break ; type = config -> device_type ; // Try to make a new device of this type. err = hw_device_init_from_type ( type , ist -> hwaccel_device , & dev ) ; if ( err < 0 ) { // Can't make a device of this type. continue ; } if ( ist -> hwaccel_device ) { av_log ( NULL , AV_LOG_INFO , \"Using auto \" \"hwaccel type %s with new device created \" \"from %s.\\n\" , av_hwdevice_get_type_name ( type ) , ist -> hwaccel_device ) ; } else { av_log ( NULL , AV_LOG_INFO , \"Using auto \" \"hwaccel type %s with new default device.\\n\" , av_hwdevice_get_type_name ( type ) ) ; } } if ( dev ) { ist -> hwaccel_device_type = type ; } else { av_log ( NULL , AV_LOG_INFO , \"Auto hwaccel \" \"disabled: no device found.\\n\" ) ; ist -> hwaccel_id = HWACCEL_NONE ; return 0 ; } } if ( ! dev ) { av_log ( NULL , AV_LOG_ERROR , \"No device available \" \"for decoder: device type %s needed for codec %s.\\n\" , av_hwdevice_get_type_name ( type ) , ist -> dec -> name ) ; return err ; } ist -> dec_ctx -> hw_device_ctx = av_buffer_ref ( dev -> device_ref ) ; if ( ! ist -> dec_ctx -> hw_device_ctx ) return AVERROR ( ENOMEM ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_hw.c@hw_device_setup_for_encode": "int hw_device_setup_for_encode ( OutputStream * ost ) { const AVCodecHWConfig * config ; HWDevice * dev = NULL ; AVBufferRef * frames_ref = NULL ; int i ; if ( ost -> filter ) { frames_ref = av_buffersink_get_hw_frames_ctx ( ost -> filter -> filter ) ; if ( frames_ref && ( ( AVHWFramesContext * ) frames_ref -> data ) -> format == ost -> enc_ctx -> pix_fmt ) { // Matching format, will try to use hw_frames_ctx. } else { frames_ref = NULL ; } } for ( i = 0 ; ; i ++ ) { config = avcodec_get_hw_config ( ost -> enc_ctx -> codec , i ) ; if ( ! config ) break ; if ( frames_ref && config -> methods & AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX && ( config -> pix_fmt == AV_PIX_FMT_NONE || config -> pix_fmt == ost -> enc_ctx -> pix_fmt ) ) { av_log ( ost -> enc_ctx , AV_LOG_VERBOSE , \"Using input \" \"frames context (format %s) with %s encoder.\\n\" , av_get_pix_fmt_name ( ost -> enc_ctx -> pix_fmt ) , ost -> enc_ctx -> codec -> name ) ; ost -> enc_ctx -> hw_frames_ctx = av_buffer_ref ( frames_ref ) ; if ( ! ost -> enc_ctx -> hw_frames_ctx ) return AVERROR ( ENOMEM ) ; return 0 ; } if ( ! dev && config -> methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX ) dev = hw_device_get_by_type ( config -> device_type ) ; } if ( dev ) { av_log ( ost -> enc_ctx , AV_LOG_VERBOSE , \"Using device %s \" \"(type %s) with %s encoder.\\n\" , dev -> name , av_hwdevice_get_type_name ( dev -> type ) , ost -> enc_ctx -> codec -> name ) ; ost -> enc_ctx -> hw_device_ctx = av_buffer_ref ( dev -> device_ref ) ; if ( ! ost -> enc_ctx -> hw_device_ctx ) return AVERROR ( ENOMEM ) ; } else { // No device required, or no device available. } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_hw.c@hwaccel_retrieve_data": "static int hwaccel_retrieve_data ( AVCodecContext * avctx , AVFrame * input ) { InputStream * ist = avctx -> opaque ; AVFrame * output = NULL ; enum AVPixelFormat output_format = ist -> hwaccel_output_format ; int err ; if ( input -> format == output_format ) { // Nothing to do. return 0 ; } output = av_frame_alloc ( ) ; if ( ! output ) return AVERROR ( ENOMEM ) ; output -> format = output_format ; err = av_hwframe_transfer_data ( output , input , 0 ) ; if ( err < 0 ) { av_log ( avctx , AV_LOG_ERROR , \"Failed to transfer data to \" \"output frame: %d.\\n\" , err ) ; goto fail ; } err = av_frame_copy_props ( output , input ) ; if ( err < 0 ) { av_frame_unref ( output ) ; goto fail ; } av_frame_unref ( input ) ; av_frame_move_ref ( input , output ) ; av_frame_free ( & output ) ; return 0 ; fail : av_frame_free ( & output ) ; return err ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_hw.c@hwaccel_decode_init": "int hwaccel_decode_init ( AVCodecContext * avctx ) { InputStream * ist = avctx -> opaque ; ist -> hwaccel_retrieve_data = & hwaccel_retrieve_data ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_hw.c@hw_device_setup_for_filter": "int hw_device_setup_for_filter ( FilterGraph * fg ) { HWDevice * dev ; int i ; // Pick the last hardware device if the user doesn't pick the device for // filters explicitly with the filter_hw_device option. if ( filter_hw_device ) dev = filter_hw_device ; else if ( nb_hw_devices > 0 ) { dev = hw_devices [ nb_hw_devices - 1 ] ; if ( nb_hw_devices > 1 ) av_log ( NULL , AV_LOG_WARNING , \"There are %d hardware devices. device \" \"%s of type %s is picked for filters by default. Set hardware \" \"device explicitly with the filter_hw_device option if device \" \"%s is not usable for filters.\\n\" , nb_hw_devices , dev -> name , av_hwdevice_get_type_name ( dev -> type ) , dev -> name ) ; } else dev = NULL ; if ( dev ) { for ( i = 0 ; i < fg -> graph -> nb_filters ; i ++ ) { fg -> graph -> filters [ i ] -> hw_device_ctx = av_buffer_ref ( dev -> device_ref ) ; if ( ! fg -> graph -> filters [ i ] -> hw_device_ctx ) return AVERROR ( ENOMEM ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@fopen_utf8": "static inline FILE * fopen_utf8 ( const char * path , const char * mode ) { return fopen ( path , mode ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@check_opt_bitexact": "static int check_opt_bitexact ( void * ctx , const AVDictionary * opts , const char * opt_name , int flag ) { const AVDictionaryEntry * e = av_dict_get ( opts , opt_name , NULL , 0 ) ; if ( e ) { const AVOption * o = av_opt_find ( ctx , opt_name , NULL , 0 , 0 ) ; int val = 0 ; if ( ! o ) return 0 ; av_opt_eval_flags ( ctx , o , e -> value , & val ) ; return ! ! ( val & flag ) ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@choose_encoder": "static int choose_encoder ( const OptionsContext * o , AVFormatContext * s , OutputStream * ost , const AVCodec * * enc ) { enum AVMediaType type = ost -> st -> codecpar -> codec_type ; char * codec_name = NULL ; * enc = NULL ; if ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO || type == AVMEDIA_TYPE_SUBTITLE ) { MATCH_PER_STREAM_OPT ( codec_names , str , codec_name , s , ost -> st ) ; if ( ! codec_name ) { ost -> st -> codecpar -> codec_id = av_guess_codec ( s -> oformat , NULL , s -> url , NULL , ost -> st -> codecpar -> codec_type ) ; * enc = avcodec_find_encoder ( ost -> st -> codecpar -> codec_id ) ; if ( ! * enc ) { av_log ( ost , AV_LOG_FATAL , \"Automatic encoder selection failed \" \"Default encoder for format %s (codec %s) is \" \"probably disabled. Please choose an encoder manually.\\n\" , s -> oformat -> name , avcodec_get_name ( ost -> st -> codecpar -> codec_id ) ) ; return AVERROR_ENCODER_NOT_FOUND ; } } else if ( strcmp ( codec_name , \"copy\" ) ) { * enc = find_codec_or_die ( ost , codec_name , ost -> st -> codecpar -> codec_type , 1 ) ; ost -> st -> codecpar -> codec_id = ( * enc ) -> id ; } } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@get_line": "static char * get_line ( AVIOContext * s , AVBPrint * bprint ) { char c ; while ( ( c = avio_r8 ( s ) ) && c != '\\n' ) av_bprint_chars ( bprint , c , 1 ) ; if ( ! av_bprint_is_complete ( bprint ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return bprint -> str ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@get_preset_file_2": "static int get_preset_file_2 ( const char * preset_name , const char * codec_name , AVIOContext * * s ) { int i , ret = - 1 ; char filename [ 1000 ] ; char * env_avconv_datadir = getenv_utf8 ( \"AVCONV_DATADIR\" ) ; char * env_home = getenv_utf8 ( \"HOME\" ) ; const char * base [ 3 ] = { env_avconv_datadir , env_home , AVCONV_DATADIR , } ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( base ) && ret < 0 ; i ++ ) { if ( ! base [ i ] ) continue ; if ( codec_name ) { snprintf ( filename , sizeof ( filename ) , \"%s%s/%s-%s.avpreset\" , base [ i ] , i != 1 ? \"\" : \"/.avconv\" , codec_name , preset_name ) ; ret = avio_open2 ( s , filename , AVIO_FLAG_READ , & int_cb , NULL ) ; } if ( ret < 0 ) { snprintf ( filename , sizeof ( filename ) , \"%s%s/%s.avpreset\" , base [ i ] , i != 1 ? \"\" : \"/.avconv\" , preset_name ) ; ret = avio_open2 ( s , filename , AVIO_FLAG_READ , & int_cb , NULL ) ; } } freeenv_utf8 ( env_home ) ; freeenv_utf8 ( env_avconv_datadir ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@enc_stats_get_file": "static int enc_stats_get_file ( AVIOContext * * io , const char * path ) { EncStatsFile * esf ; int ret ; for ( int i = 0 ; i < nb_enc_stats_files ; i ++ ) if ( ! strcmp ( path , enc_stats_files [ i ] . path ) ) { * io = enc_stats_files [ i ] . io ; return 0 ; } GROW_ARRAY ( enc_stats_files , nb_enc_stats_files ) ; esf = & enc_stats_files [ nb_enc_stats_files - 1 ] ; ret = avio_open2 ( & esf -> io , path , AVIO_FLAG_WRITE , & int_cb , NULL ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error opening stats file '%s': %s\\n\" , path , av_err2str ( ret ) ) ; return ret ; } esf -> path = av_strdup ( path ) ; if ( ! esf -> path ) return AVERROR ( ENOMEM ) ; * io = esf -> io ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@of_enc_stats_close": "void of_enc_stats_close ( void ) { for ( int i = 0 ; i < nb_enc_stats_files ; i ++ ) { av_freep ( & enc_stats_files [ i ] . path ) ; avio_closep ( & enc_stats_files [ i ] . io ) ; } av_freep ( & enc_stats_files ) ; nb_enc_stats_files = 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@unescape": "static int unescape ( char * * pdst , size_t * dst_len , const char * * pstr , char delim ) { const char * str = * pstr ; char * dst ; size_t len , idx ; * pdst = NULL ; len = strlen ( str ) ; if ( ! len ) return 0 ; dst = av_malloc ( len + 1 ) ; if ( ! dst ) return AVERROR ( ENOMEM ) ; for ( idx = 0 ; * str ; idx ++ , str ++ ) { if ( str [ 0 ] == '\\\\' && str [ 1 ] ) str ++ ; else if ( * str == delim ) break ; dst [ idx ] = * str ; } if ( ! idx ) { av_freep ( & dst ) ; return 0 ; } dst [ idx ] = 0 ; * pdst = dst ; * dst_len = idx ; * pstr = str ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@enc_stats_init": "static int enc_stats_init ( OutputStream * ost , EncStats * es , int pre , const char * path , const char * fmt_spec ) { static const struct { enum EncStatsType type ; const char * str ; int pre_only : 1 ; int post_only : 1 ; int need_input_data : 1 ; } fmt_specs [ ] = { { ENC_STATS_FILE_IDX , \"fidx\" } , { ENC_STATS_STREAM_IDX , \"sidx\" } , { ENC_STATS_FRAME_NUM , \"n\" } , { ENC_STATS_FRAME_NUM_IN , \"ni\" , 0 , 0 , 1 } , { ENC_STATS_TIMEBASE , \"tb\" } , { ENC_STATS_TIMEBASE_IN , \"tbi\" , 0 , 0 , 1 } , { ENC_STATS_PTS , \"pts\" } , { ENC_STATS_PTS_TIME , \"t\" } , { ENC_STATS_PTS_IN , \"ptsi\" , 0 , 0 , 1 } , { ENC_STATS_PTS_TIME_IN , \"ti\" , 0 , 0 , 1 } , { ENC_STATS_DTS , \"dts\" , 0 , 1 } , { ENC_STATS_DTS_TIME , \"dt\" , 0 , 1 } , { ENC_STATS_SAMPLE_NUM , \"sn\" , 1 } , { ENC_STATS_NB_SAMPLES , \"samp\" , 1 } , { ENC_STATS_PKT_SIZE , \"size\" , 0 , 1 } , { ENC_STATS_BITRATE , \"br\" , 0 , 1 } , { ENC_STATS_AVG_BITRATE , \"abr\" , 0 , 1 } , } ; const char * next = fmt_spec ; int ret ; while ( * next ) { EncStatsComponent * c ; char * val ; size_t val_len ; // get the sequence up until next opening brace ret = unescape ( & val , & val_len , & next , '{' ) ; if ( ret < 0 ) return ret ; if ( val ) { GROW_ARRAY ( es -> components , es -> nb_components ) ; c = & es -> components [ es -> nb_components - 1 ] ; c -> type = ENC_STATS_LITERAL ; c -> str = val ; c -> str_len = val_len ; } if ( ! * next ) break ; next ++ ; // get the part inside braces ret = unescape ( & val , & val_len , & next , '}' ) ; if ( ret < 0 ) return ret ; if ( ! val ) { av_log ( NULL , AV_LOG_ERROR , \"Empty formatting directive in: %s\\n\" , fmt_spec ) ; return AVERROR ( EINVAL ) ; } if ( ! * next ) { av_log ( NULL , AV_LOG_ERROR , \"Missing closing brace in: %s\\n\" , fmt_spec ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } next ++ ; GROW_ARRAY ( es -> components , es -> nb_components ) ; c = & es -> components [ es -> nb_components - 1 ] ; for ( size_t i = 0 ; i < FF_ARRAY_ELEMS ( fmt_specs ) ; i ++ ) { if ( ! strcmp ( val , fmt_specs [ i ] . str ) ) { if ( ( pre && fmt_specs [ i ] . post_only ) || ( ! pre && fmt_specs [ i ] . pre_only ) ) { av_log ( NULL , AV_LOG_ERROR , \"Format directive '%s' may only be used %s-encoding\\n\" , val , pre ? \"post\" : \"pre\" ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } c -> type = fmt_specs [ i ] . type ; if ( fmt_specs [ i ] . need_input_data ) { if ( ost -> ist ) ost -> ist -> want_frame_data = 1 ; else { av_log ( ost , AV_LOG_WARNING , \"Format directive '%s' is unavailable, because \" \"this output stream has no associated input stream\\n\" , val ) ; } } break ; } } if ( ! c -> type ) { av_log ( NULL , AV_LOG_ERROR , \"Invalid format directive: %s\\n\" , val ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } fail : av_freep ( & val ) ; if ( ret < 0 ) return ret ; } ret = enc_stats_get_file ( & es -> io , path ) ; if ( ret < 0 ) return ret ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@output_stream_item_name": "static const char * output_stream_item_name ( void * obj ) { const MuxStream * ms = obj ; return ms -> log_name ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@mux_stream_alloc": "static MuxStream * mux_stream_alloc ( Muxer * mux , enum AVMediaType type ) { const char * type_str = av_get_media_type_string ( type ) ; MuxStream * ms = allocate_array_elem ( & mux -> of . streams , sizeof ( * ms ) , & mux -> of . nb_streams ) ; ms -> ost . file_index = mux -> of . index ; ms -> ost . index = mux -> of . nb_streams - 1 ; ms -> ost . clazz = & output_stream_class ; snprintf ( ms -> log_name , sizeof ( ms -> log_name ) , \"%cost#%d:%d\" , type_str ? * type_str : '?' , mux -> of . index , ms -> ost . index ) ; return ms ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@new_output_stream": "static OutputStream * new_output_stream ( Muxer * mux , const OptionsContext * o , enum AVMediaType type , InputStream * ist ) { AVFormatContext * oc = mux -> fc ; MuxStream * ms ; OutputStream * ost ; const AVCodec * enc ; AVStream * st = avformat_new_stream ( oc , NULL ) ; int ret = 0 ; const char * bsfs = NULL , * time_base = NULL ; char * next , * codec_tag = NULL ; double qscale = - 1 ; int i ; if ( ! st ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( oc -> nb_streams - 1 < o -> nb_streamid_map ) st -> id = o -> streamid_map [ oc -> nb_streams - 1 ] ; ms = mux_stream_alloc ( mux , type ) ; ost = & ms -> ost ; ms -> muxing_queue = av_fifo_alloc2 ( 8 , sizeof ( AVPacket * ) , 0 ) ; if ( ! ms -> muxing_queue ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ms -> last_mux_dts = AV_NOPTS_VALUE ; ost -> st = st ; ost -> ist = ist ; ost -> kf . ref_pts = AV_NOPTS_VALUE ; st -> codecpar -> codec_type = type ; ret = choose_encoder ( o , oc , ost , & enc ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Error selecting an encoder\\n\" ) ; exit_program ( 1 ) ; } if ( enc ) { ost -> enc_ctx = avcodec_alloc_context3 ( enc ) ; if ( ! ost -> enc_ctx ) report_and_exit ( AVERROR ( ENOMEM ) ) ; av_strlcat ( ms -> log_name , \"/\" , sizeof ( ms -> log_name ) ) ; av_strlcat ( ms -> log_name , enc -> name , sizeof ( ms -> log_name ) ) ; } else { av_strlcat ( ms -> log_name , \"/copy\" , sizeof ( ms -> log_name ) ) ; } ost -> filtered_frame = av_frame_alloc ( ) ; if ( ! ost -> filtered_frame ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ost -> pkt = av_packet_alloc ( ) ; if ( ! ost -> pkt ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( ost -> enc_ctx ) { AVCodecContext * enc = ost -> enc_ctx ; AVIOContext * s = NULL ; char * buf = NULL , * arg = NULL , * preset = NULL ; const char * enc_stats_pre = NULL , * enc_stats_post = NULL , * mux_stats = NULL ; ost -> encoder_opts = filter_codec_opts ( o -> g -> codec_opts , enc -> codec_id , oc , st , enc -> codec ) ; MATCH_PER_STREAM_OPT ( presets , str , preset , oc , st ) ; ost -> autoscale = 1 ; MATCH_PER_STREAM_OPT ( autoscale , i , ost -> autoscale , oc , st ) ; if ( preset && ( ! ( ret = get_preset_file_2 ( preset , enc -> codec -> name , & s ) ) ) ) { AVBPrint bprint ; av_bprint_init ( & bprint , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; do { av_bprint_clear ( & bprint ) ; buf = get_line ( s , & bprint ) ; if ( ! buf [ 0 ] || buf [ 0 ] == '#' ) continue ; if ( ! ( arg = strchr ( buf , '=' ) ) ) { av_log ( ost , AV_LOG_FATAL , \"Invalid line found in the preset file.\\n\" ) ; exit_program ( 1 ) ; } * arg ++ = 0 ; av_dict_set ( & ost -> encoder_opts , buf , arg , AV_DICT_DONT_OVERWRITE ) ; } while ( ! s -> eof_reached ) ; av_bprint_finalize ( & bprint , NULL ) ; avio_closep ( & s ) ; } if ( ret ) { av_log ( ost , AV_LOG_FATAL , \"Preset %s specified, but could not be opened.\\n\" , preset ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( enc_stats_pre , str , enc_stats_pre , oc , st ) ; if ( enc_stats_pre && ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO ) ) { const char * format = \"{fidx} {sidx} {n} {t}\" ; MATCH_PER_STREAM_OPT ( enc_stats_pre_fmt , str , format , oc , st ) ; ret = enc_stats_init ( ost , & ost -> enc_stats_pre , 1 , enc_stats_pre , format ) ; if ( ret < 0 ) exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( enc_stats_post , str , enc_stats_post , oc , st ) ; if ( enc_stats_post && ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO ) ) { const char * format = \"{fidx} {sidx} {n} {t}\" ; MATCH_PER_STREAM_OPT ( enc_stats_post_fmt , str , format , oc , st ) ; ret = enc_stats_init ( ost , & ost -> enc_stats_post , 0 , enc_stats_post , format ) ; if ( ret < 0 ) exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( mux_stats , str , mux_stats , oc , st ) ; if ( mux_stats && ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO ) ) { const char * format = \"{fidx} {sidx} {n} {t}\" ; MATCH_PER_STREAM_OPT ( mux_stats_fmt , str , format , oc , st ) ; ret = enc_stats_init ( ost , & ms -> stats , 0 , mux_stats , format ) ; if ( ret < 0 ) exit_program ( 1 ) ; } } else { ost -> encoder_opts = filter_codec_opts ( o -> g -> codec_opts , AV_CODEC_ID_NONE , oc , st , NULL ) ; } if ( o -> bitexact ) { ost -> bitexact = 1 ; } else if ( ost -> enc_ctx ) { ost -> bitexact = check_opt_bitexact ( ost -> enc_ctx , ost -> encoder_opts , \"flags\" , AV_CODEC_FLAG_BITEXACT ) ; } MATCH_PER_STREAM_OPT ( time_bases , str , time_base , oc , st ) ; if ( time_base ) { AVRational q ; if ( av_parse_ratio ( & q , time_base , INT_MAX , 0 , NULL ) < 0 || q . num <= 0 || q . den <= 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid time base: %s\\n\" , time_base ) ; exit_program ( 1 ) ; } st -> time_base = q ; } MATCH_PER_STREAM_OPT ( enc_time_bases , str , time_base , oc , st ) ; if ( time_base ) { AVRational q ; if ( av_parse_ratio ( & q , time_base , INT_MAX , 0 , NULL ) < 0 || q . den <= 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid time base: %s\\n\" , time_base ) ; exit_program ( 1 ) ; } ost -> enc_timebase = q ; } ms -> max_frames = INT64_MAX ; MATCH_PER_STREAM_OPT ( max_frames , i64 , ms -> max_frames , oc , st ) ; for ( i = 0 ; i < o -> nb_max_frames ; i ++ ) { char * p = o -> max_frames [ i ] . specifier ; if ( ! * p && type != AVMEDIA_TYPE_VIDEO ) { av_log ( ost , AV_LOG_WARNING , \"Applying unspecific -frames to non video streams, maybe you meant -vframes ?\\n\" ) ; break ; } } ost -> copy_prior_start = - 1 ; MATCH_PER_STREAM_OPT ( copy_prior_start , i , ost -> copy_prior_start , oc , st ) ; MATCH_PER_STREAM_OPT ( bitstream_filters , str , bsfs , oc , st ) ; if ( bsfs && * bsfs ) { ret = av_bsf_list_parse_str ( bsfs , & ms -> bsf_ctx ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error parsing bitstream filter sequence '%s': %s\\n\" , bsfs , av_err2str ( ret ) ) ; exit_program ( 1 ) ; } } MATCH_PER_STREAM_OPT ( codec_tags , str , codec_tag , oc , st ) ; if ( codec_tag ) { uint32_t tag = strtol ( codec_tag , & next , 0 ) ; if ( * next ) tag = AV_RL32 ( codec_tag ) ; ost -> st -> codecpar -> codec_tag = tag ; if ( ost -> enc_ctx ) ost -> enc_ctx -> codec_tag = tag ; } MATCH_PER_STREAM_OPT ( qscale , dbl , qscale , oc , st ) ; if ( ost -> enc_ctx && qscale >= 0 ) { ost -> enc_ctx -> flags |= AV_CODEC_FLAG_QSCALE ; ost -> enc_ctx -> global_quality = FF_QP2LAMBDA * qscale ; } ms -> max_muxing_queue_size = 128 ; MATCH_PER_STREAM_OPT ( max_muxing_queue_size , i , ms -> max_muxing_queue_size , oc , st ) ; ms -> muxing_queue_data_threshold = 50 * 1024 * 1024 ; MATCH_PER_STREAM_OPT ( muxing_queue_data_threshold , i , ms -> muxing_queue_data_threshold , oc , st ) ; MATCH_PER_STREAM_OPT ( bits_per_raw_sample , i , ost -> bits_per_raw_sample , oc , st ) ; MATCH_PER_STREAM_OPT ( fix_sub_duration_heartbeat , i , ost -> fix_sub_duration_heartbeat , oc , st ) ; if ( oc -> oformat -> flags & AVFMT_GLOBALHEADER && ost -> enc_ctx ) ost -> enc_ctx -> flags |= AV_CODEC_FLAG_GLOBAL_HEADER ; av_dict_copy ( & ost -> sws_dict , o -> g -> sws_dict , 0 ) ; av_dict_copy ( & ost -> swr_opts , o -> g -> swr_opts , 0 ) ; if ( ost -> enc_ctx && av_get_exact_bits_per_sample ( ost -> enc_ctx -> codec_id ) == 24 ) av_dict_set ( & ost -> swr_opts , \"output_sample_bits\" , \"24\" , 0 ) ; if ( ost -> ist ) { ost -> ist -> discard = 0 ; ost -> ist -> st -> discard = ost -> ist -> user_set_discard ; } ost -> last_mux_dts = AV_NOPTS_VALUE ; ost -> last_filter_pts = AV_NOPTS_VALUE ; MATCH_PER_STREAM_OPT ( copy_initial_nonkeyframes , i , ost -> copy_initial_nonkeyframes , oc , st ) ; return ost ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@get_ost_filters": "static char * get_ost_filters ( const OptionsContext * o , AVFormatContext * oc , OutputStream * ost ) { AVStream * st = ost -> st ; if ( ost -> filters_script && ost -> filters ) { av_log ( ost , AV_LOG_ERROR , \"Both -filter and -filter_script set\\n\" ) ; exit_program ( 1 ) ; } if ( ost -> filters_script ) return file_read ( ost -> filters_script ) ; else if ( ost -> filters ) return av_strdup ( ost -> filters ) ; return av_strdup ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ? \"null\" : \"anull\" ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@check_streamcopy_filters": "static void check_streamcopy_filters ( const OptionsContext * o , AVFormatContext * oc , OutputStream * ost , enum AVMediaType type ) { if ( ost -> filters_script || ost -> filters ) { av_log ( ost , AV_LOG_ERROR , \"%s '%s' was defined, but codec copy was selected.\\n\" \"Filtering and streamcopy cannot be used together.\\n\" , ost -> filters ? \"Filtergraph\" : \"Filtergraph script\" , ost -> filters ? ost -> filters : ost -> filters_script ) ; exit_program ( 1 ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@parse_matrix_coeffs": "static void parse_matrix_coeffs ( void * logctx , uint16_t * dest , const char * str ) { int i ; const char * p = str ; for ( i = 0 ; ; i ++ ) { dest [ i ] = atoi ( p ) ; if ( i == 63 ) break ; p = strchr ( p , ',' ) ; if ( ! p ) { av_log ( logctx , AV_LOG_FATAL , \"Syntax error in matrix \\\"%s\\\" at coeff %d\\n\" , str , i ) ; exit_program ( 1 ) ; } p ++ ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@new_video_stream": "static OutputStream * new_video_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { AVFormatContext * oc = mux -> fc ; AVStream * st ; OutputStream * ost ; char * frame_rate = NULL , * max_frame_rate = NULL , * frame_aspect_ratio = NULL ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_VIDEO , ist ) ; st = ost -> st ; MATCH_PER_STREAM_OPT ( frame_rates , str , frame_rate , oc , st ) ; if ( frame_rate && av_parse_video_rate ( & ost -> frame_rate , frame_rate ) < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid framerate value: %s\\n\" , frame_rate ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( max_frame_rates , str , max_frame_rate , oc , st ) ; if ( max_frame_rate && av_parse_video_rate ( & ost -> max_frame_rate , max_frame_rate ) < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid maximum framerate value: %s\\n\" , max_frame_rate ) ; exit_program ( 1 ) ; } if ( frame_rate && max_frame_rate ) { av_log ( ost , AV_LOG_ERROR , \"Only one of -fpsmax and -r can be set for a stream.\\n\" ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( frame_aspect_ratios , str , frame_aspect_ratio , oc , st ) ; if ( frame_aspect_ratio ) { AVRational q ; if ( av_parse_ratio ( & q , frame_aspect_ratio , 255 , 0 , NULL ) < 0 || q . num <= 0 || q . den <= 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid aspect ratio: %s\\n\" , frame_aspect_ratio ) ; exit_program ( 1 ) ; } ost -> frame_aspect_ratio = q ; } MATCH_PER_STREAM_OPT ( filter_scripts , str , ost -> filters_script , oc , st ) ; MATCH_PER_STREAM_OPT ( filters , str , ost -> filters , oc , st ) ; if ( ost -> enc_ctx ) { AVCodecContext * video_enc = ost -> enc_ctx ; const char * p = NULL , * fps_mode = NULL ; char * frame_size = NULL ; char * frame_pix_fmt = NULL ; char * intra_matrix = NULL , * inter_matrix = NULL ; char * chroma_intra_matrix = NULL ; int do_pass = 0 ; int i ; MATCH_PER_STREAM_OPT ( frame_sizes , str , frame_size , oc , st ) ; if ( frame_size && av_parse_video_size ( & video_enc -> width , & video_enc -> height , frame_size ) < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid frame size: %s.\\n\" , frame_size ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( frame_pix_fmts , str , frame_pix_fmt , oc , st ) ; if ( frame_pix_fmt && * frame_pix_fmt == '+' ) { ost -> keep_pix_fmt = 1 ; if ( ! * ++ frame_pix_fmt ) frame_pix_fmt = NULL ; } if ( frame_pix_fmt && ( video_enc -> pix_fmt = av_get_pix_fmt ( frame_pix_fmt ) ) == AV_PIX_FMT_NONE ) { av_log ( ost , AV_LOG_FATAL , \"Unknown pixel format requested: %s.\\n\" , frame_pix_fmt ) ; exit_program ( 1 ) ; } st -> sample_aspect_ratio = video_enc -> sample_aspect_ratio ; MATCH_PER_STREAM_OPT ( intra_matrices , str , intra_matrix , oc , st ) ; if ( intra_matrix ) { if ( ! ( video_enc -> intra_matrix = av_mallocz ( sizeof ( * video_enc -> intra_matrix ) * 64 ) ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; parse_matrix_coeffs ( ost , video_enc -> intra_matrix , intra_matrix ) ; } MATCH_PER_STREAM_OPT ( chroma_intra_matrices , str , chroma_intra_matrix , oc , st ) ; if ( chroma_intra_matrix ) { uint16_t * p = av_mallocz ( sizeof ( * video_enc -> chroma_intra_matrix ) * 64 ) ; if ( ! p ) report_and_exit ( AVERROR ( ENOMEM ) ) ; video_enc -> chroma_intra_matrix = p ; parse_matrix_coeffs ( ost , p , chroma_intra_matrix ) ; } MATCH_PER_STREAM_OPT ( inter_matrices , str , inter_matrix , oc , st ) ; if ( inter_matrix ) { if ( ! ( video_enc -> inter_matrix = av_mallocz ( sizeof ( * video_enc -> inter_matrix ) * 64 ) ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; parse_matrix_coeffs ( ost , video_enc -> inter_matrix , inter_matrix ) ; } MATCH_PER_STREAM_OPT ( rc_overrides , str , p , oc , st ) ; for ( i = 0 ; p ; i ++ ) { int start , end , q ; int e = sscanf ( p , \"%d,%d,%d\" , & start , & end , & q ) ; if ( e != 3 ) { av_log ( ost , AV_LOG_FATAL , \"error parsing rc_override\\n\" ) ; exit_program ( 1 ) ; } video_enc -> rc_override = av_realloc_array ( video_enc -> rc_override , i + 1 , sizeof ( RcOverride ) ) ; if ( ! video_enc -> rc_override ) { av_log ( ost , AV_LOG_FATAL , \"Could not (re)allocate memory for rc_override.\\n\" ) ; exit_program ( 1 ) ; } video_enc -> rc_override [ i ] . start_frame = start ; video_enc -> rc_override [ i ] . end_frame = end ; if ( q > 0 ) { video_enc -> rc_override [ i ] . qscale = q ; video_enc -> rc_override [ i ] . quality_factor = 1.0 ; } else { video_enc -> rc_override [ i ] . qscale = 0 ; video_enc -> rc_override [ i ] . quality_factor = - q / 100.0 ; } p = strchr ( p , '/' ) ; if ( p ) p ++ ; } video_enc -> rc_override_count = i ; # if FFMPEG_OPT_PSNR if ( do_psnr ) { av_log ( ost , AV_LOG_WARNING , \"The -psnr option is deprecated, use -flags +psnr\\n\" ) ; video_enc -> flags |= AV_CODEC_FLAG_PSNR ; } # endif /* two pass mode */ MATCH_PER_STREAM_OPT ( pass , i , do_pass , oc , st ) ; if ( do_pass ) { if ( do_pass & 1 ) { video_enc -> flags |= AV_CODEC_FLAG_PASS1 ; av_dict_set ( & ost -> encoder_opts , \"flags\" , \"+pass1\" , AV_DICT_APPEND ) ; } if ( do_pass & 2 ) { video_enc -> flags |= AV_CODEC_FLAG_PASS2 ; av_dict_set ( & ost -> encoder_opts , \"flags\" , \"+pass2\" , AV_DICT_APPEND ) ; } } MATCH_PER_STREAM_OPT ( passlogfiles , str , ost -> logfile_prefix , oc , st ) ; if ( ost -> logfile_prefix && ! ( ost -> logfile_prefix = av_strdup ( ost -> logfile_prefix ) ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; if ( do_pass ) { int ost_idx = - 1 ; char logfilename [ 1024 ] ; FILE * f ; /* compute this stream's global index */ for ( int i = 0 ; i <= ost -> file_index ; i ++ ) ost_idx += output_files [ i ] -> nb_streams ; snprintf ( logfilename , sizeof ( logfilename ) , \"%s-%d.log\" , ost -> logfile_prefix ? ost -> logfile_prefix : DEFAULT_PASS_LOGFILENAME_PREFIX , ost_idx ) ; if ( ! strcmp ( ost -> enc_ctx -> codec -> name , \"libx264\" ) ) { av_dict_set ( & ost -> encoder_opts , \"stats\" , logfilename , AV_DICT_DONT_OVERWRITE ) ; } else { if ( video_enc -> flags & AV_CODEC_FLAG_PASS2 ) { char * logbuffer = file_read ( logfilename ) ; if ( ! logbuffer ) { av_log ( ost , AV_LOG_FATAL , \"Error reading log file '%s' for pass-2 encoding\\n\" , logfilename ) ; exit_program ( 1 ) ; } video_enc -> stats_in = logbuffer ; } if ( video_enc -> flags & AV_CODEC_FLAG_PASS1 ) { f = fopen_utf8 ( logfilename , \"wb\" ) ; if ( ! f ) { av_log ( ost , AV_LOG_FATAL , \"Cannot write log file '%s' for pass-1 encoding: %s\\n\" , logfilename , strerror ( errno ) ) ; exit_program ( 1 ) ; } ost -> logfile = f ; } } } MATCH_PER_STREAM_OPT ( force_fps , i , ost -> force_fps , oc , st ) ; ost -> top_field_first = - 1 ; MATCH_PER_STREAM_OPT ( top_field_first , i , ost -> top_field_first , oc , st ) ; ost -> vsync_method = video_sync_method ; MATCH_PER_STREAM_OPT ( fps_mode , str , fps_mode , oc , st ) ; if ( fps_mode ) parse_and_set_vsync ( fps_mode , & ost -> vsync_method , ost -> file_index , ost -> index , 0 ) ; if ( ( ost -> frame_rate . num || ost -> max_frame_rate . num ) && ! ( ost -> vsync_method == VSYNC_AUTO || ost -> vsync_method == VSYNC_CFR || ost -> vsync_method == VSYNC_VSCFR ) ) { av_log ( ost , AV_LOG_FATAL , \"One of -r/-fpsmax was specified \" \"together a non-CFR -vsync/-fps_mode. This is contradictory.\\n\" ) ; exit_program ( 1 ) ; } if ( ost -> vsync_method == VSYNC_AUTO ) { if ( ost -> frame_rate . num || ost -> max_frame_rate . num ) { ost -> vsync_method = VSYNC_CFR ; } else if ( ! strcmp ( oc -> oformat -> name , \"avi\" ) ) { ost -> vsync_method = VSYNC_VFR ; } else { ost -> vsync_method = ( oc -> oformat -> flags & AVFMT_VARIABLE_FPS ) ? ( ( oc -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ? VSYNC_PASSTHROUGH : VSYNC_VFR ) : VSYNC_CFR ; } if ( ost -> ist && ost -> vsync_method == VSYNC_CFR ) { const InputFile * ifile = input_files [ ost -> ist -> file_index ] ; if ( ifile -> nb_streams == 1 && ifile -> input_ts_offset == 0 ) ost -> vsync_method = VSYNC_VSCFR ; } if ( ost -> vsync_method == VSYNC_CFR && copy_ts ) { ost -> vsync_method = VSYNC_VSCFR ; } } ost -> is_cfr = ( ost -> vsync_method == VSYNC_CFR || ost -> vsync_method == VSYNC_VSCFR ) ; ost -> avfilter = get_ost_filters ( o , oc , ost ) ; if ( ! ost -> avfilter ) exit_program ( 1 ) ; ost -> last_frame = av_frame_alloc ( ) ; if ( ! ost -> last_frame ) report_and_exit ( AVERROR ( ENOMEM ) ) ; } else check_streamcopy_filters ( o , oc , ost , AVMEDIA_TYPE_VIDEO ) ; return ost ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@new_audio_stream": "static OutputStream * new_audio_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { AVFormatContext * oc = mux -> fc ; AVStream * st ; OutputStream * ost ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_AUDIO , ist ) ; st = ost -> st ; MATCH_PER_STREAM_OPT ( filter_scripts , str , ost -> filters_script , oc , st ) ; MATCH_PER_STREAM_OPT ( filters , str , ost -> filters , oc , st ) ; if ( ost -> enc_ctx ) { AVCodecContext * audio_enc = ost -> enc_ctx ; int channels = 0 ; char * layout = NULL ; char * sample_fmt = NULL ; MATCH_PER_STREAM_OPT ( audio_channels , i , channels , oc , st ) ; if ( channels ) { audio_enc -> ch_layout . order = AV_CHANNEL_ORDER_UNSPEC ; audio_enc -> ch_layout . nb_channels = channels ; } MATCH_PER_STREAM_OPT ( audio_ch_layouts , str , layout , oc , st ) ; if ( layout ) { if ( av_channel_layout_from_string ( & audio_enc -> ch_layout , layout ) < 0 ) { # if FF_API_OLD_CHANNEL_LAYOUT uint64_t mask ; AV_NOWARN_DEPRECATED ( { mask = av_get_channel_layout ( layout ) ; } ) if ( ! mask ) { # endif av_log ( ost , AV_LOG_FATAL , \"Unknown channel layout: %s\\n\" , layout ) ; exit_program ( 1 ) ; # if FF_API_OLD_CHANNEL_LAYOUT } av_log ( ost , AV_LOG_WARNING , \"Channel layout '%s' uses a deprecated syntax.\\n\" , layout ) ; av_channel_layout_from_mask ( & audio_enc -> ch_layout , mask ) ; # endif } } MATCH_PER_STREAM_OPT ( sample_fmts , str , sample_fmt , oc , st ) ; if ( sample_fmt && ( audio_enc -> sample_fmt = av_get_sample_fmt ( sample_fmt ) ) == AV_SAMPLE_FMT_NONE ) { av_log ( ost , AV_LOG_FATAL , \"Invalid sample format '%s'\\n\" , sample_fmt ) ; exit_program ( 1 ) ; } MATCH_PER_STREAM_OPT ( audio_sample_rate , i , audio_enc -> sample_rate , oc , st ) ; MATCH_PER_STREAM_OPT ( apad , str , ost -> apad , oc , st ) ; ost -> apad = av_strdup ( ost -> apad ) ; ost -> avfilter = get_ost_filters ( o , oc , ost ) ; if ( ! ost -> avfilter ) exit_program ( 1 ) ; # if FFMPEG_OPT_MAP_CHANNEL /* check for channel mapping for this audio stream */ for ( int n = 0 ; n < o -> nb_audio_channel_maps ; n ++ ) { AudioChannelMap * map = & o -> audio_channel_maps [ n ] ; if ( ( map -> ofile_idx == - 1 || ost -> file_index == map -> ofile_idx ) && ( map -> ostream_idx == - 1 || ost -> st -> index == map -> ostream_idx ) ) { InputStream * ist ; if ( map -> channel_idx == - 1 ) { ist = NULL ; } else if ( ! ost -> ist ) { av_log ( ost , AV_LOG_FATAL , \"Cannot determine input stream for channel mapping %d.%d\\n\" , ost -> file_index , ost -> st -> index ) ; continue ; } else { ist = ost -> ist ; } if ( ! ist || ( ist -> file_index == map -> file_idx && ist -> st -> index == map -> stream_idx ) ) { if ( av_reallocp_array ( & ost -> audio_channels_map , ost -> audio_channels_mapped + 1 , sizeof ( * ost -> audio_channels_map ) ) < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; ost -> audio_channels_map [ ost -> audio_channels_mapped ++ ] = map -> channel_idx ; } } } # endif } else check_streamcopy_filters ( o , oc , ost , AVMEDIA_TYPE_AUDIO ) ; return ost ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@new_data_stream": "static OutputStream * new_data_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { OutputStream * ost ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_DATA , ist ) ; if ( ost -> enc_ctx ) { av_log ( ost , AV_LOG_FATAL , \"Data stream encoding not supported yet (only streamcopy)\\n\" ) ; exit_program ( 1 ) ; } return ost ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@new_unknown_stream": "static OutputStream * new_unknown_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { OutputStream * ost ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_UNKNOWN , ist ) ; if ( ost -> enc_ctx ) { av_log ( ost , AV_LOG_FATAL , \"Unknown stream encoding not supported yet (only streamcopy)\\n\" ) ; exit_program ( 1 ) ; } return ost ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@new_attachment_stream": "static OutputStream * new_attachment_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { OutputStream * ost = new_output_stream ( mux , o , AVMEDIA_TYPE_ATTACHMENT , ist ) ; ost -> finished = 1 ; return ost ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@new_subtitle_stream": "static OutputStream * new_subtitle_stream ( Muxer * mux , const OptionsContext * o , InputStream * ist ) { AVStream * st ; OutputStream * ost ; ost = new_output_stream ( mux , o , AVMEDIA_TYPE_SUBTITLE , ist ) ; st = ost -> st ; if ( ost -> enc_ctx ) { AVCodecContext * subtitle_enc = ost -> enc_ctx ; char * frame_size = NULL ; MATCH_PER_STREAM_OPT ( frame_sizes , str , frame_size , mux -> fc , st ) ; if ( frame_size && av_parse_video_size ( & subtitle_enc -> width , & subtitle_enc -> height , frame_size ) < 0 ) { av_log ( ost , AV_LOG_FATAL , \"Invalid frame size: %s.\\n\" , frame_size ) ; exit_program ( 1 ) ; } } return ost ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@init_output_filter": "static void init_output_filter ( OutputFilter * ofilter , const OptionsContext * o , Muxer * mux ) { OutputStream * ost ; switch ( ofilter -> type ) { case AVMEDIA_TYPE_VIDEO : ost = new_video_stream ( mux , o , NULL ) ; break ; case AVMEDIA_TYPE_AUDIO : ost = new_audio_stream ( mux , o , NULL ) ; break ; default : av_log ( mux , AV_LOG_FATAL , \"Only video and audio filters are supported \" \"currently.\\n\" ) ; exit_program ( 1 ) ; } ost -> filter = ofilter ; ofilter -> ost = ost ; ofilter -> format = - 1 ; if ( ! ost -> enc_ctx ) { av_log ( ost , AV_LOG_ERROR , \"Streamcopy requested for output stream fed \" \"from a complex filtergraph. Filtering and streamcopy \" \"cannot be used together.\\n\" ) ; exit_program ( 1 ) ; } if ( ost -> avfilter && ( ost -> filters || ost -> filters_script ) ) { const char * opt = ost -> filters ? \"-vf/-af/-filter\" : \"-filter_script\" ; av_log ( ost , AV_LOG_ERROR , \"%s '%s' was specified through the %s option \" \"for output stream %d:%d, which is fed from a complex filtergraph.\\n\" \"%s and -filter_complex cannot be used together for the same stream.\\n\" , ost -> filters ? \"Filtergraph\" : \"Filtergraph script\" , ost -> filters ? ost -> filters : ost -> filters_script , opt , ost -> file_index , ost -> index , opt ) ; exit_program ( 1 ) ; } avfilter_inout_free ( & ofilter -> out_tmp ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@map_auto_video": "static void map_auto_video ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; InputStream * best_ist = NULL ; int best_score = 0 ; int qcr ; /* video: highest resolution */ if ( av_guess_codec ( oc -> oformat , NULL , oc -> url , NULL , AVMEDIA_TYPE_VIDEO ) == AV_CODEC_ID_NONE ) return ; qcr = avformat_query_codec ( oc -> oformat , oc -> oformat -> video_codec , 0 ) ; for ( int j = 0 ; j < nb_input_files ; j ++ ) { InputFile * ifile = input_files [ j ] ; InputStream * file_best_ist = NULL ; int file_best_score = 0 ; for ( int i = 0 ; i < ifile -> nb_streams ; i ++ ) { InputStream * ist = ifile -> streams [ i ] ; int score ; if ( ist -> user_set_discard == AVDISCARD_ALL || ist -> st -> codecpar -> codec_type != AVMEDIA_TYPE_VIDEO ) continue ; score = ist -> st -> codecpar -> width * ist -> st -> codecpar -> height + 100000000 * ! ! ( ist -> st -> event_flags & AVSTREAM_EVENT_FLAG_NEW_PACKETS ) + 5000000 * ! ! ( ist -> st -> disposition & AV_DISPOSITION_DEFAULT ) ; if ( ( qcr != MKTAG ( 'A' , 'P' , 'I' , 'C' ) ) && ( ist -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) ) score = 1 ; if ( score > file_best_score ) { if ( ( qcr == MKTAG ( 'A' , 'P' , 'I' , 'C' ) ) && ! ( ist -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) ) continue ; file_best_score = score ; file_best_ist = ist ; } } if ( file_best_ist ) { if ( ( qcr == MKTAG ( 'A' , 'P' , 'I' , 'C' ) ) || ! ( file_best_ist -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) ) file_best_score -= 5000000 * ! ! ( file_best_ist -> st -> disposition & AV_DISPOSITION_DEFAULT ) ; if ( file_best_score > best_score ) { best_score = file_best_score ; best_ist = file_best_ist ; } } } if ( best_ist ) new_video_stream ( mux , o , best_ist ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@map_auto_audio": "static void map_auto_audio ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; InputStream * best_ist = NULL ; int best_score = 0 ; /* audio: most channels */ if ( av_guess_codec ( oc -> oformat , NULL , oc -> url , NULL , AVMEDIA_TYPE_AUDIO ) == AV_CODEC_ID_NONE ) return ; for ( int j = 0 ; j < nb_input_files ; j ++ ) { InputFile * ifile = input_files [ j ] ; InputStream * file_best_ist = NULL ; int file_best_score = 0 ; for ( int i = 0 ; i < ifile -> nb_streams ; i ++ ) { InputStream * ist = ifile -> streams [ i ] ; int score ; if ( ist -> user_set_discard == AVDISCARD_ALL || ist -> st -> codecpar -> codec_type != AVMEDIA_TYPE_AUDIO ) continue ; score = ist -> st -> codecpar -> ch_layout . nb_channels + 100000000 * ! ! ( ist -> st -> event_flags & AVSTREAM_EVENT_FLAG_NEW_PACKETS ) + 5000000 * ! ! ( ist -> st -> disposition & AV_DISPOSITION_DEFAULT ) ; if ( score > file_best_score ) { file_best_score = score ; file_best_ist = ist ; } } if ( file_best_ist ) { file_best_score -= 5000000 * ! ! ( file_best_ist -> st -> disposition & AV_DISPOSITION_DEFAULT ) ; if ( file_best_score > best_score ) { best_score = file_best_score ; best_ist = file_best_ist ; } } } if ( best_ist ) new_audio_stream ( mux , o , best_ist ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@map_auto_subtitle": "static void map_auto_subtitle ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; char * subtitle_codec_name = NULL ; /* subtitles: pick first */ MATCH_PER_TYPE_OPT ( codec_names , str , subtitle_codec_name , oc , \"s\" ) ; if ( ! avcodec_find_encoder ( oc -> oformat -> subtitle_codec ) && ! subtitle_codec_name ) return ; for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) if ( ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { AVCodecDescriptor const * input_descriptor = avcodec_descriptor_get ( ist -> st -> codecpar -> codec_id ) ; AVCodecDescriptor const * output_descriptor = NULL ; AVCodec const * output_codec = avcodec_find_encoder ( oc -> oformat -> subtitle_codec ) ; int input_props = 0 , output_props = 0 ; if ( ist -> user_set_discard == AVDISCARD_ALL ) continue ; if ( output_codec ) output_descriptor = avcodec_descriptor_get ( output_codec -> id ) ; if ( input_descriptor ) input_props = input_descriptor -> props & ( AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB ) ; if ( output_descriptor ) output_props = output_descriptor -> props & ( AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB ) ; if ( subtitle_codec_name || input_props & output_props || // Map dvb teletext which has neither property to any output subtitle encoder ( input_descriptor && output_descriptor && ( ! input_descriptor -> props || ! output_descriptor -> props ) ) ) { new_subtitle_stream ( mux , o , ist ) ; break ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@map_auto_data": "static void map_auto_data ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; /* Data only if codec id match */ enum AVCodecID codec_id = av_guess_codec ( oc -> oformat , NULL , oc -> url , NULL , AVMEDIA_TYPE_DATA ) ; if ( codec_id == AV_CODEC_ID_NONE ) return ; for ( InputStream * ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) { if ( ist -> user_set_discard == AVDISCARD_ALL ) continue ; if ( ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA && ist -> st -> codecpar -> codec_id == codec_id ) new_data_stream ( mux , o , ist ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@map_manual": "static void map_manual ( Muxer * mux , const OptionsContext * o , const StreamMap * map ) { InputStream * ist ; if ( map -> disabled ) return ; if ( map -> linklabel ) { FilterGraph * fg ; OutputFilter * ofilter = NULL ; int j , k ; for ( j = 0 ; j < nb_filtergraphs ; j ++ ) { fg = filtergraphs [ j ] ; for ( k = 0 ; k < fg -> nb_outputs ; k ++ ) { AVFilterInOut * out = fg -> outputs [ k ] -> out_tmp ; if ( out && ! strcmp ( out -> name , map -> linklabel ) ) { ofilter = fg -> outputs [ k ] ; goto loop_end ; } } } loop_end : if ( ! ofilter ) { av_log ( mux , AV_LOG_FATAL , \"Output with label '%s' does not exist \" \"in any defined filter graph, or was already used elsewhere.\\n\" , map -> linklabel ) ; exit_program ( 1 ) ; } init_output_filter ( ofilter , o , mux ) ; } else { ist = input_files [ map -> file_index ] -> streams [ map -> stream_index ] ; if ( ist -> user_set_discard == AVDISCARD_ALL ) { av_log ( mux , AV_LOG_FATAL , \"Stream #%d:%d is disabled and cannot be mapped.\\n\" , map -> file_index , map -> stream_index ) ; exit_program ( 1 ) ; } if ( o -> subtitle_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_SUBTITLE ) return ; if ( o -> audio_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) return ; if ( o -> video_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) return ; if ( o -> data_disable && ist -> st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) return ; switch ( ist -> st -> codecpar -> codec_type ) { case AVMEDIA_TYPE_VIDEO : new_video_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_AUDIO : new_audio_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_SUBTITLE : new_subtitle_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_DATA : new_data_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_ATTACHMENT : new_attachment_stream ( mux , o , ist ) ; break ; case AVMEDIA_TYPE_UNKNOWN : if ( copy_unknown_streams ) { new_unknown_stream ( mux , o , ist ) ; break ; } default : av_log ( mux , ignore_unknown_streams ? AV_LOG_WARNING : AV_LOG_FATAL , \"Cannot map stream #%d:%d - unsupported type.\\n\" , map -> file_index , map -> stream_index ) ; if ( ! ignore_unknown_streams ) { av_log ( mux , AV_LOG_FATAL , \"If you want unsupported types ignored instead \" \"of failing, please use the -ignore_unknown option\\n\" \"If you want them copied, please use -copy_unknown\\n\" ) ; exit_program ( 1 ) ; } } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@of_add_attachments": "static void of_add_attachments ( Muxer * mux , const OptionsContext * o ) { OutputStream * ost ; int err ; for ( int i = 0 ; i < o -> nb_attachments ; i ++ ) { AVIOContext * pb ; uint8_t * attachment ; const char * p ; int64_t len ; if ( ( err = avio_open2 ( & pb , o -> attachments [ i ] , AVIO_FLAG_READ , & int_cb , NULL ) ) < 0 ) { av_log ( mux , AV_LOG_FATAL , \"Could not open attachment file %s.\\n\" , o -> attachments [ i ] ) ; exit_program ( 1 ) ; } if ( ( len = avio_size ( pb ) ) <= 0 ) { av_log ( mux , AV_LOG_FATAL , \"Could not get size of the attachment %s.\\n\" , o -> attachments [ i ] ) ; exit_program ( 1 ) ; } if ( len > INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE || ! ( attachment = av_malloc ( len + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { av_log ( mux , AV_LOG_FATAL , \"Attachment %s too large.\\n\" , o -> attachments [ i ] ) ; exit_program ( 1 ) ; } avio_read ( pb , attachment , len ) ; memset ( attachment + len , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; ost = new_attachment_stream ( mux , o , NULL ) ; ost -> attachment_filename = o -> attachments [ i ] ; ost -> st -> codecpar -> extradata = attachment ; ost -> st -> codecpar -> extradata_size = len ; p = strrchr ( o -> attachments [ i ] , '/' ) ; av_dict_set ( & ost -> st -> metadata , \"filename\" , ( p && * p ) ? p + 1 : o -> attachments [ i ] , AV_DICT_DONT_OVERWRITE ) ; avio_closep ( & pb ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@create_streams": "static void create_streams ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; int auto_disable_v = o -> video_disable ; int auto_disable_a = o -> audio_disable ; int auto_disable_s = o -> subtitle_disable ; int auto_disable_d = o -> data_disable ; /* create streams for all unlabeled output pads */ for ( int i = 0 ; i < nb_filtergraphs ; i ++ ) { FilterGraph * fg = filtergraphs [ i ] ; for ( int j = 0 ; j < fg -> nb_outputs ; j ++ ) { OutputFilter * ofilter = fg -> outputs [ j ] ; if ( ! ofilter -> out_tmp || ofilter -> out_tmp -> name ) continue ; switch ( ofilter -> type ) { case AVMEDIA_TYPE_VIDEO : auto_disable_v = 1 ; break ; case AVMEDIA_TYPE_AUDIO : auto_disable_a = 1 ; break ; case AVMEDIA_TYPE_SUBTITLE : auto_disable_s = 1 ; break ; } init_output_filter ( ofilter , o , mux ) ; } } if ( ! o -> nb_stream_maps ) { /* pick the \"best\" stream of each type */ if ( ! auto_disable_v ) map_auto_video ( mux , o ) ; if ( ! auto_disable_a ) map_auto_audio ( mux , o ) ; if ( ! auto_disable_s ) map_auto_subtitle ( mux , o ) ; if ( ! auto_disable_d ) map_auto_data ( mux , o ) ; } else { for ( int i = 0 ; i < o -> nb_stream_maps ; i ++ ) map_manual ( mux , o , & o -> stream_maps [ i ] ) ; } of_add_attachments ( mux , o ) ; if ( ! oc -> nb_streams && ! ( oc -> oformat -> flags & AVFMT_NOSTREAMS ) ) { av_dump_format ( oc , nb_output_files - 1 , oc -> url , 1 ) ; av_log ( mux , AV_LOG_ERROR , \"Output file does not contain any stream\\n\" ) ; exit_program ( 1 ) ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@setup_sync_queues": "static int setup_sync_queues ( Muxer * mux , AVFormatContext * oc , int64_t buf_size_us ) { OutputFile * of = & mux -> of ; int nb_av_enc = 0 , nb_interleaved = 0 ; int limit_frames = 0 , limit_frames_av_enc = 0 ; # define IS_AV_ENC ( ost , type ) ( ost -> enc_ctx && ( type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO ) ) # define IS_INTERLEAVED ( type ) ( type != AVMEDIA_TYPE_ATTACHMENT ) for ( int i = 0 ; i < oc -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; MuxStream * ms = ms_from_ost ( ost ) ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; ost -> sq_idx_encode = - 1 ; ost -> sq_idx_mux = - 1 ; nb_interleaved += IS_INTERLEAVED ( type ) ; nb_av_enc += IS_AV_ENC ( ost , type ) ; limit_frames |= ms -> max_frames < INT64_MAX ; limit_frames_av_enc |= ( ms -> max_frames < INT64_MAX ) && IS_AV_ENC ( ost , type ) ; } if ( ! ( ( nb_interleaved > 1 && of -> shortest ) || ( nb_interleaved > 0 && limit_frames ) ) ) return 0 ; /* if we have more than one encoded audio/video streams, or at least\n     * one encoded audio/video stream is frame-limited, then we\n     * synchronize them before encoding */ if ( ( of -> shortest && nb_av_enc > 1 ) || limit_frames_av_enc ) { of -> sq_encode = sq_alloc ( SYNC_QUEUE_FRAMES , buf_size_us ) ; if ( ! of -> sq_encode ) return AVERROR ( ENOMEM ) ; for ( int i = 0 ; i < oc -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; MuxStream * ms = ms_from_ost ( ost ) ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; if ( ! IS_AV_ENC ( ost , type ) ) continue ; ost -> sq_idx_encode = sq_add_stream ( of -> sq_encode , of -> shortest || ms -> max_frames < INT64_MAX ) ; if ( ost -> sq_idx_encode < 0 ) return ost -> sq_idx_encode ; ost -> sq_frame = av_frame_alloc ( ) ; if ( ! ost -> sq_frame ) return AVERROR ( ENOMEM ) ; if ( ms -> max_frames != INT64_MAX ) sq_limit_frames ( of -> sq_encode , ost -> sq_idx_encode , ms -> max_frames ) ; } } /* if there are any additional interleaved streams, then ALL the streams\n     * are also synchronized before sending them to the muxer */ if ( nb_interleaved > nb_av_enc ) { mux -> sq_mux = sq_alloc ( SYNC_QUEUE_PACKETS , buf_size_us ) ; if ( ! mux -> sq_mux ) return AVERROR ( ENOMEM ) ; mux -> sq_pkt = av_packet_alloc ( ) ; if ( ! mux -> sq_pkt ) return AVERROR ( ENOMEM ) ; for ( int i = 0 ; i < oc -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; MuxStream * ms = ms_from_ost ( ost ) ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; if ( ! IS_INTERLEAVED ( type ) ) continue ; ost -> sq_idx_mux = sq_add_stream ( mux -> sq_mux , of -> shortest || ms -> max_frames < INT64_MAX ) ; if ( ost -> sq_idx_mux < 0 ) return ost -> sq_idx_mux ; if ( ms -> max_frames != INT64_MAX ) sq_limit_frames ( mux -> sq_mux , ost -> sq_idx_mux , ms -> max_frames ) ; } } # undef IS_AV_ENC # undef IS_INTERLEAVED return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@of_add_programs": "static void of_add_programs ( Muxer * mux , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; /* process manually set programs */ for ( int i = 0 ; i < o -> nb_program ; i ++ ) { const char * p = o -> program [ i ] . u . str ; int progid = i + 1 ; AVProgram * program ; while ( * p ) { const char * p2 = av_get_token ( & p , \":\" ) ; const char * to_dealloc = p2 ; char * key ; if ( ! p2 ) break ; if ( * p ) p ++ ; key = av_get_token ( & p2 , \"=\" ) ; if ( ! key || ! * p2 ) { av_freep ( & to_dealloc ) ; av_freep ( & key ) ; break ; } p2 ++ ; if ( ! strcmp ( key , \"program_num\" ) ) progid = strtol ( p2 , NULL , 0 ) ; av_freep ( & to_dealloc ) ; av_freep ( & key ) ; } program = av_new_program ( oc , progid ) ; if ( ! program ) report_and_exit ( AVERROR ( ENOMEM ) ) ; p = o -> program [ i ] . u . str ; while ( * p ) { const char * p2 = av_get_token ( & p , \":\" ) ; const char * to_dealloc = p2 ; char * key ; if ( ! p2 ) break ; if ( * p ) p ++ ; key = av_get_token ( & p2 , \"=\" ) ; if ( ! key ) { av_log ( mux , AV_LOG_FATAL , \"No '=' character in program string %s.\\n\" , p2 ) ; exit_program ( 1 ) ; } if ( ! * p2 ) exit_program ( 1 ) ; p2 ++ ; if ( ! strcmp ( key , \"title\" ) ) { av_dict_set ( & program -> metadata , \"title\" , p2 , 0 ) ; } else if ( ! strcmp ( key , \"program_num\" ) ) { } else if ( ! strcmp ( key , \"st\" ) ) { int st_num = strtol ( p2 , NULL , 0 ) ; av_program_add_stream_index ( oc , progid , st_num ) ; } else { av_log ( mux , AV_LOG_FATAL , \"Unknown program key %s.\\n\" , key ) ; exit_program ( 1 ) ; } av_freep ( & to_dealloc ) ; av_freep ( & key ) ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@parse_meta_type": "static void parse_meta_type ( void * logctx , const char * arg , char * type , int * index , const char * * stream_spec ) { if ( * arg ) { * type = * arg ; switch ( * arg ) { case 'g' : break ; case 's' : if ( * ( ++ arg ) && * arg != ':' ) { av_log ( logctx , AV_LOG_FATAL , \"Invalid metadata specifier %s.\\n\" , arg ) ; exit_program ( 1 ) ; } * stream_spec = * arg == ':' ? arg + 1 : \"\" ; break ; case 'c' : case 'p' : if ( * ( ++ arg ) == ':' ) * index = strtol ( ++ arg , NULL , 0 ) ; break ; default : av_log ( logctx , AV_LOG_FATAL , \"Invalid metadata type %c.\\n\" , * arg ) ; exit_program ( 1 ) ; } } else * type = 'g' ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@of_add_metadata": "static void of_add_metadata ( OutputFile * of , AVFormatContext * oc , const OptionsContext * o ) { for ( int i = 0 ; i < o -> nb_metadata ; i ++ ) { AVDictionary * * m ; char type , * val ; const char * stream_spec ; int index = 0 , ret = 0 ; val = strchr ( o -> metadata [ i ] . u . str , '=' ) ; if ( ! val ) { av_log ( of , AV_LOG_FATAL , \"No '=' character in metadata string %s.\\n\" , o -> metadata [ i ] . u . str ) ; exit_program ( 1 ) ; } * val ++ = 0 ; parse_meta_type ( of , o -> metadata [ i ] . specifier , & type , & index , & stream_spec ) ; if ( type == 's' ) { for ( int j = 0 ; j < oc -> nb_streams ; j ++ ) { OutputStream * ost = of -> streams [ j ] ; if ( ( ret = check_stream_specifier ( oc , oc -> streams [ j ] , stream_spec ) ) > 0 ) { # if FFMPEG_ROTATION_METADATA if ( ! strcmp ( o -> metadata [ i ] . u . str , \"rotate\" ) ) { char * tail ; double theta = av_strtod ( val , & tail ) ; if ( ! * tail ) { ost -> rotate_overridden = 1 ; ost -> rotate_override_value = theta ; } av_log ( ost , AV_LOG_WARNING , \"Conversion of a 'rotate' metadata key to a \" \"proper display matrix rotation is deprecated. \" \"See -display_rotation for setting rotation \" \"instead.\" ) ; } else { # endif av_dict_set ( & oc -> streams [ j ] -> metadata , o -> metadata [ i ] . u . str , * val ? val : NULL , 0 ) ; # if FFMPEG_ROTATION_METADATA } # endif } else if ( ret < 0 ) exit_program ( 1 ) ; } } else { switch ( type ) { case 'g' : m = & oc -> metadata ; break ; case 'c' : if ( index < 0 || index >= oc -> nb_chapters ) { av_log ( of , AV_LOG_FATAL , \"Invalid chapter index %d in metadata specifier.\\n\" , index ) ; exit_program ( 1 ) ; } m = & oc -> chapters [ index ] -> metadata ; break ; case 'p' : if ( index < 0 || index >= oc -> nb_programs ) { av_log ( of , AV_LOG_FATAL , \"Invalid program index %d in metadata specifier.\\n\" , index ) ; exit_program ( 1 ) ; } m = & oc -> programs [ index ] -> metadata ; break ; default : av_log ( of , AV_LOG_FATAL , \"Invalid metadata specifier %s.\\n\" , o -> metadata [ i ] . specifier ) ; exit_program ( 1 ) ; } av_dict_set ( m , o -> metadata [ i ] . u . str , * val ? val : NULL , 0 ) ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@set_channel_layout": "static void set_channel_layout ( OutputFilter * f , OutputStream * ost ) { const AVCodec * c = ost -> enc_ctx -> codec ; int i , err ; if ( ost -> enc_ctx -> ch_layout . order != AV_CHANNEL_ORDER_UNSPEC ) { /* Pass the layout through for all orders but UNSPEC */ err = av_channel_layout_copy ( & f -> ch_layout , & ost -> enc_ctx -> ch_layout ) ; if ( err < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return ; } /* Requested layout is of order UNSPEC */ if ( ! c -> ch_layouts ) { /* Use the default native layout for the requested amount of channels when the\n           encoder doesn't have a list of supported layouts */ av_channel_layout_default ( & f -> ch_layout , ost -> enc_ctx -> ch_layout . nb_channels ) ; return ; } /* Encoder has a list of supported layouts. Pick the first layout in it with the\n       same amount of channels as the requested layout */ for ( i = 0 ; c -> ch_layouts [ i ] . nb_channels ; i ++ ) { if ( c -> ch_layouts [ i ] . nb_channels == ost -> enc_ctx -> ch_layout . nb_channels ) break ; } if ( c -> ch_layouts [ i ] . nb_channels ) { /* Use it if one is found */ err = av_channel_layout_copy ( & f -> ch_layout , & c -> ch_layouts [ i ] ) ; if ( err < 0 ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return ; } /* If no layout for the amount of channels requested was found, use the default\n       native layout for it. */ av_channel_layout_default ( & f -> ch_layout , ost -> enc_ctx -> ch_layout . nb_channels ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@copy_chapters": "static int copy_chapters ( InputFile * ifile , OutputFile * ofile , AVFormatContext * os , int copy_metadata ) { AVFormatContext * is = ifile -> ctx ; AVChapter * * tmp ; int i ; tmp = av_realloc_f ( os -> chapters , is -> nb_chapters + os -> nb_chapters , sizeof ( * os -> chapters ) ) ; if ( ! tmp ) return AVERROR ( ENOMEM ) ; os -> chapters = tmp ; for ( i = 0 ; i < is -> nb_chapters ; i ++ ) { AVChapter * in_ch = is -> chapters [ i ] , * out_ch ; int64_t start_time = ( ofile -> start_time == AV_NOPTS_VALUE ) ? 0 : ofile -> start_time ; int64_t ts_off = av_rescale_q ( start_time - ifile -> ts_offset , AV_TIME_BASE_Q , in_ch -> time_base ) ; int64_t rt = ( ofile -> recording_time == INT64_MAX ) ? INT64_MAX : av_rescale_q ( ofile -> recording_time , AV_TIME_BASE_Q , in_ch -> time_base ) ; if ( in_ch -> end < ts_off ) continue ; if ( rt != INT64_MAX && in_ch -> start > rt + ts_off ) break ; out_ch = av_mallocz ( sizeof ( AVChapter ) ) ; if ( ! out_ch ) return AVERROR ( ENOMEM ) ; out_ch -> id = in_ch -> id ; out_ch -> time_base = in_ch -> time_base ; out_ch -> start = FFMAX ( 0 , in_ch -> start - ts_off ) ; out_ch -> end = FFMIN ( rt , in_ch -> end - ts_off ) ; if ( copy_metadata ) av_dict_copy ( & out_ch -> metadata , in_ch -> metadata , 0 ) ; os -> chapters [ os -> nb_chapters ++ ] = out_ch ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@copy_metadata": "static int copy_metadata ( Muxer * mux , AVFormatContext * ic , const char * outspec , const char * inspec , int * metadata_global_manual , int * metadata_streams_manual , int * metadata_chapters_manual , const OptionsContext * o ) { AVFormatContext * oc = mux -> fc ; AVDictionary * * meta_in = NULL ; AVDictionary * * meta_out = NULL ; int i , ret = 0 ; char type_in , type_out ; const char * istream_spec = NULL , * ostream_spec = NULL ; int idx_in = 0 , idx_out = 0 ; parse_meta_type ( mux , inspec , & type_in , & idx_in , & istream_spec ) ; parse_meta_type ( mux , outspec , & type_out , & idx_out , & ostream_spec ) ; if ( type_in == 'g' || type_out == 'g' ) * metadata_global_manual = 1 ; if ( type_in == 's' || type_out == 's' ) * metadata_streams_manual = 1 ; if ( type_in == 'c' || type_out == 'c' ) * metadata_chapters_manual = 1 ; /* ic is NULL when just disabling automatic mappings */ if ( ! ic ) return 0 ; # define METADATA_CHECK_INDEX ( index , nb_elems , desc ) if ( ( index ) < 0 || ( index ) >= ( nb_elems ) ) { av_log ( mux , AV_LOG_FATAL , \"Invalid %s index %d while processing metadata maps.\\n\" , ( desc ) , ( index ) ) ; exit_program ( 1 ) ; } # define SET_DICT ( type , meta , context , index ) switch ( type ) { case 'g' : meta = & context -> metadata ; break ; case 'c' : METADATA_CHECK_INDEX ( index , context -> nb_chapters , \"chapter\" ) meta = & context -> chapters [ index ] -> metadata ; break ; case 'p' : METADATA_CHECK_INDEX ( index , context -> nb_programs , \"program\" ) meta = & context -> programs [ index ] -> metadata ; break ; case 's' : break ; /* handled separately below */ default : av_assert0 ( 0 ) ; } SET_DICT ( type_in , meta_in , ic , idx_in ) ; SET_DICT ( type_out , meta_out , oc , idx_out ) ; /* for input streams choose first matching stream */ if ( type_in == 's' ) { for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { if ( ( ret = check_stream_specifier ( ic , ic -> streams [ i ] , istream_spec ) ) > 0 ) { meta_in = & ic -> streams [ i ] -> metadata ; break ; } else if ( ret < 0 ) exit_program ( 1 ) ; } if ( ! meta_in ) { av_log ( mux , AV_LOG_FATAL , \"Stream specifier %s does not match  any streams.\\n\" , istream_spec ) ; exit_program ( 1 ) ; } } if ( type_out == 's' ) { for ( i = 0 ; i < oc -> nb_streams ; i ++ ) { if ( ( ret = check_stream_specifier ( oc , oc -> streams [ i ] , ostream_spec ) ) > 0 ) { meta_out = & oc -> streams [ i ] -> metadata ; av_dict_copy ( meta_out , * meta_in , AV_DICT_DONT_OVERWRITE ) ; } else if ( ret < 0 ) exit_program ( 1 ) ; } } else av_dict_copy ( meta_out , * meta_in , AV_DICT_DONT_OVERWRITE ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@copy_meta": "static void copy_meta ( Muxer * mux , const OptionsContext * o ) { OutputFile * of = & mux -> of ; AVFormatContext * oc = mux -> fc ; int chapters_input_file = o -> chapters_input_file ; int metadata_global_manual = 0 ; int metadata_streams_manual = 0 ; int metadata_chapters_manual = 0 ; /* copy metadata */ for ( int i = 0 ; i < o -> nb_metadata_map ; i ++ ) { char * p ; int in_file_index = strtol ( o -> metadata_map [ i ] . u . str , & p , 0 ) ; if ( in_file_index >= nb_input_files ) { av_log ( mux , AV_LOG_FATAL , \"Invalid input file index %d while \" \"processing metadata maps\\n\" , in_file_index ) ; exit_program ( 1 ) ; } copy_metadata ( mux , in_file_index >= 0 ? input_files [ in_file_index ] -> ctx : NULL , o -> metadata_map [ i ] . specifier , * p ? p + 1 : p , & metadata_global_manual , & metadata_streams_manual , & metadata_chapters_manual , o ) ; } /* copy chapters */ if ( chapters_input_file >= nb_input_files ) { if ( chapters_input_file == INT_MAX ) { /* copy chapters from the first input file that has them*/ chapters_input_file = - 1 ; for ( int i = 0 ; i < nb_input_files ; i ++ ) if ( input_files [ i ] -> ctx -> nb_chapters ) { chapters_input_file = i ; break ; } } else { av_log ( mux , AV_LOG_FATAL , \"Invalid input file index %d in chapter mapping.\\n\" , chapters_input_file ) ; exit_program ( 1 ) ; } } if ( chapters_input_file >= 0 ) copy_chapters ( input_files [ chapters_input_file ] , of , oc , ! metadata_chapters_manual ) ; /* copy global metadata by default */ if ( ! metadata_global_manual && nb_input_files ) { av_dict_copy ( & oc -> metadata , input_files [ 0 ] -> ctx -> metadata , AV_DICT_DONT_OVERWRITE ) ; if ( of -> recording_time != INT64_MAX ) av_dict_set ( & oc -> metadata , \"duration\" , NULL , 0 ) ; av_dict_set ( & oc -> metadata , \"creation_time\" , NULL , 0 ) ; av_dict_set ( & oc -> metadata , \"company_name\" , NULL , 0 ) ; av_dict_set ( & oc -> metadata , \"product_name\" , NULL , 0 ) ; av_dict_set ( & oc -> metadata , \"product_version\" , NULL , 0 ) ; } if ( ! metadata_streams_manual ) for ( int i = 0 ; i < of -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; if ( ! ost -> ist ) /* this is true e.g. for attached files */ continue ; av_dict_copy ( & ost -> st -> metadata , ost -> ist -> st -> metadata , AV_DICT_DONT_OVERWRITE ) ; if ( ost -> enc_ctx ) { av_dict_set ( & ost -> st -> metadata , \"encoder\" , NULL , 0 ) ; } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@set_dispositions": "static int set_dispositions ( Muxer * mux , const OptionsContext * o ) { OutputFile * of = & mux -> of ; AVFormatContext * ctx = mux -> fc ; int nb_streams [ AVMEDIA_TYPE_NB ] = { 0 } ; int have_default [ AVMEDIA_TYPE_NB ] = { 0 } ; int have_manual = 0 ; int ret = 0 ; const char * * dispositions ; dispositions = av_calloc ( ctx -> nb_streams , sizeof ( * dispositions ) ) ; if ( ! dispositions ) return AVERROR ( ENOMEM ) ; // first, copy the input dispositions for ( int i = 0 ; i < ctx -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; nb_streams [ ost -> st -> codecpar -> codec_type ] ++ ; MATCH_PER_STREAM_OPT ( disposition , str , dispositions [ i ] , ctx , ost -> st ) ; have_manual |= ! ! dispositions [ i ] ; if ( ost -> ist ) { ost -> st -> disposition = ost -> ist -> st -> disposition ; if ( ost -> st -> disposition & AV_DISPOSITION_DEFAULT ) have_default [ ost -> st -> codecpar -> codec_type ] = 1 ; } } if ( have_manual ) { // process manually set dispositions - they override the above copy for ( int i = 0 ; i < ctx -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; const char * disp = dispositions [ i ] ; if ( ! disp ) continue ; ret = av_opt_set ( ost -> st , \"disposition\" , disp , 0 ) ; if ( ret < 0 ) goto finish ; } } else { // For each media type with more than one stream, find a suitable stream to // mark as default, unless one is already marked default. // \"Suitable\" means the first of that type, skipping attached pictures. for ( int i = 0 ; i < ctx -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; enum AVMediaType type = ost -> st -> codecpar -> codec_type ; if ( nb_streams [ type ] < 2 || have_default [ type ] || ost -> st -> disposition & AV_DISPOSITION_ATTACHED_PIC ) continue ; ost -> st -> disposition |= AV_DISPOSITION_DEFAULT ; have_default [ type ] = 1 ; } } finish : av_freep ( & dispositions ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@compare_int64": "static int compare_int64 ( const void * a , const void * b ) { return FFDIFFSIGN ( * ( const int64_t * ) a , * ( const int64_t * ) b ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@parse_forced_key_frames": "static void parse_forced_key_frames ( KeyframeForceCtx * kf , const Muxer * mux , const char * spec ) { const char * p ; int n = 1 , i , size , index = 0 ; int64_t t , * pts ; for ( p = spec ; * p ; p ++ ) if ( * p == ',' ) n ++ ; size = n ; pts = av_malloc_array ( size , sizeof ( * pts ) ) ; if ( ! pts ) report_and_exit ( AVERROR ( ENOMEM ) ) ; p = spec ; for ( i = 0 ; i < n ; i ++ ) { char * next = strchr ( p , ',' ) ; if ( next ) * next ++ = 0 ; if ( ! memcmp ( p , \"chapters\" , 8 ) ) { AVChapter * const * ch = mux -> fc -> chapters ; unsigned int nb_ch = mux -> fc -> nb_chapters ; int j ; if ( nb_ch > INT_MAX - size || ! ( pts = av_realloc_f ( pts , size += nb_ch - 1 , sizeof ( * pts ) ) ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; t = p [ 8 ] ? parse_time_or_die ( \"force_key_frames\" , p + 8 , 1 ) : 0 ; for ( j = 0 ; j < nb_ch ; j ++ ) { const AVChapter * c = ch [ j ] ; av_assert1 ( index < size ) ; pts [ index ++ ] = av_rescale_q ( c -> start , c -> time_base , AV_TIME_BASE_Q ) + t ; } } else { av_assert1 ( index < size ) ; pts [ index ++ ] = parse_time_or_die ( \"force_key_frames\" , p , 1 ) ; } p = next ; } av_assert0 ( index == size ) ; qsort ( pts , size , sizeof ( * pts ) , compare_int64 ) ; kf -> nb_pts = size ; kf -> pts = pts ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@process_forced_keyframes": "static int process_forced_keyframes ( Muxer * mux , const OptionsContext * o ) { for ( int i = 0 ; i < mux -> of . nb_streams ; i ++ ) { OutputStream * ost = mux -> of . streams [ i ] ; const char * forced_keyframes = NULL ; MATCH_PER_STREAM_OPT ( forced_key_frames , str , forced_keyframes , mux -> fc , ost -> st ) ; if ( ! ( ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && ost -> enc_ctx && forced_keyframes ) ) continue ; if ( ! strncmp ( forced_keyframes , \"expr:\" , 5 ) ) { int ret = av_expr_parse ( & ost -> kf . pexpr , forced_keyframes + 5 , forced_keyframes_const_names , NULL , NULL , NULL , NULL , 0 , NULL ) ; if ( ret < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Invalid force_key_frames expression '%s'\\n\" , forced_keyframes + 5 ) ; return ret ; } ost -> kf . expr_const_values [ FKF_N ] = 0 ; ost -> kf . expr_const_values [ FKF_N_FORCED ] = 0 ; ost -> kf . expr_const_values [ FKF_PREV_FORCED_N ] = NAN ; ost -> kf . expr_const_values [ FKF_PREV_FORCED_T ] = NAN ; // Don't parse the 'forced_keyframes' in case of 'keep-source-keyframes', // parse it only for static kf timings } else if ( ! strcmp ( forced_keyframes , \"source\" ) ) { ost -> kf . type = KF_FORCE_SOURCE ; } else if ( ! strcmp ( forced_keyframes , \"source_no_drop\" ) ) { ost -> kf . type = KF_FORCE_SOURCE_NO_DROP ; } else { parse_forced_key_frames ( & ost -> kf , mux , forced_keyframes ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@validate_enc_avopt": "static void validate_enc_avopt ( Muxer * mux , const AVDictionary * codec_avopt ) { const AVClass * class = avcodec_get_class ( ) ; const AVClass * fclass = avformat_get_class ( ) ; const OutputFile * of = & mux -> of ; AVDictionary * unused_opts ; const AVDictionaryEntry * e ; unused_opts = strip_specifiers ( codec_avopt ) ; for ( int i = 0 ; i < of -> nb_streams ; i ++ ) { e = NULL ; while ( ( e = av_dict_iterate ( of -> streams [ i ] -> encoder_opts , e ) ) ) av_dict_set ( & unused_opts , e -> key , NULL , 0 ) ; } e = NULL ; while ( ( e = av_dict_iterate ( unused_opts , e ) ) ) { const AVOption * option = av_opt_find ( & class , e -> key , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ; const AVOption * foption = av_opt_find ( & fclass , e -> key , NULL , 0 , AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ ) ; if ( ! option || foption ) continue ; if ( ! ( option -> flags & AV_OPT_FLAG_ENCODING_PARAM ) ) { av_log ( mux , AV_LOG_ERROR , \"Codec AVOption %s (%s) is not an \" \"encoding option.\\n\" , e -> key , option -> help ? option -> help : \"\" ) ; exit_program ( 1 ) ; } // gop_timecode is injected by generic code but not always used if ( ! strcmp ( e -> key , \"gop_timecode\" ) ) continue ; av_log ( mux , AV_LOG_WARNING , \"Codec AVOption %s (%s) has not been used \" \"for any stream. The most likely reason is either wrong type \" \"(e.g. a video option with no video streams) or that it is a \" \"private option of some encoder which was not actually used for \" \"any stream.\\n\" , e -> key , option -> help ? option -> help : \"\" ) ; } av_dict_free ( & unused_opts ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@output_file_item_name": "static const char * output_file_item_name ( void * obj ) { const Muxer * mux = obj ; return mux -> log_name ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@mux_alloc": "static Muxer * mux_alloc ( void ) { Muxer * mux = allocate_array_elem ( & output_files , sizeof ( * mux ) , & nb_output_files ) ; mux -> of . clazz = & output_file_class ; mux -> of . index = nb_output_files - 1 ; snprintf ( mux -> log_name , sizeof ( mux -> log_name ) , \"out#%d\" , mux -> of . index ) ; return mux ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux_init.c@of_open": "int of_open ( const OptionsContext * o , const char * filename ) { Muxer * mux ; AVFormatContext * oc ; int err ; OutputFile * of ; int64_t recording_time = o -> recording_time ; int64_t stop_time = o -> stop_time ; mux = mux_alloc ( ) ; of = & mux -> of ; if ( stop_time != INT64_MAX && recording_time != INT64_MAX ) { stop_time = INT64_MAX ; av_log ( mux , AV_LOG_WARNING , \"-t and -to cannot be used together; using -t.\\n\" ) ; } if ( stop_time != INT64_MAX && recording_time == INT64_MAX ) { int64_t start_time = o -> start_time == AV_NOPTS_VALUE ? 0 : o -> start_time ; if ( stop_time <= start_time ) { av_log ( mux , AV_LOG_ERROR , \"-to value smaller than -ss; aborting.\\n\" ) ; exit_program ( 1 ) ; } else { recording_time = stop_time - start_time ; } } of -> recording_time = recording_time ; of -> start_time = o -> start_time ; of -> shortest = o -> shortest ; mux -> thread_queue_size = o -> thread_queue_size > 0 ? o -> thread_queue_size : 8 ; mux -> limit_filesize = o -> limit_filesize ; av_dict_copy ( & mux -> opts , o -> g -> format_opts , 0 ) ; if ( ! strcmp ( filename , \"-\" ) ) filename = \"pipe:\" ; err = avformat_alloc_output_context2 ( & oc , NULL , o -> format , filename ) ; if ( ! oc ) { print_error ( filename , err ) ; exit_program ( 1 ) ; } mux -> fc = oc ; av_strlcat ( mux -> log_name , \"/\" , sizeof ( mux -> log_name ) ) ; av_strlcat ( mux -> log_name , oc -> oformat -> name , sizeof ( mux -> log_name ) ) ; if ( strcmp ( oc -> oformat -> name , \"rtp\" ) ) want_sdp = 0 ; of -> format = oc -> oformat ; if ( recording_time != INT64_MAX ) oc -> duration = recording_time ; oc -> interrupt_callback = int_cb ; if ( o -> bitexact ) { oc -> flags |= AVFMT_FLAG_BITEXACT ; of -> bitexact = 1 ; } else { of -> bitexact = check_opt_bitexact ( oc , mux -> opts , \"fflags\" , AVFMT_FLAG_BITEXACT ) ; } /* create all output streams for this file */ create_streams ( mux , o ) ; /* check if all codec options have been used */ validate_enc_avopt ( mux , o -> g -> codec_opts ) ; /* set the decoding_needed flags and create simple filtergraphs */ for ( int i = 0 ; i < of -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; if ( ost -> enc_ctx && ost -> ist ) { InputStream * ist = ost -> ist ; ist -> decoding_needed |= DECODING_FOR_OST ; ist -> processing_needed = 1 ; if ( ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO || ost -> st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { err = init_simple_filtergraph ( ist , ost ) ; if ( err < 0 ) { av_log ( ost , AV_LOG_ERROR , \"Error initializing a simple filtergraph\\n\" ) ; exit_program ( 1 ) ; } } } else if ( ost -> ist ) { ost -> ist -> processing_needed = 1 ; } /* set the filter output constraints */ if ( ost -> filter ) { const AVCodec * c = ost -> enc_ctx -> codec ; OutputFilter * f = ost -> filter ; switch ( ost -> enc_ctx -> codec_type ) { case AVMEDIA_TYPE_VIDEO : f -> frame_rate = ost -> frame_rate ; f -> width = ost -> enc_ctx -> width ; f -> height = ost -> enc_ctx -> height ; if ( ost -> enc_ctx -> pix_fmt != AV_PIX_FMT_NONE ) { f -> format = ost -> enc_ctx -> pix_fmt ; } else { f -> formats = c -> pix_fmts ; } break ; case AVMEDIA_TYPE_AUDIO : if ( ost -> enc_ctx -> sample_fmt != AV_SAMPLE_FMT_NONE ) { f -> format = ost -> enc_ctx -> sample_fmt ; } else { f -> formats = c -> sample_fmts ; } if ( ost -> enc_ctx -> sample_rate ) { f -> sample_rate = ost -> enc_ctx -> sample_rate ; } else { f -> sample_rates = c -> supported_samplerates ; } if ( ost -> enc_ctx -> ch_layout . nb_channels ) { set_channel_layout ( f , ost ) ; } else if ( c -> ch_layouts ) { f -> ch_layouts = c -> ch_layouts ; } break ; } } } /* check filename in case of an image number is expected */ if ( oc -> oformat -> flags & AVFMT_NEEDNUMBER ) { if ( ! av_filename_number_test ( oc -> url ) ) { print_error ( oc -> url , AVERROR ( EINVAL ) ) ; exit_program ( 1 ) ; } } if ( ! ( oc -> oformat -> flags & AVFMT_NOFILE ) ) { /* test if it already exists to avoid losing precious files */ assert_file_overwrite ( filename ) ; /* open the file */ if ( ( err = avio_open2 ( & oc -> pb , filename , AVIO_FLAG_WRITE , & oc -> interrupt_callback , & mux -> opts ) ) < 0 ) { print_error ( filename , err ) ; exit_program ( 1 ) ; } } else if ( strcmp ( oc -> oformat -> name , \"image2\" ) == 0 && ! av_filename_number_test ( filename ) ) assert_file_overwrite ( filename ) ; if ( o -> mux_preload ) { av_dict_set_int ( & mux -> opts , \"preload\" , o -> mux_preload * AV_TIME_BASE , 0 ) ; } oc -> max_delay = ( int ) ( o -> mux_max_delay * AV_TIME_BASE ) ; /* copy metadata and chapters from input files */ copy_meta ( mux , o ) ; of_add_programs ( mux , o ) ; of_add_metadata ( of , oc , o ) ; err = set_dispositions ( mux , o ) ; if ( err < 0 ) { av_log ( mux , AV_LOG_FATAL , \"Error setting output stream dispositions\\n\" ) ; exit_program ( 1 ) ; } // parse forced keyframe specifications; // must be done after chapters are created err = process_forced_keyframes ( mux , o ) ; if ( err < 0 ) { av_log ( mux , AV_LOG_FATAL , \"Error processing forced keyframes\\n\" ) ; exit_program ( 1 ) ; } err = setup_sync_queues ( mux , oc , o -> shortest_buf_duration * AV_TIME_BASE ) ; if ( err < 0 ) { av_log ( mux , AV_LOG_FATAL , \"Error setting up output sync queues\\n\" ) ; exit_program ( 1 ) ; } of -> url = filename ; /* write the header for files with no streams */ if ( of -> format -> flags & AVFMT_NOSTREAMS && oc -> nb_streams == 0 ) { int ret = mux_check_init ( mux ) ; if ( ret < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@get_compliance_normal_pix_fmts": "static const enum AVPixelFormat * get_compliance_normal_pix_fmts ( const AVCodec * codec , const enum AVPixelFormat default_formats [ ] ) { static const enum AVPixelFormat mjpeg_formats [ ] = { AV_PIX_FMT_YUVJ420P , AV_PIX_FMT_YUVJ422P , AV_PIX_FMT_YUVJ444P , AV_PIX_FMT_NONE } ; if ( ! strcmp ( codec -> name , \"mjpeg\" ) ) { return mjpeg_formats ; } else { return default_formats ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@choose_pixel_fmt": "enum AVPixelFormat choose_pixel_fmt ( const AVCodec * codec , enum AVPixelFormat target , int strict_std_compliance ) { if ( codec && codec -> pix_fmts ) { const enum AVPixelFormat * p = codec -> pix_fmts ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( target ) ; //FIXME: This should check for AV_PIX_FMT_FLAG_ALPHA after PAL8 pixel format without alpha is implemented int has_alpha = desc ? desc -> nb_components % 2 == 0 : 0 ; enum AVPixelFormat best = AV_PIX_FMT_NONE ; if ( strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL ) { p = get_compliance_normal_pix_fmts ( codec , p ) ; } for ( ; * p != AV_PIX_FMT_NONE ; p ++ ) { best = av_find_best_pix_fmt_of_2 ( best , * p , target , has_alpha , NULL ) ; if ( * p == target ) break ; } if ( * p == AV_PIX_FMT_NONE ) { if ( target != AV_PIX_FMT_NONE ) av_log ( NULL , AV_LOG_WARNING , \"Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\\n\" , av_get_pix_fmt_name ( target ) , codec -> name , av_get_pix_fmt_name ( best ) ) ; return best ; } } return target ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@choose_pix_fmts": "static const char * choose_pix_fmts ( OutputFilter * ofilter , AVBPrint * bprint ) { OutputStream * ost = ofilter -> ost ; AVCodecContext * enc = ost -> enc_ctx ; const AVDictionaryEntry * strict_dict = av_dict_get ( ost -> encoder_opts , \"strict\" , NULL , 0 ) ; if ( strict_dict ) // used by choose_pixel_fmt() and below av_opt_set ( ost -> enc_ctx , \"strict\" , strict_dict -> value , 0 ) ; if ( ost -> keep_pix_fmt ) { avfilter_graph_set_auto_convert ( ofilter -> graph -> graph , AVFILTER_AUTO_CONVERT_NONE ) ; if ( ost -> enc_ctx -> pix_fmt == AV_PIX_FMT_NONE ) return NULL ; return av_get_pix_fmt_name ( ost -> enc_ctx -> pix_fmt ) ; } if ( ost -> enc_ctx -> pix_fmt != AV_PIX_FMT_NONE ) { return av_get_pix_fmt_name ( choose_pixel_fmt ( enc -> codec , enc -> pix_fmt , ost -> enc_ctx -> strict_std_compliance ) ) ; } else if ( enc -> codec -> pix_fmts ) { const enum AVPixelFormat * p ; p = enc -> codec -> pix_fmts ; if ( ost -> enc_ctx -> strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL ) { p = get_compliance_normal_pix_fmts ( enc -> codec , p ) ; } for ( ; * p != AV_PIX_FMT_NONE ; p ++ ) { const char * name = av_get_pix_fmt_name ( * p ) ; av_bprintf ( bprint , \"%s%c\" , name , p [ 1 ] == AV_PIX_FMT_NONE ? '\\0' : '|' ) ; } if ( ! av_bprint_is_complete ( bprint ) ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return bprint -> str ; } else return NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@choose_sample_fmts": "static void choose_ ## name ( OutputFilter * ofilter , AVBPrint * bprint ) \\\n{ if ( ofilter -> var == none && ! ofilter -> supported_list ) return ; av_bprintf ( bprint , # name \"=\" ) ; if ( ofilter -> var != none ) { av_bprintf ( bprint , printf_format , get_name ( ofilter -> var ) ) ; } else { const type * p ; for ( p = ofilter -> supported_list ; * p != none ; p ++ ) { av_bprintf ( bprint , printf_format \"|\" , get_name ( * p ) ) ; } if ( bprint -> len > 0 ) bprint -> str [ -- bprint -> len ] = '\\0' ; } av_bprint_chars ( bprint , ':' , 1 ) ; \\\n} //DEF_CHOOSE_FORMAT(pix_fmts, enum AVPixelFormat, format, formats, AV_PIX_FMT_NONE, //                  GET_PIX_FMT_NAME) DEF_CHOOSE_FORMAT ( sample_fmts , enum AVSampleFormat , format , formats , AV_SAMPLE_FMT_NONE , \"%s\" , av_get_sample_fmt_name )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@choose_sample_rates": "static void choose_ ## name ( OutputFilter * ofilter , AVBPrint * bprint ) \\\n{ if ( ofilter -> var == none && ! ofilter -> supported_list ) return ; av_bprintf ( bprint , # name \"=\" ) ; if ( ofilter -> var != none ) { av_bprintf ( bprint , printf_format , get_name ( ofilter -> var ) ) ; } else { const type * p ; for ( p = ofilter -> supported_list ; * p != none ; p ++ ) { av_bprintf ( bprint , printf_format \"|\" , get_name ( * p ) ) ; } if ( bprint -> len > 0 ) bprint -> str [ -- bprint -> len ] = '\\0' ; } av_bprint_chars ( bprint , ':' , 1 ) ; \\\n} //DEF_CHOOSE_FORMAT(pix_fmts, enum AVPixelFormat, format, formats, AV_PIX_FMT_NONE, //                  GET_PIX_FMT_NAME) DEF_CHOOSE_FORMAT ( sample_fmts , enum AVSampleFormat , format , formats , AV_SAMPLE_FMT_NONE , \"%s\" , av_get_sample_fmt_name ) DEF_CHOOSE_FORMAT ( sample_rates , int , sample_rate , sample_rates , 0 , \"%d\" , )",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@choose_channel_layouts": "static void choose_channel_layouts ( OutputFilter * ofilter , AVBPrint * bprint ) { if ( av_channel_layout_check ( & ofilter -> ch_layout ) ) { av_bprintf ( bprint , \"channel_layouts=\" ) ; av_channel_layout_describe_bprint ( & ofilter -> ch_layout , bprint ) ; } else if ( ofilter -> ch_layouts ) { const AVChannelLayout * p ; av_bprintf ( bprint , \"channel_layouts=\" ) ; for ( p = ofilter -> ch_layouts ; p -> nb_channels ; p ++ ) { av_channel_layout_describe_bprint ( p , bprint ) ; av_bprintf ( bprint , \"|\" ) ; } if ( bprint -> len > 0 ) bprint -> str [ -- bprint -> len ] = '\\0' ; } else return ; av_bprint_chars ( bprint , ':' , 1 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@init_simple_filtergraph": "int init_simple_filtergraph ( InputStream * ist , OutputStream * ost ) { FilterGraph * fg = av_mallocz ( sizeof ( * fg ) ) ; OutputFilter * ofilter ; InputFilter * ifilter ; if ( ! fg ) report_and_exit ( AVERROR ( ENOMEM ) ) ; fg -> index = nb_filtergraphs ; ofilter = ALLOC_ARRAY_ELEM ( fg -> outputs , fg -> nb_outputs ) ; ofilter -> ost = ost ; ofilter -> graph = fg ; ofilter -> format = - 1 ; ost -> filter = ofilter ; ifilter = ALLOC_ARRAY_ELEM ( fg -> inputs , fg -> nb_inputs ) ; ifilter -> ist = ist ; ifilter -> graph = fg ; ifilter -> format = - 1 ; ifilter -> frame_queue = av_fifo_alloc2 ( 8 , sizeof ( AVFrame * ) , AV_FIFO_FLAG_AUTO_GROW ) ; if ( ! ifilter -> frame_queue ) report_and_exit ( AVERROR ( ENOMEM ) ) ; GROW_ARRAY ( ist -> filters , ist -> nb_filters ) ; ist -> filters [ ist -> nb_filters - 1 ] = ifilter ; GROW_ARRAY ( filtergraphs , nb_filtergraphs ) ; filtergraphs [ nb_filtergraphs - 1 ] = fg ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@describe_filter_link": "static char * describe_filter_link ( FilterGraph * fg , AVFilterInOut * inout , int in ) { AVFilterContext * ctx = inout -> filter_ctx ; AVFilterPad * pads = in ? ctx -> input_pads : ctx -> output_pads ; int nb_pads = in ? ctx -> nb_inputs : ctx -> nb_outputs ; char * res ; if ( nb_pads > 1 ) res = av_strdup ( ctx -> filter -> name ) ; else res = av_asprintf ( \"%s:%s\" , ctx -> filter -> name , avfilter_pad_get_name ( pads , inout -> pad_idx ) ) ; if ( ! res ) report_and_exit ( AVERROR ( ENOMEM ) ) ; return res ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@init_input_filter": "static void init_input_filter ( FilterGraph * fg , AVFilterInOut * in ) { InputStream * ist = NULL ; enum AVMediaType type = avfilter_pad_get_type ( in -> filter_ctx -> input_pads , in -> pad_idx ) ; InputFilter * ifilter ; int i ; // TODO: support other filter types if ( type != AVMEDIA_TYPE_VIDEO && type != AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_FATAL , \"Only video and audio filters supported \" \"currently.\\n\" ) ; exit_program ( 1 ) ; } if ( in -> name ) { AVFormatContext * s ; AVStream * st = NULL ; char * p ; int file_idx = strtol ( in -> name , & p , 0 ) ; if ( file_idx < 0 || file_idx >= nb_input_files ) { av_log ( NULL , AV_LOG_FATAL , \"Invalid file index %d in filtergraph description %s.\\n\" , file_idx , fg -> graph_desc ) ; exit_program ( 1 ) ; } s = input_files [ file_idx ] -> ctx ; for ( i = 0 ; i < s -> nb_streams ; i ++ ) { enum AVMediaType stream_type = s -> streams [ i ] -> codecpar -> codec_type ; if ( stream_type != type && ! ( stream_type == AVMEDIA_TYPE_SUBTITLE && type == AVMEDIA_TYPE_VIDEO /* sub2video hack */ ) ) continue ; if ( check_stream_specifier ( s , s -> streams [ i ] , * p == ':' ? p + 1 : p ) == 1 ) { st = s -> streams [ i ] ; break ; } } if ( ! st ) { av_log ( NULL , AV_LOG_FATAL , \"Stream specifier '%s' in filtergraph description %s \" \"matches no streams.\\n\" , p , fg -> graph_desc ) ; exit_program ( 1 ) ; } ist = input_files [ file_idx ] -> streams [ st -> index ] ; if ( ist -> user_set_discard == AVDISCARD_ALL ) { av_log ( NULL , AV_LOG_FATAL , \"Stream specifier '%s' in filtergraph description %s \" \"matches a disabled input stream.\\n\" , p , fg -> graph_desc ) ; exit_program ( 1 ) ; } } else { /* find the first unused stream of corresponding type */ for ( ist = ist_iter ( NULL ) ; ist ; ist = ist_iter ( ist ) ) { if ( ist -> user_set_discard == AVDISCARD_ALL ) continue ; if ( ist -> dec_ctx -> codec_type == type && ist -> discard ) break ; } if ( ! ist ) { av_log ( NULL , AV_LOG_FATAL , \"Cannot find a matching stream for \" \"unlabeled input pad %d on filter %s\\n\" , in -> pad_idx , in -> filter_ctx -> name ) ; exit_program ( 1 ) ; } } av_assert0 ( ist ) ; ist -> discard = 0 ; ist -> decoding_needed |= DECODING_FOR_FILTER ; ist -> processing_needed = 1 ; ist -> st -> discard = AVDISCARD_NONE ; ifilter = ALLOC_ARRAY_ELEM ( fg -> inputs , fg -> nb_inputs ) ; ifilter -> ist = ist ; ifilter -> graph = fg ; ifilter -> format = - 1 ; ifilter -> type = ist -> st -> codecpar -> codec_type ; ifilter -> name = describe_filter_link ( fg , in , 1 ) ; ifilter -> frame_queue = av_fifo_alloc2 ( 8 , sizeof ( AVFrame * ) , AV_FIFO_FLAG_AUTO_GROW ) ; if ( ! ifilter -> frame_queue ) report_and_exit ( AVERROR ( ENOMEM ) ) ; GROW_ARRAY ( ist -> filters , ist -> nb_filters ) ; ist -> filters [ ist -> nb_filters - 1 ] = ifilter ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@read_binary": "static int read_binary ( const char * path , uint8_t * * data , int * len ) { AVIOContext * io = NULL ; int64_t fsize ; int ret ; * data = NULL ; * len = 0 ; ret = avio_open2 ( & io , path , AVIO_FLAG_READ , & int_cb , NULL ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot open file '%s': %s\\n\" , path , av_err2str ( ret ) ) ; return ret ; } fsize = avio_size ( io ) ; if ( fsize < 0 || fsize > INT_MAX ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot obtain size of file %s\\n\" , path ) ; ret = AVERROR ( EIO ) ; goto fail ; } * data = av_malloc ( fsize ) ; if ( ! * data ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } ret = avio_read ( io , * data , fsize ) ; if ( ret != fsize ) { av_log ( NULL , AV_LOG_ERROR , \"Error reading file %s\\n\" , path ) ; ret = ret < 0 ? ret : AVERROR ( EIO ) ; goto fail ; } * len = fsize ; return 0 ; fail : avio_close ( io ) ; av_freep ( data ) ; * len = 0 ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@filter_opt_apply": "static int filter_opt_apply ( AVFilterContext * f , const char * key , const char * val ) { const AVOption * o = NULL ; int ret ; ret = av_opt_set ( f , key , val , AV_OPT_SEARCH_CHILDREN ) ; if ( ret >= 0 ) return 0 ; if ( ret == AVERROR_OPTION_NOT_FOUND && key [ 0 ] == '/' ) o = av_opt_find ( f , key + 1 , NULL , 0 , AV_OPT_SEARCH_CHILDREN ) ; if ( ! o ) goto err_apply ; // key is a valid option name prefixed with '/' // interpret value as a path from which to load the actual option value key ++ ; if ( o -> type == AV_OPT_TYPE_BINARY ) { uint8_t * data ; int len ; ret = read_binary ( val , & data , & len ) ; if ( ret < 0 ) goto err_load ; ret = av_opt_set_bin ( f , key , data , len , AV_OPT_SEARCH_CHILDREN ) ; av_freep ( & data ) ; } else { char * data = file_read ( val ) ; if ( ! data ) { ret = AVERROR ( EIO ) ; goto err_load ; } ret = av_opt_set ( f , key , data , AV_OPT_SEARCH_CHILDREN ) ; av_freep ( & data ) ; } if ( ret < 0 ) goto err_apply ; return 0 ; err_apply : av_log ( NULL , AV_LOG_ERROR , \"Error applying option '%s' to filter '%s': %s\\n\" , key , f -> filter -> name , av_err2str ( ret ) ) ; return ret ; err_load : av_log ( NULL , AV_LOG_ERROR , \"Error loading value for option '%s' from file '%s'\\n\" , key , val ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@graph_opts_apply": "static int graph_opts_apply ( AVFilterGraphSegment * seg ) { for ( size_t i = 0 ; i < seg -> nb_chains ; i ++ ) { AVFilterChain * ch = seg -> chains [ i ] ; for ( size_t j = 0 ; j < ch -> nb_filters ; j ++ ) { AVFilterParams * p = ch -> filters [ j ] ; const AVDictionaryEntry * e = NULL ; av_assert0 ( p -> filter ) ; while ( ( e = av_dict_iterate ( p -> opts , e ) ) ) { int ret = filter_opt_apply ( p -> filter , e -> key , e -> value ) ; if ( ret < 0 ) return ret ; } av_dict_free ( & p -> opts ) ; } } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@graph_parse": "static int graph_parse ( AVFilterGraph * graph , const char * desc , AVFilterInOut * * inputs , AVFilterInOut * * outputs ) { AVFilterGraphSegment * seg ; int ret ; ret = avfilter_graph_segment_parse ( graph , desc , 0 , & seg ) ; if ( ret < 0 ) return ret ; ret = avfilter_graph_segment_create_filters ( seg , 0 ) ; if ( ret < 0 ) goto fail ; ret = graph_opts_apply ( seg ) ; if ( ret < 0 ) goto fail ; ret = avfilter_graph_segment_apply ( seg , 0 , inputs , outputs ) ; fail : avfilter_graph_segment_free ( & seg ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@init_complex_filtergraph": "int init_complex_filtergraph ( FilterGraph * fg ) { AVFilterInOut * inputs , * outputs , * cur ; AVFilterGraph * graph ; int ret = 0 ; /* this graph is only used for determining the kinds of inputs\n     * and outputs we have, and is discarded on exit from this function */ graph = avfilter_graph_alloc ( ) ; if ( ! graph ) return AVERROR ( ENOMEM ) ; graph -> nb_threads = 1 ; ret = graph_parse ( graph , fg -> graph_desc , & inputs , & outputs ) ; if ( ret < 0 ) goto fail ; for ( cur = inputs ; cur ; cur = cur -> next ) init_input_filter ( fg , cur ) ; for ( cur = outputs ; cur ; ) { OutputFilter * const ofilter = ALLOC_ARRAY_ELEM ( fg -> outputs , fg -> nb_outputs ) ; ofilter -> graph = fg ; ofilter -> out_tmp = cur ; ofilter -> type = avfilter_pad_get_type ( cur -> filter_ctx -> output_pads , cur -> pad_idx ) ; ofilter -> name = describe_filter_link ( fg , cur , 0 ) ; cur = cur -> next ; ofilter -> out_tmp -> next = NULL ; } fail : avfilter_inout_free ( & inputs ) ; avfilter_graph_free ( & graph ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@insert_trim": "static int insert_trim ( int64_t start_time , int64_t duration , AVFilterContext * * last_filter , int * pad_idx , const char * filter_name ) { AVFilterGraph * graph = ( * last_filter ) -> graph ; AVFilterContext * ctx ; const AVFilter * trim ; enum AVMediaType type = avfilter_pad_get_type ( ( * last_filter ) -> output_pads , * pad_idx ) ; const char * name = ( type == AVMEDIA_TYPE_VIDEO ) ? \"trim\" : \"atrim\" ; int ret = 0 ; if ( duration == INT64_MAX && start_time == AV_NOPTS_VALUE ) return 0 ; trim = avfilter_get_by_name ( name ) ; if ( ! trim ) { av_log ( NULL , AV_LOG_ERROR , \"%s filter not present, cannot limit \" \"recording time.\\n\" , name ) ; return AVERROR_FILTER_NOT_FOUND ; } ctx = avfilter_graph_alloc_filter ( graph , trim , filter_name ) ; if ( ! ctx ) return AVERROR ( ENOMEM ) ; if ( duration != INT64_MAX ) { ret = av_opt_set_int ( ctx , \"durationi\" , duration , AV_OPT_SEARCH_CHILDREN ) ; } if ( ret >= 0 && start_time != AV_NOPTS_VALUE ) { ret = av_opt_set_int ( ctx , \"starti\" , start_time , AV_OPT_SEARCH_CHILDREN ) ; } if ( ret < 0 ) { av_log ( ctx , AV_LOG_ERROR , \"Error configuring the %s filter\" , name ) ; return ret ; } ret = avfilter_init_str ( ctx , NULL ) ; if ( ret < 0 ) return ret ; ret = avfilter_link ( * last_filter , * pad_idx , ctx , 0 ) ; if ( ret < 0 ) return ret ; * last_filter = ctx ; * pad_idx = 0 ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@insert_filter": "static int insert_filter ( AVFilterContext * * last_filter , int * pad_idx , const char * filter_name , const char * args ) { AVFilterGraph * graph = ( * last_filter ) -> graph ; AVFilterContext * ctx ; int ret ; ret = avfilter_graph_create_filter ( & ctx , avfilter_get_by_name ( filter_name ) , filter_name , args , NULL , graph ) ; if ( ret < 0 ) return ret ; ret = avfilter_link ( * last_filter , * pad_idx , ctx , 0 ) ; if ( ret < 0 ) return ret ; * last_filter = ctx ; * pad_idx = 0 ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@configure_output_video_filter": "static int configure_output_video_filter ( FilterGraph * fg , OutputFilter * ofilter , AVFilterInOut * out ) { OutputStream * ost = ofilter -> ost ; OutputFile * of = output_files [ ost -> file_index ] ; AVFilterContext * last_filter = out -> filter_ctx ; AVBPrint bprint ; int pad_idx = out -> pad_idx ; int ret ; const char * pix_fmts ; char name [ 255 ] ; snprintf ( name , sizeof ( name ) , \"out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = avfilter_graph_create_filter ( & ofilter -> filter , avfilter_get_by_name ( \"buffersink\" ) , name , NULL , NULL , fg -> graph ) ; if ( ret < 0 ) return ret ; if ( ( ofilter -> width || ofilter -> height ) && ofilter -> ost -> autoscale ) { char args [ 255 ] ; AVFilterContext * filter ; const AVDictionaryEntry * e = NULL ; snprintf ( args , sizeof ( args ) , \"%d:%d\" , ofilter -> width , ofilter -> height ) ; while ( ( e = av_dict_iterate ( ost -> sws_dict , e ) ) ) { av_strlcatf ( args , sizeof ( args ) , \":%s=%s\" , e -> key , e -> value ) ; } snprintf ( name , sizeof ( name ) , \"scaler_out_%d_%d\" , ost -> file_index , ost -> index ) ; if ( ( ret = avfilter_graph_create_filter ( & filter , avfilter_get_by_name ( \"scale\" ) , name , args , NULL , fg -> graph ) ) < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , pad_idx , filter , 0 ) ) < 0 ) return ret ; last_filter = filter ; pad_idx = 0 ; } av_bprint_init ( & bprint , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; if ( ( pix_fmts = choose_pix_fmts ( ofilter , & bprint ) ) ) { AVFilterContext * filter ; ret = avfilter_graph_create_filter ( & filter , avfilter_get_by_name ( \"format\" ) , \"format\" , pix_fmts , NULL , fg -> graph ) ; av_bprint_finalize ( & bprint , NULL ) ; if ( ret < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , pad_idx , filter , 0 ) ) < 0 ) return ret ; last_filter = filter ; pad_idx = 0 ; } if ( ost -> frame_rate . num && 0 ) { AVFilterContext * fps ; char args [ 255 ] ; snprintf ( args , sizeof ( args ) , \"fps=%d/%d\" , ost -> frame_rate . num , ost -> frame_rate . den ) ; snprintf ( name , sizeof ( name ) , \"fps_out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = avfilter_graph_create_filter ( & fps , avfilter_get_by_name ( \"fps\" ) , name , args , NULL , fg -> graph ) ; if ( ret < 0 ) return ret ; ret = avfilter_link ( last_filter , pad_idx , fps , 0 ) ; if ( ret < 0 ) return ret ; last_filter = fps ; pad_idx = 0 ; } snprintf ( name , sizeof ( name ) , \"trim_out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = insert_trim ( of -> start_time , of -> recording_time , & last_filter , & pad_idx , name ) ; if ( ret < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , pad_idx , ofilter -> filter , 0 ) ) < 0 ) return ret ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@configure_output_audio_filter": "static int configure_output_audio_filter ( FilterGraph * fg , OutputFilter * ofilter , AVFilterInOut * out ) { OutputStream * ost = ofilter -> ost ; OutputFile * of = output_files [ ost -> file_index ] ; AVCodecContext * codec = ost -> enc_ctx ; AVFilterContext * last_filter = out -> filter_ctx ; int pad_idx = out -> pad_idx ; AVBPrint args ; char name [ 255 ] ; int ret ; snprintf ( name , sizeof ( name ) , \"out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = avfilter_graph_create_filter ( & ofilter -> filter , avfilter_get_by_name ( \"abuffersink\" ) , name , NULL , NULL , fg -> graph ) ; if ( ret < 0 ) return ret ; if ( ( ret = av_opt_set_int ( ofilter -> filter , \"all_channel_counts\" , 1 , AV_OPT_SEARCH_CHILDREN ) ) < 0 ) return ret ; # define AUTO_INSERT_FILTER ( opt_name , filter_name , arg ) do { AVFilterContext * filt_ctx ; av_log ( NULL , AV_LOG_INFO , opt_name \" is forwarded to lavfi \" \"similarly to -af \" filter_name \"=%s.\\n\" , arg ) ; ret = avfilter_graph_create_filter ( & filt_ctx , avfilter_get_by_name ( filter_name ) , filter_name , arg , NULL , fg -> graph ) ; if ( ret < 0 ) goto fail ; ret = avfilter_link ( last_filter , pad_idx , filt_ctx , 0 ) ; if ( ret < 0 ) goto fail ; last_filter = filt_ctx ; pad_idx = 0 ; \\\n} while ( 0 ) av_bprint_init ( & args , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; # if FFMPEG_OPT_MAP_CHANNEL if ( ost -> audio_channels_mapped ) { AVChannelLayout mapped_layout = { 0 } ; int i ; av_channel_layout_default ( & mapped_layout , ost -> audio_channels_mapped ) ; av_channel_layout_describe_bprint ( & mapped_layout , & args ) ; for ( i = 0 ; i < ost -> audio_channels_mapped ; i ++ ) if ( ost -> audio_channels_map [ i ] != - 1 ) av_bprintf ( & args , \"|c%d=c%d\" , i , ost -> audio_channels_map [ i ] ) ; AUTO_INSERT_FILTER ( \"-map_channel\" , \"pan\" , args . str ) ; av_bprint_clear ( & args ) ; } # endif if ( codec -> ch_layout . order == AV_CHANNEL_ORDER_UNSPEC ) av_channel_layout_default ( & codec -> ch_layout , codec -> ch_layout . nb_channels ) ; choose_sample_fmts ( ofilter , & args ) ; choose_sample_rates ( ofilter , & args ) ; choose_channel_layouts ( ofilter , & args ) ; if ( ! av_bprint_is_complete ( & args ) ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } if ( args . len ) { AVFilterContext * format ; snprintf ( name , sizeof ( name ) , \"format_out_%d_%d\" , ost -> file_index , ost -> index ) ; ret = avfilter_graph_create_filter ( & format , avfilter_get_by_name ( \"aformat\" ) , name , args . str , NULL , fg -> graph ) ; if ( ret < 0 ) goto fail ; ret = avfilter_link ( last_filter , pad_idx , format , 0 ) ; if ( ret < 0 ) goto fail ; last_filter = format ; pad_idx = 0 ; } if ( ost -> apad && of -> shortest ) { int i ; for ( i = 0 ; i < of -> nb_streams ; i ++ ) if ( of -> streams [ i ] -> st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) break ; if ( i < of -> nb_streams ) { AUTO_INSERT_FILTER ( \"-apad\" , \"apad\" , ost -> apad ) ; } } snprintf ( name , sizeof ( name ) , \"trim for output stream %d:%d\" , ost -> file_index , ost -> index ) ; ret = insert_trim ( of -> start_time , of -> recording_time , & last_filter , & pad_idx , name ) ; if ( ret < 0 ) goto fail ; if ( ( ret = avfilter_link ( last_filter , pad_idx , ofilter -> filter , 0 ) ) < 0 ) goto fail ; fail : av_bprint_finalize ( & args , NULL ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@configure_output_filter": "int configure_output_filter ( FilterGraph * fg , OutputFilter * ofilter , AVFilterInOut * out ) { if ( ! ofilter -> ost ) { av_log ( NULL , AV_LOG_FATAL , \"Filter %s has an unconnected output\\n\" , ofilter -> name ) ; exit_program ( 1 ) ; } switch ( avfilter_pad_get_type ( out -> filter_ctx -> output_pads , out -> pad_idx ) ) { case AVMEDIA_TYPE_VIDEO : return configure_output_video_filter ( fg , ofilter , out ) ; case AVMEDIA_TYPE_AUDIO : return configure_output_audio_filter ( fg , ofilter , out ) ; default : av_assert0 ( 0 ) ; return 0 ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@check_filter_outputs": "void check_filter_outputs ( void ) { int i ; for ( i = 0 ; i < nb_filtergraphs ; i ++ ) { int n ; for ( n = 0 ; n < filtergraphs [ i ] -> nb_outputs ; n ++ ) { OutputFilter * output = filtergraphs [ i ] -> outputs [ n ] ; if ( ! output -> ost ) { av_log ( NULL , AV_LOG_FATAL , \"Filter %s has an unconnected output\\n\" , output -> name ) ; exit_program ( 1 ) ; } } } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@sub2video_prepare": "static int sub2video_prepare ( InputStream * ist , InputFilter * ifilter ) { AVFormatContext * avf = input_files [ ist -> file_index ] -> ctx ; int i , w , h ; /* Compute the size of the canvas for the subtitles stream.\n       If the subtitles codecpar has set a size, use it. Otherwise use the\n       maximum dimensions of the video streams in the same file. */ w = ifilter -> width ; h = ifilter -> height ; if ( ! ( w && h ) ) { for ( i = 0 ; i < avf -> nb_streams ; i ++ ) { if ( avf -> streams [ i ] -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { w = FFMAX ( w , avf -> streams [ i ] -> codecpar -> width ) ; h = FFMAX ( h , avf -> streams [ i ] -> codecpar -> height ) ; } } if ( ! ( w && h ) ) { w = FFMAX ( w , 720 ) ; h = FFMAX ( h , 576 ) ; } av_log ( avf , AV_LOG_INFO , \"sub2video: using %dx%d canvas\\n\" , w , h ) ; } ist -> sub2video . w = ifilter -> width = w ; ist -> sub2video . h = ifilter -> height = h ; ifilter -> width = ist -> dec_ctx -> width ? ist -> dec_ctx -> width : ist -> sub2video . w ; ifilter -> height = ist -> dec_ctx -> height ? ist -> dec_ctx -> height : ist -> sub2video . h ; /* rectangles are AV_PIX_FMT_PAL8, but we have no guarantee that the\n       palettes for all rectangles are identical or compatible */ ifilter -> format = AV_PIX_FMT_RGB32 ; ist -> sub2video . frame = av_frame_alloc ( ) ; if ( ! ist -> sub2video . frame ) return AVERROR ( ENOMEM ) ; ist -> sub2video . last_pts = INT64_MIN ; ist -> sub2video . end_pts = INT64_MIN ; /* sub2video structure has been (re-)initialized.\n       Mark it as such so that the system will be\n       initialized with the first received heartbeat. */ ist -> sub2video . initialize = 1 ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@configure_input_video_filter": "static int configure_input_video_filter ( FilterGraph * fg , InputFilter * ifilter , AVFilterInOut * in ) { AVFilterContext * last_filter ; const AVFilter * buffer_filt = avfilter_get_by_name ( \"buffer\" ) ; const AVPixFmtDescriptor * desc ; InputStream * ist = ifilter -> ist ; InputFile * f = input_files [ ist -> file_index ] ; AVRational tb = ist -> framerate . num ? av_inv_q ( ist -> framerate ) : ist -> st -> time_base ; AVRational fr = ist -> framerate ; AVRational sar ; AVBPrint args ; char name [ 255 ] ; int ret , pad_idx = 0 ; int64_t tsoffset = 0 ; AVBufferSrcParameters * par = av_buffersrc_parameters_alloc ( ) ; if ( ! par ) return AVERROR ( ENOMEM ) ; memset ( par , 0 , sizeof ( * par ) ) ; par -> format = AV_PIX_FMT_NONE ; if ( ist -> dec_ctx -> codec_type == AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot connect video filter to audio input\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } if ( ! fr . num ) fr = ist -> framerate_guessed ; if ( ist -> dec_ctx -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { ret = sub2video_prepare ( ist , ifilter ) ; if ( ret < 0 ) goto fail ; } sar = ifilter -> sample_aspect_ratio ; if ( ! sar . den ) sar = ( AVRational ) { 0 , 1 } ; av_bprint_init ( & args , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; av_bprintf ( & args , \"video_size=%dx%d:pix_fmt=%d:time_base=%d/%d:\" \"pixel_aspect=%d/%d\" , ifilter -> width , ifilter -> height , ifilter -> format , tb . num , tb . den , sar . num , sar . den ) ; if ( fr . num && fr . den ) av_bprintf ( & args , \":frame_rate=%d/%d\" , fr . num , fr . den ) ; snprintf ( name , sizeof ( name ) , \"graph %d input from stream %d:%d\" , fg -> index , ist -> file_index , ist -> st -> index ) ; if ( ( ret = avfilter_graph_create_filter ( & ifilter -> filter , buffer_filt , name , args . str , NULL , fg -> graph ) ) < 0 ) goto fail ; par -> hw_frames_ctx = ifilter -> hw_frames_ctx ; ret = av_buffersrc_parameters_set ( ifilter -> filter , par ) ; if ( ret < 0 ) goto fail ; av_freep ( & par ) ; last_filter = ifilter -> filter ; desc = av_pix_fmt_desc_get ( ifilter -> format ) ; av_assert0 ( desc ) ; // TODO: insert hwaccel enabled filters like transpose_vaapi into the graph if ( ist -> autorotate && ! ( desc -> flags & AV_PIX_FMT_FLAG_HWACCEL ) ) { int32_t * displaymatrix = ifilter -> displaymatrix ; double theta ; if ( ! displaymatrix ) displaymatrix = ( int32_t * ) av_stream_get_side_data ( ist -> st , AV_PKT_DATA_DISPLAYMATRIX , NULL ) ; theta = get_rotation ( displaymatrix ) ; if ( fabs ( theta - 90 ) < 1.0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"transpose\" , displaymatrix [ 3 ] > 0 ? \"cclock_flip\" : \"clock\" ) ; } else if ( fabs ( theta - 180 ) < 1.0 ) { if ( displaymatrix [ 0 ] < 0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"hflip\" , NULL ) ; if ( ret < 0 ) return ret ; } if ( displaymatrix [ 4 ] < 0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"vflip\" , NULL ) ; } } else if ( fabs ( theta - 270 ) < 1.0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"transpose\" , displaymatrix [ 3 ] < 0 ? \"clock_flip\" : \"cclock\" ) ; } else if ( fabs ( theta ) > 1.0 ) { char rotate_buf [ 64 ] ; snprintf ( rotate_buf , sizeof ( rotate_buf ) , \"%f*PI/180\" , theta ) ; ret = insert_filter ( & last_filter , & pad_idx , \"rotate\" , rotate_buf ) ; } else if ( fabs ( theta ) < 1.0 ) { if ( displaymatrix && displaymatrix [ 4 ] < 0 ) { ret = insert_filter ( & last_filter , & pad_idx , \"vflip\" , NULL ) ; } } if ( ret < 0 ) return ret ; } snprintf ( name , sizeof ( name ) , \"trim_in_%d_%d\" , ist -> file_index , ist -> st -> index ) ; if ( copy_ts ) { tsoffset = f -> start_time == AV_NOPTS_VALUE ? 0 : f -> start_time ; if ( ! start_at_zero && f -> ctx -> start_time != AV_NOPTS_VALUE ) tsoffset += f -> ctx -> start_time ; } ret = insert_trim ( ( ( f -> start_time == AV_NOPTS_VALUE ) || ! f -> accurate_seek ) ? AV_NOPTS_VALUE : tsoffset , f -> recording_time , & last_filter , & pad_idx , name ) ; if ( ret < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , 0 , in -> filter_ctx , in -> pad_idx ) ) < 0 ) return ret ; return 0 ; fail : av_freep ( & par ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@configure_input_audio_filter": "static int configure_input_audio_filter ( FilterGraph * fg , InputFilter * ifilter , AVFilterInOut * in ) { AVFilterContext * last_filter ; const AVFilter * abuffer_filt = avfilter_get_by_name ( \"abuffer\" ) ; InputStream * ist = ifilter -> ist ; InputFile * f = input_files [ ist -> file_index ] ; AVBPrint args ; char name [ 255 ] ; int ret , pad_idx = 0 ; int64_t tsoffset = 0 ; if ( ist -> dec_ctx -> codec_type != AVMEDIA_TYPE_AUDIO ) { av_log ( NULL , AV_LOG_ERROR , \"Cannot connect audio filter to non audio input\\n\" ) ; return AVERROR ( EINVAL ) ; } av_bprint_init ( & args , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ; av_bprintf ( & args , \"time_base=%d/%d:sample_rate=%d:sample_fmt=%s\" , 1 , ifilter -> sample_rate , ifilter -> sample_rate , av_get_sample_fmt_name ( ifilter -> format ) ) ; if ( av_channel_layout_check ( & ifilter -> ch_layout ) && ifilter -> ch_layout . order != AV_CHANNEL_ORDER_UNSPEC ) { av_bprintf ( & args , \":channel_layout=\" ) ; av_channel_layout_describe_bprint ( & ifilter -> ch_layout , & args ) ; } else av_bprintf ( & args , \":channels=%d\" , ifilter -> ch_layout . nb_channels ) ; snprintf ( name , sizeof ( name ) , \"graph_%d_in_%d_%d\" , fg -> index , ist -> file_index , ist -> st -> index ) ; if ( ( ret = avfilter_graph_create_filter ( & ifilter -> filter , abuffer_filt , name , args . str , NULL , fg -> graph ) ) < 0 ) return ret ; last_filter = ifilter -> filter ; # define AUTO_INSERT_FILTER_INPUT ( opt_name , filter_name , arg ) do { AVFilterContext * filt_ctx ; av_log ( NULL , AV_LOG_INFO , opt_name \" is forwarded to lavfi \" \"similarly to -af \" filter_name \"=%s.\\n\" , arg ) ; snprintf ( name , sizeof ( name ) , \"graph_%d_%s_in_%d_%d\" , fg -> index , filter_name , ist -> file_index , ist -> st -> index ) ; ret = avfilter_graph_create_filter ( & filt_ctx , avfilter_get_by_name ( filter_name ) , name , arg , NULL , fg -> graph ) ; if ( ret < 0 ) return ret ; ret = avfilter_link ( last_filter , 0 , filt_ctx , 0 ) ; if ( ret < 0 ) return ret ; last_filter = filt_ctx ; \\\n} while ( 0 ) snprintf ( name , sizeof ( name ) , \"trim for input stream %d:%d\" , ist -> file_index , ist -> st -> index ) ; if ( copy_ts ) { tsoffset = f -> start_time == AV_NOPTS_VALUE ? 0 : f -> start_time ; if ( ! start_at_zero && f -> ctx -> start_time != AV_NOPTS_VALUE ) tsoffset += f -> ctx -> start_time ; } ret = insert_trim ( ( ( f -> start_time == AV_NOPTS_VALUE ) || ! f -> accurate_seek ) ? AV_NOPTS_VALUE : tsoffset , f -> recording_time , & last_filter , & pad_idx , name ) ; if ( ret < 0 ) return ret ; if ( ( ret = avfilter_link ( last_filter , 0 , in -> filter_ctx , in -> pad_idx ) ) < 0 ) return ret ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@configure_input_filter": "static int configure_input_filter ( FilterGraph * fg , InputFilter * ifilter , AVFilterInOut * in ) { if ( ! ifilter -> ist -> dec ) { av_log ( NULL , AV_LOG_ERROR , \"No decoder for stream #%d:%d, filtering impossible\\n\" , ifilter -> ist -> file_index , ifilter -> ist -> st -> index ) ; return AVERROR_DECODER_NOT_FOUND ; } switch ( avfilter_pad_get_type ( in -> filter_ctx -> input_pads , in -> pad_idx ) ) { case AVMEDIA_TYPE_VIDEO : return configure_input_video_filter ( fg , ifilter , in ) ; case AVMEDIA_TYPE_AUDIO : return configure_input_audio_filter ( fg , ifilter , in ) ; default : av_assert0 ( 0 ) ; return 0 ; } }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@cleanup_filtergraph": "static void cleanup_filtergraph ( FilterGraph * fg ) { int i ; for ( i = 0 ; i < fg -> nb_outputs ; i ++ ) fg -> outputs [ i ] -> filter = ( AVFilterContext * ) NULL ; for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) fg -> inputs [ i ] -> filter = ( AVFilterContext * ) NULL ; avfilter_graph_free ( & fg -> graph ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@filter_is_buffersrc": "static int filter_is_buffersrc ( const AVFilterContext * f ) { return f -> nb_inputs == 0 && ( ! strcmp ( f -> filter -> name , \"buffer\" ) || ! strcmp ( f -> filter -> name , \"abuffer\" ) ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@graph_is_meta": "static int graph_is_meta ( AVFilterGraph * graph ) { for ( unsigned i = 0 ; i < graph -> nb_filters ; i ++ ) { const AVFilterContext * f = graph -> filters [ i ] ; /* in addition to filters flagged as meta, also\n         * disregard sinks and buffersources (but not other sources,\n         * since they introduce data we are not aware of)\n         */ if ( ! ( ( f -> filter -> flags & AVFILTER_FLAG_METADATA_ONLY ) || f -> nb_outputs == 0 || filter_is_buffersrc ( f ) ) ) return 0 ; } return 1 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@configure_filtergraph": "int configure_filtergraph ( FilterGraph * fg ) { AVFilterInOut * inputs , * outputs , * cur ; int ret , i , simple = filtergraph_is_simple ( fg ) ; const char * graph_desc = simple ? fg -> outputs [ 0 ] -> ost -> avfilter : fg -> graph_desc ; cleanup_filtergraph ( fg ) ; if ( ! ( fg -> graph = avfilter_graph_alloc ( ) ) ) return AVERROR ( ENOMEM ) ; if ( simple ) { OutputStream * ost = fg -> outputs [ 0 ] -> ost ; if ( filter_nbthreads ) { ret = av_opt_set ( fg -> graph , \"threads\" , filter_nbthreads , 0 ) ; if ( ret < 0 ) goto fail ; } else { const AVDictionaryEntry * e = NULL ; e = av_dict_get ( ost -> encoder_opts , \"threads\" , NULL , 0 ) ; if ( e ) av_opt_set ( fg -> graph , \"threads\" , e -> value , 0 ) ; } if ( av_dict_count ( ost -> sws_dict ) ) { ret = av_dict_get_string ( ost -> sws_dict , & fg -> graph -> scale_sws_opts , '=' , ':' ) ; if ( ret < 0 ) goto fail ; } if ( av_dict_count ( ost -> swr_opts ) ) { char * args ; ret = av_dict_get_string ( ost -> swr_opts , & args , '=' , ':' ) ; if ( ret < 0 ) goto fail ; av_opt_set ( fg -> graph , \"aresample_swr_opts\" , args , 0 ) ; av_free ( args ) ; } } else { fg -> graph -> nb_threads = filter_complex_nbthreads ; } if ( ( ret = graph_parse ( fg -> graph , graph_desc , & inputs , & outputs ) ) < 0 ) goto fail ; ret = hw_device_setup_for_filter ( fg ) ; if ( ret < 0 ) goto fail ; if ( simple && ( ! inputs || inputs -> next || ! outputs || outputs -> next ) ) { const char * num_inputs ; const char * num_outputs ; if ( ! outputs ) { num_outputs = \"0\" ; } else if ( outputs -> next ) { num_outputs = \">1\" ; } else { num_outputs = \"1\" ; } if ( ! inputs ) { num_inputs = \"0\" ; } else if ( inputs -> next ) { num_inputs = \">1\" ; } else { num_inputs = \"1\" ; } av_log ( NULL , AV_LOG_ERROR , \"Simple filtergraph '%s' was expected \" \"to have exactly 1 input and 1 output.\" \" However, it had %s input(s) and %s output(s).\" \" Please adjust, or use a complex filtergraph (-filter_complex) instead.\\n\" , graph_desc , num_inputs , num_outputs ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } for ( cur = inputs , i = 0 ; cur ; cur = cur -> next , i ++ ) if ( ( ret = configure_input_filter ( fg , fg -> inputs [ i ] , cur ) ) < 0 ) { avfilter_inout_free ( & inputs ) ; avfilter_inout_free ( & outputs ) ; goto fail ; } avfilter_inout_free ( & inputs ) ; for ( cur = outputs , i = 0 ; cur ; cur = cur -> next , i ++ ) configure_output_filter ( fg , fg -> outputs [ i ] , cur ) ; avfilter_inout_free ( & outputs ) ; if ( ! auto_conversion_filters ) avfilter_graph_set_auto_convert ( fg -> graph , AVFILTER_AUTO_CONVERT_NONE ) ; if ( ( ret = avfilter_graph_config ( fg -> graph , NULL ) ) < 0 ) goto fail ; fg -> is_meta = graph_is_meta ( fg -> graph ) ; /* limit the lists of allowed formats to the ones selected, to\n     * make sure they stay the same if the filtergraph is reconfigured later */ for ( i = 0 ; i < fg -> nb_outputs ; i ++ ) { OutputFilter * ofilter = fg -> outputs [ i ] ; AVFilterContext * sink = ofilter -> filter ; ofilter -> format = av_buffersink_get_format ( sink ) ; ofilter -> width = av_buffersink_get_w ( sink ) ; ofilter -> height = av_buffersink_get_h ( sink ) ; ofilter -> sample_rate = av_buffersink_get_sample_rate ( sink ) ; av_channel_layout_uninit ( & ofilter -> ch_layout ) ; ret = av_buffersink_get_ch_layout ( sink , & ofilter -> ch_layout ) ; if ( ret < 0 ) goto fail ; } fg -> reconfiguration = 1 ; for ( i = 0 ; i < fg -> nb_outputs ; i ++ ) { OutputStream * ost = fg -> outputs [ i ] -> ost ; if ( ost -> enc_ctx -> codec_type == AVMEDIA_TYPE_AUDIO && ! ( ost -> enc_ctx -> codec -> capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE ) ) av_buffersink_set_frame_size ( ost -> filter -> filter , ost -> enc_ctx -> frame_size ) ; } for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) { AVFrame * tmp ; while ( av_fifo_read ( fg -> inputs [ i ] -> frame_queue , & tmp , 1 ) >= 0 ) { ret = av_buffersrc_add_frame ( fg -> inputs [ i ] -> filter , tmp ) ; av_frame_free ( & tmp ) ; if ( ret < 0 ) goto fail ; } } /* send the EOFs for the finished inputs */ for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) { if ( fg -> inputs [ i ] -> eof ) { ret = av_buffersrc_add_frame ( fg -> inputs [ i ] -> filter , NULL ) ; if ( ret < 0 ) goto fail ; } } /* process queued up subtitle packets */ for ( i = 0 ; i < fg -> nb_inputs ; i ++ ) { InputStream * ist = fg -> inputs [ i ] -> ist ; if ( ist -> sub2video . sub_queue && ist -> sub2video . frame ) { AVSubtitle tmp ; while ( av_fifo_read ( ist -> sub2video . sub_queue , & tmp , 1 ) >= 0 ) { sub2video_update ( ist , INT64_MIN , & tmp ) ; avsubtitle_free ( & tmp ) ; } } } return 0 ; fail : cleanup_filtergraph ( fg ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@ifilter_parameters_from_frame": "int ifilter_parameters_from_frame ( InputFilter * ifilter , const AVFrame * frame ) { AVFrameSideData * sd ; int ret ; av_buffer_unref ( & ifilter -> hw_frames_ctx ) ; ifilter -> format = frame -> format ; ifilter -> width = frame -> width ; ifilter -> height = frame -> height ; ifilter -> sample_aspect_ratio = frame -> sample_aspect_ratio ; ifilter -> sample_rate = frame -> sample_rate ; ret = av_channel_layout_copy ( & ifilter -> ch_layout , & frame -> ch_layout ) ; if ( ret < 0 ) return ret ; av_freep ( & ifilter -> displaymatrix ) ; sd = av_frame_get_side_data ( frame , AV_FRAME_DATA_DISPLAYMATRIX ) ; if ( sd ) ifilter -> displaymatrix = av_memdup ( sd -> data , sizeof ( int32_t ) * 9 ) ; if ( frame -> hw_frames_ctx ) { ifilter -> hw_frames_ctx = av_buffer_ref ( frame -> hw_frames_ctx ) ; if ( ! ifilter -> hw_frames_ctx ) return AVERROR ( ENOMEM ) ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_filter.c@filtergraph_is_simple": "int filtergraph_is_simple ( FilterGraph * fg ) { return ! fg -> graph_desc ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/ffmpegkit_abidetect.c@JNI_OnLoad": "jint JNI_OnLoad ( JavaVM * vm , void * reserved ) { JNIEnv * env ; if ( ( * vm ) -> GetEnv ( vm , ( void * * ) & env , JNI_VERSION_1_6 ) != JNI_OK ) { LOGE ( \"OnLoad failed to GetEnv for class %s.\\n\" , abiDetectClassName ) ; return JNI_FALSE ; } jclass abiDetectClass = ( * env ) -> FindClass ( env , abiDetectClassName ) ; if ( abiDetectClass == NULL ) { LOGE ( \"OnLoad failed to FindClass %s.\\n\" , abiDetectClassName ) ; return JNI_FALSE ; } if ( ( * env ) -> RegisterNatives ( env , abiDetectClass , abiDetectMethods , 4 ) < 0 ) { LOGE ( \"OnLoad failed to RegisterNatives for class %s.\\n\" , abiDetectClassName ) ; return JNI_FALSE ; } return JNI_VERSION_1_6 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@ms_from_ost": "MuxStream * ms_from_ost ( OutputStream * ost ) { return ( MuxStream * ) ost ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@mux_from_of": "static Muxer * mux_from_of ( OutputFile * of ) { return ( Muxer * ) of ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@filesize": "static int64_t filesize ( AVIOContext * pb ) { int64_t ret = - 1 ; if ( pb ) { ret = avio_size ( pb ) ; if ( ret <= 0 ) // FIXME improve avio_size() so it works with non seekable output too ret = avio_tell ( pb ) ; } return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@write_packet": "static int write_packet ( Muxer * mux , OutputStream * ost , AVPacket * pkt ) { MuxStream * ms = ms_from_ost ( ost ) ; AVFormatContext * s = mux -> fc ; AVStream * st = ost -> st ; int64_t fs ; uint64_t frame_num ; int ret ; fs = filesize ( s -> pb ) ; atomic_store ( & mux -> last_filesize , fs ) ; if ( fs >= mux -> limit_filesize ) { ret = AVERROR_EOF ; goto fail ; } if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && ost -> vsync_method == VSYNC_DROP ) pkt -> pts = pkt -> dts = AV_NOPTS_VALUE ; if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { if ( ost -> frame_rate . num && ost -> is_cfr ) { if ( pkt -> duration > 0 ) av_log ( ost , AV_LOG_WARNING , \"Overriding packet duration by frame rate, this should not happen\\n\" ) ; pkt -> duration = av_rescale_q ( 1 , av_inv_q ( ost -> frame_rate ) , pkt -> time_base ) ; } } av_packet_rescale_ts ( pkt , pkt -> time_base , ost -> st -> time_base ) ; pkt -> time_base = ost -> st -> time_base ; if ( ! ( s -> oformat -> flags & AVFMT_NOTIMESTAMPS ) ) { if ( pkt -> dts != AV_NOPTS_VALUE && pkt -> pts != AV_NOPTS_VALUE && pkt -> dts > pkt -> pts ) { av_log ( s , AV_LOG_WARNING , \"Invalid DTS: %\" PRId64 \" PTS: %\" PRId64 \" in output stream %d:%d, replacing by guess\\n\" , pkt -> dts , pkt -> pts , ost -> file_index , ost -> st -> index ) ; pkt -> pts = pkt -> dts = pkt -> pts + pkt -> dts + ms -> last_mux_dts + 1 - FFMIN3 ( pkt -> pts , pkt -> dts , ms -> last_mux_dts + 1 ) - FFMAX3 ( pkt -> pts , pkt -> dts , ms -> last_mux_dts + 1 ) ; } if ( ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO || st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO || st -> codecpar -> codec_type == AVMEDIA_TYPE_SUBTITLE ) && pkt -> dts != AV_NOPTS_VALUE && ms -> last_mux_dts != AV_NOPTS_VALUE ) { int64_t max = ms -> last_mux_dts + ! ( s -> oformat -> flags & AVFMT_TS_NONSTRICT ) ; if ( pkt -> dts < max ) { int loglevel = max - pkt -> dts > 2 || st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ? AV_LOG_WARNING : AV_LOG_DEBUG ; if ( exit_on_error ) loglevel = AV_LOG_ERROR ; av_log ( s , loglevel , \"Non-monotonous DTS in output stream \" \"%d:%d; previous: %\" PRId64 \", current: %\" PRId64 \"; \" , ost -> file_index , ost -> st -> index , ms -> last_mux_dts , pkt -> dts ) ; if ( exit_on_error ) { ret = AVERROR ( EINVAL ) ; goto fail ; } av_log ( s , loglevel , \"changing to %\" PRId64 \". This may result \" \"in incorrect timestamps in the output file.\\n\" , max ) ; if ( pkt -> pts >= pkt -> dts ) pkt -> pts = FFMAX ( pkt -> pts , max ) ; pkt -> dts = max ; } } } ms -> last_mux_dts = pkt -> dts ; ost -> data_size_mux += pkt -> size ; frame_num = atomic_fetch_add ( & ost -> packets_written , 1 ) ; pkt -> stream_index = ost -> index ; if ( debug_ts ) { av_log ( ost , AV_LOG_INFO , \"muxer <- type:%s \" \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s size:%d\\n\" , av_get_media_type_string ( st -> codecpar -> codec_type ) , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & ost -> st -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & ost -> st -> time_base ) , av_ts2str ( pkt -> duration ) , av_ts2timestr ( pkt -> duration , & ost -> st -> time_base ) , pkt -> size ) ; } if ( ms -> stats . io ) enc_stats_write ( ost , & ms -> stats , NULL , pkt , frame_num ) ; ret = av_interleaved_write_frame ( s , pkt ) ; if ( ret < 0 ) { print_error ( \"av_interleaved_write_frame()\" , ret ) ; goto fail ; } return 0 ; fail : av_packet_unref ( pkt ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@sync_queue_process": "static int sync_queue_process ( Muxer * mux , OutputStream * ost , AVPacket * pkt , int * stream_eof ) { OutputFile * of = & mux -> of ; if ( ost -> sq_idx_mux >= 0 ) { int ret = sq_send ( mux -> sq_mux , ost -> sq_idx_mux , SQPKT ( pkt ) ) ; if ( ret < 0 ) { if ( ret == AVERROR_EOF ) * stream_eof = 1 ; return ret ; } while ( 1 ) { ret = sq_receive ( mux -> sq_mux , - 1 , SQPKT ( mux -> sq_pkt ) ) ; if ( ret < 0 ) return ( ret == AVERROR_EOF || ret == AVERROR ( EAGAIN ) ) ? 0 : ret ; ret = write_packet ( mux , of -> streams [ ret ] , mux -> sq_pkt ) ; if ( ret < 0 ) return ret ; } } else if ( pkt ) return write_packet ( mux , ost , pkt ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@thread_set_name": "static void thread_set_name ( OutputFile * of ) { char name [ 16 ] ; snprintf ( name , sizeof ( name ) , \"mux%d:%s\" , of -> index , of -> format -> name ) ; ff_thread_setname ( name ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@muxer_thread": "static void * muxer_thread ( void * arg ) { Muxer * mux = arg ; OutputFile * of = & mux -> of ; AVPacket * pkt = NULL ; int ret = 0 ; pkt = av_packet_alloc ( ) ; if ( ! pkt ) { ret = AVERROR ( ENOMEM ) ; goto finish ; } thread_set_name ( of ) ; while ( 1 ) { OutputStream * ost ; int stream_idx , stream_eof = 0 ; ret = tq_receive ( mux -> tq , & stream_idx , pkt ) ; if ( stream_idx < 0 ) { av_log ( mux , AV_LOG_VERBOSE , \"All streams finished\\n\" ) ; ret = 0 ; break ; } ost = of -> streams [ stream_idx ] ; ret = sync_queue_process ( mux , ost , ret < 0 ? NULL : pkt , & stream_eof ) ; av_packet_unref ( pkt ) ; if ( ret == AVERROR_EOF && stream_eof ) tq_receive_finish ( mux -> tq , stream_idx ) ; else if ( ret < 0 ) { av_log ( mux , AV_LOG_ERROR , \"Error muxing a packet\\n\" ) ; break ; } } finish : av_packet_free ( & pkt ) ; for ( unsigned int i = 0 ; i < mux -> fc -> nb_streams ; i ++ ) tq_receive_finish ( mux -> tq , i ) ; av_log ( mux , AV_LOG_VERBOSE , \"Terminating muxer thread\\n\" ) ; return ( void * ) ( intptr_t ) ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@thread_submit_packet": "static int thread_submit_packet ( Muxer * mux , OutputStream * ost , AVPacket * pkt ) { int ret = 0 ; if ( ! pkt || ost -> finished & MUXER_FINISHED ) goto finish ; ret = tq_send ( mux -> tq , ost -> index , pkt ) ; if ( ret < 0 ) goto finish ; return 0 ; finish : if ( pkt ) av_packet_unref ( pkt ) ; ost -> finished |= MUXER_FINISHED ; tq_send_finish ( mux -> tq , ost -> index ) ; return ret == AVERROR_EOF ? 0 : ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@queue_packet": "static int queue_packet ( Muxer * mux , OutputStream * ost , AVPacket * pkt ) { MuxStream * ms = ms_from_ost ( ost ) ; AVPacket * tmp_pkt = NULL ; int ret ; if ( ! av_fifo_can_write ( ms -> muxing_queue ) ) { size_t cur_size = av_fifo_can_read ( ms -> muxing_queue ) ; size_t pkt_size = pkt ? pkt -> size : 0 ; unsigned int are_we_over_size = ( ms -> muxing_queue_data_size + pkt_size ) > ms -> muxing_queue_data_threshold ; size_t limit = are_we_over_size ? ms -> max_muxing_queue_size : SIZE_MAX ; size_t new_size = FFMIN ( 2 * cur_size , limit ) ; if ( new_size <= cur_size ) { av_log ( ost , AV_LOG_ERROR , \"Too many packets buffered for output stream %d:%d.\\n\" , ost -> file_index , ost -> st -> index ) ; return AVERROR ( ENOSPC ) ; } ret = av_fifo_grow2 ( ms -> muxing_queue , new_size - cur_size ) ; if ( ret < 0 ) return ret ; } if ( pkt ) { ret = av_packet_make_refcounted ( pkt ) ; if ( ret < 0 ) return ret ; tmp_pkt = av_packet_alloc ( ) ; if ( ! tmp_pkt ) return AVERROR ( ENOMEM ) ; av_packet_move_ref ( tmp_pkt , pkt ) ; ms -> muxing_queue_data_size += tmp_pkt -> size ; } av_fifo_write ( ms -> muxing_queue , & tmp_pkt , 1 ) ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@submit_packet": "static int submit_packet ( Muxer * mux , AVPacket * pkt , OutputStream * ost ) { int ret ; if ( mux -> tq ) { return thread_submit_packet ( mux , ost , pkt ) ; } else { /* the muxer is not initialized yet, buffer the packet */ ret = queue_packet ( mux , ost , pkt ) ; if ( ret < 0 ) { if ( pkt ) av_packet_unref ( pkt ) ; return ret ; } } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@of_output_packet": "void of_output_packet ( OutputFile * of , AVPacket * pkt , OutputStream * ost , int eof ) { Muxer * mux = mux_from_of ( of ) ; MuxStream * ms = ms_from_ost ( ost ) ; const char * err_msg ; int ret = 0 ; if ( ! eof && pkt -> dts != AV_NOPTS_VALUE ) ost -> last_mux_dts = av_rescale_q ( pkt -> dts , pkt -> time_base , AV_TIME_BASE_Q ) ; /* apply the output bitstream filters */ if ( ms -> bsf_ctx ) { int bsf_eof = 0 ; ret = av_bsf_send_packet ( ms -> bsf_ctx , eof ? NULL : pkt ) ; if ( ret < 0 ) { err_msg = \"submitting a packet for bitstream filtering\" ; goto fail ; } while ( ! bsf_eof ) { ret = av_bsf_receive_packet ( ms -> bsf_ctx , pkt ) ; if ( ret == AVERROR ( EAGAIN ) ) return ; else if ( ret == AVERROR_EOF ) bsf_eof = 1 ; else if ( ret < 0 ) { err_msg = \"applying bitstream filters to a packet\" ; goto fail ; } ret = submit_packet ( mux , bsf_eof ? NULL : pkt , ost ) ; if ( ret < 0 ) goto mux_fail ; } } else { ret = submit_packet ( mux , eof ? NULL : pkt , ost ) ; if ( ret < 0 ) goto mux_fail ; } return ; mux_fail : err_msg = \"submitting a packet to the muxer\" ; fail : av_log ( ost , AV_LOG_ERROR , \"Error %s\\n\" , err_msg ) ; if ( exit_on_error ) exit_program ( 1 ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@thread_stop": "static int thread_stop ( Muxer * mux ) { void * ret ; if ( ! mux || ! mux -> tq ) return 0 ; for ( unsigned int i = 0 ; i < mux -> fc -> nb_streams ; i ++ ) tq_send_finish ( mux -> tq , i ) ; pthread_join ( mux -> thread , & ret ) ; tq_free ( & mux -> tq ) ; return ( int ) ( intptr_t ) ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@pkt_move": "static void pkt_move ( void * dst , void * src ) { av_packet_move_ref ( dst , src ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@thread_start": "static int thread_start ( Muxer * mux ) { AVFormatContext * fc = mux -> fc ; ObjPool * op ; int ret ; op = objpool_alloc_packets ( ) ; if ( ! op ) return AVERROR ( ENOMEM ) ; mux -> tq = tq_alloc ( fc -> nb_streams , mux -> thread_queue_size , op , pkt_move ) ; if ( ! mux -> tq ) { objpool_free ( & op ) ; return AVERROR ( ENOMEM ) ; } ret = pthread_create ( & mux -> thread , NULL , muxer_thread , ( void * ) mux ) ; if ( ret ) { tq_free ( & mux -> tq ) ; return AVERROR ( ret ) ; } /* flush the muxing queues */ for ( int i = 0 ; i < fc -> nb_streams ; i ++ ) { OutputStream * ost = mux -> of . streams [ i ] ; MuxStream * ms = ms_from_ost ( ost ) ; AVPacket * pkt ; /* try to improve muxing time_base (only possible if nothing has been written yet) */ if ( ! av_fifo_can_read ( ms -> muxing_queue ) ) ost -> mux_timebase = ost -> st -> time_base ; while ( av_fifo_read ( ms -> muxing_queue , & pkt , 1 ) >= 0 ) { ret = thread_submit_packet ( mux , ost , pkt ) ; if ( pkt ) { ms -> muxing_queue_data_size -= pkt -> size ; av_packet_free ( & pkt ) ; } if ( ret < 0 ) return ret ; } } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@print_sdp": "static int print_sdp ( void ) { char sdp [ 16384 ] ; int i ; int j , ret ; AVIOContext * sdp_pb ; AVFormatContext * * avc ; for ( i = 0 ; i < nb_output_files ; i ++ ) { if ( ! mux_from_of ( output_files [ i ] ) -> header_written ) return 0 ; } avc = av_malloc_array ( nb_output_files , sizeof ( * avc ) ) ; if ( ! avc ) return AVERROR ( ENOMEM ) ; for ( i = 0 , j = 0 ; i < nb_output_files ; i ++ ) { if ( ! strcmp ( output_files [ i ] -> format -> name , \"rtp\" ) ) { avc [ j ] = mux_from_of ( output_files [ i ] ) -> fc ; j ++ ; } } if ( ! j ) { av_log ( NULL , AV_LOG_ERROR , \"No output streams in the SDP.\\n\" ) ; ret = AVERROR ( EINVAL ) ; goto fail ; } ret = av_sdp_create ( avc , j , sdp , sizeof ( sdp ) ) ; if ( ret < 0 ) goto fail ; if ( ! sdp_filename ) { av_log ( NULL , AV_LOG_ERROR , \"SDP:\\n%s\\n\" , sdp ) ; fflush ( stdout ) ; } else { ret = avio_open2 ( & sdp_pb , sdp_filename , AVIO_FLAG_WRITE , & int_cb , NULL ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Failed to open sdp file '%s'\\n\" , sdp_filename ) ; goto fail ; } avio_print ( sdp_pb , sdp ) ; avio_closep ( & sdp_pb ) ; av_freep ( & sdp_filename ) ; } // SDP successfully written, allow muxer threads to start ret = 1 ; fail : av_freep ( & avc ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@mux_check_init": "int mux_check_init ( Muxer * mux ) { OutputFile * of = & mux -> of ; AVFormatContext * fc = mux -> fc ; int ret , i ; for ( i = 0 ; i < fc -> nb_streams ; i ++ ) { OutputStream * ost = of -> streams [ i ] ; if ( ! ost -> initialized ) return 0 ; } ret = avformat_write_header ( fc , & mux -> opts ) ; if ( ret < 0 ) { av_log ( mux , AV_LOG_ERROR , \"Could not write header (incorrect codec \" \"parameters ?): %s\\n\" , av_err2str ( ret ) ) ; return ret ; } //assert_avoptions(of->opts); mux -> header_written = 1 ; av_dump_format ( fc , of -> index , fc -> url , 1 ) ; nb_output_dumped ++ ; if ( sdp_filename || want_sdp ) { ret = print_sdp ( ) ; if ( ret < 0 ) { av_log ( NULL , AV_LOG_ERROR , \"Error writing the SDP.\\n\" ) ; return ret ; } else if ( ret == 1 ) { /* SDP is written only after all the muxers are ready, so now we\n             * start ALL the threads */ for ( i = 0 ; i < nb_output_files ; i ++ ) { ret = thread_start ( mux_from_of ( output_files [ i ] ) ) ; if ( ret < 0 ) return ret ; } } } else { ret = thread_start ( mux_from_of ( of ) ) ; if ( ret < 0 ) return ret ; } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@bsf_init": "static int bsf_init ( MuxStream * ms ) { OutputStream * ost = & ms -> ost ; AVBSFContext * ctx = ms -> bsf_ctx ; int ret ; if ( ! ctx ) return 0 ; ret = avcodec_parameters_copy ( ctx -> par_in , ost -> st -> codecpar ) ; if ( ret < 0 ) return ret ; ctx -> time_base_in = ost -> st -> time_base ; ret = av_bsf_init ( ctx ) ; if ( ret < 0 ) { av_log ( ms , AV_LOG_ERROR , \"Error initializing bitstream filter: %s\\n\" , ctx -> filter -> name ) ; return ret ; } ret = avcodec_parameters_copy ( ost -> st -> codecpar , ctx -> par_out ) ; if ( ret < 0 ) return ret ; ost -> st -> time_base = ctx -> time_base_out ; return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@of_stream_init": "int of_stream_init ( OutputFile * of , OutputStream * ost ) { Muxer * mux = mux_from_of ( of ) ; MuxStream * ms = ms_from_ost ( ost ) ; int ret ; if ( ost -> sq_idx_mux >= 0 ) sq_set_tb ( mux -> sq_mux , ost -> sq_idx_mux , ost -> mux_timebase ) ; /* initialize bitstream filters for the output stream\n     * needs to be done here, because the codec id for streamcopy is not\n     * known until now */ ret = bsf_init ( ms ) ; if ( ret < 0 ) return ret ; ost -> initialized = 1 ; return mux_check_init ( mux ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@of_write_trailer": "int of_write_trailer ( OutputFile * of ) { Muxer * mux = mux_from_of ( of ) ; AVFormatContext * fc = mux -> fc ; int ret ; if ( ! mux -> tq ) { av_log ( mux , AV_LOG_ERROR , \"Nothing was written into output file, because \" \"at least one of its streams received no packets.\\n\" ) ; return AVERROR ( EINVAL ) ; } ret = thread_stop ( mux ) ; if ( ret < 0 ) main_ffmpeg_return_code = ret ; ret = av_write_trailer ( fc ) ; if ( ret < 0 ) { av_log ( mux , AV_LOG_ERROR , \"Error writing trailer: %s\\n\" , av_err2str ( ret ) ) ; return ret ; } mux -> last_filesize = filesize ( fc -> pb ) ; if ( ! ( of -> format -> flags & AVFMT_NOFILE ) ) { ret = avio_closep ( & fc -> pb ) ; if ( ret < 0 ) { av_log ( mux , AV_LOG_ERROR , \"Error closing file: %s\\n\" , av_err2str ( ret ) ) ; return ret ; } } return 0 ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@ost_free": "static void ost_free ( OutputStream * * post ) { OutputStream * ost = * post ; MuxStream * ms ; if ( ! ost ) return ; ms = ms_from_ost ( ost ) ; if ( ost -> logfile ) { if ( fclose ( ost -> logfile ) ) av_log ( ms , AV_LOG_ERROR , \"Error closing logfile, loss of information possible: %s\\n\" , av_err2str ( AVERROR ( errno ) ) ) ; ost -> logfile = NULL ; } if ( ms -> muxing_queue ) { AVPacket * pkt ; while ( av_fifo_read ( ms -> muxing_queue , & pkt , 1 ) >= 0 ) av_packet_free ( & pkt ) ; av_fifo_freep2 ( & ms -> muxing_queue ) ; } av_bsf_free ( & ms -> bsf_ctx ) ; av_frame_free ( & ost -> filtered_frame ) ; av_frame_free ( & ost -> sq_frame ) ; av_frame_free ( & ost -> last_frame ) ; av_packet_free ( & ost -> pkt ) ; av_dict_free ( & ost -> encoder_opts ) ; av_freep ( & ost -> kf . pts ) ; av_expr_free ( ost -> kf . pexpr ) ; av_freep ( & ost -> avfilter ) ; av_freep ( & ost -> logfile_prefix ) ; av_freep ( & ost -> apad ) ; # if FFMPEG_OPT_MAP_CHANNEL av_freep ( & ost -> audio_channels_map ) ; ost -> audio_channels_mapped = 0 ; # endif av_dict_free ( & ost -> sws_dict ) ; av_dict_free ( & ost -> swr_opts ) ; if ( ost -> enc_ctx ) av_freep ( & ost -> enc_ctx -> stats_in ) ; avcodec_free_context ( & ost -> enc_ctx ) ; for ( int i = 0 ; i < ost -> enc_stats_pre . nb_components ; i ++ ) av_freep ( & ost -> enc_stats_pre . components [ i ] . str ) ; av_freep ( & ost -> enc_stats_pre . components ) ; for ( int i = 0 ; i < ost -> enc_stats_post . nb_components ; i ++ ) av_freep ( & ost -> enc_stats_post . components [ i ] . str ) ; av_freep ( & ost -> enc_stats_post . components ) ; for ( int i = 0 ; i < ms -> stats . nb_components ; i ++ ) av_freep ( & ms -> stats . components [ i ] . str ) ; av_freep ( & ms -> stats . components ) ; av_freep ( post ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@fc_close": "static void fc_close ( AVFormatContext * * pfc ) { AVFormatContext * fc = * pfc ; if ( ! fc ) return ; if ( ! ( fc -> oformat -> flags & AVFMT_NOFILE ) ) avio_closep ( & fc -> pb ) ; avformat_free_context ( fc ) ; * pfc = NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@of_close": "void of_close ( OutputFile * * pof ) { OutputFile * of = * pof ; Muxer * mux ; if ( ! of ) return ; mux = mux_from_of ( of ) ; thread_stop ( mux ) ; sq_free ( & of -> sq_encode ) ; sq_free ( & mux -> sq_mux ) ; for ( int i = 0 ; i < of -> nb_streams ; i ++ ) ost_free ( & of -> streams [ i ] ) ; av_freep ( & of -> streams ) ; av_dict_free ( & mux -> opts ) ; av_packet_free ( & mux -> sq_pkt ) ; fc_close ( & mux -> fc ) ; av_freep ( pof ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_ffmpeg_mux.c@of_filesize": "int64_t of_filesize ( OutputFile * of ) { Muxer * mux = mux_from_of ( of ) ; return atomic_load ( & mux -> last_filesize ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_thread_queue.c@tq_free": "void tq_free ( ThreadQueue * * ptq ) { ThreadQueue * tq = * ptq ; if ( ! tq ) return ; if ( tq -> fifo ) { FifoElem elem ; while ( av_fifo_read ( tq -> fifo , & elem , 1 ) >= 0 ) objpool_release ( tq -> obj_pool , & elem . obj ) ; } av_fifo_freep2 ( & tq -> fifo ) ; objpool_free ( & tq -> obj_pool ) ; av_freep ( & tq -> finished ) ; pthread_cond_destroy ( & tq -> cond ) ; pthread_mutex_destroy ( & tq -> lock ) ; av_freep ( ptq ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_thread_queue.c@tq_alloc": "ThreadQueue * tq_alloc ( unsigned int nb_streams , size_t queue_size , ObjPool * obj_pool , void ( * obj_move ) ( void * dst , void * src ) ) { ThreadQueue * tq ; int ret ; tq = av_mallocz ( sizeof ( * tq ) ) ; if ( ! tq ) return NULL ; ret = pthread_cond_init ( & tq -> cond , NULL ) ; if ( ret ) { av_freep ( & tq ) ; return NULL ; } ret = pthread_mutex_init ( & tq -> lock , NULL ) ; if ( ret ) { pthread_cond_destroy ( & tq -> cond ) ; av_freep ( & tq ) ; return NULL ; } tq -> finished = av_calloc ( nb_streams , sizeof ( * tq -> finished ) ) ; if ( ! tq -> finished ) goto fail ; tq -> nb_streams = nb_streams ; tq -> fifo = av_fifo_alloc2 ( queue_size , sizeof ( FifoElem ) , 0 ) ; if ( ! tq -> fifo ) goto fail ; tq -> obj_pool = obj_pool ; tq -> obj_move = obj_move ; return tq ; fail : tq_free ( & tq ) ; return NULL ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_thread_queue.c@tq_send": "int tq_send ( ThreadQueue * tq , unsigned int stream_idx , void * data ) { int * finished ; int ret ; av_assert0 ( stream_idx < tq -> nb_streams ) ; finished = & tq -> finished [ stream_idx ] ; pthread_mutex_lock ( & tq -> lock ) ; if ( * finished & FINISHED_SEND ) { ret = AVERROR ( EINVAL ) ; goto finish ; } while ( ! ( * finished & FINISHED_RECV ) && ! av_fifo_can_write ( tq -> fifo ) ) pthread_cond_wait ( & tq -> cond , & tq -> lock ) ; if ( * finished & FINISHED_RECV ) { ret = AVERROR_EOF ; * finished |= FINISHED_SEND ; } else { FifoElem elem = { . stream_idx = stream_idx } ; ret = objpool_get ( tq -> obj_pool , & elem . obj ) ; if ( ret < 0 ) goto finish ; tq -> obj_move ( elem . obj , data ) ; ret = av_fifo_write ( tq -> fifo , & elem , 1 ) ; av_assert0 ( ret >= 0 ) ; pthread_cond_broadcast ( & tq -> cond ) ; } finish : pthread_mutex_unlock ( & tq -> lock ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_thread_queue.c@receive_locked": "static int receive_locked ( ThreadQueue * tq , int * stream_idx , void * data ) { FifoElem elem ; unsigned int nb_finished = 0 ; if ( av_fifo_read ( tq -> fifo , & elem , 1 ) >= 0 ) { tq -> obj_move ( data , elem . obj ) ; objpool_release ( tq -> obj_pool , & elem . obj ) ; * stream_idx = elem . stream_idx ; return 0 ; } for ( unsigned int i = 0 ; i < tq -> nb_streams ; i ++ ) { if ( ! ( tq -> finished [ i ] & FINISHED_SEND ) ) continue ; /* return EOF to the consumer at most once for each stream */ if ( ! ( tq -> finished [ i ] & FINISHED_RECV ) ) { tq -> finished [ i ] |= FINISHED_RECV ; * stream_idx = i ; return AVERROR_EOF ; } nb_finished ++ ; } return nb_finished == tq -> nb_streams ? AVERROR_EOF : AVERROR ( EAGAIN ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_thread_queue.c@tq_receive": "int tq_receive ( ThreadQueue * tq , int * stream_idx , void * data ) { int ret ; * stream_idx = - 1 ; pthread_mutex_lock ( & tq -> lock ) ; while ( 1 ) { ret = receive_locked ( tq , stream_idx , data ) ; if ( ret == AVERROR ( EAGAIN ) ) { pthread_cond_wait ( & tq -> cond , & tq -> lock ) ; continue ; } break ; } if ( ret == 0 ) pthread_cond_broadcast ( & tq -> cond ) ; pthread_mutex_unlock ( & tq -> lock ) ; return ret ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_thread_queue.c@tq_send_finish": "void tq_send_finish ( ThreadQueue * tq , unsigned int stream_idx ) { av_assert0 ( stream_idx < tq -> nb_streams ) ; pthread_mutex_lock ( & tq -> lock ) ; /* mark the stream as send-finished;\n     * next time the consumer thread tries to read this stream it will get\n     * an EOF and recv-finished flag will be set */ tq -> finished [ stream_idx ] |= FINISHED_SEND ; pthread_cond_broadcast ( & tq -> cond ) ; pthread_mutex_unlock ( & tq -> lock ) ; }",
    "resources/ffmpeg-kit/android/ffmpeg-kit-android-lib/src/main/cpp/fftools_thread_queue.c@tq_receive_finish": "void tq_receive_finish ( ThreadQueue * tq , unsigned int stream_idx ) { av_assert0 ( stream_idx < tq -> nb_streams ) ; pthread_mutex_lock ( & tq -> lock ) ; /* mark the stream as recv-finished;\n     * next time the producer thread tries to send for this stream, it will\n     * get an EOF and send-finished flag will be set */ tq -> finished [ stream_idx ] |= FINISHED_RECV ; pthread_cond_broadcast ( & tq -> cond ) ; pthread_mutex_unlock ( & tq -> lock ) ; }"
}